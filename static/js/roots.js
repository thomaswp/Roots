var roots;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@pixi/color/lib/Color.js":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/color/lib/Color.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var colord = __webpack_require__(/*! colord */ "./node_modules/colord/index.js");
var namesPlugin = __webpack_require__(/*! colord/plugins/names */ "./node_modules/colord/plugins/names.js");

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var namesPlugin__default = /*#__PURE__*/_interopDefaultLegacy(namesPlugin);

colord.extend([namesPlugin__default["default"]]);
const _Color = class {
  constructor(value = 16777215) {
    this._value = null;
    this._components = new Float32Array(4);
    this._components.fill(1);
    this._int = 16777215;
    this.value = value;
  }
  get red() {
    return this._components[0];
  }
  get green() {
    return this._components[1];
  }
  get blue() {
    return this._components[2];
  }
  get alpha() {
    return this._components[3];
  }
  setValue(value) {
    this.value = value;
    return this;
  }
  set value(value) {
    if (value instanceof _Color) {
      this._value = this.cloneSource(value._value);
      this._int = value._int;
      this._components.set(value._components);
    } else if (value === null) {
      throw new Error("Cannot set PIXI.Color#value to null");
    } else if (this._value === null || !this.isSourceEqual(this._value, value)) {
      this.normalize(value);
      this._value = this.cloneSource(value);
    }
  }
  get value() {
    return this._value;
  }
  cloneSource(value) {
    if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
      return value;
    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      return value.slice(0);
    } else if (typeof value === "object" && value !== null) {
      return { ...value };
    }
    return value;
  }
  isSourceEqual(value1, value2) {
    const type1 = typeof value1;
    const type2 = typeof value2;
    if (type1 !== type2) {
      return false;
    } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
      return value1 === value2;
    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
      if (value1.length !== value2.length) {
        return false;
      }
      return value1.every((v, i) => v === value2[i]);
    } else if (value1 !== null && value2 !== null) {
      const keys1 = Object.keys(value1);
      const keys2 = Object.keys(value2);
      if (keys1.length !== keys2.length) {
        return false;
      }
      return keys1.every((key) => value1[key] === value2[key]);
    }
    return value1 === value2;
  }
  toRgba() {
    const [r, g, b, a] = this._components;
    return { r, g, b, a };
  }
  toRgb() {
    const [r, g, b] = this._components;
    return { r, g, b };
  }
  toRgbaString() {
    const [r, g, b] = this.toUint8RgbArray();
    return `rgba(${r},${g},${b},${this.alpha})`;
  }
  toUint8RgbArray(out) {
    const [r, g, b] = this._components;
    out = out ?? [];
    out[0] = Math.round(r * 255);
    out[1] = Math.round(g * 255);
    out[2] = Math.round(b * 255);
    return out;
  }
  toRgbArray(out) {
    out = out ?? [];
    const [r, g, b] = this._components;
    out[0] = r;
    out[1] = g;
    out[2] = b;
    return out;
  }
  toNumber() {
    return this._int;
  }
  toLittleEndianNumber() {
    const value = this._int;
    return (value >> 16) + (value & 65280) + ((value & 255) << 16);
  }
  multiply(value) {
    const [r, g, b, a] = _Color.temp.setValue(value)._components;
    this._components[0] *= r;
    this._components[1] *= g;
    this._components[2] *= b;
    this._components[3] *= a;
    this.refreshInt();
    this._value = null;
    return this;
  }
  premultiply(alpha, applyToRGB = true) {
    if (applyToRGB) {
      this._components[0] *= alpha;
      this._components[1] *= alpha;
      this._components[2] *= alpha;
    }
    this._components[3] = alpha;
    this.refreshInt();
    this._value = null;
    return this;
  }
  toPremultiplied(alpha, applyToRGB = true) {
    if (alpha === 1) {
      return (255 << 24) + this._int;
    }
    if (alpha === 0) {
      return applyToRGB ? 0 : this._int;
    }
    let r = this._int >> 16 & 255;
    let g = this._int >> 8 & 255;
    let b = this._int & 255;
    if (applyToRGB) {
      r = r * alpha + 0.5 | 0;
      g = g * alpha + 0.5 | 0;
      b = b * alpha + 0.5 | 0;
    }
    return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;
  }
  toHex() {
    const hexString = this._int.toString(16);
    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
  }
  toHexa() {
    const alphaValue = Math.round(this._components[3] * 255);
    const alphaString = alphaValue.toString(16);
    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
  }
  setAlpha(alpha) {
    this._components[3] = this._clamp(alpha);
    return this;
  }
  round(steps) {
    const [r, g, b] = this._components;
    this._components[0] = Math.round(r * steps) / steps;
    this._components[1] = Math.round(g * steps) / steps;
    this._components[2] = Math.round(b * steps) / steps;
    this.refreshInt();
    this._value = null;
    return this;
  }
  toArray(out) {
    out = out ?? [];
    const [r, g, b, a] = this._components;
    out[0] = r;
    out[1] = g;
    out[2] = b;
    out[3] = a;
    return out;
  }
  normalize(value) {
    let r;
    let g;
    let b;
    let a;
    if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
      const int = value;
      r = (int >> 16 & 255) / 255;
      g = (int >> 8 & 255) / 255;
      b = (int & 255) / 255;
      a = 1;
    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
      value = this._clamp(value);
      [r, g, b, a = 1] = value;
    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
      value = this._clamp(value, 0, 255);
      [r, g, b, a = 255] = value;
      r /= 255;
      g /= 255;
      b /= 255;
      a /= 255;
    } else if (typeof value === "string" || typeof value === "object") {
      if (typeof value === "string") {
        const match = _Color.HEX_PATTERN.exec(value);
        if (match) {
          value = `#${match[2]}`;
        }
      }
      const color = colord.colord(value);
      if (color.isValid()) {
        ({ r, g, b, a } = color.rgba);
        r /= 255;
        g /= 255;
        b /= 255;
      }
    }
    if (r !== void 0) {
      this._components[0] = r;
      this._components[1] = g;
      this._components[2] = b;
      this._components[3] = a;
      this.refreshInt();
    } else {
      throw new Error(`Unable to convert color ${value}`);
    }
  }
  refreshInt() {
    this._clamp(this._components);
    const [r, g, b] = this._components;
    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);
  }
  _clamp(value, min = 0, max = 1) {
    if (typeof value === "number") {
      return Math.min(Math.max(value, min), max);
    }
    value.forEach((v, i) => {
      value[i] = Math.min(Math.max(v, min), max);
    });
    return value;
  }
};
let Color = _Color;
Color.shared = new _Color();
Color.temp = new _Color();
Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;

exports.Color = Color;
//# sourceMappingURL=Color.js.map


/***/ }),

/***/ "./node_modules/@pixi/color/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/color/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Color = __webpack_require__(/*! ./Color.js */ "./node_modules/@pixi/color/lib/Color.js");



exports.Color = Color.Color;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/colord/index.js":
/*!**************************************!*\
  !*** ./node_modules/colord/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

Object.defineProperty(exports, "__esModule", ({value:!0}));var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return"string"==typeof r?r.length>0:"number"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},o=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},a=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},s=/^#([0-9a-f]{3,8})$/i,i=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,o=Math.max(t,n,e),a=o-Math.min(t,n,e),s=a?o===t?(n-e)/a:o===n?2+(e-t)/a:4+(t-n)/a:0;return{h:60*(s<0?s+6:s),s:o?a/o*100:0,v:o/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var o=Math.floor(t),a=e*(1-n),s=e*(1-(t-o)*n),i=e*(1-(1-t+o)*n),h=o%6;return{r:255*[e,s,a,a,i,e][h],g:255*[i,e,e,s,a,a][h],b:255*[a,a,i,e,e,s][h],a:u}},d=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},g=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},p=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,c=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y={string:[[function(r){var t=s.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:o({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l.exec(t)||c.exec(t);if(!n)return null;var e,u,o=d({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(o)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,a=r.a,s=void 0===a?1:a;return t(n)&&t(e)&&t(u)?o({r:Number(n),g:Number(e),b:Number(u),a:Number(s)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,o=r.a,a=void 0===o?1:o;if(!t(n)||!t(e)||!t(u))return null;var s=d({h:Number(n),s:Number(e),l:Number(u),a:Number(a)});return f(s)},"hsl"],[function(r){var n=r.h,o=r.s,a=r.v,s=r.a,i=void 0===s?1:s;if(!t(n)||!t(o)||!t(a))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(o),v:Number(a),a:Number(i)});return b(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return"string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},M=function(r,t){var n=p(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},I=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},H=function(r,t){var n=p(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},$=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(I(this.rgba),2)},r.prototype.isDark=function(){return I(this.rgba)<.5},r.prototype.isLight=function(){return I(this.rgba)>=.5},r.prototype.toHex=function(){return r=a(this.rgba),t=r.r,e=r.g,u=r.b,s=(o=r.a)<1?i(n(255*o)):"","#"+i(t)+i(e)+i(u)+s;var r,t,e,u,o,s},r.prototype.toRgb=function(){return a(this.rgba)},r.prototype.toRgbString=function(){return r=a(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";var r,t,n,e,u},r.prototype.toHsl=function(){return g(p(this.rgba))},r.prototype.toHslString=function(){return r=g(p(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return j({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),j(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),j(M(this.rgba,-r))},r.prototype.grayscale=function(){return j(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),j(H(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),j(H(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return"number"==typeof r?j({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=p(this.rgba);return"number"==typeof r?j({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===j(r).toHex()},r}(),j=function(r){return r instanceof $?r:new $(r)},w=[];exports.Colord=$,exports.colord=j,exports.extend=function(r){r.forEach(function(r){w.indexOf(r)<0&&(r($,y),w.push(r))})},exports.getFormat=function(r){return x(r)[1]},exports.random=function(){return new $({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};


/***/ }),

/***/ "./node_modules/colord/plugins/names.js":
/*!**********************************************!*\
  !*** ./node_modules/colord/plugins/names.js ***!
  \**********************************************/
/***/ ((module) => {

module.exports=function(e,f){var a={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var d,i,o=r[this.toHex()];if(o)return o;if(null==f?void 0:f.closest){var n=this.toRgb(),t=1/0,b="black";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=n,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d="transparent"===r?"#0000":a[r];return d?new e(d).toRgb():null},"name"])};


/***/ }),

/***/ "./node_modules/earcut/src/earcut.js":
/*!*******************************************!*\
  !*** ./node_modules/earcut/src/earcut.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


module.exports = earcut;
module.exports["default"] = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    var p = c.next;
    while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize),
        maxZ = zOrder(x1, y1, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }

    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
           (bx - px) * (cy - py) >= (cx - px) * (by - py);
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = 0;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),

/***/ "./node_modules/honeycomb-grid/dist/honeycomb-grid.umd.js":
/*!****************************************************************!*\
  !*** ./node_modules/honeycomb-grid/dist/honeycomb-grid.umd.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

(function(u,h){ true?h(exports):0})(this,function(u){"use strict";const h=e=>Number.isFinite(e)&&!Number.isNaN(e),N=e=>typeof e=="object"&&e!==null,rt=e=>N(e)&&h(e.q)&&h(e.r),st=e=>typeof e=="function",O=e=>N(e)&&h(e.col)&&h(e.row),z=e=>N(e)&&h(e.x)&&h(e.y),R=e=>Array.isArray(e)&&h(e[0])&&h(e[1]),E=(e,t)=>t+e*(t&1)>>1;function ot(e,t){return(e%t+t)%t}const it=(e,t)=>ot(e+t,8),P=([e,t,n=-e-t])=>({q:e,r:t,s:n});function x({q:e,r:t,s:n}){const r=h(e),s=h(t),o=h(n);if(r&&s&&o)return{q:e,r:t,s:n};if(r&&s)return{q:e,r:t,s:-e-t};if(r&&o)return{q:e,r:-e-n,s:n};if(s&&o)return{q:-t-n,r:t,s:n};throw new TypeError(`Can't determine three cube coordinates from less than two coordinates. Received: { q: ${e}, r: ${t}, s: ${n} }.`)}var d=(e=>(e.FLAT="FLAT",e.POINTY="POINTY",e))(d||{});function U(e,t){if(N(e)&&e.xRadius>0&&e.yRadius>0)return e;if(N(e)&&e.width>0&&e.height>0){const{width:n,height:r}=e;return t===d.POINTY?{xRadius:n/Math.sqrt(3),yRadius:r/2}:{xRadius:n/2,yRadius:r/Math.sqrt(3)}}if(e>0)return{xRadius:e,yRadius:e};throw new TypeError(`Invalid dimensions: ${JSON.stringify(e)}. Dimensions must be expressed as an Ellipse ({ xRadius: number, yRadius: number }), a Rectangle ({ width: number, height: number }) or a number.`)}function _(e,t){if(z(e))return e;if(!t)throw new TypeError(`Supply a bounding box ({ width: number, height: number }). Received: ${JSON.stringify(t)}`);if(e==="topLeft")return{x:t.width*-.5,y:t.height*-.5};throw new TypeError(`Invalid origin: ${JSON.stringify(e)}. Origin must be expressed as a Point ({ x: number, y: number }) or the string 'topLeft'.`)}class W{static get settings(){const{dimensions:t,orientation:n,origin:r,offset:s}=this.prototype;return{dimensions:t,orientation:n,origin:r,offset:s}}get center(){const{width:t,height:n,x:r,y:s}=this;return{x:t/2-r,y:n/2-s}}get col(){return p(this).col}get corners(){const{orientation:t,width:n,height:r,x:s,y:o}=this;return t===d.POINTY?ct(n,r,s,o):ut(n,r,s,o)}get dimensions(){return b.dimensions}get height(){const{orientation:t,dimensions:{yRadius:n}}=this;return t===d.POINTY?n*2:n*Math.sqrt(3)}get isFlat(){return this.orientation===d.FLAT}get isPointy(){return this.orientation===d.POINTY}get orientation(){return b.orientation}get origin(){return b.origin}get offset(){return b.offset}get row(){return p(this).row}get width(){const{orientation:t,dimensions:{xRadius:n}}=this;return t===d.POINTY?n*Math.sqrt(3):n*2}get x(){return $(this).x}get y(){return $(this).y}get s(){return-this.q-this.r}q;r;constructor(t=[0,0]){const{q:n,r}=w(this,t);this.q=n,this.r=r}clone(t=this){return new this.constructor(t)}equals(t){return k(this,O(t)?B(this,t):t)}toString(){return`${this.constructor.name}(${this.q},${this.r})`}translate(t){return X(this,t)}}const b={dimensions:{xRadius:1,yRadius:1},orientation:d.POINTY,origin:{x:0,y:0},offset:-1},ct=(e,t,n,r)=>[{x:n+e*.5,y:r-t*.25},{x:n+e*.5,y:r+t*.25},{x:n,y:r+t*.5},{x:n-e*.5,y:r+t*.25},{x:n-e*.5,y:r-t*.25},{x:n,y:r-t*.5}],ut=(e,t,n,r)=>[{x:n+e*.25,y:r-t*.5},{x:n+e*.5,y:r},{x:n+e*.25,y:r+t*.5},{x:n-e*.25,y:r+t*.5},{x:n-e*.5,y:r},{x:n-e*.25,y:r-t*.5}];function Z(e){const{dimensions:t,orientation:n,origin:r,offset:s}={...b,...e};return class extends W{get dimensions(){return U(t,n)}get orientation(){return n}get origin(){return _(r,this)}get offset(){return s}}}function k(e,t){if(O(e)&&O(t))return e.col===t.col&&e.row===t.row;if(Object.hasOwn(e,"col")||Object.hasOwn(t,"col"))throw new Error(`Can't compare coordinates where one are offset coordinates. Either pass two offset coordinates or two axial/cube coordinates. Received: ${JSON.stringify(e)} and ${JSON.stringify(t)}`);const n=R(e)?P(e):e,r=R(t)?P(t):t;return n.q===r.q&&n.r===r.r}const ft=(e,t,n)=>({col:e+E(n,t),row:t}),ht=(e,t,n)=>({col:e,row:t+E(n,e)}),p=({q:e,r:t,offset:n,isPointy:r})=>r?ft(e,t,n):ht(e,t,n),$=({orientation:e,dimensions:{xRadius:t,yRadius:n},origin:{x:r,y:s},q:o,r:i})=>e===d.POINTY?{x:t*Math.sqrt(3)*(o+i/2)-r,y:n*3/2*i-s}:{x:t*3/2*o-r,y:n*Math.sqrt(3)*(i+o/2)-s},Y=(e,t,n)=>{const r=e-E(n,t),s=t,o=-r-s;return{q:r,r:s,s:o}},J=(e,t,n)=>{const r=e,s=t-E(n,e),o=-r-s;return{q:r,r:s,s:o}},B=({offset:e,orientation:t},{col:n,row:r})=>t===d.POINTY?Y(n,r,e):J(n,r,e),F=e=>{const{q:t,r:n,s:r}=x(e);let s=Math.round(t),o=Math.round(n),i=Math.round(r);const c=Math.abs(t-s),f=Math.abs(n-o),l=Math.abs(r-i);return c>f&&c>l?s=-o-i:f>l?o=-s-i:i=-s-o,{q:s,r:o,s:i}},V=({dimensions:{xRadius:e,yRadius:t},origin:n,orientation:r},{x:s,y:o})=>(s+=n.x,o+=n.y,r===d.POINTY?F({q:Math.sqrt(3)*s/(3*e)-o/(3*t),r:2/3*(o/t)}):F({q:2/3*(s/e),r:Math.sqrt(3)*o/(3*t)-s/(3*e)}));function w(e,t){return R(t)?P(t):O(t)?B(e,t):x(t)}function X(e,t){const{q:n,r,s}=x(e),{q:o,r:i,s:c}=x(t),f={q:n+o,r:r+i,s:s+c};return e instanceof W?e.clone(f):f}function I(e,t,n){const{q:r,r:s,s:o}=w(e,t),{q:i,r:c,s:f}=w(e,n);return Math.max(Math.abs(r-i),Math.abs(s-c),Math.abs(o-f))}var L=(e=>(e.CLOCKWISE="CLOCKWISE",e.COUNTERCLOCKWISE="COUNTERCLOCKWISE",e))(L||{}),a=(e=>(e[e.N=0]="N",e[e.NE=1]="NE",e[e.E=2]="E",e[e.SE=3]="SE",e[e.S=4]="S",e[e.SW=5]="SW",e[e.W=6]="W",e[e.NW=7]="NW",e))(a||{});const at=[null,{q:1,r:-1},{q:1,r:0},{q:0,r:1},null,{q:-1,r:1},{q:-1,r:0},{q:0,r:-1}],lt=[{q:0,r:-1},{q:1,r:-1},null,{q:1,r:0},{q:0,r:1},{q:-1,r:1},null,{q:-1,r:0}],gt=({offset:e,q:t,r:n,col:r,row:s},o)=>{if(o===a.S||o===a.N){const c=o===a.S?s+1:s-1;return Y(r,c,e)}const i=at[o];return{q:t+i.q,r:n+i.r}},dt=({offset:e,q:t,r:n,col:r,row:s},o)=>{if(o===a.E||o===a.W){const c=o===a.E?r+1:r-1;return J(c,s,e)}const i=lt[o];return{q:t+i.q,r:n+i.r}},A=(e,t)=>e.clone(e.isPointy?gt(e,t):dt(e,t));function C(e){return Array.isArray(e)?function(n,r){const s=[];let o=r;for(const i of e)for(const c of i(n,o))s.push(o=c);return s}:e}const mt=(...e)=>t=>e.map(t);function v(e){return qt(e)?yt(e):Tt(e)}function qt(e){return e.direction in a}function yt({start:e,direction:t,length:n}){return function(s,o){const i=[];let f=s(e??o);!e&&o&&(f=A(f,t));for(let l=0;l<n;l++)i.push(f),f=A(f,t);return i}}function Tt({start:e,stop:t}){return function(r,s){const o=[],i=r(e??s),c=D(i),f=D(w(i,t)),l=Ot(c,f),g=I(i,i,t),S=1/Math.max(g,1);let T=!e&&s?1:0;for(T;T<=g;T++){const H=F(l(S*T));o.push(r(H))}return o}}function D({q:e,r:t,s:n}){return{q:e+1e-6,r:t+1e-6,s:n+-2e-6}}function Ot(e,t){return n=>{const r=e.q*(1-n)+t.q*n,s=e.r*(1-n)+t.r*n;return{q:r,r:s}}}const xt=e=>(t,n)=>[A(t(n),e)];function j(e,t,{includeSource:n=!0}={}){return function(s,o){const i=[];for(const c of C(e)(s,o)){n&&i.push(c);for(const f of C(t)(s,c))i.push(f)}return i}}function bt(e,t){return function(r,s){const{width:o,height:i,start:c,direction:f=a.E}=t?wt(e,t,r()):e,l=c??s??[0,0],g=j(v({start:l,direction:it(f,2),length:i}),v({direction:f,length:o-1}))(r,l);return!c&&s?g.slice(1):g}}function wt(e,t,{isPointy:n,offset:r}){const{col:s,row:o}=G(e,n,r),{col:i,row:c}=G(t,n,r),f=s<i?"A":"B",l=o<c?"A":"B",g=f+l,{swapWidthHeight:S,direction:T}=Ct[g],H=Math.abs(s-i)+1,m=Math.abs(o-c)+1;return{width:S?m:H,height:S?H:m,start:e,direction:T}}function G(e,t,n){if(O(e))return e;const{q:r,r:s}=R(e)?P(e):x(e);return p({q:r,r:s,isPointy:t,offset:n})}const Ct={AA:{swapWidthHeight:!1,direction:a.E},AB:{swapWidthHeight:!0,direction:a.N},BA:{swapWidthHeight:!0,direction:a.S},BB:{swapWidthHeight:!1,direction:a.W}};function St(e,t){return C(Array.from({length:e},()=>C(t)))}function tt(e){const{center:t,rotation:n=L.CLOCKWISE}=e;return function(s,o){const i=n.toUpperCase(),c=[];let{radius:f}=e;const l=h(f);let g;l?g=s(t).translate({q:f,s:-f}):(g=s(e.start??o),f=I(g,t,g));const{q:S,r:T,s:H}=w(g,t);let m=s({q:S,r:T-f,s:H+f});if(i===L.CLOCKWISE)for(let y=0;y<6;y++)for(let M=0;M<f;M++){const{q:K,r:Q}=et[y];m=s({q:m.q+K,r:m.r+Q}),c.push(m)}else for(let y=5;y>=0;y--)for(let M=0;M<f;M++){const{q:K,r:Q}=et[y];m=s({q:m.q-K,r:m.r-Q}),c.push(m)}const Nt=l?!1:!e.start&&o,nt=c.findIndex(y=>y.equals(g));return c.slice(nt+(Nt?1:0)).concat(c.slice(0,nt))}}const et=[{q:1,r:0},{q:0,r:1},{q:-1,r:1},{q:-1,r:0},{q:0,r:-1},{q:1,r:-1}];function Ht({radius:e,start:t,rotation:n}){return function(s,o){const i=t??o??[0,0],c=!t&&o?e:e+1;return j(v({start:t,direction:a.N,length:c}),tt({center:i,rotation:n}))(s,o)}}class q{static fromIterable(t){const n=t[Symbol.iterator]().next().value;if(!n)throw new TypeError(`Can't create grid from empty iterable: ${JSON.stringify(t)}`);return new q(n.constructor,t)}static fromJSON({hexSettings:t,coordinates:n},r){if(r){const o=n.map(r),i=o.length>0?o[0].constructor:r({q:0,r:0},0,[{q:0,r:0}]).constructor;return new q(i,o)}const s=Z(t);return new q(s,n.map(o=>new s(o)))}get size(){return this.#e.size}get pixelWidth(){if(this.size===0)return 0;const{isPointy:t,width:n}=this.hexPrototype,r=this.toArray(),{0:s,length:o,[o-1]:i}=t?r.sort((c,f)=>f.s-c.s||c.q-f.q):r.sort((c,f)=>c.q-f.q);return i.x-s.x+n}get pixelHeight(){if(this.size===0)return 0;const{isPointy:t,height:n}=this.hexPrototype,r=this.toArray(),{0:s,length:o,[o-1]:i}=t?r.sort((c,f)=>c.r-f.r):r.sort((c,f)=>f.s-c.s||c.r-f.r);return i.y-s.y+n}[Symbol.iterator](){return this.#e.values()}get hexPrototype(){return this.#t.prototype}#t;#e=new Map;constructor(t,n=[]){if(t instanceof q){this.#t=t.#t,this.setHexes(t);return}this.#t=t,this.setHexes(this.#r(n))}createHex(t){return new this.#t(t)}getHex(t){const n=this.createHex(t);return this.#e.get(n.toString())}hasHex(t){return this.#e.has(t.toString())}setHexes(t){for(const n of t){const r=n instanceof W?n:new this.#t(n);this.#n(r)}return this}filter(t){const n=new q(this.#t);for(const r of this)t(r)&&n.#n(r);return n}map(t){const n=new q(this.#t);for(const r of this)n.#n(t(r));return n}traverse(t,{bail:n=!1}={}){const r=new q(this.#t);for(const s of this.#r(t)){const o=this.getHex(s);if(o)r.#n(o);else if(n)return r}return r}forEach(t){for(const n of this)t(n);return this}reduce(t,n){if(n===void 0){let s,o,i;for(const c of this)o=i,i=c,o&&(s=t(o,i));return s}let r=n;for(const s of this)r=t(r,s);return r}toArray(){return Array.from(this)}toJSON(){const{dimensions:t,orientation:n,origin:r,offset:s}=this.hexPrototype;return{hexSettings:{dimensions:t,orientation:n,origin:r,offset:s},coordinates:this.toArray()}}toString(){return`${this.constructor.name}(${this.size})`}pointToHex(t,{allowOutside:n=!0}={}){const r=V(this.hexPrototype,t),s=this.getHex(r);return n?s??this.createHex(r):s}distance(t,n,{allowOutside:r=!0}={}){if(r)return I(this.hexPrototype,t,n);const s=this.getHex(t),o=this.getHex(n);if(!(!s||!o))return I(this.hexPrototype,s,o)}neighborOf(t,n,{allowOutside:r=!0}={}){const s=A(this.createHex(t),n),o=this.getHex(s);return r?o??s:o}#n(t){this.#e.set(t.toString(),t)}#r(t){return this.#s(t)?this.#o(t):Array.isArray(t)&&this.#s(t[0])?this.#o(C(t)):t}#s(t){return st(t)}#o(t){return t(this.createHex.bind(this))}}u.Direction=a,u.Grid=q,u.Hex=W,u.Orientation=d,u.Rotation=L,u.completeCube=x,u.concat=C,u.createHexDimensions=U,u.createHexOrigin=_,u.defaultHexSettings=b,u.defineHex=Z,u.distance=I,u.equals=k,u.fromCoordinates=mt,u.hexToOffset=p,u.hexToPoint=$,u.isAxial=rt,u.isOffset=O,u.isPoint=z,u.isTuple=R,u.line=v,u.move=xt,u.neighborOf=A,u.offsetFromZero=E,u.offsetToCube=B,u.offsetToCubeFlat=J,u.offsetToCubePointy=Y,u.pointToCube=V,u.rectangle=bt,u.repeat=St,u.repeatWith=j,u.ring=tt,u.round=F,u.spiral=Ht,u.toCube=w,u.translate=X,u.tupleToCube=P,Object.defineProperty(u,Symbol.toStringTag,{value:"Module"})});


/***/ }),

/***/ "./node_modules/ismobilejs/esm/index.js":
/*!**********************************************!*\
  !*** ./node_modules/ismobilejs/esm/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _isMobile__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _isMobile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isMobile */ "./node_modules/ismobilejs/esm/isMobile.js");


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/ismobilejs/esm/isMobile.js":
/*!*************************************************!*\
  !*** ./node_modules/ismobilejs/esm/isMobile.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isMobile)
/* harmony export */ });
var appleIphone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
var amazonTablet = /Silk/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackBerry = /BlackBerry/i;
var otherBlackBerry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
var isAppleTabletOnIos13 = function (navigator) {
    return (typeof navigator !== 'undefined' &&
        navigator.platform === 'MacIntel' &&
        typeof navigator.maxTouchPoints === 'number' &&
        navigator.maxTouchPoints > 1 &&
        typeof MSStream === 'undefined');
};
function createMatch(userAgent) {
    return function (regex) { return regex.test(userAgent); };
}
function isMobile(param) {
    var nav = {
        userAgent: '',
        platform: '',
        maxTouchPoints: 0
    };
    if (!param && typeof navigator !== 'undefined') {
        nav = {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            maxTouchPoints: navigator.maxTouchPoints || 0
        };
    }
    else if (typeof param === 'string') {
        nav.userAgent = param;
    }
    else if (param && param.userAgent) {
        nav = {
            userAgent: param.userAgent,
            platform: param.platform,
            maxTouchPoints: param.maxTouchPoints || 0
        };
    }
    var userAgent = nav.userAgent;
    var tmp = userAgent.split('[FBAN');
    if (typeof tmp[1] !== 'undefined') {
        userAgent = tmp[0];
    }
    tmp = userAgent.split('Twitter');
    if (typeof tmp[1] !== 'undefined') {
        userAgent = tmp[0];
    }
    var match = createMatch(userAgent);
    var result = {
        apple: {
            phone: match(appleIphone) && !match(windowsPhone),
            ipod: match(appleIpod),
            tablet: !match(appleIphone) &&
                (match(appleTablet) || isAppleTabletOnIos13(nav)) &&
                !match(windowsPhone),
            universal: match(appleUniversal),
            device: (match(appleIphone) ||
                match(appleIpod) ||
                match(appleTablet) ||
                match(appleUniversal) ||
                isAppleTabletOnIos13(nav)) &&
                !match(windowsPhone)
        },
        amazon: {
            phone: match(amazonPhone),
            tablet: !match(amazonPhone) && match(amazonTablet),
            device: match(amazonPhone) || match(amazonTablet)
        },
        android: {
            phone: (!match(windowsPhone) && match(amazonPhone)) ||
                (!match(windowsPhone) && match(androidPhone)),
            tablet: !match(windowsPhone) &&
                !match(amazonPhone) &&
                !match(androidPhone) &&
                (match(amazonTablet) || match(androidTablet)),
            device: (!match(windowsPhone) &&
                (match(amazonPhone) ||
                    match(amazonTablet) ||
                    match(androidPhone) ||
                    match(androidTablet))) ||
                match(/\bokhttp\b/i)
        },
        windows: {
            phone: match(windowsPhone),
            tablet: match(windowsTablet),
            device: match(windowsPhone) || match(windowsTablet)
        },
        other: {
            blackberry: match(otherBlackBerry),
            blackberry10: match(otherBlackBerry10),
            opera: match(otherOpera),
            firefox: match(otherFirefox),
            chrome: match(otherChrome),
            device: match(otherBlackBerry) ||
                match(otherBlackBerry10) ||
                match(otherOpera) ||
                match(otherFirefox) ||
                match(otherChrome)
        },
        any: false,
        phone: false,
        tablet: false
    };
    result.any =
        result.apple.device ||
            result.android.device ||
            result.windows.device ||
            result.other.device;
    result.phone =
        result.apple.phone || result.android.phone || result.windows.phone;
    result.tablet =
        result.apple.tablet || result.android.tablet || result.windows.tablet;
    return result;
}
//# sourceMappingURL=isMobile.js.map

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters.js":
/*!*********************************************!*\
  !*** ./node_modules/pixi.js/lib/filters.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var filterAlpha = __webpack_require__(/*! @pixi/filter-alpha */ "./node_modules/pixi.js/node_modules/@pixi/filter-alpha/lib/index.js");
var filterBlur = __webpack_require__(/*! @pixi/filter-blur */ "./node_modules/pixi.js/node_modules/@pixi/filter-blur/lib/index.js");
var filterColorMatrix = __webpack_require__(/*! @pixi/filter-color-matrix */ "./node_modules/pixi.js/node_modules/@pixi/filter-color-matrix/lib/index.js");
var filterDisplacement = __webpack_require__(/*! @pixi/filter-displacement */ "./node_modules/pixi.js/node_modules/@pixi/filter-displacement/lib/index.js");
var filterFxaa = __webpack_require__(/*! @pixi/filter-fxaa */ "./node_modules/pixi.js/node_modules/@pixi/filter-fxaa/lib/index.js");
var filterNoise = __webpack_require__(/*! @pixi/filter-noise */ "./node_modules/pixi.js/node_modules/@pixi/filter-noise/lib/index.js");

const filters = {
  AlphaFilter: filterAlpha.AlphaFilter,
  BlurFilter: filterBlur.BlurFilter,
  BlurFilterPass: filterBlur.BlurFilterPass,
  ColorMatrixFilter: filterColorMatrix.ColorMatrixFilter,
  DisplacementFilter: filterDisplacement.DisplacementFilter,
  FXAAFilter: filterFxaa.FXAAFilter,
  NoiseFilter: filterNoise.NoiseFilter
};
Object.entries(filters).forEach(([key, FilterClass]) => {
  Object.defineProperty(filters, key, {
    get() {
      core.utils.deprecation("7.1.0", `filters.${key} has moved to ${key}`);
      return FilterClass;
    }
  });
});

exports.filters = filters;
//# sourceMappingURL=filters.js.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/pixi.js/lib/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(/*! @pixi/mixin-cache-as-bitmap */ "./node_modules/pixi.js/node_modules/@pixi/mixin-cache-as-bitmap/lib/index.js");
__webpack_require__(/*! @pixi/mixin-get-child-by-name */ "./node_modules/pixi.js/node_modules/@pixi/mixin-get-child-by-name/lib/index.js");
__webpack_require__(/*! @pixi/mixin-get-global-position */ "./node_modules/pixi.js/node_modules/@pixi/mixin-get-global-position/lib/index.js");
var filters = __webpack_require__(/*! ./filters.js */ "./node_modules/pixi.js/lib/filters.js");
var accessibility = __webpack_require__(/*! @pixi/accessibility */ "./node_modules/pixi.js/node_modules/@pixi/accessibility/lib/index.js");
var app = __webpack_require__(/*! @pixi/app */ "./node_modules/pixi.js/node_modules/@pixi/app/lib/index.js");
var assets = __webpack_require__(/*! @pixi/assets */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/index.js");
var compressedTextures = __webpack_require__(/*! @pixi/compressed-textures */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/index.js");
var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var display = __webpack_require__(/*! @pixi/display */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/index.js");
var events = __webpack_require__(/*! @pixi/events */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/index.js");
var extract = __webpack_require__(/*! @pixi/extract */ "./node_modules/pixi.js/node_modules/@pixi/extract/lib/index.js");
var filterAlpha = __webpack_require__(/*! @pixi/filter-alpha */ "./node_modules/pixi.js/node_modules/@pixi/filter-alpha/lib/index.js");
var filterBlur = __webpack_require__(/*! @pixi/filter-blur */ "./node_modules/pixi.js/node_modules/@pixi/filter-blur/lib/index.js");
var filterColorMatrix = __webpack_require__(/*! @pixi/filter-color-matrix */ "./node_modules/pixi.js/node_modules/@pixi/filter-color-matrix/lib/index.js");
var filterDisplacement = __webpack_require__(/*! @pixi/filter-displacement */ "./node_modules/pixi.js/node_modules/@pixi/filter-displacement/lib/index.js");
var filterFxaa = __webpack_require__(/*! @pixi/filter-fxaa */ "./node_modules/pixi.js/node_modules/@pixi/filter-fxaa/lib/index.js");
var filterNoise = __webpack_require__(/*! @pixi/filter-noise */ "./node_modules/pixi.js/node_modules/@pixi/filter-noise/lib/index.js");
var graphics = __webpack_require__(/*! @pixi/graphics */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/index.js");
var mesh = __webpack_require__(/*! @pixi/mesh */ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/index.js");
var meshExtras = __webpack_require__(/*! @pixi/mesh-extras */ "./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/index.js");
var particleContainer = __webpack_require__(/*! @pixi/particle-container */ "./node_modules/pixi.js/node_modules/@pixi/particle-container/lib/index.js");
var prepare = __webpack_require__(/*! @pixi/prepare */ "./node_modules/pixi.js/node_modules/@pixi/prepare/lib/index.js");
var sprite = __webpack_require__(/*! @pixi/sprite */ "./node_modules/pixi.js/node_modules/@pixi/sprite/lib/index.js");
var spriteAnimated = __webpack_require__(/*! @pixi/sprite-animated */ "./node_modules/pixi.js/node_modules/@pixi/sprite-animated/lib/index.js");
var spriteTiling = __webpack_require__(/*! @pixi/sprite-tiling */ "./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/index.js");
var spritesheet = __webpack_require__(/*! @pixi/spritesheet */ "./node_modules/pixi.js/node_modules/@pixi/spritesheet/lib/index.js");
var text = __webpack_require__(/*! @pixi/text */ "./node_modules/pixi.js/node_modules/@pixi/text/lib/index.js");
var textBitmap = __webpack_require__(/*! @pixi/text-bitmap */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/index.js");
var textHtml = __webpack_require__(/*! @pixi/text-html */ "./node_modules/pixi.js/node_modules/@pixi/text-html/lib/index.js");



exports.filters = filters.filters;
Object.keys(accessibility).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return accessibility[k]; }
	});
});
Object.keys(app).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return app[k]; }
	});
});
Object.keys(assets).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return assets[k]; }
	});
});
Object.keys(compressedTextures).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return compressedTextures[k]; }
	});
});
Object.keys(core).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return core[k]; }
	});
});
Object.keys(display).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return display[k]; }
	});
});
Object.keys(events).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return events[k]; }
	});
});
Object.keys(extract).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return extract[k]; }
	});
});
Object.keys(filterAlpha).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return filterAlpha[k]; }
	});
});
Object.keys(filterBlur).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return filterBlur[k]; }
	});
});
Object.keys(filterColorMatrix).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return filterColorMatrix[k]; }
	});
});
Object.keys(filterDisplacement).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return filterDisplacement[k]; }
	});
});
Object.keys(filterFxaa).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return filterFxaa[k]; }
	});
});
Object.keys(filterNoise).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return filterNoise[k]; }
	});
});
Object.keys(graphics).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return graphics[k]; }
	});
});
Object.keys(mesh).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return mesh[k]; }
	});
});
Object.keys(meshExtras).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return meshExtras[k]; }
	});
});
Object.keys(particleContainer).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return particleContainer[k]; }
	});
});
Object.keys(prepare).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return prepare[k]; }
	});
});
Object.keys(sprite).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return sprite[k]; }
	});
});
Object.keys(spriteAnimated).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return spriteAnimated[k]; }
	});
});
Object.keys(spriteTiling).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return spriteTiling[k]; }
	});
});
Object.keys(spritesheet).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return spritesheet[k]; }
	});
});
Object.keys(text).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return text[k]; }
	});
});
Object.keys(textBitmap).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return textBitmap[k]; }
	});
});
Object.keys(textHtml).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return textHtml[k]; }
	});
});
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/accessibility/lib/AccessibilityManager.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/accessibility/lib/AccessibilityManager.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var display = __webpack_require__(/*! @pixi/display */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/index.js");
var events = __webpack_require__(/*! @pixi/events */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/index.js");
var accessibleTarget = __webpack_require__(/*! ./accessibleTarget.js */ "./node_modules/pixi.js/node_modules/@pixi/accessibility/lib/accessibleTarget.js");

display.DisplayObject.mixin(accessibleTarget.accessibleTarget);
const KEY_CODE_TAB = 9;
const DIV_TOUCH_SIZE = 100;
const DIV_TOUCH_POS_X = 0;
const DIV_TOUCH_POS_Y = 0;
const DIV_TOUCH_ZINDEX = 2;
const DIV_HOOK_SIZE = 1;
const DIV_HOOK_POS_X = -1e3;
const DIV_HOOK_POS_Y = -1e3;
const DIV_HOOK_ZINDEX = 2;
class AccessibilityManager {
  constructor(renderer) {
    this.debug = false;
    this._isActive = false;
    this._isMobileAccessibility = false;
    this.pool = [];
    this.renderId = 0;
    this.children = [];
    this.androidUpdateCount = 0;
    this.androidUpdateFrequency = 500;
    this._hookDiv = null;
    if (core.utils.isMobile.tablet || core.utils.isMobile.phone) {
      this.createTouchHook();
    }
    const div = document.createElement("div");
    div.style.width = `${DIV_TOUCH_SIZE}px`;
    div.style.height = `${DIV_TOUCH_SIZE}px`;
    div.style.position = "absolute";
    div.style.top = `${DIV_TOUCH_POS_X}px`;
    div.style.left = `${DIV_TOUCH_POS_Y}px`;
    div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
    this.div = div;
    this.renderer = renderer;
    this._onKeyDown = this._onKeyDown.bind(this);
    this._onMouseMove = this._onMouseMove.bind(this);
    globalThis.addEventListener("keydown", this._onKeyDown, false);
  }
  get isActive() {
    return this._isActive;
  }
  get isMobileAccessibility() {
    return this._isMobileAccessibility;
  }
  createTouchHook() {
    const hookDiv = document.createElement("button");
    hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
    hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
    hookDiv.style.position = "absolute";
    hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
    hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
    hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
    hookDiv.style.backgroundColor = "#FF0000";
    hookDiv.title = "select to enable accessibility for this content";
    hookDiv.addEventListener("focus", () => {
      this._isMobileAccessibility = true;
      this.activate();
      this.destroyTouchHook();
    });
    document.body.appendChild(hookDiv);
    this._hookDiv = hookDiv;
  }
  destroyTouchHook() {
    if (!this._hookDiv) {
      return;
    }
    document.body.removeChild(this._hookDiv);
    this._hookDiv = null;
  }
  activate() {
    if (this._isActive) {
      return;
    }
    this._isActive = true;
    globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
    globalThis.removeEventListener("keydown", this._onKeyDown, false);
    this.renderer.on("postrender", this.update, this);
    this.renderer.view.parentNode?.appendChild(this.div);
  }
  deactivate() {
    if (!this._isActive || this._isMobileAccessibility) {
      return;
    }
    this._isActive = false;
    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
    globalThis.addEventListener("keydown", this._onKeyDown, false);
    this.renderer.off("postrender", this.update);
    this.div.parentNode?.removeChild(this.div);
  }
  updateAccessibleObjects(displayObject) {
    if (!displayObject.visible || !displayObject.accessibleChildren) {
      return;
    }
    if (displayObject.accessible && displayObject.isInteractive()) {
      if (!displayObject._accessibleActive) {
        this.addChild(displayObject);
      }
      displayObject.renderId = this.renderId;
    }
    const children = displayObject.children;
    if (children) {
      for (let i = 0; i < children.length; i++) {
        this.updateAccessibleObjects(children[i]);
      }
    }
  }
  update() {
    const now = performance.now();
    if (core.utils.isMobile.android.device && now < this.androidUpdateCount) {
      return;
    }
    this.androidUpdateCount = now + this.androidUpdateFrequency;
    if (!this.renderer.renderingToScreen) {
      return;
    }
    if (this.renderer.lastObjectRendered) {
      this.updateAccessibleObjects(this.renderer.lastObjectRendered);
    }
    const { x, y, width, height } = this.renderer.view.getBoundingClientRect();
    const { width: viewWidth, height: viewHeight, resolution } = this.renderer;
    const sx = width / viewWidth * resolution;
    const sy = height / viewHeight * resolution;
    let div = this.div;
    div.style.left = `${x}px`;
    div.style.top = `${y}px`;
    div.style.width = `${viewWidth}px`;
    div.style.height = `${viewHeight}px`;
    for (let i = 0; i < this.children.length; i++) {
      const child = this.children[i];
      if (child.renderId !== this.renderId) {
        child._accessibleActive = false;
        core.utils.removeItems(this.children, i, 1);
        this.div.removeChild(child._accessibleDiv);
        this.pool.push(child._accessibleDiv);
        child._accessibleDiv = null;
        i--;
      } else {
        div = child._accessibleDiv;
        let hitArea = child.hitArea;
        const wt = child.worldTransform;
        if (child.hitArea) {
          div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;
          div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;
          div.style.width = `${hitArea.width * wt.a * sx}px`;
          div.style.height = `${hitArea.height * wt.d * sy}px`;
        } else {
          hitArea = child.getBounds();
          this.capHitArea(hitArea);
          div.style.left = `${hitArea.x * sx}px`;
          div.style.top = `${hitArea.y * sy}px`;
          div.style.width = `${hitArea.width * sx}px`;
          div.style.height = `${hitArea.height * sy}px`;
          if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
            div.title = child.accessibleTitle;
          }
          if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
            div.setAttribute("aria-label", child.accessibleHint);
          }
        }
        if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
          div.title = child.accessibleTitle;
          div.tabIndex = child.tabIndex;
          if (this.debug)
            this.updateDebugHTML(div);
        }
      }
    }
    this.renderId++;
  }
  updateDebugHTML(div) {
    div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
  }
  capHitArea(hitArea) {
    if (hitArea.x < 0) {
      hitArea.width += hitArea.x;
      hitArea.x = 0;
    }
    if (hitArea.y < 0) {
      hitArea.height += hitArea.y;
      hitArea.y = 0;
    }
    const { width: viewWidth, height: viewHeight } = this.renderer;
    if (hitArea.x + hitArea.width > viewWidth) {
      hitArea.width = viewWidth - hitArea.x;
    }
    if (hitArea.y + hitArea.height > viewHeight) {
      hitArea.height = viewHeight - hitArea.y;
    }
  }
  addChild(displayObject) {
    let div = this.pool.pop();
    if (!div) {
      div = document.createElement("button");
      div.style.width = `${DIV_TOUCH_SIZE}px`;
      div.style.height = `${DIV_TOUCH_SIZE}px`;
      div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
      div.style.position = "absolute";
      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
      div.style.borderStyle = "none";
      if (navigator.userAgent.toLowerCase().includes("chrome")) {
        div.setAttribute("aria-live", "off");
      } else {
        div.setAttribute("aria-live", "polite");
      }
      if (navigator.userAgent.match(/rv:.*Gecko\//)) {
        div.setAttribute("aria-relevant", "additions");
      } else {
        div.setAttribute("aria-relevant", "text");
      }
      div.addEventListener("click", this._onClick.bind(this));
      div.addEventListener("focus", this._onFocus.bind(this));
      div.addEventListener("focusout", this._onFocusOut.bind(this));
    }
    div.style.pointerEvents = displayObject.accessiblePointerEvents;
    div.type = displayObject.accessibleType;
    if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
      div.title = displayObject.accessibleTitle;
    } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {
      div.title = `displayObject ${displayObject.tabIndex}`;
    }
    if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {
      div.setAttribute("aria-label", displayObject.accessibleHint);
    }
    if (this.debug)
      this.updateDebugHTML(div);
    displayObject._accessibleActive = true;
    displayObject._accessibleDiv = div;
    div.displayObject = displayObject;
    this.children.push(displayObject);
    this.div.appendChild(displayObject._accessibleDiv);
    displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
  }
  _dispatchEvent(e, type) {
    const { displayObject: target } = e.target;
    const boundry = this.renderer.events.rootBoundary;
    const event = Object.assign(new events.FederatedEvent(boundry), { target });
    boundry.rootTarget = this.renderer.lastObjectRendered;
    type.forEach((type2) => boundry.dispatchEvent(event, type2));
  }
  _onClick(e) {
    this._dispatchEvent(e, ["click", "pointertap", "tap"]);
  }
  _onFocus(e) {
    if (!e.target.getAttribute("aria-live")) {
      e.target.setAttribute("aria-live", "assertive");
    }
    this._dispatchEvent(e, ["mouseover"]);
  }
  _onFocusOut(e) {
    if (!e.target.getAttribute("aria-live")) {
      e.target.setAttribute("aria-live", "polite");
    }
    this._dispatchEvent(e, ["mouseout"]);
  }
  _onKeyDown(e) {
    if (e.keyCode !== KEY_CODE_TAB) {
      return;
    }
    this.activate();
  }
  _onMouseMove(e) {
    if (e.movementX === 0 && e.movementY === 0) {
      return;
    }
    this.deactivate();
  }
  destroy() {
    this.destroyTouchHook();
    this.div = null;
    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
    globalThis.removeEventListener("keydown", this._onKeyDown);
    this.pool = null;
    this.children = null;
    this.renderer = null;
  }
}
AccessibilityManager.extension = {
  name: "accessibility",
  type: [
    core.ExtensionType.RendererPlugin,
    core.ExtensionType.CanvasRendererPlugin
  ]
};
core.extensions.add(AccessibilityManager);

exports.AccessibilityManager = AccessibilityManager;
//# sourceMappingURL=AccessibilityManager.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/accessibility/lib/accessibleTarget.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/accessibility/lib/accessibleTarget.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const accessibleTarget = {
  accessible: false,
  accessibleTitle: null,
  accessibleHint: null,
  tabIndex: 0,
  _accessibleActive: false,
  _accessibleDiv: null,
  accessibleType: "button",
  accessiblePointerEvents: "auto",
  accessibleChildren: true,
  renderId: -1
};

exports.accessibleTarget = accessibleTarget;
//# sourceMappingURL=accessibleTarget.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/accessibility/lib/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/accessibility/lib/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var AccessibilityManager = __webpack_require__(/*! ./AccessibilityManager.js */ "./node_modules/pixi.js/node_modules/@pixi/accessibility/lib/AccessibilityManager.js");
var accessibleTarget = __webpack_require__(/*! ./accessibleTarget.js */ "./node_modules/pixi.js/node_modules/@pixi/accessibility/lib/accessibleTarget.js");



exports.AccessibilityManager = AccessibilityManager.AccessibilityManager;
exports.accessibleTarget = accessibleTarget.accessibleTarget;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/app/lib/Application.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/app/lib/Application.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var display = __webpack_require__(/*! @pixi/display */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/index.js");

const _Application = class {
  constructor(options) {
    this.stage = new display.Container();
    options = Object.assign({
      forceCanvas: false
    }, options);
    this.renderer = core.autoDetectRenderer(options);
    _Application._plugins.forEach((plugin) => {
      plugin.init.call(this, options);
    });
  }
  render() {
    this.renderer.render(this.stage);
  }
  get view() {
    return this.renderer.view;
  }
  get screen() {
    return this.renderer.screen;
  }
  destroy(removeView, stageOptions) {
    const plugins = _Application._plugins.slice(0);
    plugins.reverse();
    plugins.forEach((plugin) => {
      plugin.destroy.call(this);
    });
    this.stage.destroy(stageOptions);
    this.stage = null;
    this.renderer.destroy(removeView);
    this.renderer = null;
  }
};
let Application = _Application;
Application._plugins = [];
core.extensions.handleByList(core.ExtensionType.Application, Application._plugins);

exports.Application = Application;
//# sourceMappingURL=Application.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/app/lib/ResizePlugin.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/app/lib/ResizePlugin.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

class ResizePlugin {
  static init(options) {
    Object.defineProperty(this, "resizeTo", {
      set(dom) {
        globalThis.removeEventListener("resize", this.queueResize);
        this._resizeTo = dom;
        if (dom) {
          globalThis.addEventListener("resize", this.queueResize);
          this.resize();
        }
      },
      get() {
        return this._resizeTo;
      }
    });
    this.queueResize = () => {
      if (!this._resizeTo) {
        return;
      }
      this.cancelResize();
      this._resizeId = requestAnimationFrame(() => this.resize());
    };
    this.cancelResize = () => {
      if (this._resizeId) {
        cancelAnimationFrame(this._resizeId);
        this._resizeId = null;
      }
    };
    this.resize = () => {
      if (!this._resizeTo) {
        return;
      }
      this.cancelResize();
      let width;
      let height;
      if (this._resizeTo === globalThis.window) {
        width = globalThis.innerWidth;
        height = globalThis.innerHeight;
      } else {
        const { clientWidth, clientHeight } = this._resizeTo;
        width = clientWidth;
        height = clientHeight;
      }
      this.renderer.resize(width, height);
      this.render();
    };
    this._resizeId = null;
    this._resizeTo = null;
    this.resizeTo = options.resizeTo || null;
  }
  static destroy() {
    globalThis.removeEventListener("resize", this.queueResize);
    this.cancelResize();
    this.cancelResize = null;
    this.queueResize = null;
    this.resizeTo = null;
    this.resize = null;
  }
}
ResizePlugin.extension = core.ExtensionType.Application;
core.extensions.add(ResizePlugin);

exports.ResizePlugin = ResizePlugin;
//# sourceMappingURL=ResizePlugin.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/app/lib/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/app/lib/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Application = __webpack_require__(/*! ./Application.js */ "./node_modules/pixi.js/node_modules/@pixi/app/lib/Application.js");
var ResizePlugin = __webpack_require__(/*! ./ResizePlugin.js */ "./node_modules/pixi.js/node_modules/@pixi/app/lib/ResizePlugin.js");



exports.Application = Application.Application;
exports.ResizePlugin = ResizePlugin.ResizePlugin;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/AssetExtension.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/AssetExtension.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

const assetKeyMap = {
  loader: core.ExtensionType.LoadParser,
  resolver: core.ExtensionType.ResolveParser,
  cache: core.ExtensionType.CacheParser,
  detection: core.ExtensionType.DetectionParser
};
core.extensions.handle(core.ExtensionType.Asset, (extension) => {
  const ref = extension.ref;
  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => core.extensions.add(Object.assign(ref[key], { extension: ref[key].extension ?? type })));
}, (extension) => {
  const ref = extension.ref;
  Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => core.extensions.remove(ref[key]));
});
//# sourceMappingURL=AssetExtension.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/Assets.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/Assets.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var BackgroundLoader = __webpack_require__(/*! ./BackgroundLoader.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/BackgroundLoader.js");
var Cache = __webpack_require__(/*! ./cache/Cache.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/cache/Cache.js");
var Loader = __webpack_require__(/*! ./loader/Loader.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/Loader.js");
__webpack_require__(/*! ./loader/parsers/index.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/index.js");
var Resolver = __webpack_require__(/*! ./resolver/Resolver.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/resolver/Resolver.js");
var convertToList = __webpack_require__(/*! ./utils/convertToList.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/convertToList.js");
var isSingleItem = __webpack_require__(/*! ./utils/isSingleItem.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/isSingleItem.js");
var loadTextures = __webpack_require__(/*! ./loader/parsers/textures/loadTextures.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.js");

class AssetsClass {
  constructor() {
    this._detections = [];
    this._initialized = false;
    this.resolver = new Resolver.Resolver();
    this.loader = new Loader.Loader();
    this.cache = Cache.Cache;
    this._backgroundLoader = new BackgroundLoader.BackgroundLoader(this.loader);
    this._backgroundLoader.active = true;
    this.reset();
  }
  async init(options = {}) {
    if (this._initialized) {
      console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
      return;
    }
    this._initialized = true;
    if (options.defaultSearchParams) {
      this.resolver.setDefaultSearchParams(options.defaultSearchParams);
    }
    if (options.basePath) {
      this.resolver.basePath = options.basePath;
    }
    if (options.bundleIdentifier) {
      this.resolver.setBundleIdentifier(options.bundleIdentifier);
    }
    if (options.manifest) {
      let manifest = options.manifest;
      if (typeof manifest === "string") {
        manifest = await this.load(manifest);
      }
      this.resolver.addManifest(manifest);
    }
    const resolutionPref = options.texturePreference?.resolution ?? 1;
    const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
    let formats = [];
    if (options.texturePreference?.format) {
      const formatPref = options.texturePreference?.format;
      formats = typeof formatPref === "string" ? [formatPref] : formatPref;
      for (const detection of this._detections) {
        if (!await detection.test()) {
          formats = await detection.remove(formats);
        }
      }
    } else {
      for (const detection of this._detections) {
        if (await detection.test()) {
          formats = await detection.add(formats);
        }
      }
    }
    this.resolver.prefer({
      params: {
        format: formats,
        resolution
      }
    });
    if (options.preferences) {
      this.setPreferences(options.preferences);
    }
  }
  add(keysIn, assetsIn, data) {
    this.resolver.add(keysIn, assetsIn, data);
  }
  async load(urls, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    const singleAsset = isSingleItem.isSingleItem(urls);
    const urlArray = convertToList.convertToList(urls).map((url) => {
      if (typeof url !== "string") {
        this.resolver.add(url.src, url);
        return url.src;
      }
      if (!this.resolver.hasKey(url)) {
        this.resolver.add(url, url);
      }
      return url;
    });
    const resolveResults = this.resolver.resolve(urlArray);
    const out = await this._mapLoadToResolve(resolveResults, onProgress);
    return singleAsset ? out[urlArray[0]] : out;
  }
  addBundle(bundleId, assets) {
    this.resolver.addBundle(bundleId, assets);
  }
  async loadBundle(bundleIds, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    let singleAsset = false;
    if (typeof bundleIds === "string") {
      singleAsset = true;
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const out = {};
    const keys = Object.keys(resolveResults);
    let count = 0;
    let total = 0;
    const _onProgress = () => {
      onProgress?.(++count / total);
    };
    const promises = keys.map((bundleId) => {
      const resolveResult = resolveResults[bundleId];
      total += Object.keys(resolveResult).length;
      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
        out[bundleId] = resolveResult2;
      });
    });
    await Promise.all(promises);
    return singleAsset ? out[bundleIds[0]] : out;
  }
  async backgroundLoad(urls) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof urls === "string") {
      urls = [urls];
    }
    const resolveResults = this.resolver.resolve(urls);
    this._backgroundLoader.add(Object.values(resolveResults));
  }
  async backgroundLoadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof bundleIds === "string") {
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    Object.values(resolveResults).forEach((resolveResult) => {
      this._backgroundLoader.add(Object.values(resolveResult));
    });
  }
  reset() {
    this.resolver.reset();
    this.loader.reset();
    this.cache.reset();
    this._initialized = false;
  }
  get(keys) {
    if (typeof keys === "string") {
      return Cache.Cache.get(keys);
    }
    const assets = {};
    for (let i = 0; i < keys.length; i++) {
      assets[i] = Cache.Cache.get(keys[i]);
    }
    return assets;
  }
  async _mapLoadToResolve(resolveResults, onProgress) {
    const resolveArray = Object.values(resolveResults);
    const resolveKeys = Object.keys(resolveResults);
    this._backgroundLoader.active = false;
    const loadedAssets = await this.loader.load(resolveArray, onProgress);
    this._backgroundLoader.active = true;
    const out = {};
    resolveArray.forEach((resolveResult, i) => {
      const asset = loadedAssets[resolveResult.src];
      const keys = [resolveResult.src];
      if (resolveResult.alias) {
        keys.push(...resolveResult.alias);
      }
      out[resolveKeys[i]] = asset;
      Cache.Cache.set(keys, asset);
    });
    return out;
  }
  async unload(urls) {
    if (!this._initialized) {
      await this.init();
    }
    const urlArray = convertToList.convertToList(urls).map((url) => typeof url !== "string" ? url.src : url);
    const resolveResults = this.resolver.resolve(urlArray);
    await this._unloadFromResolved(resolveResults);
  }
  async unloadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    bundleIds = convertToList.convertToList(bundleIds);
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
    await Promise.all(promises);
  }
  async _unloadFromResolved(resolveResult) {
    const resolveArray = Object.values(resolveResult);
    resolveArray.forEach((resolveResult2) => {
      Cache.Cache.remove(resolveResult2.src);
    });
    await this.loader.unload(resolveArray);
  }
  get detections() {
    return this._detections;
  }
  get preferWorkers() {
    return loadTextures.loadTextures.config.preferWorkers;
  }
  set preferWorkers(value) {
    core.utils.deprecation("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead.");
    this.setPreferences({ preferWorkers: value });
  }
  setPreferences(preferences) {
    this.loader.parsers.forEach((parser) => {
      if (!parser.config)
        return;
      Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {
        parser.config[key] = preferences[key];
      });
    });
  }
}
const Assets = new AssetsClass();
core.extensions.handleByList(core.ExtensionType.LoadParser, Assets.loader.parsers).handleByList(core.ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(core.ExtensionType.CacheParser, Assets.cache.parsers).handleByList(core.ExtensionType.DetectionParser, Assets.detections);

exports.Assets = Assets;
exports.AssetsClass = AssetsClass;
//# sourceMappingURL=Assets.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/BackgroundLoader.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/BackgroundLoader.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class BackgroundLoader {
  constructor(loader, verbose = false) {
    this._loader = loader;
    this._assetList = [];
    this._isLoading = false;
    this._maxConcurrent = 1;
    this.verbose = verbose;
  }
  add(assetUrls) {
    assetUrls.forEach((a) => {
      this._assetList.push(a);
    });
    if (this.verbose)
      console.log("[BackgroundLoader] assets: ", this._assetList);
    if (this._isActive && !this._isLoading) {
      this._next();
    }
  }
  async _next() {
    if (this._assetList.length && this._isActive) {
      this._isLoading = true;
      const toLoad = [];
      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
      for (let i = 0; i < toLoadAmount; i++) {
        toLoad.push(this._assetList.pop());
      }
      await this._loader.load(toLoad);
      this._isLoading = false;
      this._next();
    }
  }
  get active() {
    return this._isActive;
  }
  set active(value) {
    if (this._isActive === value)
      return;
    this._isActive = value;
    if (value && !this._isLoading) {
      this._next();
    }
  }
}

exports.BackgroundLoader = BackgroundLoader;
//# sourceMappingURL=BackgroundLoader.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/cache/Cache.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/cache/Cache.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
__webpack_require__(/*! ../utils/index.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/index.js");
var convertToList = __webpack_require__(/*! ../utils/convertToList.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/convertToList.js");

class CacheClass {
  constructor() {
    this._parsers = [];
    this._cache = /* @__PURE__ */ new Map();
    this._cacheMap = /* @__PURE__ */ new Map();
  }
  reset() {
    this._cacheMap.clear();
    this._cache.clear();
  }
  has(key) {
    return this._cache.has(key);
  }
  get(key) {
    const result = this._cache.get(key);
    if (!result) {
      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
    }
    return result;
  }
  set(key, value) {
    const keys = convertToList.convertToList(key);
    let cacheableAssets;
    for (let i = 0; i < this.parsers.length; i++) {
      const parser = this.parsers[i];
      if (parser.test(value)) {
        cacheableAssets = parser.getCacheableAssets(keys, value);
        break;
      }
    }
    if (!cacheableAssets) {
      cacheableAssets = {};
      keys.forEach((key2) => {
        cacheableAssets[key2] = value;
      });
    }
    const cacheKeys = Object.keys(cacheableAssets);
    const cachedAssets = {
      cacheKeys,
      keys
    };
    keys.forEach((key2) => {
      this._cacheMap.set(key2, cachedAssets);
    });
    cacheKeys.forEach((key2) => {
      if (this._cache.has(key2) && this._cache.get(key2) !== value) {
        console.warn("[Cache] already has key:", key2);
      }
      this._cache.set(key2, cacheableAssets[key2]);
    });
    if (value instanceof core.Texture) {
      const texture = value;
      keys.forEach((key2) => {
        if (texture.baseTexture !== core.Texture.EMPTY.baseTexture) {
          core.BaseTexture.addToCache(texture.baseTexture, key2);
        }
        core.Texture.addToCache(texture, key2);
      });
    }
  }
  remove(key) {
    this._cacheMap.get(key);
    if (!this._cacheMap.has(key)) {
      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
      return;
    }
    const cacheMap = this._cacheMap.get(key);
    const cacheKeys = cacheMap.cacheKeys;
    cacheKeys.forEach((key2) => {
      this._cache.delete(key2);
    });
    cacheMap.keys.forEach((key2) => {
      this._cacheMap.delete(key2);
    });
  }
  get parsers() {
    return this._parsers;
  }
}
const Cache = new CacheClass();

exports.Cache = Cache;
//# sourceMappingURL=Cache.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/cache/CacheParser.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/cache/CacheParser.js ***!
  \*********************************************************************************/
/***/ (() => {

"use strict";


//# sourceMappingURL=CacheParser.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/cache/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/cache/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Cache = __webpack_require__(/*! ./Cache.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/cache/Cache.js");
__webpack_require__(/*! ./CacheParser.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/cache/CacheParser.js");
__webpack_require__(/*! ./parsers/index.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/cache/parsers/index.js");



exports.Cache = Cache.Cache;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/cache/parsers/cacheTextureArray.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/cache/parsers/cacheTextureArray.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

const cacheTextureArray = {
  extension: core.ExtensionType.CacheParser,
  test: (asset) => Array.isArray(asset) && asset.every((t) => t instanceof core.Texture),
  getCacheableAssets: (keys, asset) => {
    const out = {};
    keys.forEach((key) => {
      asset.forEach((item, i) => {
        out[key + (i === 0 ? "" : i + 1)] = item;
      });
    });
    return out;
  }
};
core.extensions.add(cacheTextureArray);

exports.cacheTextureArray = cacheTextureArray;
//# sourceMappingURL=cacheTextureArray.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/cache/parsers/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/cache/parsers/index.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var cacheTextureArray = __webpack_require__(/*! ./cacheTextureArray.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/cache/parsers/cacheTextureArray.js");



exports.cacheTextureArray = cacheTextureArray.cacheTextureArray;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/detections/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/detections/index.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! ./parsers/index.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/detections/parsers/index.js");

//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/detections/parsers/detectAvif.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/detections/parsers/detectAvif.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

const detectAvif = {
  extension: {
    type: core.ExtensionType.DetectionParser,
    priority: 1
  },
  test: async () => {
    if (!globalThis.createImageBitmap)
      return false;
    const avifData = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=";
    const blob = await core.settings.ADAPTER.fetch(avifData).then((r) => r.blob());
    return createImageBitmap(blob).then(() => true, () => false);
  },
  add: async (formats) => [...formats, "avif"],
  remove: async (formats) => formats.filter((f) => f !== "avif")
};
core.extensions.add(detectAvif);

exports.detectAvif = detectAvif;
//# sourceMappingURL=detectAvif.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/detections/parsers/detectDefaults.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/detections/parsers/detectDefaults.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

const imageFormats = ["png", "jpg", "jpeg"];
const detectDefaults = {
  extension: {
    type: core.ExtensionType.DetectionParser,
    priority: -1
  },
  test: () => Promise.resolve(true),
  add: async (formats) => [...formats, ...imageFormats],
  remove: async (formats) => formats.filter((f) => !imageFormats.includes(f))
};
core.extensions.add(detectDefaults);

exports.detectDefaults = detectDefaults;
//# sourceMappingURL=detectDefaults.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/detections/parsers/detectWebp.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/detections/parsers/detectWebp.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

const detectWebp = {
  extension: {
    type: core.ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => {
    if (!globalThis.createImageBitmap)
      return false;
    const webpData = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=";
    const blob = await core.settings.ADAPTER.fetch(webpData).then((r) => r.blob());
    return createImageBitmap(blob).then(() => true, () => false);
  },
  add: async (formats) => [...formats, "webp"],
  remove: async (formats) => formats.filter((f) => f !== "webp")
};
core.extensions.add(detectWebp);

exports.detectWebp = detectWebp;
//# sourceMappingURL=detectWebp.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/detections/parsers/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/detections/parsers/index.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var detectAvif = __webpack_require__(/*! ./detectAvif.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/detections/parsers/detectAvif.js");
var detectWebp = __webpack_require__(/*! ./detectWebp.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/detections/parsers/detectWebp.js");
var detectDefaults = __webpack_require__(/*! ./detectDefaults.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/detections/parsers/detectDefaults.js");



exports.detectAvif = detectAvif.detectAvif;
exports.detectWebp = detectWebp.detectWebp;
exports.detectDefaults = detectDefaults.detectDefaults;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(/*! ./AssetExtension.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/AssetExtension.js");
var Assets = __webpack_require__(/*! ./Assets.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/Assets.js");
__webpack_require__(/*! ./cache/index.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/cache/index.js");
__webpack_require__(/*! ./detections/index.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/detections/index.js");
__webpack_require__(/*! ./loader/index.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/index.js");
__webpack_require__(/*! ./resolver/index.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/resolver/index.js");
__webpack_require__(/*! ./utils/index.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/index.js");
var Cache = __webpack_require__(/*! ./cache/Cache.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/cache/Cache.js");
var cacheTextureArray = __webpack_require__(/*! ./cache/parsers/cacheTextureArray.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/cache/parsers/cacheTextureArray.js");
var detectAvif = __webpack_require__(/*! ./detections/parsers/detectAvif.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/detections/parsers/detectAvif.js");
var detectWebp = __webpack_require__(/*! ./detections/parsers/detectWebp.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/detections/parsers/detectWebp.js");
var detectDefaults = __webpack_require__(/*! ./detections/parsers/detectDefaults.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/detections/parsers/detectDefaults.js");
var LoaderParser = __webpack_require__(/*! ./loader/parsers/LoaderParser.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.js");
var loadJson = __webpack_require__(/*! ./loader/parsers/loadJson.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/loadJson.js");
var loadTxt = __webpack_require__(/*! ./loader/parsers/loadTxt.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/loadTxt.js");
var loadWebFont = __webpack_require__(/*! ./loader/parsers/loadWebFont.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/loadWebFont.js");
var loadSVG = __webpack_require__(/*! ./loader/parsers/textures/loadSVG.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/loadSVG.js");
var loadTextures = __webpack_require__(/*! ./loader/parsers/textures/loadTextures.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.js");
var createTexture = __webpack_require__(/*! ./loader/parsers/textures/utils/createTexture.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.js");
var resolveTextureUrl = __webpack_require__(/*! ./resolver/parsers/resolveTextureUrl.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/resolver/parsers/resolveTextureUrl.js");
var checkDataUrl = __webpack_require__(/*! ./utils/checkDataUrl.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/checkDataUrl.js");
var checkExtension = __webpack_require__(/*! ./utils/checkExtension.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/checkExtension.js");
var convertToList = __webpack_require__(/*! ./utils/convertToList.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/convertToList.js");
var copySearchParams = __webpack_require__(/*! ./utils/copySearchParams.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/copySearchParams.js");
var createStringVariations = __webpack_require__(/*! ./utils/createStringVariations.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/createStringVariations.js");
var isSingleItem = __webpack_require__(/*! ./utils/isSingleItem.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/isSingleItem.js");



exports.Assets = Assets.Assets;
exports.AssetsClass = Assets.AssetsClass;
exports.Cache = Cache.Cache;
exports.cacheTextureArray = cacheTextureArray.cacheTextureArray;
exports.detectAvif = detectAvif.detectAvif;
exports.detectWebp = detectWebp.detectWebp;
exports.detectDefaults = detectDefaults.detectDefaults;
exports.LoaderParserPriority = LoaderParser.LoaderParserPriority;
exports.loadJson = loadJson.loadJson;
exports.loadTxt = loadTxt.loadTxt;
exports.getFontFamilyName = loadWebFont.getFontFamilyName;
exports.loadWebFont = loadWebFont.loadWebFont;
exports.loadSVG = loadSVG.loadSVG;
exports.loadImageBitmap = loadTextures.loadImageBitmap;
exports.loadTextures = loadTextures.loadTextures;
exports.createTexture = createTexture.createTexture;
exports.resolveTextureUrl = resolveTextureUrl.resolveTextureUrl;
exports.checkDataUrl = checkDataUrl.checkDataUrl;
exports.checkExtension = checkExtension.checkExtension;
exports.convertToList = convertToList.convertToList;
exports.copySearchParams = copySearchParams.copySearchParams;
exports.createStringVariations = createStringVariations.createStringVariations;
exports.isSingleItem = isSingleItem.isSingleItem;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/Loader.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/Loader.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
__webpack_require__(/*! ../utils/index.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/index.js");
var isSingleItem = __webpack_require__(/*! ../utils/isSingleItem.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/isSingleItem.js");
var convertToList = __webpack_require__(/*! ../utils/convertToList.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/convertToList.js");

class Loader {
  constructor() {
    this._parsers = [];
    this._parsersValidated = false;
    this.parsers = new Proxy(this._parsers, {
      set: (target, key, value) => {
        this._parsersValidated = false;
        target[key] = value;
        return true;
      }
    });
    this.promiseCache = {};
  }
  reset() {
    this._parsersValidated = false;
    this.promiseCache = {};
  }
  _getLoadPromiseAndParser(url, data) {
    const result = {
      promise: null,
      parser: null
    };
    result.promise = (async () => {
      let asset = null;
      let parser = null;
      if (data.loadParser) {
        parser = this._parserHash[data.loadParser];
        if (!parser) {
          console.warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url}`);
        }
      }
      if (!parser) {
        for (let i = 0; i < this.parsers.length; i++) {
          const parserX = this.parsers[i];
          if (parserX.load && parserX.test?.(url, data, this)) {
            parser = parserX;
            break;
          }
        }
        if (!parser) {
          console.warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);
          return null;
        }
      }
      asset = await parser.load(url, data, this);
      result.parser = parser;
      for (let i = 0; i < this.parsers.length; i++) {
        const parser2 = this.parsers[i];
        if (parser2.parse) {
          if (parser2.parse && await parser2.testParse?.(asset, data, this)) {
            asset = await parser2.parse(asset, data, this) || asset;
            result.parser = parser2;
          }
        }
      }
      return asset;
    })();
    return result;
  }
  async load(assetsToLoadIn, onProgress) {
    if (!this._parsersValidated) {
      this._validateParsers();
    }
    let count = 0;
    const assets = {};
    const singleAsset = isSingleItem.isSingleItem(assetsToLoadIn);
    const assetsToLoad = convertToList.convertToList(assetsToLoadIn, (item) => ({
      src: item
    }));
    const total = assetsToLoad.length;
    const promises = assetsToLoad.map(async (asset) => {
      const url = core.utils.path.toAbsolute(asset.src);
      if (!assets[asset.src]) {
        try {
          if (!this.promiseCache[url]) {
            this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);
          }
          assets[asset.src] = await this.promiseCache[url].promise;
          if (onProgress)
            onProgress(++count / total);
        } catch (e) {
          delete this.promiseCache[url];
          delete assets[asset.src];
          throw new Error(`[Loader.load] Failed to load ${url}.
${e}`);
        }
      }
    });
    await Promise.all(promises);
    return singleAsset ? assets[assetsToLoad[0].src] : assets;
  }
  async unload(assetsToUnloadIn) {
    const assetsToUnload = convertToList.convertToList(assetsToUnloadIn, (item) => ({
      src: item
    }));
    const promises = assetsToUnload.map(async (asset) => {
      const url = core.utils.path.toAbsolute(asset.src);
      const loadPromise = this.promiseCache[url];
      if (loadPromise) {
        const loadedAsset = await loadPromise.promise;
        loadPromise.parser?.unload?.(loadedAsset, asset, this);
        delete this.promiseCache[url];
      }
    });
    await Promise.all(promises);
  }
  _validateParsers() {
    this._parsersValidated = true;
    this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {
      if (hash[parser.name]) {
        console.warn(`[Assets] loadParser name conflict "${parser.name}"`);
      }
      return { ...hash, [parser.name]: parser };
    }, {});
  }
}

exports.Loader = Loader;
//# sourceMappingURL=Loader.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! ./parsers/index.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/index.js");
__webpack_require__(/*! ./types.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/types.js");

//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
  LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
  LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
  LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
  return LoaderParserPriority2;
})(LoaderParserPriority || {});

exports.LoaderParserPriority = LoaderParserPriority;
//# sourceMappingURL=LoaderParser.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/WorkerManager.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/WorkerManager.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

let UUID = 0;
let MAX_WORKERS;
const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
const checkImageBitmapCode = {
  id: "checkImageBitmap",
  code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${WHITE_PNG}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
};
const workerCode = {
  id: "loadImageBitmap",
  code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
};
let workerURL;
class WorkerManagerClass {
  constructor() {
    this._initialized = false;
    this._createdWorkers = 0;
    this.workerPool = [];
    this.queue = [];
    this.resolveHash = {};
  }
  isImageBitmapSupported() {
    if (this._isImageBitmapSupported !== void 0)
      return this._isImageBitmapSupported;
    this._isImageBitmapSupported = new Promise((resolve) => {
      const workerURL2 = URL.createObjectURL(new Blob([checkImageBitmapCode.code], { type: "application/javascript" }));
      const worker = new Worker(workerURL2);
      worker.addEventListener("message", (event) => {
        worker.terminate();
        URL.revokeObjectURL(workerURL2);
        resolve(event.data);
      });
    });
    return this._isImageBitmapSupported;
  }
  loadImageBitmap(src) {
    return this._run("loadImageBitmap", [src]);
  }
  async _initWorkers() {
    if (this._initialized)
      return;
    this._initialized = true;
  }
  getWorker() {
    if (MAX_WORKERS === void 0) {
      MAX_WORKERS = navigator.hardwareConcurrency || 4;
    }
    let worker = this.workerPool.pop();
    if (!worker && this._createdWorkers < MAX_WORKERS) {
      if (!workerURL) {
        workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: "application/javascript" }));
      }
      this._createdWorkers++;
      worker = new Worker(workerURL);
      worker.addEventListener("message", (event) => {
        this.complete(event.data);
        this.returnWorker(event.target);
        this.next();
      });
    }
    return worker;
  }
  returnWorker(worker) {
    this.workerPool.push(worker);
  }
  complete(data) {
    if (data.error !== void 0) {
      this.resolveHash[data.uuid].reject(data.error);
    } else {
      this.resolveHash[data.uuid].resolve(data.data);
    }
    this.resolveHash[data.uuid] = null;
  }
  async _run(id, args) {
    await this._initWorkers();
    const promise = new Promise((resolve, reject) => {
      this.queue.push({ id, arguments: args, resolve, reject });
    });
    this.next();
    return promise;
  }
  next() {
    if (!this.queue.length)
      return;
    const worker = this.getWorker();
    if (!worker) {
      return;
    }
    const toDo = this.queue.pop();
    const id = toDo.id;
    this.resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };
    worker.postMessage({
      data: toDo.arguments,
      uuid: UUID++,
      id
    });
  }
}
const WorkerManager = new WorkerManagerClass();

exports.WorkerManager = WorkerManager;
//# sourceMappingURL=WorkerManager.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var LoaderParser = __webpack_require__(/*! ./LoaderParser.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.js");
var loadJson = __webpack_require__(/*! ./loadJson.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/loadJson.js");
var loadTxt = __webpack_require__(/*! ./loadTxt.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/loadTxt.js");
var loadWebFont = __webpack_require__(/*! ./loadWebFont.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/loadWebFont.js");
__webpack_require__(/*! ./textures/index.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/index.js");



exports.LoaderParserPriority = LoaderParser.LoaderParserPriority;
exports.loadJson = loadJson.loadJson;
exports.loadTxt = loadTxt.loadTxt;
exports.getFontFamilyName = loadWebFont.getFontFamilyName;
exports.loadWebFont = loadWebFont.loadWebFont;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/loadJson.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/loadJson.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var checkDataUrl = __webpack_require__(/*! ../../utils/checkDataUrl.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/checkDataUrl.js");
var checkExtension = __webpack_require__(/*! ../../utils/checkExtension.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/checkExtension.js");
var LoaderParser = __webpack_require__(/*! ./LoaderParser.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.js");

const validJSONExtension = ".json";
const validJSONMIME = "application/json";
const loadJson = {
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: LoaderParser.LoaderParserPriority.Low
  },
  name: "loadJson",
  test(url) {
    return checkDataUrl.checkDataUrl(url, validJSONMIME) || checkExtension.checkExtension(url, validJSONExtension);
  },
  async load(url) {
    const response = await core.settings.ADAPTER.fetch(url);
    const json = await response.json();
    return json;
  }
};
core.extensions.add(loadJson);

exports.loadJson = loadJson;
//# sourceMappingURL=loadJson.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/loadTxt.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/loadTxt.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var checkDataUrl = __webpack_require__(/*! ../../utils/checkDataUrl.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/checkDataUrl.js");
var checkExtension = __webpack_require__(/*! ../../utils/checkExtension.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/checkExtension.js");
var LoaderParser = __webpack_require__(/*! ./LoaderParser.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.js");

const validTXTExtension = ".txt";
const validTXTMIME = "text/plain";
const loadTxt = {
  name: "loadTxt",
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: LoaderParser.LoaderParserPriority.Low
  },
  test(url) {
    return checkDataUrl.checkDataUrl(url, validTXTMIME) || checkExtension.checkExtension(url, validTXTExtension);
  },
  async load(url) {
    const response = await core.settings.ADAPTER.fetch(url);
    const txt = await response.text();
    return txt;
  }
};
core.extensions.add(loadTxt);

exports.loadTxt = loadTxt;
//# sourceMappingURL=loadTxt.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/loadWebFont.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/loadWebFont.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var checkDataUrl = __webpack_require__(/*! ../../utils/checkDataUrl.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/checkDataUrl.js");
var checkExtension = __webpack_require__(/*! ../../utils/checkExtension.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/checkExtension.js");
var LoaderParser = __webpack_require__(/*! ./LoaderParser.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.js");

const validWeights = [
  "normal",
  "bold",
  "100",
  "200",
  "300",
  "400",
  "500",
  "600",
  "700",
  "800",
  "900"
];
const validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
const validFontMIMEs = [
  "font/ttf",
  "font/otf",
  "font/woff",
  "font/woff2"
];
const CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
function getFontFamilyName(url) {
  const ext = core.utils.path.extname(url);
  const name = core.utils.path.basename(url, ext);
  const nameWithSpaces = name.replace(/(-|_)/g, " ");
  const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
  let valid = nameTokens.length > 0;
  for (const token of nameTokens) {
    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
      valid = false;
      break;
    }
  }
  let fontFamilyName = nameTokens.join(" ");
  if (!valid) {
    fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`;
  }
  return fontFamilyName;
}
const loadWebFont = {
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: LoaderParser.LoaderParserPriority.Low
  },
  name: "loadWebFont",
  test(url) {
    return checkDataUrl.checkDataUrl(url, validFontMIMEs) || checkExtension.checkExtension(url, validFontExtensions);
  },
  async load(url, options) {
    const fonts = core.settings.ADAPTER.getFontFaceSet();
    if (fonts) {
      const fontFaces = [];
      const name = options.data?.family ?? getFontFamilyName(url);
      const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"];
      const data = options.data ?? {};
      for (let i = 0; i < weights.length; i++) {
        const weight = weights[i];
        const font = new FontFace(name, `url(${encodeURI(url)})`, {
          ...data,
          weight
        });
        await font.load();
        fonts.add(font);
        fontFaces.push(font);
      }
      return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
    }
    console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
    return null;
  },
  unload(font) {
    (Array.isArray(font) ? font : [font]).forEach((t) => core.settings.ADAPTER.getFontFaceSet().delete(t));
  }
};
core.extensions.add(loadWebFont);

exports.getFontFamilyName = getFontFamilyName;
exports.loadWebFont = loadWebFont;
//# sourceMappingURL=loadWebFont.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/index.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var loadSVG = __webpack_require__(/*! ./loadSVG.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/loadSVG.js");
var loadTextures = __webpack_require__(/*! ./loadTextures.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.js");
__webpack_require__(/*! ./utils/index.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/utils/index.js");



exports.loadSVG = loadSVG.loadSVG;
exports.loadImageBitmap = loadTextures.loadImageBitmap;
exports.loadTextures = loadTextures.loadTextures;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/loadSVG.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/loadSVG.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var checkDataUrl = __webpack_require__(/*! ../../../utils/checkDataUrl.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/checkDataUrl.js");
var checkExtension = __webpack_require__(/*! ../../../utils/checkExtension.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/checkExtension.js");
var LoaderParser = __webpack_require__(/*! ../LoaderParser.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.js");
var loadTextures = __webpack_require__(/*! ./loadTextures.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.js");
var createTexture = __webpack_require__(/*! ./utils/createTexture.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.js");

const validSVGExtension = ".svg";
const validSVGMIME = "image/svg+xml";
const loadSVG = {
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: LoaderParser.LoaderParserPriority.High
  },
  name: "loadSVG",
  test(url) {
    return checkDataUrl.checkDataUrl(url, validSVGMIME) || checkExtension.checkExtension(url, validSVGExtension);
  },
  async testParse(data) {
    return core.SVGResource.test(data);
  },
  async parse(asset, data, loader) {
    const src = new core.SVGResource(asset, data?.data?.resourceOptions);
    await src.load();
    const base = new core.BaseTexture(src, {
      resolution: core.utils.getResolutionOfUrl(asset),
      ...data?.data
    });
    base.resource.src = asset;
    const texture = createTexture.createTexture(base, loader, asset);
    return texture;
  },
  async load(url, _options) {
    const response = await core.settings.ADAPTER.fetch(url);
    return response.text();
  },
  unload: loadTextures.loadTextures.unload
};
core.extensions.add(loadSVG);

exports.loadSVG = loadSVG;
//# sourceMappingURL=loadSVG.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var checkDataUrl = __webpack_require__(/*! ../../../utils/checkDataUrl.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/checkDataUrl.js");
var checkExtension = __webpack_require__(/*! ../../../utils/checkExtension.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/checkExtension.js");
var LoaderParser = __webpack_require__(/*! ../LoaderParser.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.js");
var WorkerManager = __webpack_require__(/*! ../WorkerManager.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/WorkerManager.js");
var createTexture = __webpack_require__(/*! ./utils/createTexture.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.js");

const validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
const validImageMIMEs = [
  "image/jpeg",
  "image/png",
  "image/webp",
  "image/avif"
];
async function loadImageBitmap(url) {
  const response = await core.settings.ADAPTER.fetch(url);
  if (!response.ok) {
    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);
  }
  const imageBlob = await response.blob();
  const imageBitmap = await createImageBitmap(imageBlob);
  return imageBitmap;
}
const loadTextures = {
  name: "loadTextures",
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: LoaderParser.LoaderParserPriority.High
  },
  config: {
    preferWorkers: true,
    preferCreateImageBitmap: true,
    crossOrigin: "anonymous"
  },
  test(url) {
    return checkDataUrl.checkDataUrl(url, validImageMIMEs) || checkExtension.checkExtension(url, validImageExtensions);
  },
  async load(url, asset, loader) {
    let src = null;
    if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
      if (this.config.preferWorkers && await WorkerManager.WorkerManager.isImageBitmapSupported()) {
        src = await WorkerManager.WorkerManager.loadImageBitmap(url);
      } else {
        src = await loadImageBitmap(url);
      }
    } else {
      src = await new Promise((resolve) => {
        src = new Image();
        src.crossOrigin = this.config.crossOrigin;
        src.src = url;
        if (src.complete) {
          resolve(src);
        } else {
          src.onload = () => {
            resolve(src);
          };
        }
      });
    }
    const base = new core.BaseTexture(src, {
      resolution: core.utils.getResolutionOfUrl(url),
      ...asset.data
    });
    base.resource.src = url;
    return createTexture.createTexture(base, loader, url);
  },
  unload(texture) {
    texture.destroy(true);
  }
};
core.extensions.add(loadTextures);

exports.loadImageBitmap = loadImageBitmap;
exports.loadTextures = loadTextures;
//# sourceMappingURL=loadTextures.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

function createTexture(base, loader, url) {
  const texture = new core.Texture(base);
  texture.baseTexture.on("dispose", () => {
    delete loader.promiseCache[url];
  });
  return texture;
}

exports.createTexture = createTexture;
//# sourceMappingURL=createTexture.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/utils/index.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/utils/index.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var createTexture = __webpack_require__(/*! ./createTexture.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.js");



exports.createTexture = createTexture.createTexture;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/types.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/types.js ***!
  \****************************************************************************/
/***/ (() => {

"use strict";


//# sourceMappingURL=types.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/resolver/Resolver.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/resolver/Resolver.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var convertToList = __webpack_require__(/*! ../utils/convertToList.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/convertToList.js");
var createStringVariations = __webpack_require__(/*! ../utils/createStringVariations.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/createStringVariations.js");
var isSingleItem = __webpack_require__(/*! ../utils/isSingleItem.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/isSingleItem.js");

class Resolver {
  constructor() {
    this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
    };
    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
    this._assetMap = {};
    this._preferredOrder = [];
    this._parsers = [];
    this._resolverHash = {};
    this._bundles = {};
  }
  setBundleIdentifier(bundleIdentifier) {
    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
    if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
    }
  }
  prefer(...preferOrders) {
    preferOrders.forEach((prefer) => {
      this._preferredOrder.push(prefer);
      if (!prefer.priority) {
        prefer.priority = Object.keys(prefer.params);
      }
    });
    this._resolverHash = {};
  }
  set basePath(basePath) {
    this._basePath = basePath;
  }
  get basePath() {
    return this._basePath;
  }
  set rootPath(rootPath) {
    this._rootPath = rootPath;
  }
  get rootPath() {
    return this._rootPath;
  }
  get parsers() {
    return this._parsers;
  }
  reset() {
    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
    this._assetMap = {};
    this._preferredOrder = [];
    this._resolverHash = {};
    this._rootPath = null;
    this._basePath = null;
    this._manifest = null;
    this._bundles = {};
    this._defaultSearchParams = null;
  }
  setDefaultSearchParams(searchParams) {
    if (typeof searchParams === "string") {
      this._defaultSearchParams = searchParams;
    } else {
      const queryValues = searchParams;
      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
    }
  }
  addManifest(manifest) {
    if (this._manifest) {
      console.warn("[Resolver] Manifest already exists, this will be overwritten");
    }
    this._manifest = manifest;
    manifest.bundles.forEach((bundle) => {
      this.addBundle(bundle.name, bundle.assets);
    });
  }
  addBundle(bundleId, assets) {
    const assetNames = [];
    if (Array.isArray(assets)) {
      assets.forEach((asset) => {
        if (typeof asset.name === "string") {
          const bundleAssetId = this._createBundleAssetId(bundleId, asset.name);
          assetNames.push(bundleAssetId);
          this.add([asset.name, bundleAssetId], asset.srcs, asset.data);
        } else {
          const bundleIds = asset.name.map((name) => this._createBundleAssetId(bundleId, name));
          bundleIds.forEach((bundleId2) => {
            assetNames.push(bundleId2);
          });
          this.add([...asset.name, ...bundleIds], asset.srcs);
        }
      });
    } else {
      Object.keys(assets).forEach((key) => {
        assetNames.push(this._createBundleAssetId(bundleId, key));
        this.add([key, this._createBundleAssetId(bundleId, key)], assets[key]);
      });
    }
    this._bundles[bundleId] = assetNames;
  }
  add(keysIn, assetsIn, data) {
    const keys = convertToList.convertToList(keysIn);
    keys.forEach((key) => {
      if (this.hasKey(key)) {
        console.warn(`[Resolver] already has key: ${key} overwriting`);
      }
    });
    if (!Array.isArray(assetsIn)) {
      if (typeof assetsIn === "string") {
        assetsIn = createStringVariations.createStringVariations(assetsIn);
      } else {
        assetsIn = [assetsIn];
      }
    }
    const assetMap = assetsIn.map((asset) => {
      let formattedAsset = asset;
      if (typeof asset === "string") {
        let parsed = false;
        for (let i = 0; i < this._parsers.length; i++) {
          const parser = this._parsers[i];
          if (parser.test(asset)) {
            formattedAsset = parser.parse(asset);
            parsed = true;
            break;
          }
        }
        if (!parsed) {
          formattedAsset = {
            src: asset
          };
        }
      }
      if (!formattedAsset.format) {
        formattedAsset.format = formattedAsset.src.split(".").pop();
      }
      if (!formattedAsset.alias) {
        formattedAsset.alias = keys;
      }
      if (this._basePath || this._rootPath) {
        formattedAsset.src = core.utils.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
      }
      formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
      formattedAsset.data = formattedAsset.data ?? data;
      return formattedAsset;
    });
    keys.forEach((key) => {
      this._assetMap[key] = assetMap;
    });
  }
  resolveBundle(bundleIds) {
    const singleAsset = isSingleItem.isSingleItem(bundleIds);
    bundleIds = convertToList.convertToList(bundleIds);
    const out = {};
    bundleIds.forEach((bundleId) => {
      const assetNames = this._bundles[bundleId];
      if (assetNames) {
        const results = this.resolve(assetNames);
        const assets = {};
        for (const key in results) {
          const asset = results[key];
          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
        }
        out[bundleId] = assets;
      }
    });
    return singleAsset ? out[bundleIds[0]] : out;
  }
  resolveUrl(key) {
    const result = this.resolve(key);
    if (typeof key !== "string") {
      const out = {};
      for (const i in result) {
        out[i] = result[i].src;
      }
      return out;
    }
    return result.src;
  }
  resolve(keys) {
    const singleAsset = isSingleItem.isSingleItem(keys);
    keys = convertToList.convertToList(keys);
    const result = {};
    keys.forEach((key) => {
      if (!this._resolverHash[key]) {
        if (this._assetMap[key]) {
          let assets = this._assetMap[key];
          const preferredOrder = this._getPreferredOrder(assets);
          const bestAsset = assets[0];
          preferredOrder?.priority.forEach((priorityKey) => {
            preferredOrder.params[priorityKey].forEach((value) => {
              const filteredAssets = assets.filter((asset) => {
                if (asset[priorityKey]) {
                  return asset[priorityKey] === value;
                }
                return false;
              });
              if (filteredAssets.length) {
                assets = filteredAssets;
              }
            });
          });
          this._resolverHash[key] = assets[0] ?? bestAsset;
        } else {
          let src = key;
          if (this._basePath || this._rootPath) {
            src = core.utils.path.toAbsolute(src, this._basePath, this._rootPath);
          }
          src = this._appendDefaultSearchParams(src);
          this._resolverHash[key] = {
            src
          };
        }
      }
      result[key] = this._resolverHash[key];
    });
    return singleAsset ? result[keys[0]] : result;
  }
  hasKey(key) {
    return !!this._assetMap[key];
  }
  hasBundle(key) {
    return !!this._bundles[key];
  }
  _getPreferredOrder(assets) {
    for (let i = 0; i < assets.length; i++) {
      const asset = assets[0];
      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
      if (preferred) {
        return preferred;
      }
    }
    return this._preferredOrder[0];
  }
  _appendDefaultSearchParams(url) {
    if (!this._defaultSearchParams)
      return url;
    const paramConnector = /\?/.test(url) ? "&" : "?";
    return `${url}${paramConnector}${this._defaultSearchParams}`;
  }
}

exports.Resolver = Resolver;
//# sourceMappingURL=Resolver.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/resolver/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/resolver/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! ./parsers/index.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/resolver/parsers/index.js");
__webpack_require__(/*! ./types.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/resolver/types.js");

//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/resolver/parsers/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/resolver/parsers/index.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var resolveTextureUrl = __webpack_require__(/*! ./resolveTextureUrl.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/resolver/parsers/resolveTextureUrl.js");



exports.resolveTextureUrl = resolveTextureUrl.resolveTextureUrl;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/resolver/parsers/resolveTextureUrl.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/resolver/parsers/resolveTextureUrl.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
__webpack_require__(/*! ../../loader/index.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/index.js");
var loadTextures = __webpack_require__(/*! ../../loader/parsers/textures/loadTextures.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.js");

const resolveTextureUrl = {
  extension: core.ExtensionType.ResolveParser,
  test: loadTextures.loadTextures.test,
  parse: (value) => ({
    resolution: parseFloat(core.settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
    format: value.split(".").pop(),
    src: value
  })
};
core.extensions.add(resolveTextureUrl);

exports.resolveTextureUrl = resolveTextureUrl;
//# sourceMappingURL=resolveTextureUrl.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/resolver/types.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/resolver/types.js ***!
  \******************************************************************************/
/***/ (() => {

"use strict";


//# sourceMappingURL=types.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/checkDataUrl.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/checkDataUrl.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function checkDataUrl(url, mimes) {
  if (Array.isArray(mimes)) {
    for (const mime of mimes) {
      if (url.startsWith(`data:${mime}`))
        return true;
    }
    return false;
  }
  return url.startsWith(`data:${mimes}`);
}

exports.checkDataUrl = checkDataUrl;
//# sourceMappingURL=checkDataUrl.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/checkExtension.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/checkExtension.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

function checkExtension(url, extension) {
  const tempURL = url.split("?")[0];
  const ext = core.utils.path.extname(tempURL).toLowerCase();
  if (Array.isArray(extension)) {
    return extension.includes(ext);
  }
  return ext === extension;
}

exports.checkExtension = checkExtension;
//# sourceMappingURL=checkExtension.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/convertToList.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/convertToList.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const convertToList = (input, transform) => {
  if (!Array.isArray(input)) {
    input = [input];
  }
  if (!transform) {
    return input;
  }
  return input.map((item) => {
    if (typeof item === "string") {
      return transform(item);
    }
    return item;
  });
};

exports.convertToList = convertToList;
//# sourceMappingURL=convertToList.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/copySearchParams.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/copySearchParams.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const copySearchParams = (targetUrl, sourceUrl) => {
  const searchParams = sourceUrl.split("?")[1];
  if (searchParams) {
    targetUrl += `?${searchParams}`;
  }
  return targetUrl;
};

exports.copySearchParams = copySearchParams;
//# sourceMappingURL=copySearchParams.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/createStringVariations.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/createStringVariations.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function processX(base, ids, depth, result, tags) {
  const id = ids[depth];
  for (let i = 0; i < id.length; i++) {
    const value = id[i];
    if (depth < ids.length - 1) {
      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
    } else {
      tags.push(base.replace(result[depth], value));
    }
  }
}
function createStringVariations(string) {
  const regex = /\{(.*?)\}/g;
  const result = string.match(regex);
  const tags = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    });
    processX(string, ids, 0, result, tags);
  } else {
    tags.push(string);
  }
  return tags;
}

exports.createStringVariations = createStringVariations;
//# sourceMappingURL=createStringVariations.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var checkDataUrl = __webpack_require__(/*! ./checkDataUrl.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/checkDataUrl.js");
var checkExtension = __webpack_require__(/*! ./checkExtension.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/checkExtension.js");
var convertToList = __webpack_require__(/*! ./convertToList.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/convertToList.js");
var copySearchParams = __webpack_require__(/*! ./copySearchParams.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/copySearchParams.js");
var createStringVariations = __webpack_require__(/*! ./createStringVariations.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/createStringVariations.js");
var isSingleItem = __webpack_require__(/*! ./isSingleItem.js */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/isSingleItem.js");



exports.checkDataUrl = checkDataUrl.checkDataUrl;
exports.checkExtension = checkExtension.checkExtension;
exports.convertToList = convertToList.convertToList;
exports.copySearchParams = copySearchParams.copySearchParams;
exports.createStringVariations = createStringVariations.createStringVariations;
exports.isSingleItem = isSingleItem.isSingleItem;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/isSingleItem.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/assets/lib/utils/isSingleItem.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const isSingleItem = (item) => !Array.isArray(item);

exports.isSingleItem = isSingleItem;
//# sourceMappingURL=isSingleItem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/const.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/const.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var INTERNAL_FORMATS = /* @__PURE__ */ ((INTERNAL_FORMATS2) => {
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
  return INTERNAL_FORMATS2;
})(INTERNAL_FORMATS || {});
const INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {
  [33776 /* COMPRESSED_RGB_S3TC_DXT1_EXT */]: 0.5,
  [33777 /* COMPRESSED_RGBA_S3TC_DXT1_EXT */]: 0.5,
  [33778 /* COMPRESSED_RGBA_S3TC_DXT3_EXT */]: 1,
  [33779 /* COMPRESSED_RGBA_S3TC_DXT5_EXT */]: 1,
  [35916 /* COMPRESSED_SRGB_S3TC_DXT1_EXT */]: 0.5,
  [35917 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */]: 0.5,
  [35918 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */]: 1,
  [35919 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */]: 1,
  [37488 /* COMPRESSED_R11_EAC */]: 0.5,
  [37489 /* COMPRESSED_SIGNED_R11_EAC */]: 0.5,
  [37490 /* COMPRESSED_RG11_EAC */]: 1,
  [37491 /* COMPRESSED_SIGNED_RG11_EAC */]: 1,
  [37492 /* COMPRESSED_RGB8_ETC2 */]: 0.5,
  [37496 /* COMPRESSED_RGBA8_ETC2_EAC */]: 1,
  [37493 /* COMPRESSED_SRGB8_ETC2 */]: 0.5,
  [37497 /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */]: 1,
  [37494 /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: 0.5,
  [37495 /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: 0.5,
  [35840 /* COMPRESSED_RGB_PVRTC_4BPPV1_IMG */]: 0.5,
  [35842 /* COMPRESSED_RGBA_PVRTC_4BPPV1_IMG */]: 0.5,
  [35841 /* COMPRESSED_RGB_PVRTC_2BPPV1_IMG */]: 0.25,
  [35843 /* COMPRESSED_RGBA_PVRTC_2BPPV1_IMG */]: 0.25,
  [36196 /* COMPRESSED_RGB_ETC1_WEBGL */]: 0.5,
  [35986 /* COMPRESSED_RGB_ATC_WEBGL */]: 0.5,
  [35986 /* COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL */]: 1,
  [34798 /* COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL */]: 1,
  [37808 /* COMPRESSED_RGBA_ASTC_4x4_KHR */]: 1
};

exports.INTERNAL_FORMATS = INTERNAL_FORMATS;
exports.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL;
//# sourceMappingURL=const.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(/*! ./const.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/const.js");
__webpack_require__(/*! ./loaders/index.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/index.js");
__webpack_require__(/*! ./parsers/index.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/parsers/index.js");
__webpack_require__(/*! ./resources/index.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/resources/index.js");
var detectCompressedTextures = __webpack_require__(/*! ./loaders/detectCompressedTextures.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/detectCompressedTextures.js");
var loadDDS = __webpack_require__(/*! ./loaders/loadDDS.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/loadDDS.js");
var loadKTX = __webpack_require__(/*! ./loaders/loadKTX.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/loadKTX.js");
var resolveCompressedTextureUrl = __webpack_require__(/*! ./loaders/resolveCompressedTextureUrl.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/resolveCompressedTextureUrl.js");
var parseDDS = __webpack_require__(/*! ./parsers/parseDDS.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.js");
var parseKTX = __webpack_require__(/*! ./parsers/parseKTX.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.js");
var BlobResource = __webpack_require__(/*! ./resources/BlobResource.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/resources/BlobResource.js");
var CompressedTextureResource = __webpack_require__(/*! ./resources/CompressedTextureResource.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.js");



exports.INTERNAL_FORMATS = _const.INTERNAL_FORMATS;
exports.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = _const.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL;
exports.detectCompressedTextures = detectCompressedTextures.detectCompressedTextures;
exports.loadDDS = loadDDS.loadDDS;
exports.loadKTX = loadKTX.loadKTX;
exports.resolveCompressedTextureUrl = resolveCompressedTextureUrl.resolveCompressedTextureUrl;
exports.parseDDS = parseDDS.parseDDS;
exports.FORMATS_TO_COMPONENTS = parseKTX.FORMATS_TO_COMPONENTS;
exports.TYPES_TO_BYTES_PER_COMPONENT = parseKTX.TYPES_TO_BYTES_PER_COMPONENT;
exports.TYPES_TO_BYTES_PER_PIXEL = parseKTX.TYPES_TO_BYTES_PER_PIXEL;
exports.parseKTX = parseKTX.parseKTX;
exports.BlobResource = BlobResource.BlobResource;
exports.CompressedTextureResource = CompressedTextureResource.CompressedTextureResource;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/compressedTextureExtensions.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/compressedTextureExtensions.js ***!
  \****************************************************************************************************************/
/***/ (() => {

"use strict";


//# sourceMappingURL=compressedTextureExtensions.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/detectCompressedTextures.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/detectCompressedTextures.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

let storedGl;
let extensions;
function getCompressedTextureExtensions() {
  extensions = {
    s3tc: storedGl.getExtension("WEBGL_compressed_texture_s3tc"),
    s3tc_sRGB: storedGl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
    etc: storedGl.getExtension("WEBGL_compressed_texture_etc"),
    etc1: storedGl.getExtension("WEBGL_compressed_texture_etc1"),
    pvrtc: storedGl.getExtension("WEBGL_compressed_texture_pvrtc") || storedGl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
    atc: storedGl.getExtension("WEBGL_compressed_texture_atc"),
    astc: storedGl.getExtension("WEBGL_compressed_texture_astc")
  };
}
const detectCompressedTextures = {
  extension: {
    type: core.ExtensionType.DetectionParser,
    priority: 2
  },
  test: async () => {
    const canvas = core.settings.ADAPTER.createCanvas();
    const gl = canvas.getContext("webgl");
    if (!gl) {
      console.warn("WebGL not available for compressed textures.");
      return false;
    }
    storedGl = gl;
    return true;
  },
  add: async (formats) => {
    if (!extensions)
      getCompressedTextureExtensions();
    const textureFormats = [];
    for (const extensionName in extensions) {
      const extension = extensions[extensionName];
      if (!extension) {
        continue;
      }
      textureFormats.push(extensionName);
    }
    return [...textureFormats, ...formats];
  },
  remove: async (formats) => {
    if (!extensions)
      getCompressedTextureExtensions();
    return formats.filter((f) => !(f in extensions));
  }
};
core.extensions.add(detectCompressedTextures);

exports.detectCompressedTextures = detectCompressedTextures;
//# sourceMappingURL=detectCompressedTextures.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(/*! ./compressedTextureExtensions.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/compressedTextureExtensions.js");
var detectCompressedTextures = __webpack_require__(/*! ./detectCompressedTextures.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/detectCompressedTextures.js");
var loadDDS = __webpack_require__(/*! ./loadDDS.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/loadDDS.js");
var loadKTX = __webpack_require__(/*! ./loadKTX.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/loadKTX.js");
var resolveCompressedTextureUrl = __webpack_require__(/*! ./resolveCompressedTextureUrl.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/resolveCompressedTextureUrl.js");



exports.detectCompressedTextures = detectCompressedTextures.detectCompressedTextures;
exports.loadDDS = loadDDS.loadDDS;
exports.loadKTX = loadKTX.loadKTX;
exports.resolveCompressedTextureUrl = resolveCompressedTextureUrl.resolveCompressedTextureUrl;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/loadDDS.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/loadDDS.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var assets = __webpack_require__(/*! @pixi/assets */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/index.js");
var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
__webpack_require__(/*! ../parsers/index.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/parsers/index.js");
var parseDDS = __webpack_require__(/*! ../parsers/parseDDS.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.js");

const loadDDS = {
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: assets.LoaderParserPriority.High
  },
  name: "loadDDS",
  test(url) {
    return assets.checkExtension(url, ".dds");
  },
  async load(url, asset, loader) {
    const response = await core.settings.ADAPTER.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    const resources = parseDDS.parseDDS(arrayBuffer);
    const textures = resources.map((resource) => {
      const base = new core.BaseTexture(resource, {
        mipmap: core.MIPMAP_MODES.OFF,
        alphaMode: core.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
        resolution: core.utils.getResolutionOfUrl(url),
        ...asset.data
      });
      return assets.createTexture(base, loader, url);
    });
    return textures.length === 1 ? textures[0] : textures;
  },
  unload(texture) {
    if (Array.isArray(texture)) {
      texture.forEach((t) => t.destroy(true));
    } else {
      texture.destroy(true);
    }
  }
};
core.extensions.add(loadDDS);

exports.loadDDS = loadDDS;
//# sourceMappingURL=loadDDS.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/loadKTX.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/loadKTX.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var assets = __webpack_require__(/*! @pixi/assets */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/index.js");
var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
__webpack_require__(/*! ../parsers/index.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/parsers/index.js");
var parseKTX = __webpack_require__(/*! ../parsers/parseKTX.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.js");

const loadKTX = {
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: assets.LoaderParserPriority.High
  },
  name: "loadKTX",
  test(url) {
    return assets.checkExtension(url, ".ktx");
  },
  async load(url, asset, loader) {
    const response = await core.settings.ADAPTER.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    const { compressed, uncompressed, kvData } = parseKTX.parseKTX(url, arrayBuffer);
    const resources = compressed ?? uncompressed;
    const options = {
      mipmap: core.MIPMAP_MODES.OFF,
      alphaMode: core.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
      resolution: core.utils.getResolutionOfUrl(url),
      ...asset.data
    };
    const textures = resources.map((resource) => {
      if (resources === uncompressed) {
        Object.assign(options, {
          type: resource.type,
          format: resource.format
        });
      }
      const base = new core.BaseTexture(resource, options);
      base.ktxKeyValueData = kvData;
      return assets.createTexture(base, loader, url);
    });
    return textures.length === 1 ? textures[0] : textures;
  },
  unload(texture) {
    if (Array.isArray(texture)) {
      texture.forEach((t) => t.destroy(true));
    } else {
      texture.destroy(true);
    }
  }
};
core.extensions.add(loadKTX);

exports.loadKTX = loadKTX;
//# sourceMappingURL=loadKTX.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/resolveCompressedTextureUrl.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/loaders/resolveCompressedTextureUrl.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

const resolveCompressedTextureUrl = {
  extension: core.ExtensionType.ResolveParser,
  test: (value) => {
    const temp = value.split("?")[0];
    const extension = temp.split(".").pop();
    return ["basis", "ktx", "dds"].includes(extension);
  },
  parse: (value) => {
    const temp = value.split("?")[0];
    const extension = temp.split(".").pop();
    if (extension === "ktx") {
      const extensions2 = [
        ".s3tc.ktx",
        ".s3tc_sRGB.ktx",
        ".etc.ktx",
        ".etc1.ktx",
        ".pvrt.ktx",
        ".atc.ktx",
        ".astc.ktx"
      ];
      if (extensions2.some((ext) => value.endsWith(ext))) {
        return {
          resolution: parseFloat(core.settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
          format: extensions2.find((ext) => value.endsWith(ext)),
          src: value
        };
      }
    }
    return {
      resolution: parseFloat(core.settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
      format: value.split(".").pop(),
      src: value
    };
  }
};
core.extensions.add(resolveCompressedTextureUrl);

exports.resolveCompressedTextureUrl = resolveCompressedTextureUrl;
//# sourceMappingURL=resolveCompressedTextureUrl.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/parsers/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/parsers/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var parseDDS = __webpack_require__(/*! ./parseDDS.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.js");
var parseKTX = __webpack_require__(/*! ./parseKTX.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.js");



exports.parseDDS = parseDDS.parseDDS;
exports.FORMATS_TO_COMPONENTS = parseKTX.FORMATS_TO_COMPONENTS;
exports.TYPES_TO_BYTES_PER_COMPONENT = parseKTX.TYPES_TO_BYTES_PER_COMPONENT;
exports.TYPES_TO_BYTES_PER_PIXEL = parseKTX.TYPES_TO_BYTES_PER_PIXEL;
exports.parseKTX = parseKTX.parseKTX;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/const.js");
__webpack_require__(/*! ../resources/index.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/resources/index.js");
var CompressedTextureResource = __webpack_require__(/*! ../resources/CompressedTextureResource.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.js");

const DDS_MAGIC_SIZE = 4;
const DDS_HEADER_SIZE = 124;
const DDS_HEADER_PF_SIZE = 32;
const DDS_HEADER_DX10_SIZE = 20;
const DDS_MAGIC = 542327876;
const DDS_FIELDS = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
};
const DDS_PF_FIELDS = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
};
const DDS_DX10_FIELDS = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
};
var DXGI_FORMAT = /* @__PURE__ */ ((DXGI_FORMAT2) => {
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_UNKNOWN"] = 0] = "DXGI_FORMAT_UNKNOWN";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_TYPELESS"] = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_FLOAT"] = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_UINT"] = 3] = "DXGI_FORMAT_R32G32B32A32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_SINT"] = 4] = "DXGI_FORMAT_R32G32B32A32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_TYPELESS"] = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_FLOAT"] = 6] = "DXGI_FORMAT_R32G32B32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_UINT"] = 7] = "DXGI_FORMAT_R32G32B32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_SINT"] = 8] = "DXGI_FORMAT_R32G32B32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_TYPELESS"] = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_FLOAT"] = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UNORM"] = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UINT"] = 12] = "DXGI_FORMAT_R16G16B16A16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SNORM"] = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SINT"] = 14] = "DXGI_FORMAT_R16G16B16A16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_TYPELESS"] = 15] = "DXGI_FORMAT_R32G32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_FLOAT"] = 16] = "DXGI_FORMAT_R32G32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_UINT"] = 17] = "DXGI_FORMAT_R32G32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_SINT"] = 18] = "DXGI_FORMAT_R32G32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G8X24_TYPELESS"] = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT_S8X24_UINT"] = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS"] = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X32_TYPELESS_G8X24_UINT"] = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_TYPELESS"] = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UNORM"] = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UINT"] = 25] = "DXGI_FORMAT_R10G10B10A2_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R11G11B10_FLOAT"] = 26] = "DXGI_FORMAT_R11G11B10_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_TYPELESS"] = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM"] = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM_SRGB"] = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UINT"] = 30] = "DXGI_FORMAT_R8G8B8A8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SNORM"] = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SINT"] = 32] = "DXGI_FORMAT_R8G8B8A8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_TYPELESS"] = 33] = "DXGI_FORMAT_R16G16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_FLOAT"] = 34] = "DXGI_FORMAT_R16G16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UNORM"] = 35] = "DXGI_FORMAT_R16G16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UINT"] = 36] = "DXGI_FORMAT_R16G16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SNORM"] = 37] = "DXGI_FORMAT_R16G16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SINT"] = 38] = "DXGI_FORMAT_R16G16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_TYPELESS"] = 39] = "DXGI_FORMAT_R32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT"] = 40] = "DXGI_FORMAT_D32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT"] = 41] = "DXGI_FORMAT_R32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_UINT"] = 42] = "DXGI_FORMAT_R32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_SINT"] = 43] = "DXGI_FORMAT_R32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24G8_TYPELESS"] = 44] = "DXGI_FORMAT_R24G8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D24_UNORM_S8_UINT"] = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24_UNORM_X8_TYPELESS"] = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X24_TYPELESS_G8_UINT"] = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_TYPELESS"] = 48] = "DXGI_FORMAT_R8G8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UNORM"] = 49] = "DXGI_FORMAT_R8G8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UINT"] = 50] = "DXGI_FORMAT_R8G8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SNORM"] = 51] = "DXGI_FORMAT_R8G8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SINT"] = 52] = "DXGI_FORMAT_R8G8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_TYPELESS"] = 53] = "DXGI_FORMAT_R16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_FLOAT"] = 54] = "DXGI_FORMAT_R16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D16_UNORM"] = 55] = "DXGI_FORMAT_D16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UNORM"] = 56] = "DXGI_FORMAT_R16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UINT"] = 57] = "DXGI_FORMAT_R16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SNORM"] = 58] = "DXGI_FORMAT_R16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SINT"] = 59] = "DXGI_FORMAT_R16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_TYPELESS"] = 60] = "DXGI_FORMAT_R8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UNORM"] = 61] = "DXGI_FORMAT_R8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UINT"] = 62] = "DXGI_FORMAT_R8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SNORM"] = 63] = "DXGI_FORMAT_R8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SINT"] = 64] = "DXGI_FORMAT_R8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8_UNORM"] = 65] = "DXGI_FORMAT_A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R1_UNORM"] = 66] = "DXGI_FORMAT_R1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R9G9B9E5_SHAREDEXP"] = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_B8G8_UNORM"] = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_G8R8_G8B8_UNORM"] = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_TYPELESS"] = 70] = "DXGI_FORMAT_BC1_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM"] = 71] = "DXGI_FORMAT_BC1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM_SRGB"] = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_TYPELESS"] = 73] = "DXGI_FORMAT_BC2_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM"] = 74] = "DXGI_FORMAT_BC2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM_SRGB"] = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_TYPELESS"] = 76] = "DXGI_FORMAT_BC3_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM"] = 77] = "DXGI_FORMAT_BC3_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM_SRGB"] = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_TYPELESS"] = 79] = "DXGI_FORMAT_BC4_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_UNORM"] = 80] = "DXGI_FORMAT_BC4_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_SNORM"] = 81] = "DXGI_FORMAT_BC4_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_TYPELESS"] = 82] = "DXGI_FORMAT_BC5_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_UNORM"] = 83] = "DXGI_FORMAT_BC5_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_SNORM"] = 84] = "DXGI_FORMAT_BC5_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G6R5_UNORM"] = 85] = "DXGI_FORMAT_B5G6R5_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G5R5A1_UNORM"] = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM"] = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM"] = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM"] = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_TYPELESS"] = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM_SRGB"] = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_TYPELESS"] = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM_SRGB"] = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_TYPELESS"] = 94] = "DXGI_FORMAT_BC6H_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_UF16"] = 95] = "DXGI_FORMAT_BC6H_UF16";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_SF16"] = 96] = "DXGI_FORMAT_BC6H_SF16";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_TYPELESS"] = 97] = "DXGI_FORMAT_BC7_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM"] = 98] = "DXGI_FORMAT_BC7_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM_SRGB"] = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AYUV"] = 100] = "DXGI_FORMAT_AYUV";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y410"] = 101] = "DXGI_FORMAT_Y410";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y416"] = 102] = "DXGI_FORMAT_Y416";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV12"] = 103] = "DXGI_FORMAT_NV12";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P010"] = 104] = "DXGI_FORMAT_P010";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P016"] = 105] = "DXGI_FORMAT_P016";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_420_OPAQUE"] = 106] = "DXGI_FORMAT_420_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_YUY2"] = 107] = "DXGI_FORMAT_YUY2";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y210"] = 108] = "DXGI_FORMAT_Y210";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y216"] = 109] = "DXGI_FORMAT_Y216";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV11"] = 110] = "DXGI_FORMAT_NV11";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AI44"] = 111] = "DXGI_FORMAT_AI44";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_IA44"] = 112] = "DXGI_FORMAT_IA44";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P8"] = 113] = "DXGI_FORMAT_P8";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8P8"] = 114] = "DXGI_FORMAT_A8P8";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B4G4R4A4_UNORM"] = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P208"] = 116] = "DXGI_FORMAT_P208";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V208"] = 117] = "DXGI_FORMAT_V208";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V408"] = 118] = "DXGI_FORMAT_V408";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE"] = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE"] = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_FORCE_UINT"] = 121] = "DXGI_FORMAT_FORCE_UINT";
  return DXGI_FORMAT2;
})(DXGI_FORMAT || {});
var D3D10_RESOURCE_DIMENSION = /* @__PURE__ */ ((D3D10_RESOURCE_DIMENSION2) => {
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE1D"] = 2] = "DDS_DIMENSION_TEXTURE1D";
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE2D"] = 3] = "DDS_DIMENSION_TEXTURE2D";
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE3D"] = 6] = "DDS_DIMENSION_TEXTURE3D";
  return D3D10_RESOURCE_DIMENSION2;
})(D3D10_RESOURCE_DIMENSION || {});
const PF_FLAGS = 1;
const DDPF_ALPHA = 2;
const DDPF_FOURCC = 4;
const DDPF_RGB = 64;
const DDPF_YUV = 512;
const DDPF_LUMINANCE = 131072;
const FOURCC_DXT1 = 827611204;
const FOURCC_DXT3 = 861165636;
const FOURCC_DXT5 = 894720068;
const FOURCC_DX10 = 808540228;
const DDS_RESOURCE_MISC_TEXTURECUBE = 4;
const FOURCC_TO_FORMAT = {
  [FOURCC_DXT1]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [FOURCC_DXT3]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [FOURCC_DXT5]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT
};
const DXGI_TO_FORMAT = {
  [70 /* DXGI_FORMAT_BC1_TYPELESS */]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [71 /* DXGI_FORMAT_BC1_UNORM */]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [73 /* DXGI_FORMAT_BC2_TYPELESS */]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [74 /* DXGI_FORMAT_BC2_UNORM */]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [76 /* DXGI_FORMAT_BC3_TYPELESS */]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  [77 /* DXGI_FORMAT_BC3_UNORM */]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  [72 /* DXGI_FORMAT_BC1_UNORM_SRGB */]: _const.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
  [75 /* DXGI_FORMAT_BC2_UNORM_SRGB */]: _const.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
  [78 /* DXGI_FORMAT_BC3_UNORM_SRGB */]: _const.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
};
function parseDDS(arrayBuffer) {
  const data = new Uint32Array(arrayBuffer);
  const magicWord = data[0];
  if (magicWord !== DDS_MAGIC) {
    throw new Error("Invalid DDS file magic word");
  }
  const header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
  const height = header[DDS_FIELDS.HEIGHT];
  const width = header[DDS_FIELDS.WIDTH];
  const mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT];
  const pixelFormat = new Uint32Array(arrayBuffer, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT);
  const formatFlags = pixelFormat[PF_FLAGS];
  if (formatFlags & DDPF_FOURCC) {
    const fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];
    if (fourCC !== FOURCC_DX10) {
      const internalFormat2 = FOURCC_TO_FORMAT[fourCC];
      const dataOffset2 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
      const texData = new Uint8Array(arrayBuffer, dataOffset2);
      const resource = new CompressedTextureResource.CompressedTextureResource(texData, {
        format: internalFormat2,
        width,
        height,
        levels: mipmapCount
      });
      return [resource];
    }
    const dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
    const dx10Header = new Uint32Array(data.buffer, dx10Offset, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    const dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT];
    const resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION];
    const miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG];
    const arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE];
    const internalFormat = DXGI_TO_FORMAT[dxgiFormat];
    if (internalFormat === void 0) {
      throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);
    }
    if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE) {
      throw new Error("DDSParser does not support cubemap textures");
    }
    if (resourceDimension === 6 /* DDS_DIMENSION_TEXTURE3D */) {
      throw new Error("DDSParser does not supported 3D texture data");
    }
    const imageBuffers = new Array();
    const dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
    if (arraySize === 1) {
      imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));
    } else {
      const pixelSize = _const.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat];
      let imageSize = 0;
      let levelWidth = width;
      let levelHeight = height;
      for (let i = 0; i < mipmapCount; i++) {
        const alignedLevelWidth = Math.max(1, levelWidth + 3 & ~3);
        const alignedLevelHeight = Math.max(1, levelHeight + 3 & ~3);
        const levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;
        imageSize += levelSize;
        levelWidth = levelWidth >>> 1;
        levelHeight = levelHeight >>> 1;
      }
      let imageOffset = dataOffset;
      for (let i = 0; i < arraySize; i++) {
        imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize));
        imageOffset += imageSize;
      }
    }
    return imageBuffers.map((buffer) => new CompressedTextureResource.CompressedTextureResource(buffer, {
      format: internalFormat,
      width,
      height,
      levels: mipmapCount
    }));
  }
  if (formatFlags & DDPF_RGB) {
    throw new Error("DDSParser does not support uncompressed texture data.");
  }
  if (formatFlags & DDPF_YUV) {
    throw new Error("DDSParser does not supported YUV uncompressed texture data.");
  }
  if (formatFlags & DDPF_LUMINANCE) {
    throw new Error("DDSParser does not support single-channel (lumninance) texture data!");
  }
  if (formatFlags & DDPF_ALPHA) {
    throw new Error("DDSParser does not support single-channel (alpha) texture data!");
  }
  throw new Error("DDSParser failed to load a texture file due to an unknown reason!");
}

exports.parseDDS = parseDDS;
//# sourceMappingURL=parseDDS.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var _const = __webpack_require__(/*! ../const.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/const.js");
__webpack_require__(/*! ../resources/index.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/resources/index.js");
var CompressedTextureResource = __webpack_require__(/*! ../resources/CompressedTextureResource.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.js");

const FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
const ENDIANNESS = 67305985;
const KTX_FIELDS = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
};
const FILE_HEADER_SIZE = 64;
const TYPES_TO_BYTES_PER_COMPONENT = {
  [core.TYPES.UNSIGNED_BYTE]: 1,
  [core.TYPES.UNSIGNED_SHORT]: 2,
  [core.TYPES.INT]: 4,
  [core.TYPES.UNSIGNED_INT]: 4,
  [core.TYPES.FLOAT]: 4,
  [core.TYPES.HALF_FLOAT]: 8
};
const FORMATS_TO_COMPONENTS = {
  [core.FORMATS.RGBA]: 4,
  [core.FORMATS.RGB]: 3,
  [core.FORMATS.RG]: 2,
  [core.FORMATS.RED]: 1,
  [core.FORMATS.LUMINANCE]: 1,
  [core.FORMATS.LUMINANCE_ALPHA]: 2,
  [core.FORMATS.ALPHA]: 1
};
const TYPES_TO_BYTES_PER_PIXEL = {
  [core.TYPES.UNSIGNED_SHORT_4_4_4_4]: 2,
  [core.TYPES.UNSIGNED_SHORT_5_5_5_1]: 2,
  [core.TYPES.UNSIGNED_SHORT_5_6_5]: 2
};
function parseKTX(url, arrayBuffer, loadKeyValueData = false) {
  const dataView = new DataView(arrayBuffer);
  if (!validate(url, dataView)) {
    return null;
  }
  const littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, true) === ENDIANNESS;
  const glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian);
  const glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian);
  const glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian);
  const pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian);
  const pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1;
  const pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1;
  const numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;
  const numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian);
  const numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);
  const bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
  if (pixelHeight === 0 || pixelDepth !== 1) {
    throw new Error("Only 2D textures are supported");
  }
  if (numberOfFaces !== 1) {
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  }
  if (numberOfArrayElements !== 1) {
    throw new Error("WebGL does not support array textures");
  }
  const blockWidth = 4;
  const blockHeight = 4;
  const alignedWidth = pixelWidth + 3 & ~3;
  const alignedHeight = pixelHeight + 3 & ~3;
  const imageBuffers = new Array(numberOfArrayElements);
  let imagePixels = pixelWidth * pixelHeight;
  if (glType === 0) {
    imagePixels = alignedWidth * alignedHeight;
  }
  let imagePixelByteSize;
  if (glType !== 0) {
    if (TYPES_TO_BYTES_PER_COMPONENT[glType]) {
      imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat];
    } else {
      imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType];
    }
  } else {
    imagePixelByteSize = _const.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];
  }
  if (imagePixelByteSize === void 0) {
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  }
  const kvData = loadKeyValueData ? parseKvData(dataView, bytesOfKeyValueData, littleEndian) : null;
  const imageByteSize = imagePixels * imagePixelByteSize;
  let mipByteSize = imageByteSize;
  let mipWidth = pixelWidth;
  let mipHeight = pixelHeight;
  let alignedMipWidth = alignedWidth;
  let alignedMipHeight = alignedHeight;
  let imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;
  for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
    const imageSize = dataView.getUint32(imageOffset, littleEndian);
    let elementOffset = imageOffset + 4;
    for (let arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {
      let mips = imageBuffers[arrayElement];
      if (!mips) {
        mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels);
      }
      mips[mipmapLevel] = {
        levelID: mipmapLevel,
        levelWidth: numberOfMipmapLevels > 1 || glType !== 0 ? mipWidth : alignedMipWidth,
        levelHeight: numberOfMipmapLevels > 1 || glType !== 0 ? mipHeight : alignedMipHeight,
        levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)
      };
      elementOffset += mipByteSize;
    }
    imageOffset += imageSize + 4;
    imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;
    mipWidth = mipWidth >> 1 || 1;
    mipHeight = mipHeight >> 1 || 1;
    alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1);
    alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1);
    mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
  }
  if (glType !== 0) {
    return {
      uncompressed: imageBuffers.map((levelBuffers) => {
        let buffer = levelBuffers[0].levelBuffer;
        let convertToInt = false;
        if (glType === core.TYPES.FLOAT) {
          buffer = new Float32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        } else if (glType === core.TYPES.UNSIGNED_INT) {
          convertToInt = true;
          buffer = new Uint32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        } else if (glType === core.TYPES.INT) {
          convertToInt = true;
          buffer = new Int32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        }
        return {
          resource: new core.BufferResource(buffer, {
            width: levelBuffers[0].levelWidth,
            height: levelBuffers[0].levelHeight
          }),
          type: glType,
          format: convertToInt ? convertFormatToInteger(glFormat) : glFormat
        };
      }),
      kvData
    };
  }
  return {
    compressed: imageBuffers.map((levelBuffers) => new CompressedTextureResource.CompressedTextureResource(null, {
      format: glInternalFormat,
      width: pixelWidth,
      height: pixelHeight,
      levels: numberOfMipmapLevels,
      levelBuffers
    })),
    kvData
  };
}
function validate(url, dataView) {
  for (let i = 0; i < FILE_IDENTIFIER.length; i++) {
    if (dataView.getUint8(i) !== FILE_IDENTIFIER[i]) {
      console.error(`${url} is not a valid *.ktx file!`);
      return false;
    }
  }
  return true;
}
function convertFormatToInteger(format) {
  switch (format) {
    case core.FORMATS.RGBA:
      return core.FORMATS.RGBA_INTEGER;
    case core.FORMATS.RGB:
      return core.FORMATS.RGB_INTEGER;
    case core.FORMATS.RG:
      return core.FORMATS.RG_INTEGER;
    case core.FORMATS.RED:
      return core.FORMATS.RED_INTEGER;
    default:
      return format;
  }
}
function parseKvData(dataView, bytesOfKeyValueData, littleEndian) {
  const kvData = /* @__PURE__ */ new Map();
  let bytesIntoKeyValueData = 0;
  while (bytesIntoKeyValueData < bytesOfKeyValueData) {
    const keyAndValueByteSize = dataView.getUint32(FILE_HEADER_SIZE + bytesIntoKeyValueData, littleEndian);
    const keyAndValueByteOffset = FILE_HEADER_SIZE + bytesIntoKeyValueData + 4;
    const valuePadding = 3 - (keyAndValueByteSize + 3) % 4;
    if (keyAndValueByteSize === 0 || keyAndValueByteSize > bytesOfKeyValueData - bytesIntoKeyValueData) {
      console.error("KTXLoader: keyAndValueByteSize out of bounds");
      break;
    }
    let keyNulByte = 0;
    for (; keyNulByte < keyAndValueByteSize; keyNulByte++) {
      if (dataView.getUint8(keyAndValueByteOffset + keyNulByte) === 0) {
        break;
      }
    }
    if (keyNulByte === -1) {
      console.error("KTXLoader: Failed to find null byte terminating kvData key");
      break;
    }
    const key = new TextDecoder().decode(new Uint8Array(dataView.buffer, keyAndValueByteOffset, keyNulByte));
    const value = new DataView(dataView.buffer, keyAndValueByteOffset + keyNulByte + 1, keyAndValueByteSize - keyNulByte - 1);
    kvData.set(key, value);
    bytesIntoKeyValueData += 4 + keyAndValueByteSize + valuePadding;
  }
  return kvData;
}

exports.FORMATS_TO_COMPONENTS = FORMATS_TO_COMPONENTS;
exports.TYPES_TO_BYTES_PER_COMPONENT = TYPES_TO_BYTES_PER_COMPONENT;
exports.TYPES_TO_BYTES_PER_PIXEL = TYPES_TO_BYTES_PER_PIXEL;
exports.parseKTX = parseKTX;
//# sourceMappingURL=parseKTX.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/resources/BlobResource.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/resources/BlobResource.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

class BlobResource extends core.BufferResource {
  constructor(source, options = { width: 1, height: 1, autoLoad: true }) {
    let origin;
    let data;
    if (typeof source === "string") {
      origin = source;
      data = new Uint8Array();
    } else {
      origin = null;
      data = source;
    }
    super(data, options);
    this.origin = origin;
    this.buffer = data ? new core.ViewableBuffer(data) : null;
    this._load = null;
    this.loaded = false;
    if (this.origin !== null && options.autoLoad !== false) {
      this.load();
    }
    if (this.origin === null && this.buffer) {
      this._load = Promise.resolve(this);
      this.loaded = true;
      this.onBlobLoaded(this.buffer.rawBinaryData);
    }
  }
  onBlobLoaded(_data) {
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = fetch(this.origin).then((response) => response.blob()).then((blob) => blob.arrayBuffer()).then((arrayBuffer) => {
      this.data = new Uint32Array(arrayBuffer);
      this.buffer = new core.ViewableBuffer(arrayBuffer);
      this.loaded = true;
      this.onBlobLoaded(arrayBuffer);
      this.update();
      return this;
    });
    return this._load;
  }
}

exports.BlobResource = BlobResource;
//# sourceMappingURL=BlobResource.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/const.js");
var BlobResource = __webpack_require__(/*! ./BlobResource.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/resources/BlobResource.js");

class CompressedTextureResource extends BlobResource.BlobResource {
  constructor(source, options) {
    super(source, options);
    this.format = options.format;
    this.levels = options.levels || 1;
    this._width = options.width;
    this._height = options.height;
    this._extension = CompressedTextureResource._formatToExtension(this.format);
    if (options.levelBuffers || this.buffer) {
      this._levelBuffers = options.levelBuffers || CompressedTextureResource._createLevelBuffers(source instanceof Uint8Array ? source : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
    }
  }
  upload(renderer, _texture, _glTexture) {
    const gl = renderer.gl;
    const extension = renderer.context.extensions[this._extension];
    if (!extension) {
      throw new Error(`${this._extension} textures are not supported on the current machine`);
    }
    if (!this._levelBuffers) {
      return false;
    }
    for (let i = 0, j = this.levels; i < j; i++) {
      const { levelID, levelWidth, levelHeight, levelBuffer } = this._levelBuffers[i];
      gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);
    }
    return true;
  }
  onBlobLoaded() {
    this._levelBuffers = CompressedTextureResource._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
  }
  static _formatToExtension(format) {
    if (format >= 33776 && format <= 33779) {
      return "s3tc";
    } else if (format >= 37488 && format <= 37497) {
      return "etc";
    } else if (format >= 35840 && format <= 35843) {
      return "pvrtc";
    } else if (format >= 36196) {
      return "etc1";
    } else if (format >= 35986 && format <= 34798) {
      return "atc";
    }
    throw new Error("Invalid (compressed) texture format given!");
  }
  static _createLevelBuffers(buffer, format, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
    const buffers = new Array(levels);
    let offset = buffer.byteOffset;
    let levelWidth = imageWidth;
    let levelHeight = imageHeight;
    let alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
    let alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
    let levelSize = alignedLevelWidth * alignedLevelHeight * _const.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];
    for (let i = 0; i < levels; i++) {
      buffers[i] = {
        levelID: i,
        levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,
        levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,
        levelBuffer: new Uint8Array(buffer.buffer, offset, levelSize)
      };
      offset += levelSize;
      levelWidth = levelWidth >> 1 || 1;
      levelHeight = levelHeight >> 1 || 1;
      alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
      alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
      levelSize = alignedLevelWidth * alignedLevelHeight * _const.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];
    }
    return buffers;
  }
}

exports.CompressedTextureResource = CompressedTextureResource;
//# sourceMappingURL=CompressedTextureResource.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/resources/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/resources/index.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var BlobResource = __webpack_require__(/*! ./BlobResource.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/resources/BlobResource.js");
var CompressedTextureResource = __webpack_require__(/*! ./CompressedTextureResource.js */ "./node_modules/pixi.js/node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.js");



exports.BlobResource = BlobResource.BlobResource;
exports.CompressedTextureResource = CompressedTextureResource.CompressedTextureResource;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var ENV = /* @__PURE__ */ ((ENV2) => {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
  return ENV2;
})(ENV || {});
var RENDERER_TYPE = /* @__PURE__ */ ((RENDERER_TYPE2) => {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
  return RENDERER_TYPE2;
})(RENDERER_TYPE || {});
var BUFFER_BITS = /* @__PURE__ */ ((BUFFER_BITS2) => {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
  return BUFFER_BITS2;
})(BUFFER_BITS || {});
var BLEND_MODES = /* @__PURE__ */ ((BLEND_MODES2) => {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
  return BLEND_MODES2;
})(BLEND_MODES || {});
var DRAW_MODES = /* @__PURE__ */ ((DRAW_MODES2) => {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  return DRAW_MODES2;
})(DRAW_MODES || {});
var FORMATS = /* @__PURE__ */ ((FORMATS2) => {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  return FORMATS2;
})(FORMATS || {});
var TARGETS = /* @__PURE__ */ ((TARGETS2) => {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  return TARGETS2;
})(TARGETS || {});
var TYPES = /* @__PURE__ */ ((TYPES2) => {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
  return TYPES2;
})(TYPES || {});
var SAMPLER_TYPES = /* @__PURE__ */ ((SAMPLER_TYPES2) => {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
  return SAMPLER_TYPES2;
})(SAMPLER_TYPES || {});
var SCALE_MODES = /* @__PURE__ */ ((SCALE_MODES2) => {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
  return SCALE_MODES2;
})(SCALE_MODES || {});
var WRAP_MODES = /* @__PURE__ */ ((WRAP_MODES2) => {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  return WRAP_MODES2;
})(WRAP_MODES || {});
var MIPMAP_MODES = /* @__PURE__ */ ((MIPMAP_MODES2) => {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
  return MIPMAP_MODES2;
})(MIPMAP_MODES || {});
var ALPHA_MODES = /* @__PURE__ */ ((ALPHA_MODES2) => {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
  return ALPHA_MODES2;
})(ALPHA_MODES || {});
var CLEAR_MODES = /* @__PURE__ */ ((CLEAR_MODES2) => {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
  return CLEAR_MODES2;
})(CLEAR_MODES || {});
var GC_MODES = /* @__PURE__ */ ((GC_MODES2) => {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
  return GC_MODES2;
})(GC_MODES || {});
var PRECISION = /* @__PURE__ */ ((PRECISION2) => {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
  return PRECISION2;
})(PRECISION || {});
var MASK_TYPES = /* @__PURE__ */ ((MASK_TYPES2) => {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
  MASK_TYPES2[MASK_TYPES2["COLOR"] = 4] = "COLOR";
  return MASK_TYPES2;
})(MASK_TYPES || {});
var COLOR_MASK_BITS = /* @__PURE__ */ ((COLOR_MASK_BITS2) => {
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["RED"] = 1] = "RED";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["GREEN"] = 2] = "GREEN";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["BLUE"] = 4] = "BLUE";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["ALPHA"] = 8] = "ALPHA";
  return COLOR_MASK_BITS2;
})(COLOR_MASK_BITS || {});
var MSAA_QUALITY = /* @__PURE__ */ ((MSAA_QUALITY2) => {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
  return MSAA_QUALITY2;
})(MSAA_QUALITY || {});
var BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
  return BUFFER_TYPE2;
})(BUFFER_TYPE || {});

exports.ALPHA_MODES = ALPHA_MODES;
exports.BLEND_MODES = BLEND_MODES;
exports.BUFFER_BITS = BUFFER_BITS;
exports.BUFFER_TYPE = BUFFER_TYPE;
exports.CLEAR_MODES = CLEAR_MODES;
exports.COLOR_MASK_BITS = COLOR_MASK_BITS;
exports.DRAW_MODES = DRAW_MODES;
exports.ENV = ENV;
exports.FORMATS = FORMATS;
exports.GC_MODES = GC_MODES;
exports.MASK_TYPES = MASK_TYPES;
exports.MIPMAP_MODES = MIPMAP_MODES;
exports.MSAA_QUALITY = MSAA_QUALITY;
exports.PRECISION = PRECISION;
exports.RENDERER_TYPE = RENDERER_TYPE;
exports.SAMPLER_TYPES = SAMPLER_TYPES;
exports.SCALE_MODES = SCALE_MODES;
exports.TARGETS = TARGETS;
exports.TYPES = TYPES;
exports.WRAP_MODES = WRAP_MODES;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/IRenderer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/IRenderer.js ***!
  \***********************************************************************/
/***/ (() => {

"use strict";


//# sourceMappingURL=IRenderer.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/Renderer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/Renderer.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
var math = __webpack_require__(/*! @pixi/math */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/index.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");
var utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/index.js");
var UniformGroup = __webpack_require__(/*! ./shader/UniformGroup.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/UniformGroup.js");
var SystemManager = __webpack_require__(/*! ./system/SystemManager.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/system/SystemManager.js");

const _Renderer = class extends SystemManager.SystemManager {
  constructor(options) {
    super();
    this.type = constants.RENDERER_TYPE.WEBGL;
    options = Object.assign({}, settings.settings.RENDER_OPTIONS, options);
    this.gl = null;
    this.CONTEXT_UID = 0;
    this.globalUniforms = new UniformGroup.UniformGroup({
      projectionMatrix: new math.Matrix()
    }, true);
    const systemConfig = {
      runners: [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "reset",
        "update",
        "postrender",
        "prerender",
        "resize"
      ],
      systems: _Renderer.__systems,
      priority: [
        "_view",
        "textureGenerator",
        "background",
        "_plugin",
        "startup",
        "context",
        "state",
        "texture",
        "buffer",
        "geometry",
        "framebuffer",
        "transformFeedback",
        "mask",
        "scissor",
        "stencil",
        "projection",
        "textureGC",
        "filter",
        "renderTexture",
        "batch",
        "objectRenderer",
        "_multisample"
      ]
    };
    this.setup(systemConfig);
    if ("useContextAlpha" in options) {
      utils.deprecation("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead");
      options.premultipliedAlpha = options.useContextAlpha && options.useContextAlpha !== "notMultiplied";
      options.backgroundAlpha = options.useContextAlpha === false ? 1 : options.backgroundAlpha;
    }
    this._plugin.rendererPlugins = _Renderer.__plugins;
    this.options = options;
    this.startup.run(this.options);
  }
  static test(options) {
    if (options?.forceCanvas) {
      return false;
    }
    return utils.isWebGLSupported();
  }
  render(displayObject, options) {
    this.objectRenderer.render(displayObject, options);
  }
  resize(desiredScreenWidth, desiredScreenHeight) {
    this._view.resizeView(desiredScreenWidth, desiredScreenHeight);
  }
  reset() {
    this.runners.reset.emit();
    return this;
  }
  clear() {
    this.renderTexture.bind();
    this.renderTexture.clear();
  }
  destroy(removeView = false) {
    this.runners.destroy.items.reverse();
    this.emitWithCustomOptions(this.runners.destroy, {
      _view: removeView
    });
    super.destroy();
  }
  get plugins() {
    return this._plugin.plugins;
  }
  get multisample() {
    return this._multisample.multisample;
  }
  get width() {
    return this._view.element.width;
  }
  get height() {
    return this._view.element.height;
  }
  get resolution() {
    return this._view.resolution;
  }
  set resolution(value) {
    this._view.resolution = value;
    this.runners.resolutionChange.emit(value);
  }
  get autoDensity() {
    return this._view.autoDensity;
  }
  get view() {
    return this._view.element;
  }
  get screen() {
    return this._view.screen;
  }
  get lastObjectRendered() {
    return this.objectRenderer.lastObjectRendered;
  }
  get renderingToScreen() {
    return this.objectRenderer.renderingToScreen;
  }
  get rendererLogId() {
    return `WebGL ${this.context.webGLVersion}`;
  }
  get clearBeforeRender() {
    utils.deprecation("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead.");
    return this.background.clearBeforeRender;
  }
  get useContextAlpha() {
    utils.deprecation("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead.");
    return this.context.useContextAlpha;
  }
  get preserveDrawingBuffer() {
    utils.deprecation("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context");
    return this.context.preserveDrawingBuffer;
  }
  get backgroundColor() {
    utils.deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");
    return this.background.color;
  }
  set backgroundColor(value) {
    utils.deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");
    this.background.color = value;
  }
  get backgroundAlpha() {
    utils.deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");
    return this.background.alpha;
  }
  set backgroundAlpha(value) {
    utils.deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");
    this.background.alpha = value;
  }
  get powerPreference() {
    utils.deprecation("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context");
    return this.context.powerPreference;
  }
  generateTexture(displayObject, options) {
    return this.textureGenerator.generateTexture(displayObject, options);
  }
};
let Renderer = _Renderer;
Renderer.extension = {
  type: extensions.ExtensionType.Renderer,
  priority: 1
};
Renderer.__plugins = {};
Renderer.__systems = {};
extensions.extensions.handleByMap(extensions.ExtensionType.RendererPlugin, Renderer.__plugins);
extensions.extensions.handleByMap(extensions.ExtensionType.RendererSystem, Renderer.__systems);
extensions.extensions.add(Renderer);

exports.Renderer = Renderer;
//# sourceMappingURL=Renderer.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/autoDetectRenderer.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/autoDetectRenderer.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");

const renderers = [];
extensions.extensions.handleByList(extensions.ExtensionType.Renderer, renderers);
function autoDetectRenderer(options) {
  for (const RendererType of renderers) {
    if (RendererType.test(options)) {
      return new RendererType(options);
    }
  }
  throw new Error("Unable to auto-detect a suitable renderer.");
}

exports.autoDetectRenderer = autoDetectRenderer;
//# sourceMappingURL=autoDetectRenderer.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/background/BackgroundSystem.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/background/BackgroundSystem.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var color = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.js");
var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");

class BackgroundSystem {
  constructor() {
    this.clearBeforeRender = true;
    this._backgroundColor = new color.Color(0);
    this.alpha = 1;
  }
  init(options) {
    this.clearBeforeRender = options.clearBeforeRender;
    const { backgroundColor, background, backgroundAlpha } = options;
    const color = background ?? backgroundColor;
    if (color !== void 0) {
      this.color = color;
    }
    this.alpha = backgroundAlpha;
  }
  get color() {
    return this._backgroundColor.value;
  }
  set color(value) {
    this._backgroundColor.setValue(value);
  }
  get alpha() {
    return this._backgroundColor.alpha;
  }
  set alpha(value) {
    this._backgroundColor.setAlpha(value);
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  destroy() {
  }
}
BackgroundSystem.defaultOptions = {
  backgroundAlpha: 1,
  backgroundColor: 0,
  clearBeforeRender: true
};
BackgroundSystem.extension = {
  type: [
    extensions.ExtensionType.RendererSystem,
    extensions.ExtensionType.CanvasRendererSystem
  ],
  name: "background"
};
extensions.extensions.add(BackgroundSystem);

exports.BackgroundSystem = BackgroundSystem;
//# sourceMappingURL=BackgroundSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchDrawCall.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchDrawCall.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");

class BatchDrawCall {
  constructor() {
    this.texArray = null;
    this.blend = 0;
    this.type = constants.DRAW_MODES.TRIANGLES;
    this.start = 0;
    this.size = 0;
    this.data = null;
  }
}

exports.BatchDrawCall = BatchDrawCall;
//# sourceMappingURL=BatchDrawCall.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchGeometry.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchGeometry.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var Buffer = __webpack_require__(/*! ../geometry/Buffer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/Buffer.js");
var Geometry = __webpack_require__(/*! ../geometry/Geometry.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/Geometry.js");

class BatchGeometry extends Geometry.Geometry {
  constructor(_static = false) {
    super();
    this._buffer = new Buffer.Buffer(null, _static, false);
    this._indexBuffer = new Buffer.Buffer(null, _static, true);
    this.addAttribute("aVertexPosition", this._buffer, 2, false, constants.TYPES.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, false, constants.TYPES.FLOAT).addAttribute("aColor", this._buffer, 4, true, constants.TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, true, constants.TYPES.FLOAT).addIndex(this._indexBuffer);
  }
}

exports.BatchGeometry = BatchGeometry;
//# sourceMappingURL=BatchGeometry.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchRenderer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchRenderer.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var color = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.js");
var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");
var utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/index.js");
var ViewableBuffer = __webpack_require__(/*! ../geometry/ViewableBuffer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/ViewableBuffer.js");
var checkMaxIfStatementsInShader = __webpack_require__(/*! ../shader/utils/checkMaxIfStatementsInShader.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.js");
var State = __webpack_require__(/*! ../state/State.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/state/State.js");
var BaseTexture = __webpack_require__(/*! ../textures/BaseTexture.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/BaseTexture.js");
var BatchDrawCall = __webpack_require__(/*! ./BatchDrawCall.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchDrawCall.js");
var BatchGeometry = __webpack_require__(/*! ./BatchGeometry.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchGeometry.js");
var BatchShaderGenerator = __webpack_require__(/*! ./BatchShaderGenerator.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchShaderGenerator.js");
var BatchTextureArray = __webpack_require__(/*! ./BatchTextureArray.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchTextureArray.js");
var canUploadSameBuffer = __webpack_require__(/*! ./canUploadSameBuffer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/canUploadSameBuffer.js");
var maxRecommendedTextures = __webpack_require__(/*! ./maxRecommendedTextures.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/maxRecommendedTextures.js");
var ObjectRenderer = __webpack_require__(/*! ./ObjectRenderer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/ObjectRenderer.js");
var texture$1 = __webpack_require__(/*! ./texture.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/texture.js");
var texture = __webpack_require__(/*! ./texture2.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/texture2.js");

const _BatchRenderer = class extends ObjectRenderer.ObjectRenderer {
  constructor(renderer) {
    super(renderer);
    this.setShaderGenerator();
    this.geometryClass = BatchGeometry.BatchGeometry;
    this.vertexSize = 6;
    this.state = State.State.for2d();
    this.size = _BatchRenderer.defaultBatchSize * 4;
    this._vertexCount = 0;
    this._indexCount = 0;
    this._bufferedElements = [];
    this._bufferedTextures = [];
    this._bufferSize = 0;
    this._shader = null;
    this._packedGeometries = [];
    this._packedGeometryPoolSize = 2;
    this._flushId = 0;
    this._aBuffers = {};
    this._iBuffers = {};
    this.maxTextures = 1;
    this.renderer.on("prerender", this.onPrerender, this);
    renderer.runners.contextChange.add(this);
    this._dcIndex = 0;
    this._aIndex = 0;
    this._iIndex = 0;
    this._attributeBuffer = null;
    this._indexBuffer = null;
    this._tempBoundTextures = [];
  }
  static get defaultMaxTextures() {
    this._defaultMaxTextures = this._defaultMaxTextures ?? maxRecommendedTextures.maxRecommendedTextures(32);
    return this._defaultMaxTextures;
  }
  static set defaultMaxTextures(value) {
    this._defaultMaxTextures = value;
  }
  static get canUploadSameBuffer() {
    this._canUploadSameBuffer = this._canUploadSameBuffer ?? canUploadSameBuffer.canUploadSameBuffer();
    return this._canUploadSameBuffer;
  }
  static set canUploadSameBuffer(value) {
    this._canUploadSameBuffer = value;
  }
  get MAX_TEXTURES() {
    utils.deprecation("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures");
    return this.maxTextures;
  }
  static get defaultVertexSrc() {
    return texture["default"];
  }
  static get defaultFragmentTemplate() {
    return texture$1["default"];
  }
  setShaderGenerator({
    vertex = _BatchRenderer.defaultVertexSrc,
    fragment = _BatchRenderer.defaultFragmentTemplate
  } = {}) {
    this.shaderGenerator = new BatchShaderGenerator.BatchShaderGenerator(vertex, fragment);
  }
  contextChange() {
    const gl = this.renderer.gl;
    if (settings.settings.PREFER_ENV === constants.ENV.WEBGL_LEGACY) {
      this.maxTextures = 1;
    } else {
      this.maxTextures = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _BatchRenderer.defaultMaxTextures);
      this.maxTextures = checkMaxIfStatementsInShader.checkMaxIfStatementsInShader(this.maxTextures, gl);
    }
    this._shader = this.shaderGenerator.generateShader(this.maxTextures);
    for (let i = 0; i < this._packedGeometryPoolSize; i++) {
      this._packedGeometries[i] = new this.geometryClass();
    }
    this.initFlushBuffers();
  }
  initFlushBuffers() {
    const {
      _drawCallPool,
      _textureArrayPool
    } = _BatchRenderer;
    const MAX_SPRITES = this.size / 4;
    const MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;
    while (_drawCallPool.length < MAX_SPRITES) {
      _drawCallPool.push(new BatchDrawCall.BatchDrawCall());
    }
    while (_textureArrayPool.length < MAX_TA) {
      _textureArrayPool.push(new BatchTextureArray.BatchTextureArray());
    }
    for (let i = 0; i < this.maxTextures; i++) {
      this._tempBoundTextures[i] = null;
    }
  }
  onPrerender() {
    this._flushId = 0;
  }
  render(element) {
    if (!element._texture.valid) {
      return;
    }
    if (this._vertexCount + element.vertexData.length / 2 > this.size) {
      this.flush();
    }
    this._vertexCount += element.vertexData.length / 2;
    this._indexCount += element.indices.length;
    this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
    this._bufferedElements[this._bufferSize++] = element;
  }
  buildTexturesAndDrawCalls() {
    const {
      _bufferedTextures: textures,
      maxTextures
    } = this;
    const textureArrays = _BatchRenderer._textureArrayPool;
    const batch = this.renderer.batch;
    const boundTextures = this._tempBoundTextures;
    const touch = this.renderer.textureGC.count;
    let TICK = ++BaseTexture.BaseTexture._globalBatch;
    let countTexArrays = 0;
    let texArray = textureArrays[0];
    let start = 0;
    batch.copyBoundTextures(boundTextures, maxTextures);
    for (let i = 0; i < this._bufferSize; ++i) {
      const tex = textures[i];
      textures[i] = null;
      if (tex._batchEnabled === TICK) {
        continue;
      }
      if (texArray.count >= maxTextures) {
        batch.boundArray(texArray, boundTextures, TICK, maxTextures);
        this.buildDrawCalls(texArray, start, i);
        start = i;
        texArray = textureArrays[++countTexArrays];
        ++TICK;
      }
      tex._batchEnabled = TICK;
      tex.touched = touch;
      texArray.elements[texArray.count++] = tex;
    }
    if (texArray.count > 0) {
      batch.boundArray(texArray, boundTextures, TICK, maxTextures);
      this.buildDrawCalls(texArray, start, this._bufferSize);
      ++countTexArrays;
      ++TICK;
    }
    for (let i = 0; i < boundTextures.length; i++) {
      boundTextures[i] = null;
    }
    BaseTexture.BaseTexture._globalBatch = TICK;
  }
  buildDrawCalls(texArray, start, finish) {
    const {
      _bufferedElements: elements,
      _attributeBuffer,
      _indexBuffer,
      vertexSize
    } = this;
    const drawCalls = _BatchRenderer._drawCallPool;
    let dcIndex = this._dcIndex;
    let aIndex = this._aIndex;
    let iIndex = this._iIndex;
    let drawCall = drawCalls[dcIndex];
    drawCall.start = this._iIndex;
    drawCall.texArray = texArray;
    for (let i = start; i < finish; ++i) {
      const sprite = elements[i];
      const tex = sprite._texture.baseTexture;
      const spriteBlendMode = utils.premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
      elements[i] = null;
      if (start < i && drawCall.blend !== spriteBlendMode) {
        drawCall.size = iIndex - drawCall.start;
        start = i;
        drawCall = drawCalls[++dcIndex];
        drawCall.texArray = texArray;
        drawCall.start = iIndex;
      }
      this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
      aIndex += sprite.vertexData.length / 2 * vertexSize;
      iIndex += sprite.indices.length;
      drawCall.blend = spriteBlendMode;
    }
    if (start < finish) {
      drawCall.size = iIndex - drawCall.start;
      ++dcIndex;
    }
    this._dcIndex = dcIndex;
    this._aIndex = aIndex;
    this._iIndex = iIndex;
  }
  bindAndClearTexArray(texArray) {
    const textureSystem = this.renderer.texture;
    for (let j = 0; j < texArray.count; j++) {
      textureSystem.bind(texArray.elements[j], texArray.ids[j]);
      texArray.elements[j] = null;
    }
    texArray.count = 0;
  }
  updateGeometry() {
    const {
      _packedGeometries: packedGeometries,
      _attributeBuffer: attributeBuffer,
      _indexBuffer: indexBuffer
    } = this;
    if (!_BatchRenderer.canUploadSameBuffer) {
      if (this._packedGeometryPoolSize <= this._flushId) {
        this._packedGeometryPoolSize++;
        packedGeometries[this._flushId] = new this.geometryClass();
      }
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.bind(packedGeometries[this._flushId]);
      this.renderer.geometry.updateBuffers();
      this._flushId++;
    } else {
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.updateBuffers();
    }
  }
  drawBatches() {
    const dcCount = this._dcIndex;
    const { gl, state: stateSystem } = this.renderer;
    const drawCalls = _BatchRenderer._drawCallPool;
    let curTexArray = null;
    for (let i = 0; i < dcCount; i++) {
      const { texArray, type, size, start, blend } = drawCalls[i];
      if (curTexArray !== texArray) {
        curTexArray = texArray;
        this.bindAndClearTexArray(texArray);
      }
      this.state.blendMode = blend;
      stateSystem.set(this.state);
      gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);
    }
  }
  flush() {
    if (this._vertexCount === 0) {
      return;
    }
    this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
    this._indexBuffer = this.getIndexBuffer(this._indexCount);
    this._aIndex = 0;
    this._iIndex = 0;
    this._dcIndex = 0;
    this.buildTexturesAndDrawCalls();
    this.updateGeometry();
    this.drawBatches();
    this._bufferSize = 0;
    this._vertexCount = 0;
    this._indexCount = 0;
  }
  start() {
    this.renderer.state.set(this.state);
    this.renderer.texture.ensureSamplerType(this.maxTextures);
    this.renderer.shader.bind(this._shader);
    if (_BatchRenderer.canUploadSameBuffer) {
      this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }
  }
  stop() {
    this.flush();
  }
  destroy() {
    for (let i = 0; i < this._packedGeometryPoolSize; i++) {
      if (this._packedGeometries[i]) {
        this._packedGeometries[i].destroy();
      }
    }
    this.renderer.off("prerender", this.onPrerender, this);
    this._aBuffers = null;
    this._iBuffers = null;
    this._packedGeometries = null;
    this._attributeBuffer = null;
    this._indexBuffer = null;
    if (this._shader) {
      this._shader.destroy();
      this._shader = null;
    }
    super.destroy();
  }
  getAttributeBuffer(size) {
    const roundedP2 = utils.nextPow2(Math.ceil(size / 8));
    const roundedSizeIndex = utils.log2(roundedP2);
    const roundedSize = roundedP2 * 8;
    if (this._aBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    let buffer = this._aBuffers[roundedSize];
    if (!buffer) {
      this._aBuffers[roundedSize] = buffer = new ViewableBuffer.ViewableBuffer(roundedSize * this.vertexSize * 4);
    }
    return buffer;
  }
  getIndexBuffer(size) {
    const roundedP2 = utils.nextPow2(Math.ceil(size / 12));
    const roundedSizeIndex = utils.log2(roundedP2);
    const roundedSize = roundedP2 * 12;
    if (this._iBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    let buffer = this._iBuffers[roundedSizeIndex];
    if (!buffer) {
      this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
    }
    return buffer;
  }
  packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
    const {
      uint32View,
      float32View
    } = attributeBuffer;
    const packedVertices = aIndex / this.vertexSize;
    const uvs = element.uvs;
    const indicies = element.indices;
    const vertexData = element.vertexData;
    const textureId = element._texture.baseTexture._batchLocation;
    const alpha = Math.min(element.worldAlpha, 1);
    const argb = color.Color.shared.setValue(element._tintRGB).toPremultiplied(alpha, element._texture.baseTexture.alphaMode > 0);
    for (let i = 0; i < vertexData.length; i += 2) {
      float32View[aIndex++] = vertexData[i];
      float32View[aIndex++] = vertexData[i + 1];
      float32View[aIndex++] = uvs[i];
      float32View[aIndex++] = uvs[i + 1];
      uint32View[aIndex++] = argb;
      float32View[aIndex++] = textureId;
    }
    for (let i = 0; i < indicies.length; i++) {
      indexBuffer[iIndex++] = packedVertices + indicies[i];
    }
  }
};
let BatchRenderer = _BatchRenderer;
BatchRenderer.defaultBatchSize = 4096;
BatchRenderer.extension = {
  name: "batch",
  type: extensions.ExtensionType.RendererPlugin
};
BatchRenderer._drawCallPool = [];
BatchRenderer._textureArrayPool = [];
extensions.extensions.add(BatchRenderer);

exports.BatchRenderer = BatchRenderer;
//# sourceMappingURL=BatchRenderer.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchShaderGenerator.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchShaderGenerator.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var math = __webpack_require__(/*! @pixi/math */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/index.js");
var Program = __webpack_require__(/*! ../shader/Program.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/Program.js");
var Shader = __webpack_require__(/*! ../shader/Shader.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/Shader.js");
var UniformGroup = __webpack_require__(/*! ../shader/UniformGroup.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/UniformGroup.js");

class BatchShaderGenerator {
  constructor(vertexSrc, fragTemplate) {
    this.vertexSrc = vertexSrc;
    this.fragTemplate = fragTemplate;
    this.programCache = {};
    this.defaultGroupCache = {};
    if (!fragTemplate.includes("%count%")) {
      throw new Error('Fragment template must contain "%count%".');
    }
    if (!fragTemplate.includes("%forloop%")) {
      throw new Error('Fragment template must contain "%forloop%".');
    }
  }
  generateShader(maxTextures) {
    if (!this.programCache[maxTextures]) {
      const sampleValues = new Int32Array(maxTextures);
      for (let i = 0; i < maxTextures; i++) {
        sampleValues[i] = i;
      }
      this.defaultGroupCache[maxTextures] = UniformGroup.UniformGroup.from({ uSamplers: sampleValues }, true);
      let fragmentSrc = this.fragTemplate;
      fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures}`);
      fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
      this.programCache[maxTextures] = new Program.Program(this.vertexSrc, fragmentSrc);
    }
    const uniforms = {
      tint: new Float32Array([1, 1, 1, 1]),
      translationMatrix: new math.Matrix(),
      default: this.defaultGroupCache[maxTextures]
    };
    return new Shader.Shader(this.programCache[maxTextures], uniforms);
  }
  generateSampleSrc(maxTextures) {
    let src = "";
    src += "\n";
    src += "\n";
    for (let i = 0; i < maxTextures; i++) {
      if (i > 0) {
        src += "\nelse ";
      }
      if (i < maxTextures - 1) {
        src += `if(vTextureId < ${i}.5)`;
      }
      src += "\n{";
      src += `
	color = texture2D(uSamplers[${i}], vTextureCoord);`;
      src += "\n}";
    }
    src += "\n";
    src += "\n";
    return src;
  }
}

exports.BatchShaderGenerator = BatchShaderGenerator;
//# sourceMappingURL=BatchShaderGenerator.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchSystem.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchSystem.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
var ObjectRenderer = __webpack_require__(/*! ./ObjectRenderer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/ObjectRenderer.js");

class BatchSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.emptyRenderer = new ObjectRenderer.ObjectRenderer(renderer);
    this.currentRenderer = this.emptyRenderer;
  }
  setObjectRenderer(objectRenderer) {
    if (this.currentRenderer === objectRenderer) {
      return;
    }
    this.currentRenderer.stop();
    this.currentRenderer = objectRenderer;
    this.currentRenderer.start();
  }
  flush() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  reset() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  copyBoundTextures(arr, maxTextures) {
    const { boundTextures } = this.renderer.texture;
    for (let i = maxTextures - 1; i >= 0; --i) {
      arr[i] = boundTextures[i] || null;
      if (arr[i]) {
        arr[i]._batchLocation = i;
      }
    }
  }
  boundArray(texArray, boundTextures, batchId, maxTextures) {
    const { elements, ids, count } = texArray;
    let j = 0;
    for (let i = 0; i < count; i++) {
      const tex = elements[i];
      const loc = tex._batchLocation;
      if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
        ids[i] = loc;
        continue;
      }
      while (j < maxTextures) {
        const bound = boundTextures[j];
        if (bound && bound._batchEnabled === batchId && bound._batchLocation === j) {
          j++;
          continue;
        }
        ids[i] = j;
        tex._batchLocation = j;
        boundTextures[j] = tex;
        break;
      }
    }
  }
  destroy() {
    this.renderer = null;
  }
}
BatchSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "batch"
};
extensions.extensions.add(BatchSystem);

exports.BatchSystem = BatchSystem;
//# sourceMappingURL=BatchSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchTextureArray.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchTextureArray.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class BatchTextureArray {
  constructor() {
    this.elements = [];
    this.ids = [];
    this.count = 0;
  }
  clear() {
    for (let i = 0; i < this.count; i++) {
      this.elements[i] = null;
    }
    this.count = 0;
  }
}

exports.BatchTextureArray = BatchTextureArray;
//# sourceMappingURL=BatchTextureArray.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/ObjectRenderer.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/ObjectRenderer.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class ObjectRenderer {
  constructor(renderer) {
    this.renderer = renderer;
  }
  flush() {
  }
  destroy() {
    this.renderer = null;
  }
  start() {
  }
  stop() {
    this.flush();
  }
  render(_object) {
  }
}

exports.ObjectRenderer = ObjectRenderer;
//# sourceMappingURL=ObjectRenderer.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/canUploadSameBuffer.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/canUploadSameBuffer.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");

function canUploadSameBuffer() {
  return !settings.isMobile.apple.device;
}

exports.canUploadSameBuffer = canUploadSameBuffer;
//# sourceMappingURL=canUploadSameBuffer.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/maxRecommendedTextures.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/maxRecommendedTextures.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");

function maxRecommendedTextures(max) {
  let allowMax = true;
  const navigator = settings.settings.ADAPTER.getNavigator();
  if (settings.isMobile.tablet || settings.isMobile.phone) {
    if (settings.isMobile.apple.device) {
      const match = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (match) {
        const majorVersion = parseInt(match[1], 10);
        if (majorVersion < 11) {
          allowMax = false;
        }
      }
    }
    if (settings.isMobile.android.device) {
      const match = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (match) {
        const majorVersion = parseInt(match[1], 10);
        if (majorVersion < 7) {
          allowMax = false;
        }
      }
    }
  }
  return allowMax ? max : 4;
}

exports.maxRecommendedTextures = maxRecommendedTextures;
//# sourceMappingURL=maxRecommendedTextures.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/texture.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/texture.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var defaultFragment = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";

exports["default"] = defaultFragment;
//# sourceMappingURL=texture.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/texture2.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/texture2.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var defaultVertex = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";

exports["default"] = defaultVertex;
//# sourceMappingURL=texture2.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/context/ContextSystem.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/context/ContextSystem.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");

let CONTEXT_UID_COUNTER = 0;
class ContextSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.webGLVersion = 1;
    this.extensions = {};
    this.supports = {
      uint32Indices: false
    };
    this.handleContextLost = this.handleContextLost.bind(this);
    this.handleContextRestored = this.handleContextRestored.bind(this);
  }
  get isLost() {
    return !this.gl || this.gl.isContextLost();
  }
  contextChange(gl) {
    this.gl = gl;
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
  }
  init(options) {
    if (options.context) {
      this.initFromContext(options.context);
    } else {
      const alpha = this.renderer.background.alpha < 1;
      const premultipliedAlpha = options.premultipliedAlpha;
      this.preserveDrawingBuffer = options.preserveDrawingBuffer;
      this.useContextAlpha = options.useContextAlpha;
      this.powerPreference = options.powerPreference;
      this.initFromOptions({
        alpha,
        premultipliedAlpha,
        antialias: options.antialias,
        stencil: true,
        preserveDrawingBuffer: options.preserveDrawingBuffer,
        powerPreference: options.powerPreference
      });
    }
  }
  initFromContext(gl) {
    this.gl = gl;
    this.validateContext(gl);
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
    this.renderer.runners.contextChange.emit(gl);
    const view = this.renderer.view;
    if (view.addEventListener !== void 0) {
      view.addEventListener("webglcontextlost", this.handleContextLost, false);
      view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
    }
  }
  initFromOptions(options) {
    const gl = this.createContext(this.renderer.view, options);
    this.initFromContext(gl);
  }
  createContext(canvas, options) {
    let gl;
    if (settings.settings.PREFER_ENV >= constants.ENV.WEBGL2) {
      gl = canvas.getContext("webgl2", options);
    }
    if (gl) {
      this.webGLVersion = 2;
    } else {
      this.webGLVersion = 1;
      gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
      if (!gl) {
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      }
    }
    this.gl = gl;
    this.getExtensions();
    return this.gl;
  }
  getExtensions() {
    const { gl } = this;
    const common = {
      loseContext: gl.getExtension("WEBGL_lose_context"),
      anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      etc: gl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: gl.getExtension("WEBGL_compressed_texture_atc"),
      astc: gl.getExtension("WEBGL_compressed_texture_astc")
    };
    if (this.webGLVersion === 1) {
      Object.assign(this.extensions, common, {
        drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
        depthTexture: gl.getExtension("WEBGL_depth_texture"),
        vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
        floatTexture: gl.getExtension("OES_texture_float"),
        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
        textureHalfFloat: gl.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
      });
    } else if (this.webGLVersion === 2) {
      Object.assign(this.extensions, common, {
        colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
      });
    }
  }
  handleContextLost(event) {
    event.preventDefault();
    setTimeout(() => {
      if (this.gl.isContextLost() && this.extensions.loseContext) {
        this.extensions.loseContext.restoreContext();
      }
    }, 0);
  }
  handleContextRestored() {
    this.renderer.runners.contextChange.emit(this.gl);
  }
  destroy() {
    const view = this.renderer.view;
    this.renderer = null;
    if (view.removeEventListener !== void 0) {
      view.removeEventListener("webglcontextlost", this.handleContextLost);
      view.removeEventListener("webglcontextrestored", this.handleContextRestored);
    }
    this.gl.useProgram(null);
    if (this.extensions.loseContext) {
      this.extensions.loseContext.loseContext();
    }
  }
  postrender() {
    if (this.renderer.objectRenderer.renderingToScreen) {
      this.gl.flush();
    }
  }
  validateContext(gl) {
    const attributes = gl.getContextAttributes();
    const isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
    if (isWebGl2) {
      this.webGLVersion = 2;
    }
    if (attributes && !attributes.stencil) {
      console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    }
    const hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
    this.supports.uint32Indices = hasuint32;
    if (!hasuint32) {
      console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
    }
  }
}
ContextSystem.defaultOptions = {
  context: null,
  antialias: false,
  premultipliedAlpha: true,
  preserveDrawingBuffer: false,
  powerPreference: "default"
};
ContextSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "context"
};
extensions.extensions.add(ContextSystem);

exports.ContextSystem = ContextSystem;
//# sourceMappingURL=ContextSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/Filter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/Filter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var Program = __webpack_require__(/*! ../shader/Program.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/Program.js");
var Shader = __webpack_require__(/*! ../shader/Shader.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/Shader.js");
var State = __webpack_require__(/*! ../state/State.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/state/State.js");
var defaultFilter$1 = __webpack_require__(/*! ./defaultFilter.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/defaultFilter.js");
var defaultFilter = __webpack_require__(/*! ./defaultFilter2.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/defaultFilter2.js");

const _Filter = class extends Shader.Shader {
  constructor(vertexSrc, fragmentSrc, uniforms) {
    const program = Program.Program.from(vertexSrc || _Filter.defaultVertexSrc, fragmentSrc || _Filter.defaultFragmentSrc);
    super(program, uniforms);
    this.padding = 0;
    this.resolution = _Filter.defaultResolution;
    this.multisample = _Filter.defaultMultisample;
    this.enabled = true;
    this.autoFit = true;
    this.state = new State.State();
  }
  apply(filterManager, input, output, clearMode, _currentState) {
    filterManager.applyFilter(this, input, output, clearMode);
  }
  get blendMode() {
    return this.state.blendMode;
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._resolution = value;
  }
  static get defaultVertexSrc() {
    return defaultFilter["default"];
  }
  static get defaultFragmentSrc() {
    return defaultFilter$1["default"];
  }
};
let Filter = _Filter;
Filter.defaultResolution = 1;
Filter.defaultMultisample = constants.MSAA_QUALITY.NONE;

exports.Filter = Filter;
//# sourceMappingURL=Filter.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/FilterState.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/FilterState.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var math = __webpack_require__(/*! @pixi/math */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/index.js");

class FilterState {
  constructor() {
    this.renderTexture = null;
    this.target = null;
    this.legacy = false;
    this.resolution = 1;
    this.multisample = constants.MSAA_QUALITY.NONE;
    this.sourceFrame = new math.Rectangle();
    this.destinationFrame = new math.Rectangle();
    this.bindingSourceFrame = new math.Rectangle();
    this.bindingDestinationFrame = new math.Rectangle();
    this.filters = [];
    this.transform = null;
  }
  clear() {
    this.target = null;
    this.filters = null;
    this.renderTexture = null;
  }
}

exports.FilterState = FilterState;
//# sourceMappingURL=FilterState.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/FilterSystem.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/FilterSystem.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
var math = __webpack_require__(/*! @pixi/math */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/index.js");
var RenderTexturePool = __webpack_require__(/*! ../renderTexture/RenderTexturePool.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.js");
var UniformGroup = __webpack_require__(/*! ../shader/UniformGroup.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/UniformGroup.js");
var Quad = __webpack_require__(/*! ../utils/Quad.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/utils/Quad.js");
var QuadUv = __webpack_require__(/*! ../utils/QuadUv.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/utils/QuadUv.js");
var FilterState = __webpack_require__(/*! ./FilterState.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/FilterState.js");

const tempPoints = [new math.Point(), new math.Point(), new math.Point(), new math.Point()];
const tempMatrix = new math.Matrix();
class FilterSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.defaultFilterStack = [{}];
    this.texturePool = new RenderTexturePool.RenderTexturePool();
    this.statePool = [];
    this.quad = new Quad.Quad();
    this.quadUv = new QuadUv.QuadUv();
    this.tempRect = new math.Rectangle();
    this.activeState = {};
    this.globalUniforms = new UniformGroup.UniformGroup({
      outputFrame: new math.Rectangle(),
      inputSize: new Float32Array(4),
      inputPixel: new Float32Array(4),
      inputClamp: new Float32Array(4),
      resolution: 1,
      filterArea: new Float32Array(4),
      filterClamp: new Float32Array(4)
    }, true);
    this.forceClear = false;
    this.useMaxPadding = false;
  }
  init() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  push(target, filters) {
    const renderer = this.renderer;
    const filterStack = this.defaultFilterStack;
    const state = this.statePool.pop() || new FilterState.FilterState();
    const renderTextureSystem = this.renderer.renderTexture;
    let resolution = filters[0].resolution;
    let multisample = filters[0].multisample;
    let padding = filters[0].padding;
    let autoFit = filters[0].autoFit;
    let legacy = filters[0].legacy ?? true;
    for (let i = 1; i < filters.length; i++) {
      const filter = filters[i];
      resolution = Math.min(resolution, filter.resolution);
      multisample = Math.min(multisample, filter.multisample);
      padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;
      autoFit = autoFit && filter.autoFit;
      legacy = legacy || (filter.legacy ?? true);
    }
    if (filterStack.length === 1) {
      this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;
    }
    filterStack.push(state);
    state.resolution = resolution;
    state.multisample = multisample;
    state.legacy = legacy;
    state.target = target;
    state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
    state.sourceFrame.pad(padding);
    const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
    if (renderer.projection.transform) {
      this.transformAABB(tempMatrix.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);
    }
    if (autoFit) {
      state.sourceFrame.fit(sourceFrameProjected);
      if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {
        state.sourceFrame.width = 0;
        state.sourceFrame.height = 0;
      }
    } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {
      state.sourceFrame.width = 0;
      state.sourceFrame.height = 0;
    }
    this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
    state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);
    state.filters = filters;
    state.destinationFrame.width = state.renderTexture.width;
    state.destinationFrame.height = state.renderTexture.height;
    const destinationFrame = this.tempRect;
    destinationFrame.x = 0;
    destinationFrame.y = 0;
    destinationFrame.width = state.sourceFrame.width;
    destinationFrame.height = state.sourceFrame.height;
    state.renderTexture.filterFrame = state.sourceFrame;
    state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);
    state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);
    state.transform = renderer.projection.transform;
    renderer.projection.transform = null;
    renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);
    renderer.framebuffer.clear(0, 0, 0, 0);
  }
  pop() {
    const filterStack = this.defaultFilterStack;
    const state = filterStack.pop();
    const filters = state.filters;
    this.activeState = state;
    const globalUniforms = this.globalUniforms.uniforms;
    globalUniforms.outputFrame = state.sourceFrame;
    globalUniforms.resolution = state.resolution;
    const inputSize = globalUniforms.inputSize;
    const inputPixel = globalUniforms.inputPixel;
    const inputClamp = globalUniforms.inputClamp;
    inputSize[0] = state.destinationFrame.width;
    inputSize[1] = state.destinationFrame.height;
    inputSize[2] = 1 / inputSize[0];
    inputSize[3] = 1 / inputSize[1];
    inputPixel[0] = Math.round(inputSize[0] * state.resolution);
    inputPixel[1] = Math.round(inputSize[1] * state.resolution);
    inputPixel[2] = 1 / inputPixel[0];
    inputPixel[3] = 1 / inputPixel[1];
    inputClamp[0] = 0.5 * inputPixel[2];
    inputClamp[1] = 0.5 * inputPixel[3];
    inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
    inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
    if (state.legacy) {
      const filterArea = globalUniforms.filterArea;
      filterArea[0] = state.destinationFrame.width;
      filterArea[1] = state.destinationFrame.height;
      filterArea[2] = state.sourceFrame.x;
      filterArea[3] = state.sourceFrame.y;
      globalUniforms.filterClamp = globalUniforms.inputClamp;
    }
    this.globalUniforms.update();
    const lastState = filterStack[filterStack.length - 1];
    this.renderer.framebuffer.blit();
    if (filters.length === 1) {
      filters[0].apply(this, state.renderTexture, lastState.renderTexture, constants.CLEAR_MODES.BLEND, state);
      this.returnFilterTexture(state.renderTexture);
    } else {
      let flip = state.renderTexture;
      let flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
      flop.filterFrame = flip.filterFrame;
      let i = 0;
      for (i = 0; i < filters.length - 1; ++i) {
        if (i === 1 && state.multisample > 1) {
          flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
          flop.filterFrame = flip.filterFrame;
        }
        filters[i].apply(this, flip, flop, constants.CLEAR_MODES.CLEAR, state);
        const t = flip;
        flip = flop;
        flop = t;
      }
      filters[i].apply(this, flip, lastState.renderTexture, constants.CLEAR_MODES.BLEND, state);
      if (i > 1 && state.multisample > 1) {
        this.returnFilterTexture(state.renderTexture);
      }
      this.returnFilterTexture(flip);
      this.returnFilterTexture(flop);
    }
    state.clear();
    this.statePool.push(state);
  }
  bindAndClear(filterTexture, clearMode = constants.CLEAR_MODES.CLEAR) {
    const {
      renderTexture: renderTextureSystem,
      state: stateSystem
    } = this.renderer;
    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      this.renderer.projection.transform = this.activeState.transform;
    } else {
      this.renderer.projection.transform = null;
    }
    if (filterTexture?.filterFrame) {
      const destinationFrame = this.tempRect;
      destinationFrame.x = 0;
      destinationFrame.y = 0;
      destinationFrame.width = filterTexture.filterFrame.width;
      destinationFrame.height = filterTexture.filterFrame.height;
      renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
    } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      renderTextureSystem.bind(filterTexture);
    } else {
      this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
    }
    const autoClear = stateSystem.stateId & 1 || this.forceClear;
    if (clearMode === constants.CLEAR_MODES.CLEAR || clearMode === constants.CLEAR_MODES.BLIT && autoClear) {
      this.renderer.framebuffer.clear(0, 0, 0, 0);
    }
  }
  applyFilter(filter, input, output, clearMode) {
    const renderer = this.renderer;
    renderer.state.set(filter.state);
    this.bindAndClear(output, clearMode);
    filter.uniforms.uSampler = input;
    filter.uniforms.filterGlobals = this.globalUniforms;
    renderer.shader.bind(filter);
    filter.legacy = !!filter.program.attributeData.aTextureCoord;
    if (filter.legacy) {
      this.quadUv.map(input._frame, input.filterFrame);
      renderer.geometry.bind(this.quadUv);
      renderer.geometry.draw(constants.DRAW_MODES.TRIANGLES);
    } else {
      renderer.geometry.bind(this.quad);
      renderer.geometry.draw(constants.DRAW_MODES.TRIANGLE_STRIP);
    }
  }
  calculateSpriteMatrix(outputMatrix, sprite) {
    const { sourceFrame, destinationFrame } = this.activeState;
    const { orig } = sprite._texture;
    const mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
    const worldTransform = sprite.worldTransform.copyTo(math.Matrix.TEMP_MATRIX);
    worldTransform.invert();
    mappedMatrix.prepend(worldTransform);
    mappedMatrix.scale(1 / orig.width, 1 / orig.height);
    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
    return mappedMatrix;
  }
  destroy() {
    this.renderer = null;
    this.texturePool.clear(false);
  }
  getOptimalFilterTexture(minWidth, minHeight, resolution = 1, multisample = constants.MSAA_QUALITY.NONE) {
    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
  }
  getFilterTexture(input, resolution, multisample) {
    if (typeof input === "number") {
      const swap = input;
      input = resolution;
      resolution = swap;
    }
    input = input || this.activeState.renderTexture;
    const filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || constants.MSAA_QUALITY.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  }
  returnFilterTexture(renderTexture) {
    this.texturePool.returnTexture(renderTexture);
  }
  emptyPool() {
    this.texturePool.clear(true);
  }
  resize() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  transformAABB(matrix, rect) {
    const lt = tempPoints[0];
    const lb = tempPoints[1];
    const rt = tempPoints[2];
    const rb = tempPoints[3];
    lt.set(rect.left, rect.top);
    lb.set(rect.left, rect.bottom);
    rt.set(rect.right, rect.top);
    rb.set(rect.right, rect.bottom);
    matrix.apply(lt, lt);
    matrix.apply(lb, lb);
    matrix.apply(rt, rt);
    matrix.apply(rb, rb);
    const x0 = Math.min(lt.x, lb.x, rt.x, rb.x);
    const y0 = Math.min(lt.y, lb.y, rt.y, rb.y);
    const x1 = Math.max(lt.x, lb.x, rt.x, rb.x);
    const y1 = Math.max(lt.y, lb.y, rt.y, rb.y);
    rect.x = x0;
    rect.y = y0;
    rect.width = x1 - x0;
    rect.height = y1 - y0;
  }
  roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {
      return;
    }
    if (transform) {
      const { a, b, c, d } = transform;
      if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4)) {
        return;
      }
    }
    transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.transformAABB(transform, frame);
    frame.ceil(resolution);
    this.transformAABB(transform.invert(), frame);
  }
}
FilterSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "filter"
};
extensions.extensions.add(FilterSystem);

exports.FilterSystem = FilterSystem;
//# sourceMappingURL=FilterSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/IFilterTarget.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/IFilterTarget.js ***!
  \***********************************************************************************/
/***/ (() => {

"use strict";


//# sourceMappingURL=IFilterTarget.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/defaultFilter.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/defaultFilter.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var defaultFragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";

exports["default"] = defaultFragment;
//# sourceMappingURL=defaultFilter.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/defaultFilter2.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/defaultFilter2.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var defaultVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";

exports["default"] = defaultVertex;
//# sourceMappingURL=defaultFilter2.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var math = __webpack_require__(/*! @pixi/math */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/index.js");
var TextureMatrix = __webpack_require__(/*! ../../textures/TextureMatrix.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/TextureMatrix.js");
var Filter = __webpack_require__(/*! ../Filter.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/Filter.js");
var spriteMaskFilter$1 = __webpack_require__(/*! ./spriteMaskFilter2.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter2.js");
var spriteMaskFilter = __webpack_require__(/*! ./spriteMaskFilter3.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter3.js");

class SpriteMaskFilter extends Filter.Filter {
  constructor(vertexSrc, fragmentSrc, uniforms) {
    let sprite = null;
    if (typeof vertexSrc !== "string" && fragmentSrc === void 0 && uniforms === void 0) {
      sprite = vertexSrc;
      vertexSrc = void 0;
      fragmentSrc = void 0;
      uniforms = void 0;
    }
    super(vertexSrc || spriteMaskFilter["default"], fragmentSrc || spriteMaskFilter$1["default"], uniforms);
    this.maskSprite = sprite;
    this.maskMatrix = new math.Matrix();
  }
  get maskSprite() {
    return this._maskSprite;
  }
  set maskSprite(value) {
    this._maskSprite = value;
    if (this._maskSprite) {
      this._maskSprite.renderable = false;
    }
  }
  apply(filterManager, input, output, clearMode) {
    const maskSprite = this._maskSprite;
    const tex = maskSprite._texture;
    if (!tex.valid) {
      return;
    }
    if (!tex.uvMatrix) {
      tex.uvMatrix = new TextureMatrix.TextureMatrix(tex, 0);
    }
    tex.uvMatrix.update();
    this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
    this.uniforms.mask = tex;
    this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
    this.uniforms.alpha = maskSprite.worldAlpha;
    this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
    filterManager.applyFilter(this, input, output, clearMode);
  }
}

exports.SpriteMaskFilter = SpriteMaskFilter;
//# sourceMappingURL=SpriteMaskFilter.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter2.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter2.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var fragment = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";

exports["default"] = fragment;
//# sourceMappingURL=spriteMaskFilter2.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter3.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter3.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";

exports["default"] = vertex;
//# sourceMappingURL=spriteMaskFilter3.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/fragments/default.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/fragments/default.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var $defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";

exports["default"] = $defaultVertex;
//# sourceMappingURL=default.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/fragments/defaultFilter.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/fragments/defaultFilter.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var $defaultFilterVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";

exports["default"] = $defaultFilterVertex;
//# sourceMappingURL=defaultFilter.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/fragments/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/fragments/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _default = __webpack_require__(/*! ./default.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/fragments/default.js");
var defaultFilter = __webpack_require__(/*! ./defaultFilter.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/fragments/defaultFilter.js");

const defaultVertex = _default["default"];
const defaultFilterVertex = defaultFilter["default"];

exports.defaultFilterVertex = defaultFilterVertex;
exports.defaultVertex = defaultVertex;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/framebuffer/Framebuffer.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/framebuffer/Framebuffer.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var runner = __webpack_require__(/*! @pixi/runner */ "./node_modules/pixi.js/node_modules/@pixi/runner/lib/index.js");
var BaseTexture = __webpack_require__(/*! ../textures/BaseTexture.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/BaseTexture.js");
var DepthResource = __webpack_require__(/*! ../textures/resources/DepthResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/DepthResource.js");

class Framebuffer {
  constructor(width, height) {
    this.width = Math.round(width || 100);
    this.height = Math.round(height || 100);
    this.stencil = false;
    this.depth = false;
    this.dirtyId = 0;
    this.dirtyFormat = 0;
    this.dirtySize = 0;
    this.depthTexture = null;
    this.colorTextures = [];
    this.glFramebuffers = {};
    this.disposeRunner = new runner.Runner("disposeFramebuffer");
    this.multisample = constants.MSAA_QUALITY.NONE;
  }
  get colorTexture() {
    return this.colorTextures[0];
  }
  addColorTexture(index = 0, texture) {
    this.colorTextures[index] = texture || new BaseTexture.BaseTexture(null, {
      scaleMode: constants.SCALE_MODES.NEAREST,
      resolution: 1,
      mipmap: constants.MIPMAP_MODES.OFF,
      width: this.width,
      height: this.height
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  addDepthTexture(texture) {
    this.depthTexture = texture || new BaseTexture.BaseTexture(new DepthResource.DepthResource(null, { width: this.width, height: this.height }), {
      scaleMode: constants.SCALE_MODES.NEAREST,
      resolution: 1,
      width: this.width,
      height: this.height,
      mipmap: constants.MIPMAP_MODES.OFF,
      format: constants.FORMATS.DEPTH_COMPONENT,
      type: constants.TYPES.UNSIGNED_SHORT
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  enableDepth() {
    this.depth = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  enableStencil() {
    this.stencil = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  resize(width, height) {
    width = Math.round(width);
    height = Math.round(height);
    if (width === this.width && height === this.height)
      return;
    this.width = width;
    this.height = height;
    this.dirtyId++;
    this.dirtySize++;
    for (let i = 0; i < this.colorTextures.length; i++) {
      const texture = this.colorTextures[i];
      const resolution = texture.resolution;
      texture.setSize(width / resolution, height / resolution);
    }
    if (this.depthTexture) {
      const resolution = this.depthTexture.resolution;
      this.depthTexture.setSize(width / resolution, height / resolution);
    }
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroyDepthTexture() {
    if (this.depthTexture) {
      this.depthTexture.destroy();
      this.depthTexture = null;
      ++this.dirtyId;
      ++this.dirtyFormat;
    }
  }
}

exports.Framebuffer = Framebuffer;
//# sourceMappingURL=Framebuffer.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
var math = __webpack_require__(/*! @pixi/math */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/index.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");
var Framebuffer = __webpack_require__(/*! ./Framebuffer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/framebuffer/Framebuffer.js");
var GLFramebuffer = __webpack_require__(/*! ./GLFramebuffer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.js");

const tempRectangle = new math.Rectangle();
class FramebufferSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.managedFramebuffers = [];
    this.unknownFramebuffer = new Framebuffer.Framebuffer(10, 10);
    this.msaaSamples = null;
  }
  contextChange() {
    this.disposeAll(true);
    const gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.current = this.unknownFramebuffer;
    this.viewport = new math.Rectangle();
    this.hasMRT = true;
    this.writeDepthTexture = true;
    if (this.renderer.context.webGLVersion === 1) {
      let nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers;
      let nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
      if (settings.settings.PREFER_ENV === constants.ENV.WEBGL_LEGACY) {
        nativeDrawBuffersExtension = null;
        nativeDepthTextureExtension = null;
      }
      if (nativeDrawBuffersExtension) {
        gl.drawBuffers = (activeTextures) => nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures);
      } else {
        this.hasMRT = false;
        gl.drawBuffers = () => {
        };
      }
      if (!nativeDepthTextureExtension) {
        this.writeDepthTexture = false;
      }
    } else {
      this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
    }
  }
  bind(framebuffer, frame, mipLevel = 0) {
    const { gl } = this;
    if (framebuffer) {
      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
      if (this.current !== framebuffer) {
        this.current = framebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
      }
      if (fbo.mipLevel !== mipLevel) {
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
        fbo.mipLevel = mipLevel;
      }
      if (fbo.dirtyId !== framebuffer.dirtyId) {
        fbo.dirtyId = framebuffer.dirtyId;
        if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
          fbo.dirtyFormat = framebuffer.dirtyFormat;
          fbo.dirtySize = framebuffer.dirtySize;
          this.updateFramebuffer(framebuffer, mipLevel);
        } else if (fbo.dirtySize !== framebuffer.dirtySize) {
          fbo.dirtySize = framebuffer.dirtySize;
          this.resizeFramebuffer(framebuffer);
        }
      }
      for (let i = 0; i < framebuffer.colorTextures.length; i++) {
        const tex = framebuffer.colorTextures[i];
        this.renderer.texture.unbind(tex.parentTextureArray || tex);
      }
      if (framebuffer.depthTexture) {
        this.renderer.texture.unbind(framebuffer.depthTexture);
      }
      if (frame) {
        const mipWidth = frame.width >> mipLevel;
        const mipHeight = frame.height >> mipLevel;
        const scale = mipWidth / frame.width;
        this.setViewport(frame.x * scale, frame.y * scale, mipWidth, mipHeight);
      } else {
        const mipWidth = framebuffer.width >> mipLevel;
        const mipHeight = framebuffer.height >> mipLevel;
        this.setViewport(0, 0, mipWidth, mipHeight);
      }
    } else {
      if (this.current) {
        this.current = null;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      if (frame) {
        this.setViewport(frame.x, frame.y, frame.width, frame.height);
      } else {
        this.setViewport(0, 0, this.renderer.width, this.renderer.height);
      }
    }
  }
  setViewport(x, y, width, height) {
    const v = this.viewport;
    x = Math.round(x);
    y = Math.round(y);
    width = Math.round(width);
    height = Math.round(height);
    if (v.width !== width || v.height !== height || v.x !== x || v.y !== y) {
      v.x = x;
      v.y = y;
      v.width = width;
      v.height = height;
      this.gl.viewport(x, y, width, height);
    }
  }
  get size() {
    if (this.current) {
      return { x: 0, y: 0, width: this.current.width, height: this.current.height };
    }
    return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
  }
  clear(r, g, b, a, mask = constants.BUFFER_BITS.COLOR | constants.BUFFER_BITS.DEPTH) {
    const { gl } = this;
    gl.clearColor(r, g, b, a);
    gl.clear(mask);
  }
  initFramebuffer(framebuffer) {
    const { gl } = this;
    const fbo = new GLFramebuffer.GLFramebuffer(gl.createFramebuffer());
    fbo.multisample = this.detectSamples(framebuffer.multisample);
    framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
    this.managedFramebuffers.push(framebuffer);
    framebuffer.disposeRunner.add(this);
    return fbo;
  }
  resizeFramebuffer(framebuffer) {
    const { gl } = this;
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (fbo.stencil) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
    }
    const colorTextures = framebuffer.colorTextures;
    let count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    for (let i = 0; i < count; i++) {
      const texture = colorTextures[i];
      const parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0);
      if (i === 0 && fbo.msaaBuffer) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);
      }
    }
    if (framebuffer.depthTexture && this.writeDepthTexture) {
      this.renderer.texture.bind(framebuffer.depthTexture, 0);
    }
  }
  updateFramebuffer(framebuffer, mipLevel) {
    const { gl } = this;
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    const colorTextures = framebuffer.colorTextures;
    let count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    if (fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer)) {
      fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer();
    } else if (fbo.msaaBuffer) {
      gl.deleteRenderbuffer(fbo.msaaBuffer);
      fbo.msaaBuffer = null;
      if (fbo.blitFramebuffer) {
        fbo.blitFramebuffer.dispose();
        fbo.blitFramebuffer = null;
      }
    }
    const activeTextures = [];
    for (let i = 0; i < count; i++) {
      const texture = colorTextures[i];
      const parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0);
      if (i === 0 && fbo.msaaBuffer) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
      } else {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
        activeTextures.push(gl.COLOR_ATTACHMENT0 + i);
      }
    }
    if (activeTextures.length > 1) {
      gl.drawBuffers(activeTextures);
    }
    if (framebuffer.depthTexture) {
      const writeDepthTexture = this.writeDepthTexture;
      if (writeDepthTexture) {
        const depthTexture = framebuffer.depthTexture;
        this.renderer.texture.bind(depthTexture, 0);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
      }
    }
    if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
      fbo.stencil = fbo.stencil || gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
    } else if (fbo.stencil) {
      gl.deleteRenderbuffer(fbo.stencil);
      fbo.stencil = null;
    }
  }
  canMultisampleFramebuffer(framebuffer) {
    return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
  }
  detectSamples(samples) {
    const { msaaSamples } = this;
    let res = constants.MSAA_QUALITY.NONE;
    if (samples <= 1 || msaaSamples === null) {
      return res;
    }
    for (let i = 0; i < msaaSamples.length; i++) {
      if (msaaSamples[i] <= samples) {
        res = msaaSamples[i];
        break;
      }
    }
    if (res === 1) {
      res = constants.MSAA_QUALITY.NONE;
    }
    return res;
  }
  blit(framebuffer, sourcePixels, destPixels) {
    const { current, renderer, gl, CONTEXT_UID } = this;
    if (renderer.context.webGLVersion !== 2) {
      return;
    }
    if (!current) {
      return;
    }
    const fbo = current.glFramebuffers[CONTEXT_UID];
    if (!fbo) {
      return;
    }
    if (!framebuffer) {
      if (!fbo.msaaBuffer) {
        return;
      }
      const colorTexture = current.colorTextures[0];
      if (!colorTexture) {
        return;
      }
      if (!fbo.blitFramebuffer) {
        fbo.blitFramebuffer = new Framebuffer.Framebuffer(current.width, current.height);
        fbo.blitFramebuffer.addColorTexture(0, colorTexture);
      }
      framebuffer = fbo.blitFramebuffer;
      if (framebuffer.colorTextures[0] !== colorTexture) {
        framebuffer.colorTextures[0] = colorTexture;
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
      }
      if (framebuffer.width !== current.width || framebuffer.height !== current.height) {
        framebuffer.width = current.width;
        framebuffer.height = current.height;
        framebuffer.dirtyId++;
        framebuffer.dirtySize++;
      }
    }
    if (!sourcePixels) {
      sourcePixels = tempRectangle;
      sourcePixels.width = current.width;
      sourcePixels.height = current.height;
    }
    if (!destPixels) {
      destPixels = sourcePixels;
    }
    const sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
    this.bind(framebuffer);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
    gl.blitFramebuffer(sourcePixels.left, sourcePixels.top, sourcePixels.right, sourcePixels.bottom, destPixels.left, destPixels.top, destPixels.right, destPixels.bottom, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, framebuffer.glFramebuffers[this.CONTEXT_UID].framebuffer);
  }
  disposeFramebuffer(framebuffer, contextLost) {
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    const gl = this.gl;
    if (!fbo) {
      return;
    }
    delete framebuffer.glFramebuffers[this.CONTEXT_UID];
    const index = this.managedFramebuffers.indexOf(framebuffer);
    if (index >= 0) {
      this.managedFramebuffers.splice(index, 1);
    }
    framebuffer.disposeRunner.remove(this);
    if (!contextLost) {
      gl.deleteFramebuffer(fbo.framebuffer);
      if (fbo.msaaBuffer) {
        gl.deleteRenderbuffer(fbo.msaaBuffer);
      }
      if (fbo.stencil) {
        gl.deleteRenderbuffer(fbo.stencil);
      }
    }
    if (fbo.blitFramebuffer) {
      this.disposeFramebuffer(fbo.blitFramebuffer, contextLost);
    }
  }
  disposeAll(contextLost) {
    const list = this.managedFramebuffers;
    this.managedFramebuffers = [];
    for (let i = 0; i < list.length; i++) {
      this.disposeFramebuffer(list[i], contextLost);
    }
  }
  forceStencil() {
    const framebuffer = this.current;
    if (!framebuffer) {
      return;
    }
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (!fbo || fbo.stencil) {
      return;
    }
    framebuffer.stencil = true;
    const w = framebuffer.width;
    const h = framebuffer.height;
    const gl = this.gl;
    const stencil = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
    if (fbo.msaaBuffer) {
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, w, h);
    } else {
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w, h);
    }
    fbo.stencil = stencil;
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
  }
  reset() {
    this.current = this.unknownFramebuffer;
    this.viewport = new math.Rectangle();
  }
  destroy() {
    this.renderer = null;
  }
}
FramebufferSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "framebuffer"
};
extensions.extensions.add(FramebufferSystem);

exports.FramebufferSystem = FramebufferSystem;
//# sourceMappingURL=FramebufferSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");

class GLFramebuffer {
  constructor(framebuffer) {
    this.framebuffer = framebuffer;
    this.stencil = null;
    this.dirtyId = -1;
    this.dirtyFormat = -1;
    this.dirtySize = -1;
    this.multisample = constants.MSAA_QUALITY.NONE;
    this.msaaBuffer = null;
    this.blitFramebuffer = null;
    this.mipLevel = 0;
  }
}

exports.GLFramebuffer = GLFramebuffer;
//# sourceMappingURL=GLFramebuffer.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/framebuffer/MultisampleSystem.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/framebuffer/MultisampleSystem.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");

class MultisampleSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  contextChange(gl) {
    let samples;
    if (this.renderer.context.webGLVersion === 1) {
      const framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    } else {
      const framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
    }
    if (samples >= constants.MSAA_QUALITY.HIGH) {
      this.multisample = constants.MSAA_QUALITY.HIGH;
    } else if (samples >= constants.MSAA_QUALITY.MEDIUM) {
      this.multisample = constants.MSAA_QUALITY.MEDIUM;
    } else if (samples >= constants.MSAA_QUALITY.LOW) {
      this.multisample = constants.MSAA_QUALITY.LOW;
    } else {
      this.multisample = constants.MSAA_QUALITY.NONE;
    }
  }
  destroy() {
  }
}
MultisampleSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "_multisample"
};
extensions.extensions.add(MultisampleSystem);

exports.MultisampleSystem = MultisampleSystem;
//# sourceMappingURL=MultisampleSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/Attribute.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/Attribute.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");

class Attribute {
  constructor(buffer, size = 0, normalized = false, type = constants.TYPES.FLOAT, stride, start, instance, divisor = 1) {
    this.buffer = buffer;
    this.size = size;
    this.normalized = normalized;
    this.type = type;
    this.stride = stride;
    this.start = start;
    this.instance = instance;
    this.divisor = divisor;
  }
  destroy() {
    this.buffer = null;
  }
  static from(buffer, size, normalized, type, stride) {
    return new Attribute(buffer, size, normalized, type, stride);
  }
}

exports.Attribute = Attribute;
//# sourceMappingURL=Attribute.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/Buffer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/Buffer.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var runner = __webpack_require__(/*! @pixi/runner */ "./node_modules/pixi.js/node_modules/@pixi/runner/lib/index.js");

let UID = 0;
class Buffer {
  constructor(data, _static = true, index = false) {
    this.data = data || new Float32Array(1);
    this._glBuffers = {};
    this._updateID = 0;
    this.index = index;
    this.static = _static;
    this.id = UID++;
    this.disposeRunner = new runner.Runner("disposeBuffer");
  }
  update(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    this.data = data || this.data;
    this._updateID++;
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroy() {
    this.dispose();
    this.data = null;
  }
  set index(value) {
    this.type = value ? constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : constants.BUFFER_TYPE.ARRAY_BUFFER;
  }
  get index() {
    return this.type === constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
  }
  static from(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    return new Buffer(data);
  }
}

exports.Buffer = Buffer;
//# sourceMappingURL=Buffer.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/BufferSystem.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/BufferSystem.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
var GLBuffer = __webpack_require__(/*! ./GLBuffer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/GLBuffer.js");

class BufferSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.managedBuffers = {};
    this.boundBufferBases = {};
  }
  destroy() {
    this.renderer = null;
  }
  contextChange() {
    this.disposeAll(true);
    this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }
  bind(buffer) {
    const { gl, CONTEXT_UID } = this;
    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    gl.bindBuffer(buffer.type, glBuffer.buffer);
  }
  unbind(type) {
    const { gl } = this;
    gl.bindBuffer(type, null);
  }
  bindBufferBase(buffer, index) {
    const { gl, CONTEXT_UID } = this;
    if (this.boundBufferBases[index] !== buffer) {
      const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      this.boundBufferBases[index] = buffer;
      gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
    }
  }
  bindBufferRange(buffer, index, offset) {
    const { gl, CONTEXT_UID } = this;
    offset = offset || 0;
    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);
  }
  update(buffer) {
    const { gl, CONTEXT_UID } = this;
    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    if (buffer._updateID === glBuffer.updateID) {
      return;
    }
    glBuffer.updateID = buffer._updateID;
    gl.bindBuffer(buffer.type, glBuffer.buffer);
    if (glBuffer.byteLength >= buffer.data.byteLength) {
      gl.bufferSubData(buffer.type, 0, buffer.data);
    } else {
      const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
      glBuffer.byteLength = buffer.data.byteLength;
      gl.bufferData(buffer.type, buffer.data, drawType);
    }
  }
  dispose(buffer, contextLost) {
    if (!this.managedBuffers[buffer.id]) {
      return;
    }
    delete this.managedBuffers[buffer.id];
    const glBuffer = buffer._glBuffers[this.CONTEXT_UID];
    const gl = this.gl;
    buffer.disposeRunner.remove(this);
    if (!glBuffer) {
      return;
    }
    if (!contextLost) {
      gl.deleteBuffer(glBuffer.buffer);
    }
    delete buffer._glBuffers[this.CONTEXT_UID];
  }
  disposeAll(contextLost) {
    const all = Object.keys(this.managedBuffers);
    for (let i = 0; i < all.length; i++) {
      this.dispose(this.managedBuffers[all[i]], contextLost);
    }
  }
  createGLBuffer(buffer) {
    const { CONTEXT_UID, gl } = this;
    buffer._glBuffers[CONTEXT_UID] = new GLBuffer.GLBuffer(gl.createBuffer());
    this.managedBuffers[buffer.id] = buffer;
    buffer.disposeRunner.add(this);
    return buffer._glBuffers[CONTEXT_UID];
  }
}
BufferSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "buffer"
};
extensions.extensions.add(BufferSystem);

exports.BufferSystem = BufferSystem;
//# sourceMappingURL=BufferSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/GLBuffer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/GLBuffer.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class GLBuffer {
  constructor(buffer) {
    this.buffer = buffer || null;
    this.updateID = -1;
    this.byteLength = -1;
    this.refCount = 0;
  }
}

exports.GLBuffer = GLBuffer;
//# sourceMappingURL=GLBuffer.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/Geometry.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/Geometry.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var runner = __webpack_require__(/*! @pixi/runner */ "./node_modules/pixi.js/node_modules/@pixi/runner/lib/index.js");
var utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/index.js");
var Attribute = __webpack_require__(/*! ./Attribute.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/Attribute.js");
var Buffer = __webpack_require__(/*! ./Buffer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/Buffer.js");
var interleaveTypedArrays = __webpack_require__(/*! ./utils/interleaveTypedArrays.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/utils/interleaveTypedArrays.js");

const byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
let UID = 0;
const map = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
};
class Geometry {
  constructor(buffers = [], attributes = {}) {
    this.buffers = buffers;
    this.indexBuffer = null;
    this.attributes = attributes;
    this.glVertexArrayObjects = {};
    this.id = UID++;
    this.instanced = false;
    this.instanceCount = 1;
    this.disposeRunner = new runner.Runner("disposeGeometry");
    this.refCount = 0;
  }
  addAttribute(id, buffer, size = 0, normalized = false, type, stride, start, instance = false) {
    if (!buffer) {
      throw new Error("You must pass a buffer when creating an attribute");
    }
    if (!(buffer instanceof Buffer.Buffer)) {
      if (buffer instanceof Array) {
        buffer = new Float32Array(buffer);
      }
      buffer = new Buffer.Buffer(buffer);
    }
    const ids = id.split("|");
    if (ids.length > 1) {
      for (let i = 0; i < ids.length; i++) {
        this.addAttribute(ids[i], buffer, size, normalized, type);
      }
      return this;
    }
    let bufferIndex = this.buffers.indexOf(buffer);
    if (bufferIndex === -1) {
      this.buffers.push(buffer);
      bufferIndex = this.buffers.length - 1;
    }
    this.attributes[id] = new Attribute.Attribute(bufferIndex, size, normalized, type, stride, start, instance);
    this.instanced = this.instanced || instance;
    return this;
  }
  getAttribute(id) {
    return this.attributes[id];
  }
  getBuffer(id) {
    return this.buffers[this.getAttribute(id).buffer];
  }
  addIndex(buffer) {
    if (!(buffer instanceof Buffer.Buffer)) {
      if (buffer instanceof Array) {
        buffer = new Uint16Array(buffer);
      }
      buffer = new Buffer.Buffer(buffer);
    }
    buffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    this.indexBuffer = buffer;
    if (!this.buffers.includes(buffer)) {
      this.buffers.push(buffer);
    }
    return this;
  }
  getIndex() {
    return this.indexBuffer;
  }
  interleave() {
    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
      return this;
    const arrays = [];
    const sizes = [];
    const interleavedBuffer = new Buffer.Buffer();
    let i;
    for (i in this.attributes) {
      const attribute = this.attributes[i];
      const buffer = this.buffers[attribute.buffer];
      arrays.push(buffer.data);
      sizes.push(attribute.size * byteSizeMap[attribute.type] / 4);
      attribute.buffer = 0;
    }
    interleavedBuffer.data = interleaveTypedArrays.interleaveTypedArrays(arrays, sizes);
    for (i = 0; i < this.buffers.length; i++) {
      if (this.buffers[i] !== this.indexBuffer) {
        this.buffers[i].destroy();
      }
    }
    this.buffers = [interleavedBuffer];
    if (this.indexBuffer) {
      this.buffers.push(this.indexBuffer);
    }
    return this;
  }
  getSize() {
    for (const i in this.attributes) {
      const attribute = this.attributes[i];
      const buffer = this.buffers[attribute.buffer];
      return buffer.data.length / (attribute.stride / 4 || attribute.size);
    }
    return 0;
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroy() {
    this.dispose();
    this.buffers = null;
    this.indexBuffer = null;
    this.attributes = null;
  }
  clone() {
    const geometry = new Geometry();
    for (let i = 0; i < this.buffers.length; i++) {
      geometry.buffers[i] = new Buffer.Buffer(this.buffers[i].data.slice(0));
    }
    for (const i in this.attributes) {
      const attrib = this.attributes[i];
      geometry.attributes[i] = new Attribute.Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
    }
    if (this.indexBuffer) {
      geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
      geometry.indexBuffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    }
    return geometry;
  }
  static merge(geometries) {
    const geometryOut = new Geometry();
    const arrays = [];
    const sizes = [];
    const offsets = [];
    let geometry;
    for (let i = 0; i < geometries.length; i++) {
      geometry = geometries[i];
      for (let j = 0; j < geometry.buffers.length; j++) {
        sizes[j] = sizes[j] || 0;
        sizes[j] += geometry.buffers[j].data.length;
        offsets[j] = 0;
      }
    }
    for (let i = 0; i < geometry.buffers.length; i++) {
      arrays[i] = new map[utils.getBufferType(geometry.buffers[i].data)](sizes[i]);
      geometryOut.buffers[i] = new Buffer.Buffer(arrays[i]);
    }
    for (let i = 0; i < geometries.length; i++) {
      geometry = geometries[i];
      for (let j = 0; j < geometry.buffers.length; j++) {
        arrays[j].set(geometry.buffers[j].data, offsets[j]);
        offsets[j] += geometry.buffers[j].data.length;
      }
    }
    geometryOut.attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
      geometryOut.indexBuffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      let offset = 0;
      let stride = 0;
      let offset2 = 0;
      let bufferIndexToCount = 0;
      for (let i = 0; i < geometry.buffers.length; i++) {
        if (geometry.buffers[i] !== geometry.indexBuffer) {
          bufferIndexToCount = i;
          break;
        }
      }
      for (const i in geometry.attributes) {
        const attribute = geometry.attributes[i];
        if ((attribute.buffer | 0) === bufferIndexToCount) {
          stride += attribute.size * byteSizeMap[attribute.type] / 4;
        }
      }
      for (let i = 0; i < geometries.length; i++) {
        const indexBufferData = geometries[i].indexBuffer.data;
        for (let j = 0; j < indexBufferData.length; j++) {
          geometryOut.indexBuffer.data[j + offset2] += offset;
        }
        offset += geometries[i].buffers[bufferIndexToCount].data.length / stride;
        offset2 += indexBufferData.length;
      }
    }
    return geometryOut;
  }
}

exports.Geometry = Geometry;
//# sourceMappingURL=Geometry.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/GeometrySystem.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/GeometrySystem.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");

const byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
class GeometrySystem {
  constructor(renderer) {
    this.renderer = renderer;
    this._activeGeometry = null;
    this._activeVao = null;
    this.hasVao = true;
    this.hasInstance = true;
    this.canUseUInt32ElementIndex = false;
    this.managedGeometries = {};
  }
  contextChange() {
    this.disposeAll(true);
    const gl = this.gl = this.renderer.gl;
    const context = this.renderer.context;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    if (context.webGLVersion !== 2) {
      let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;
      if (settings.settings.PREFER_ENV === constants.ENV.WEBGL_LEGACY) {
        nativeVaoExtension = null;
      }
      if (nativeVaoExtension) {
        gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
        gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
        gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
      } else {
        this.hasVao = false;
        gl.createVertexArray = () => null;
        gl.bindVertexArray = () => null;
        gl.deleteVertexArray = () => null;
      }
    }
    if (context.webGLVersion !== 2) {
      const instanceExt = gl.getExtension("ANGLE_instanced_arrays");
      if (instanceExt) {
        gl.vertexAttribDivisor = (a, b) => instanceExt.vertexAttribDivisorANGLE(a, b);
        gl.drawElementsInstanced = (a, b, c, d, e) => instanceExt.drawElementsInstancedANGLE(a, b, c, d, e);
        gl.drawArraysInstanced = (a, b, c, d) => instanceExt.drawArraysInstancedANGLE(a, b, c, d);
      } else {
        this.hasInstance = false;
      }
    }
    this.canUseUInt32ElementIndex = context.webGLVersion === 2 || !!context.extensions.uint32ElementIndex;
  }
  bind(geometry, shader) {
    shader = shader || this.renderer.shader.shader;
    const { gl } = this;
    let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    let incRefCount = false;
    if (!vaos) {
      this.managedGeometries[geometry.id] = geometry;
      geometry.disposeRunner.add(this);
      geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
      incRefCount = true;
    }
    const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
    this._activeGeometry = geometry;
    if (this._activeVao !== vao) {
      this._activeVao = vao;
      if (this.hasVao) {
        gl.bindVertexArray(vao);
      } else {
        this.activateVao(geometry, shader.program);
      }
    }
    this.updateBuffers();
  }
  reset() {
    this.unbind();
  }
  updateBuffers() {
    const geometry = this._activeGeometry;
    const bufferSystem = this.renderer.buffer;
    for (let i = 0; i < geometry.buffers.length; i++) {
      const buffer = geometry.buffers[i];
      bufferSystem.update(buffer);
    }
  }
  checkCompatibility(geometry, program) {
    const geometryAttributes = geometry.attributes;
    const shaderAttributes = program.attributeData;
    for (const j in shaderAttributes) {
      if (!geometryAttributes[j]) {
        throw new Error(`shader and geometry incompatible, geometry missing the "${j}" attribute`);
      }
    }
  }
  getSignature(geometry, program) {
    const attribs = geometry.attributes;
    const shaderAttributes = program.attributeData;
    const strings = ["g", geometry.id];
    for (const i in attribs) {
      if (shaderAttributes[i]) {
        strings.push(i, shaderAttributes[i].location);
      }
    }
    return strings.join("-");
  }
  initGeometryVao(geometry, shader, incRefCount = true) {
    const gl = this.gl;
    const CONTEXT_UID = this.CONTEXT_UID;
    const bufferSystem = this.renderer.buffer;
    const program = shader.program;
    if (!program.glPrograms[CONTEXT_UID]) {
      this.renderer.shader.generateProgram(shader);
    }
    this.checkCompatibility(geometry, program);
    const signature = this.getSignature(geometry, program);
    const vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    let vao = vaoObjectHash[signature];
    if (vao) {
      vaoObjectHash[program.id] = vao;
      return vao;
    }
    const buffers = geometry.buffers;
    const attributes = geometry.attributes;
    const tempStride = {};
    const tempStart = {};
    for (const j in buffers) {
      tempStride[j] = 0;
      tempStart[j] = 0;
    }
    for (const j in attributes) {
      if (!attributes[j].size && program.attributeData[j]) {
        attributes[j].size = program.attributeData[j].size;
      } else if (!attributes[j].size) {
        console.warn(`PIXI Geometry attribute '${j}' size cannot be determined (likely the bound shader does not have the attribute)`);
      }
      tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap[attributes[j].type];
    }
    for (const j in attributes) {
      const attribute = attributes[j];
      const attribSize = attribute.size;
      if (attribute.stride === void 0) {
        if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type]) {
          attribute.stride = 0;
        } else {
          attribute.stride = tempStride[attribute.buffer];
        }
      }
      if (attribute.start === void 0) {
        attribute.start = tempStart[attribute.buffer];
        tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];
      }
    }
    vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    for (let i = 0; i < buffers.length; i++) {
      const buffer = buffers[i];
      bufferSystem.bind(buffer);
      if (incRefCount) {
        buffer._glBuffers[CONTEXT_UID].refCount++;
      }
    }
    this.activateVao(geometry, program);
    vaoObjectHash[program.id] = vao;
    vaoObjectHash[signature] = vao;
    gl.bindVertexArray(null);
    bufferSystem.unbind(constants.BUFFER_TYPE.ARRAY_BUFFER);
    return vao;
  }
  disposeGeometry(geometry, contextLost) {
    if (!this.managedGeometries[geometry.id]) {
      return;
    }
    delete this.managedGeometries[geometry.id];
    const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    const gl = this.gl;
    const buffers = geometry.buffers;
    const bufferSystem = this.renderer?.buffer;
    geometry.disposeRunner.remove(this);
    if (!vaos) {
      return;
    }
    if (bufferSystem) {
      for (let i = 0; i < buffers.length; i++) {
        const buf = buffers[i]._glBuffers[this.CONTEXT_UID];
        if (buf) {
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            bufferSystem.dispose(buffers[i], contextLost);
          }
        }
      }
    }
    if (!contextLost) {
      for (const vaoId in vaos) {
        if (vaoId[0] === "g") {
          const vao = vaos[vaoId];
          if (this._activeVao === vao) {
            this.unbind();
          }
          gl.deleteVertexArray(vao);
        }
      }
    }
    delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
  }
  disposeAll(contextLost) {
    const all = Object.keys(this.managedGeometries);
    for (let i = 0; i < all.length; i++) {
      this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
    }
  }
  activateVao(geometry, program) {
    const gl = this.gl;
    const CONTEXT_UID = this.CONTEXT_UID;
    const bufferSystem = this.renderer.buffer;
    const buffers = geometry.buffers;
    const attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      bufferSystem.bind(geometry.indexBuffer);
    }
    let lastBuffer = null;
    for (const j in attributes) {
      const attribute = attributes[j];
      const buffer = buffers[attribute.buffer];
      const glBuffer = buffer._glBuffers[CONTEXT_UID];
      if (program.attributeData[j]) {
        if (lastBuffer !== glBuffer) {
          bufferSystem.bind(buffer);
          lastBuffer = glBuffer;
        }
        const location = program.attributeData[j].location;
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
        if (attribute.instance) {
          if (this.hasInstance) {
            gl.vertexAttribDivisor(location, attribute.divisor);
          } else {
            throw new Error("geometry error, GPU Instancing is not supported on this device");
          }
        }
      }
    }
  }
  draw(type, size, start, instanceCount) {
    const { gl } = this;
    const geometry = this._activeGeometry;
    if (geometry.indexBuffer) {
      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
      const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
      if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
        if (geometry.instanced) {
          gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
        } else {
          gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
        }
      } else {
        console.warn("unsupported index buffer type: uint32");
      }
    } else if (geometry.instanced) {
      gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);
    } else {
      gl.drawArrays(type, start, size || geometry.getSize());
    }
    return this;
  }
  unbind() {
    this.gl.bindVertexArray(null);
    this._activeVao = null;
    this._activeGeometry = null;
  }
  destroy() {
    this.renderer = null;
  }
}
GeometrySystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "geometry"
};
extensions.extensions.add(GeometrySystem);

exports.GeometrySystem = GeometrySystem;
//# sourceMappingURL=GeometrySystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/ViewableBuffer.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/ViewableBuffer.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class ViewableBuffer {
  constructor(sizeOrBuffer) {
    if (typeof sizeOrBuffer === "number") {
      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
    } else if (sizeOrBuffer instanceof Uint8Array) {
      this.rawBinaryData = sizeOrBuffer.buffer;
    } else {
      this.rawBinaryData = sizeOrBuffer;
    }
    this.uint32View = new Uint32Array(this.rawBinaryData);
    this.float32View = new Float32Array(this.rawBinaryData);
  }
  get int8View() {
    if (!this._int8View) {
      this._int8View = new Int8Array(this.rawBinaryData);
    }
    return this._int8View;
  }
  get uint8View() {
    if (!this._uint8View) {
      this._uint8View = new Uint8Array(this.rawBinaryData);
    }
    return this._uint8View;
  }
  get int16View() {
    if (!this._int16View) {
      this._int16View = new Int16Array(this.rawBinaryData);
    }
    return this._int16View;
  }
  get uint16View() {
    if (!this._uint16View) {
      this._uint16View = new Uint16Array(this.rawBinaryData);
    }
    return this._uint16View;
  }
  get int32View() {
    if (!this._int32View) {
      this._int32View = new Int32Array(this.rawBinaryData);
    }
    return this._int32View;
  }
  view(type) {
    return this[`${type}View`];
  }
  destroy() {
    this.rawBinaryData = null;
    this._int8View = null;
    this._uint8View = null;
    this._int16View = null;
    this._uint16View = null;
    this._int32View = null;
    this.uint32View = null;
    this.float32View = null;
  }
  static sizeOf(type) {
    switch (type) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(`${type} isn't a valid view type`);
    }
  }
}

exports.ViewableBuffer = ViewableBuffer;
//# sourceMappingURL=ViewableBuffer.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/utils/interleaveTypedArrays.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/utils/interleaveTypedArrays.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/index.js");

const map = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays(arrays, sizes) {
  let outSize = 0;
  let stride = 0;
  const views = {};
  for (let i = 0; i < arrays.length; i++) {
    stride += sizes[i];
    outSize += arrays[i].length;
  }
  const buffer = new ArrayBuffer(outSize * 4);
  let out = null;
  let littleOffset = 0;
  for (let i = 0; i < arrays.length; i++) {
    const size = sizes[i];
    const array = arrays[i];
    const type = utils.getBufferType(array);
    if (!views[type]) {
      views[type] = new map[type](buffer);
    }
    out = views[type];
    for (let j = 0; j < array.length; j++) {
      const indexStart = (j / size | 0) * stride + littleOffset;
      const index = j % size;
      out[indexStart + index] = array[j];
    }
    littleOffset += size;
  }
  return new Float32Array(buffer);
}

exports.interleaveTypedArrays = interleaveTypedArrays;
//# sourceMappingURL=interleaveTypedArrays.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(/*! ./settings.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/settings.js");
var color = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.js");
var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
var math = __webpack_require__(/*! @pixi/math */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/index.js");
var runner = __webpack_require__(/*! @pixi/runner */ "./node_modules/pixi.js/node_modules/@pixi/runner/lib/index.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");
var ticker = __webpack_require__(/*! @pixi/ticker */ "./node_modules/pixi.js/node_modules/@pixi/ticker/lib/index.js");
var utils$1 = __webpack_require__(/*! @pixi/utils */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/index.js");
var autoDetectRenderer = __webpack_require__(/*! ./autoDetectRenderer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/autoDetectRenderer.js");
var BackgroundSystem = __webpack_require__(/*! ./background/BackgroundSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/background/BackgroundSystem.js");
var BatchDrawCall = __webpack_require__(/*! ./batch/BatchDrawCall.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchDrawCall.js");
var BatchGeometry = __webpack_require__(/*! ./batch/BatchGeometry.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchGeometry.js");
var BatchRenderer = __webpack_require__(/*! ./batch/BatchRenderer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchRenderer.js");
var BatchShaderGenerator = __webpack_require__(/*! ./batch/BatchShaderGenerator.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchShaderGenerator.js");
var BatchSystem = __webpack_require__(/*! ./batch/BatchSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchSystem.js");
var BatchTextureArray = __webpack_require__(/*! ./batch/BatchTextureArray.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchTextureArray.js");
var ObjectRenderer = __webpack_require__(/*! ./batch/ObjectRenderer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/ObjectRenderer.js");
var ContextSystem = __webpack_require__(/*! ./context/ContextSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/context/ContextSystem.js");
var Filter = __webpack_require__(/*! ./filters/Filter.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/Filter.js");
var FilterState = __webpack_require__(/*! ./filters/FilterState.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/FilterState.js");
var FilterSystem = __webpack_require__(/*! ./filters/FilterSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/FilterSystem.js");
__webpack_require__(/*! ./filters/IFilterTarget.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/IFilterTarget.js");
var SpriteMaskFilter = __webpack_require__(/*! ./filters/spriteMask/SpriteMaskFilter.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.js");
var index = __webpack_require__(/*! ./fragments/index.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/fragments/index.js");
var Framebuffer = __webpack_require__(/*! ./framebuffer/Framebuffer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/framebuffer/Framebuffer.js");
var FramebufferSystem = __webpack_require__(/*! ./framebuffer/FramebufferSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.js");
var GLFramebuffer = __webpack_require__(/*! ./framebuffer/GLFramebuffer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.js");
var MultisampleSystem = __webpack_require__(/*! ./framebuffer/MultisampleSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/framebuffer/MultisampleSystem.js");
var Attribute = __webpack_require__(/*! ./geometry/Attribute.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/Attribute.js");
var Buffer = __webpack_require__(/*! ./geometry/Buffer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/Buffer.js");
var BufferSystem = __webpack_require__(/*! ./geometry/BufferSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/BufferSystem.js");
var Geometry = __webpack_require__(/*! ./geometry/Geometry.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/Geometry.js");
var GeometrySystem = __webpack_require__(/*! ./geometry/GeometrySystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/GeometrySystem.js");
var ViewableBuffer = __webpack_require__(/*! ./geometry/ViewableBuffer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/ViewableBuffer.js");
__webpack_require__(/*! ./IRenderer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/IRenderer.js");
var MaskData = __webpack_require__(/*! ./mask/MaskData.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/mask/MaskData.js");
var MaskSystem = __webpack_require__(/*! ./mask/MaskSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/mask/MaskSystem.js");
var ScissorSystem = __webpack_require__(/*! ./mask/ScissorSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/mask/ScissorSystem.js");
var StencilSystem = __webpack_require__(/*! ./mask/StencilSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/mask/StencilSystem.js");
var PluginSystem = __webpack_require__(/*! ./plugin/PluginSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/plugin/PluginSystem.js");
var ProjectionSystem = __webpack_require__(/*! ./projection/ProjectionSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/projection/ProjectionSystem.js");
var ObjectRendererSystem = __webpack_require__(/*! ./render/ObjectRendererSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/render/ObjectRendererSystem.js");
var Renderer = __webpack_require__(/*! ./Renderer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/Renderer.js");
var BaseRenderTexture = __webpack_require__(/*! ./renderTexture/BaseRenderTexture.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.js");
var GenerateTextureSystem = __webpack_require__(/*! ./renderTexture/GenerateTextureSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.js");
var RenderTexture = __webpack_require__(/*! ./renderTexture/RenderTexture.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/RenderTexture.js");
var RenderTexturePool = __webpack_require__(/*! ./renderTexture/RenderTexturePool.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.js");
var RenderTextureSystem = __webpack_require__(/*! ./renderTexture/RenderTextureSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.js");
var GLProgram = __webpack_require__(/*! ./shader/GLProgram.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/GLProgram.js");
var Program = __webpack_require__(/*! ./shader/Program.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/Program.js");
var Shader = __webpack_require__(/*! ./shader/Shader.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/Shader.js");
var ShaderSystem = __webpack_require__(/*! ./shader/ShaderSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/ShaderSystem.js");
var UniformGroup = __webpack_require__(/*! ./shader/UniformGroup.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/UniformGroup.js");
var checkMaxIfStatementsInShader = __webpack_require__(/*! ./shader/utils/checkMaxIfStatementsInShader.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.js");
var generateProgram = __webpack_require__(/*! ./shader/utils/generateProgram.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/generateProgram.js");
var generateUniformBufferSync = __webpack_require__(/*! ./shader/utils/generateUniformBufferSync.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.js");
var getTestContext = __webpack_require__(/*! ./shader/utils/getTestContext.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/getTestContext.js");
var uniformParsers = __webpack_require__(/*! ./shader/utils/uniformParsers.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/uniformParsers.js");
var unsafeEvalSupported = __webpack_require__(/*! ./shader/utils/unsafeEvalSupported.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.js");
var StartupSystem = __webpack_require__(/*! ./startup/StartupSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/startup/StartupSystem.js");
var State = __webpack_require__(/*! ./state/State.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/state/State.js");
var StateSystem = __webpack_require__(/*! ./state/StateSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/state/StateSystem.js");
__webpack_require__(/*! ./system/ISystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/system/ISystem.js");
__webpack_require__(/*! ./systems.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/systems.js");
var BaseTexture = __webpack_require__(/*! ./textures/BaseTexture.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/BaseTexture.js");
var GLTexture = __webpack_require__(/*! ./textures/GLTexture.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/GLTexture.js");
__webpack_require__(/*! ./textures/resources/index.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/index.js");
var Texture = __webpack_require__(/*! ./textures/Texture.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/Texture.js");
var TextureGCSystem = __webpack_require__(/*! ./textures/TextureGCSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/TextureGCSystem.js");
var TextureMatrix = __webpack_require__(/*! ./textures/TextureMatrix.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/TextureMatrix.js");
var TextureSystem = __webpack_require__(/*! ./textures/TextureSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/TextureSystem.js");
var TextureUvs = __webpack_require__(/*! ./textures/TextureUvs.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/TextureUvs.js");
var TransformFeedback = __webpack_require__(/*! ./transformFeedback/TransformFeedback.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/transformFeedback/TransformFeedback.js");
var TransformFeedbackSystem = __webpack_require__(/*! ./transformFeedback/TransformFeedbackSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.js");
var Quad = __webpack_require__(/*! ./utils/Quad.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/utils/Quad.js");
var QuadUv = __webpack_require__(/*! ./utils/QuadUv.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/utils/QuadUv.js");
var ViewSystem = __webpack_require__(/*! ./view/ViewSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/view/ViewSystem.js");
var SystemManager = __webpack_require__(/*! ./system/SystemManager.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/system/SystemManager.js");
var BaseImageResource = __webpack_require__(/*! ./textures/resources/BaseImageResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js");
var Resource = __webpack_require__(/*! ./textures/resources/Resource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/Resource.js");
var AbstractMultiResource = __webpack_require__(/*! ./textures/resources/AbstractMultiResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.js");
var ArrayResource = __webpack_require__(/*! ./textures/resources/ArrayResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/ArrayResource.js");
var autoDetectResource = __webpack_require__(/*! ./textures/resources/autoDetectResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/autoDetectResource.js");
var BufferResource = __webpack_require__(/*! ./textures/resources/BufferResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/BufferResource.js");
var CanvasResource = __webpack_require__(/*! ./textures/resources/CanvasResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/CanvasResource.js");
var CubeResource = __webpack_require__(/*! ./textures/resources/CubeResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/CubeResource.js");
var ImageBitmapResource = __webpack_require__(/*! ./textures/resources/ImageBitmapResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.js");
var ImageResource = __webpack_require__(/*! ./textures/resources/ImageResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/ImageResource.js");
var SVGResource = __webpack_require__(/*! ./textures/resources/SVGResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/SVGResource.js");
var VideoResource = __webpack_require__(/*! ./textures/resources/VideoResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/VideoResource.js");

function _interopNamespace(e) {
	if (e && e.__esModule) return e;
	var n = Object.create(null);
	if (e) {
		Object.keys(e).forEach(function (k) {
			if (k !== 'default') {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		});
	}
	n["default"] = e;
	return n;
}

var utils__namespace = /*#__PURE__*/_interopNamespace(utils$1);

const VERSION = "7.2.4";

exports.utils = utils__namespace;
exports.autoDetectRenderer = autoDetectRenderer.autoDetectRenderer;
exports.BackgroundSystem = BackgroundSystem.BackgroundSystem;
exports.BatchDrawCall = BatchDrawCall.BatchDrawCall;
exports.BatchGeometry = BatchGeometry.BatchGeometry;
exports.BatchRenderer = BatchRenderer.BatchRenderer;
exports.BatchShaderGenerator = BatchShaderGenerator.BatchShaderGenerator;
exports.BatchSystem = BatchSystem.BatchSystem;
exports.BatchTextureArray = BatchTextureArray.BatchTextureArray;
exports.ObjectRenderer = ObjectRenderer.ObjectRenderer;
exports.ContextSystem = ContextSystem.ContextSystem;
exports.Filter = Filter.Filter;
exports.FilterState = FilterState.FilterState;
exports.FilterSystem = FilterSystem.FilterSystem;
exports.SpriteMaskFilter = SpriteMaskFilter.SpriteMaskFilter;
exports.defaultFilterVertex = index.defaultFilterVertex;
exports.defaultVertex = index.defaultVertex;
exports.Framebuffer = Framebuffer.Framebuffer;
exports.FramebufferSystem = FramebufferSystem.FramebufferSystem;
exports.GLFramebuffer = GLFramebuffer.GLFramebuffer;
exports.MultisampleSystem = MultisampleSystem.MultisampleSystem;
exports.Attribute = Attribute.Attribute;
exports.Buffer = Buffer.Buffer;
exports.BufferSystem = BufferSystem.BufferSystem;
exports.Geometry = Geometry.Geometry;
exports.GeometrySystem = GeometrySystem.GeometrySystem;
exports.ViewableBuffer = ViewableBuffer.ViewableBuffer;
exports.MaskData = MaskData.MaskData;
exports.MaskSystem = MaskSystem.MaskSystem;
exports.ScissorSystem = ScissorSystem.ScissorSystem;
exports.StencilSystem = StencilSystem.StencilSystem;
exports.PluginSystem = PluginSystem.PluginSystem;
exports.ProjectionSystem = ProjectionSystem.ProjectionSystem;
exports.ObjectRendererSystem = ObjectRendererSystem.ObjectRendererSystem;
exports.Renderer = Renderer.Renderer;
exports.BaseRenderTexture = BaseRenderTexture.BaseRenderTexture;
exports.GenerateTextureSystem = GenerateTextureSystem.GenerateTextureSystem;
exports.RenderTexture = RenderTexture.RenderTexture;
exports.RenderTexturePool = RenderTexturePool.RenderTexturePool;
exports.RenderTextureSystem = RenderTextureSystem.RenderTextureSystem;
exports.GLProgram = GLProgram.GLProgram;
exports.IGLUniformData = GLProgram.IGLUniformData;
exports.Program = Program.Program;
exports.Shader = Shader.Shader;
exports.ShaderSystem = ShaderSystem.ShaderSystem;
exports.UniformGroup = UniformGroup.UniformGroup;
exports.checkMaxIfStatementsInShader = checkMaxIfStatementsInShader.checkMaxIfStatementsInShader;
exports.generateProgram = generateProgram.generateProgram;
exports.createUBOElements = generateUniformBufferSync.createUBOElements;
exports.generateUniformBufferSync = generateUniformBufferSync.generateUniformBufferSync;
exports.getUBOData = generateUniformBufferSync.getUBOData;
exports.getTestContext = getTestContext.getTestContext;
exports.uniformParsers = uniformParsers.uniformParsers;
exports.unsafeEvalSupported = unsafeEvalSupported.unsafeEvalSupported;
exports.StartupSystem = StartupSystem.StartupSystem;
exports.State = State.State;
exports.StateSystem = StateSystem.StateSystem;
exports.BaseTexture = BaseTexture.BaseTexture;
exports.GLTexture = GLTexture.GLTexture;
exports.Texture = Texture.Texture;
exports.TextureGCSystem = TextureGCSystem.TextureGCSystem;
exports.TextureMatrix = TextureMatrix.TextureMatrix;
exports.TextureSystem = TextureSystem.TextureSystem;
exports.TextureUvs = TextureUvs.TextureUvs;
exports.TransformFeedback = TransformFeedback.TransformFeedback;
exports.TransformFeedbackSystem = TransformFeedbackSystem.TransformFeedbackSystem;
exports.Quad = Quad.Quad;
exports.QuadUv = QuadUv.QuadUv;
exports.ViewSystem = ViewSystem.ViewSystem;
exports.SystemManager = SystemManager.SystemManager;
exports.BaseImageResource = BaseImageResource.BaseImageResource;
exports.Resource = Resource.Resource;
exports.AbstractMultiResource = AbstractMultiResource.AbstractMultiResource;
exports.ArrayResource = ArrayResource.ArrayResource;
exports.INSTALLED = autoDetectResource.INSTALLED;
exports.autoDetectResource = autoDetectResource.autoDetectResource;
exports.BufferResource = BufferResource.BufferResource;
exports.CanvasResource = CanvasResource.CanvasResource;
exports.CubeResource = CubeResource.CubeResource;
exports.ImageBitmapResource = ImageBitmapResource.ImageBitmapResource;
exports.ImageResource = ImageResource.ImageResource;
exports.SVGResource = SVGResource.SVGResource;
exports.VideoResource = VideoResource.VideoResource;
exports.VERSION = VERSION;
Object.keys(color).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return color[k]; }
	});
});
Object.keys(constants).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return constants[k]; }
	});
});
Object.keys(extensions).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return extensions[k]; }
	});
});
Object.keys(math).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return math[k]; }
	});
});
Object.keys(runner).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return runner[k]; }
	});
});
Object.keys(settings).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return settings[k]; }
	});
});
Object.keys(ticker).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return ticker[k]; }
	});
});
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/mask/AbstractMaskSystem.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/mask/AbstractMaskSystem.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class AbstractMaskSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.maskStack = [];
    this.glConst = 0;
  }
  getStackLength() {
    return this.maskStack.length;
  }
  setMaskStack(maskStack) {
    const { gl } = this.renderer;
    const curStackLen = this.getStackLength();
    this.maskStack = maskStack;
    const newStackLen = this.getStackLength();
    if (newStackLen !== curStackLen) {
      if (newStackLen === 0) {
        gl.disable(this.glConst);
      } else {
        gl.enable(this.glConst);
        this._useCurrent();
      }
    }
  }
  _useCurrent() {
  }
  destroy() {
    this.renderer = null;
    this.maskStack = null;
  }
}

exports.AbstractMaskSystem = AbstractMaskSystem;
//# sourceMappingURL=AbstractMaskSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/mask/MaskData.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/mask/MaskData.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var Filter = __webpack_require__(/*! ../filters/Filter.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/Filter.js");

class MaskData {
  constructor(maskObject = null) {
    this.type = constants.MASK_TYPES.NONE;
    this.autoDetect = true;
    this.maskObject = maskObject || null;
    this.pooled = false;
    this.isMaskData = true;
    this.resolution = null;
    this.multisample = Filter.Filter.defaultMultisample;
    this.enabled = true;
    this.colorMask = 15;
    this._filters = null;
    this._stencilCounter = 0;
    this._scissorCounter = 0;
    this._scissorRect = null;
    this._scissorRectLocal = null;
    this._colorMask = 15;
    this._target = null;
  }
  get filter() {
    return this._filters ? this._filters[0] : null;
  }
  set filter(value) {
    if (value) {
      if (this._filters) {
        this._filters[0] = value;
      } else {
        this._filters = [value];
      }
    } else {
      this._filters = null;
    }
  }
  reset() {
    if (this.pooled) {
      this.maskObject = null;
      this.type = constants.MASK_TYPES.NONE;
      this.autoDetect = true;
    }
    this._target = null;
    this._scissorRectLocal = null;
  }
  copyCountersOrReset(maskAbove) {
    if (maskAbove) {
      this._stencilCounter = maskAbove._stencilCounter;
      this._scissorCounter = maskAbove._scissorCounter;
      this._scissorRect = maskAbove._scissorRect;
    } else {
      this._stencilCounter = 0;
      this._scissorCounter = 0;
      this._scissorRect = null;
    }
  }
}

exports.MaskData = MaskData;
//# sourceMappingURL=MaskData.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/mask/MaskSystem.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/mask/MaskSystem.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
var SpriteMaskFilter = __webpack_require__(/*! ../filters/spriteMask/SpriteMaskFilter.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.js");
var MaskData = __webpack_require__(/*! ./MaskData.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/mask/MaskData.js");

class MaskSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.enableScissor = true;
    this.alphaMaskPool = [];
    this.maskDataPool = [];
    this.maskStack = [];
    this.alphaMaskIndex = 0;
  }
  setMaskStack(maskStack) {
    this.maskStack = maskStack;
    this.renderer.scissor.setMaskStack(maskStack);
    this.renderer.stencil.setMaskStack(maskStack);
  }
  push(target, maskDataOrTarget) {
    let maskData = maskDataOrTarget;
    if (!maskData.isMaskData) {
      const d = this.maskDataPool.pop() || new MaskData.MaskData();
      d.pooled = true;
      d.maskObject = maskDataOrTarget;
      maskData = d;
    }
    const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
    maskData.copyCountersOrReset(maskAbove);
    maskData._colorMask = maskAbove ? maskAbove._colorMask : 15;
    if (maskData.autoDetect) {
      this.detect(maskData);
    }
    maskData._target = target;
    if (maskData.type !== constants.MASK_TYPES.SPRITE) {
      this.maskStack.push(maskData);
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case constants.MASK_TYPES.SCISSOR:
          this.renderer.scissor.push(maskData);
          break;
        case constants.MASK_TYPES.STENCIL:
          this.renderer.stencil.push(maskData);
          break;
        case constants.MASK_TYPES.SPRITE:
          maskData.copyCountersOrReset(null);
          this.pushSpriteMask(maskData);
          break;
        case constants.MASK_TYPES.COLOR:
          this.pushColorMask(maskData);
          break;
        default:
          break;
      }
    }
    if (maskData.type === constants.MASK_TYPES.SPRITE) {
      this.maskStack.push(maskData);
    }
  }
  pop(target) {
    const maskData = this.maskStack.pop();
    if (!maskData || maskData._target !== target) {
      return;
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case constants.MASK_TYPES.SCISSOR:
          this.renderer.scissor.pop(maskData);
          break;
        case constants.MASK_TYPES.STENCIL:
          this.renderer.stencil.pop(maskData.maskObject);
          break;
        case constants.MASK_TYPES.SPRITE:
          this.popSpriteMask(maskData);
          break;
        case constants.MASK_TYPES.COLOR:
          this.popColorMask(maskData);
          break;
        default:
          break;
      }
    }
    maskData.reset();
    if (maskData.pooled) {
      this.maskDataPool.push(maskData);
    }
    if (this.maskStack.length !== 0) {
      const maskCurrent = this.maskStack[this.maskStack.length - 1];
      if (maskCurrent.type === constants.MASK_TYPES.SPRITE && maskCurrent._filters) {
        maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;
      }
    }
  }
  detect(maskData) {
    const maskObject = maskData.maskObject;
    if (!maskObject) {
      maskData.type = constants.MASK_TYPES.COLOR;
    } else if (maskObject.isSprite) {
      maskData.type = constants.MASK_TYPES.SPRITE;
    } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {
      maskData.type = constants.MASK_TYPES.SCISSOR;
    } else {
      maskData.type = constants.MASK_TYPES.STENCIL;
    }
  }
  pushSpriteMask(maskData) {
    const { maskObject } = maskData;
    const target = maskData._target;
    let alphaMaskFilter = maskData._filters;
    if (!alphaMaskFilter) {
      alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
      if (!alphaMaskFilter) {
        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter.SpriteMaskFilter()];
      }
    }
    const renderer = this.renderer;
    const renderTextureSystem = renderer.renderTexture;
    let resolution;
    let multisample;
    if (renderTextureSystem.current) {
      const renderTexture = renderTextureSystem.current;
      resolution = maskData.resolution || renderTexture.resolution;
      multisample = maskData.multisample ?? renderTexture.multisample;
    } else {
      resolution = maskData.resolution || renderer.resolution;
      multisample = maskData.multisample ?? renderer.multisample;
    }
    alphaMaskFilter[0].resolution = resolution;
    alphaMaskFilter[0].multisample = multisample;
    alphaMaskFilter[0].maskSprite = maskObject;
    const stashFilterArea = target.filterArea;
    target.filterArea = maskObject.getBounds(true);
    renderer.filter.push(target, alphaMaskFilter);
    target.filterArea = stashFilterArea;
    if (!maskData._filters) {
      this.alphaMaskIndex++;
    }
  }
  popSpriteMask(maskData) {
    this.renderer.filter.pop();
    if (maskData._filters) {
      maskData._filters[0].maskSprite = null;
    } else {
      this.alphaMaskIndex--;
      this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;
    }
  }
  pushColorMask(maskData) {
    const currColorMask = maskData._colorMask;
    const nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;
    if (nextColorMask !== currColorMask) {
      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
    }
  }
  popColorMask(maskData) {
    const currColorMask = maskData._colorMask;
    const nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
    if (nextColorMask !== currColorMask) {
      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
    }
  }
  destroy() {
    this.renderer = null;
  }
}
MaskSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "mask"
};
extensions.extensions.add(MaskSystem);

exports.MaskSystem = MaskSystem;
//# sourceMappingURL=MaskSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/mask/ScissorSystem.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/mask/ScissorSystem.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
var math = __webpack_require__(/*! @pixi/math */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/index.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");
var AbstractMaskSystem = __webpack_require__(/*! ./AbstractMaskSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/mask/AbstractMaskSystem.js");

const tempMatrix = new math.Matrix();
const rectPool = [];
const _ScissorSystem = class extends AbstractMaskSystem.AbstractMaskSystem {
  constructor(renderer) {
    super(renderer);
    this.glConst = settings.settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;
  }
  getStackLength() {
    const maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._scissorCounter;
    }
    return 0;
  }
  calcScissorRect(maskData) {
    if (maskData._scissorRectLocal) {
      return;
    }
    const prevData = maskData._scissorRect;
    const { maskObject } = maskData;
    const { renderer } = this;
    const renderTextureSystem = renderer.renderTexture;
    const rect = maskObject.getBounds(true, rectPool.pop() ?? new math.Rectangle());
    this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
    if (prevData) {
      rect.fit(prevData);
    }
    maskData._scissorRectLocal = rect;
  }
  static isMatrixRotated(matrix) {
    if (!matrix) {
      return false;
    }
    const { a, b, c, d } = matrix;
    return (Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4);
  }
  testScissor(maskData) {
    const { maskObject } = maskData;
    if (!maskObject.isFastRect || !maskObject.isFastRect()) {
      return false;
    }
    if (_ScissorSystem.isMatrixRotated(maskObject.worldTransform)) {
      return false;
    }
    if (_ScissorSystem.isMatrixRotated(this.renderer.projection.transform)) {
      return false;
    }
    this.calcScissorRect(maskData);
    const rect = maskData._scissorRectLocal;
    return rect.width > 0 && rect.height > 0;
  }
  roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (_ScissorSystem.isMatrixRotated(transform)) {
      return;
    }
    transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.renderer.filter.transformAABB(transform, frame);
    frame.fit(bindingDestinationFrame);
    frame.x = Math.round(frame.x * resolution);
    frame.y = Math.round(frame.y * resolution);
    frame.width = Math.round(frame.width * resolution);
    frame.height = Math.round(frame.height * resolution);
  }
  push(maskData) {
    if (!maskData._scissorRectLocal) {
      this.calcScissorRect(maskData);
    }
    const { gl } = this.renderer;
    if (!maskData._scissorRect) {
      gl.enable(gl.SCISSOR_TEST);
    }
    maskData._scissorCounter++;
    maskData._scissorRect = maskData._scissorRectLocal;
    this._useCurrent();
  }
  pop(maskData) {
    const { gl } = this.renderer;
    if (maskData) {
      rectPool.push(maskData._scissorRectLocal);
    }
    if (this.getStackLength() > 0) {
      this._useCurrent();
    } else {
      gl.disable(gl.SCISSOR_TEST);
    }
  }
  _useCurrent() {
    const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
    let y;
    if (this.renderer.renderTexture.current) {
      y = rect.y;
    } else {
      y = this.renderer.height - rect.height - rect.y;
    }
    this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);
  }
};
let ScissorSystem = _ScissorSystem;
ScissorSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "scissor"
};
extensions.extensions.add(ScissorSystem);

exports.ScissorSystem = ScissorSystem;
//# sourceMappingURL=ScissorSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/mask/StencilSystem.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/mask/StencilSystem.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");
var AbstractMaskSystem = __webpack_require__(/*! ./AbstractMaskSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/mask/AbstractMaskSystem.js");

class StencilSystem extends AbstractMaskSystem.AbstractMaskSystem {
  constructor(renderer) {
    super(renderer);
    this.glConst = settings.settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;
  }
  getStackLength() {
    const maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._stencilCounter;
    }
    return 0;
  }
  push(maskData) {
    const maskObject = maskData.maskObject;
    const { gl } = this.renderer;
    const prevMaskCount = maskData._stencilCounter;
    if (prevMaskCount === 0) {
      this.renderer.framebuffer.forceStencil();
      gl.clearStencil(0);
      gl.clear(gl.STENCIL_BUFFER_BIT);
      gl.enable(gl.STENCIL_TEST);
    }
    maskData._stencilCounter++;
    const colorMask = maskData._colorMask;
    if (colorMask !== 0) {
      maskData._colorMask = 0;
      gl.colorMask(false, false, false, false);
    }
    gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
    maskObject.renderable = true;
    maskObject.render(this.renderer);
    this.renderer.batch.flush();
    maskObject.renderable = false;
    if (colorMask !== 0) {
      maskData._colorMask = colorMask;
      gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
    }
    this._useCurrent();
  }
  pop(maskObject) {
    const gl = this.renderer.gl;
    if (this.getStackLength() === 0) {
      gl.disable(gl.STENCIL_TEST);
    } else {
      const maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      const colorMask = maskData ? maskData._colorMask : 15;
      if (colorMask !== 0) {
        maskData._colorMask = 0;
        gl.colorMask(false, false, false, false);
      }
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
      maskObject.renderable = true;
      maskObject.render(this.renderer);
      this.renderer.batch.flush();
      maskObject.renderable = false;
      if (colorMask !== 0) {
        maskData._colorMask = colorMask;
        gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
      }
      this._useCurrent();
    }
  }
  _useCurrent() {
    const gl = this.renderer.gl;
    gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
  }
}
StencilSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "stencil"
};
extensions.extensions.add(StencilSystem);

exports.StencilSystem = StencilSystem;
//# sourceMappingURL=StencilSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/plugin/PluginSystem.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/plugin/PluginSystem.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
var utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/index.js");

class PluginSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.plugins = {};
    Object.defineProperties(this.plugins, {
      extract: {
        enumerable: false,
        get() {
          utils.deprecation("7.0.0", "renderer.plugins.extract has moved to renderer.extract");
          return renderer.extract;
        }
      },
      prepare: {
        enumerable: false,
        get() {
          utils.deprecation("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare");
          return renderer.prepare;
        }
      },
      interaction: {
        enumerable: false,
        get() {
          utils.deprecation("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events");
          return renderer.events;
        }
      }
    });
  }
  init() {
    const staticMap = this.rendererPlugins;
    for (const o in staticMap) {
      this.plugins[o] = new staticMap[o](this.renderer);
    }
  }
  destroy() {
    for (const o in this.plugins) {
      this.plugins[o].destroy();
      this.plugins[o] = null;
    }
  }
}
PluginSystem.extension = {
  type: [
    extensions.ExtensionType.RendererSystem,
    extensions.ExtensionType.CanvasRendererSystem
  ],
  name: "_plugin"
};
extensions.extensions.add(PluginSystem);

exports.PluginSystem = PluginSystem;
//# sourceMappingURL=PluginSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/projection/ProjectionSystem.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/projection/ProjectionSystem.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
var math = __webpack_require__(/*! @pixi/math */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/index.js");

class ProjectionSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.destinationFrame = null;
    this.sourceFrame = null;
    this.defaultFrame = null;
    this.projectionMatrix = new math.Matrix();
    this.transform = null;
  }
  update(destinationFrame, sourceFrame, resolution, root) {
    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
    this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
    this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);
    if (this.transform) {
      this.projectionMatrix.append(this.transform);
    }
    const renderer = this.renderer;
    renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
    renderer.globalUniforms.update();
    if (renderer.shader.shader) {
      renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
    }
  }
  calculateProjection(_destinationFrame, sourceFrame, _resolution, root) {
    const pm = this.projectionMatrix;
    const sign = !root ? 1 : -1;
    pm.identity();
    pm.a = 1 / sourceFrame.width * 2;
    pm.d = sign * (1 / sourceFrame.height * 2);
    pm.tx = -1 - sourceFrame.x * pm.a;
    pm.ty = -sign - sourceFrame.y * pm.d;
  }
  setTransform(_matrix) {
  }
  destroy() {
    this.renderer = null;
  }
}
ProjectionSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "projection"
};
extensions.extensions.add(ProjectionSystem);

exports.ProjectionSystem = ProjectionSystem;
//# sourceMappingURL=ProjectionSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var color = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.js");
var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var Framebuffer = __webpack_require__(/*! ../framebuffer/Framebuffer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/framebuffer/Framebuffer.js");
var BaseTexture = __webpack_require__(/*! ../textures/BaseTexture.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/BaseTexture.js");

class BaseRenderTexture extends BaseTexture.BaseTexture {
  constructor(options = {}) {
    if (typeof options === "number") {
      const width = arguments[0];
      const height = arguments[1];
      const scaleMode = arguments[2];
      const resolution = arguments[3];
      options = { width, height, scaleMode, resolution };
    }
    options.width = options.width || 100;
    options.height = options.height || 100;
    options.multisample ?? (options.multisample = constants.MSAA_QUALITY.NONE);
    super(null, options);
    this.mipmap = constants.MIPMAP_MODES.OFF;
    this.valid = true;
    this._clear = new color.Color([0, 0, 0, 0]);
    this.framebuffer = new Framebuffer.Framebuffer(this.realWidth, this.realHeight).addColorTexture(0, this);
    this.framebuffer.multisample = options.multisample;
    this.maskStack = [];
    this.filterStack = [{}];
  }
  set clearColor(value) {
    this._clear.setValue(value);
  }
  get clearColor() {
    return this._clear.value;
  }
  get clear() {
    return this._clear;
  }
  resize(desiredWidth, desiredHeight) {
    this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution);
    this.setRealSize(this.framebuffer.width, this.framebuffer.height);
  }
  dispose() {
    this.framebuffer.dispose();
    super.dispose();
  }
  destroy() {
    super.destroy();
    this.framebuffer.destroyDepthTexture();
    this.framebuffer = null;
  }
}

exports.BaseRenderTexture = BaseRenderTexture;
//# sourceMappingURL=BaseRenderTexture.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
var math = __webpack_require__(/*! @pixi/math */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/index.js");
var RenderTexture = __webpack_require__(/*! ./RenderTexture.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/RenderTexture.js");

const tempTransform = new math.Transform();
class GenerateTextureSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this._tempMatrix = new math.Matrix();
  }
  generateTexture(displayObject, options) {
    const { region: manualRegion, ...textureOptions } = options || {};
    const region = manualRegion || displayObject.getLocalBounds(null, true);
    if (region.width === 0)
      region.width = 1;
    if (region.height === 0)
      region.height = 1;
    const renderTexture = RenderTexture.RenderTexture.create({
      width: region.width,
      height: region.height,
      ...textureOptions
    });
    this._tempMatrix.tx = -region.x;
    this._tempMatrix.ty = -region.y;
    const transform = displayObject.transform;
    displayObject.transform = tempTransform;
    this.renderer.render(displayObject, {
      renderTexture,
      transform: this._tempMatrix,
      skipUpdateTransform: !!displayObject.parent,
      blit: true
    });
    displayObject.transform = transform;
    return renderTexture;
  }
  destroy() {
  }
}
GenerateTextureSystem.extension = {
  type: [
    extensions.ExtensionType.RendererSystem,
    extensions.ExtensionType.CanvasRendererSystem
  ],
  name: "textureGenerator"
};
extensions.extensions.add(GenerateTextureSystem);

exports.GenerateTextureSystem = GenerateTextureSystem;
//# sourceMappingURL=GenerateTextureSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/RenderTexture.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/RenderTexture.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Texture = __webpack_require__(/*! ../textures/Texture.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/Texture.js");
var BaseRenderTexture = __webpack_require__(/*! ./BaseRenderTexture.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.js");

class RenderTexture extends Texture.Texture {
  constructor(baseRenderTexture, frame) {
    super(baseRenderTexture, frame);
    this.valid = true;
    this.filterFrame = null;
    this.filterPoolKey = null;
    this.updateUvs();
  }
  get framebuffer() {
    return this.baseTexture.framebuffer;
  }
  get multisample() {
    return this.framebuffer.multisample;
  }
  set multisample(value) {
    this.framebuffer.multisample = value;
  }
  resize(desiredWidth, desiredHeight, resizeBaseTexture = true) {
    const resolution = this.baseTexture.resolution;
    const width = Math.round(desiredWidth * resolution) / resolution;
    const height = Math.round(desiredHeight * resolution) / resolution;
    this.valid = width > 0 && height > 0;
    this._frame.width = this.orig.width = width;
    this._frame.height = this.orig.height = height;
    if (resizeBaseTexture) {
      this.baseTexture.resize(width, height);
    }
    this.updateUvs();
  }
  setResolution(resolution) {
    const { baseTexture } = this;
    if (baseTexture.resolution === resolution) {
      return;
    }
    baseTexture.setResolution(resolution);
    this.resize(baseTexture.width, baseTexture.height, false);
  }
  static create(options) {
    return new RenderTexture(new BaseRenderTexture.BaseRenderTexture(options));
  }
}

exports.RenderTexture = RenderTexture;
//# sourceMappingURL=RenderTexture.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/index.js");
var BaseRenderTexture = __webpack_require__(/*! ./BaseRenderTexture.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.js");
var RenderTexture = __webpack_require__(/*! ./RenderTexture.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/RenderTexture.js");

class RenderTexturePool {
  constructor(textureOptions) {
    this.texturePool = {};
    this.textureOptions = textureOptions || {};
    this.enableFullScreen = false;
    this._pixelsWidth = 0;
    this._pixelsHeight = 0;
  }
  createTexture(realWidth, realHeight, multisample = constants.MSAA_QUALITY.NONE) {
    const baseRenderTexture = new BaseRenderTexture.BaseRenderTexture(Object.assign({
      width: realWidth,
      height: realHeight,
      resolution: 1,
      multisample
    }, this.textureOptions));
    return new RenderTexture.RenderTexture(baseRenderTexture);
  }
  getOptimalTexture(minWidth, minHeight, resolution = 1, multisample = constants.MSAA_QUALITY.NONE) {
    let key;
    minWidth = Math.ceil(minWidth * resolution - 1e-6);
    minHeight = Math.ceil(minHeight * resolution - 1e-6);
    if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
      minWidth = utils.nextPow2(minWidth);
      minHeight = utils.nextPow2(minHeight);
      key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;
      if (multisample > 1) {
        key += multisample * 4294967296;
      }
    } else {
      key = multisample > 1 ? -multisample : -1;
    }
    if (!this.texturePool[key]) {
      this.texturePool[key] = [];
    }
    let renderTexture = this.texturePool[key].pop();
    if (!renderTexture) {
      renderTexture = this.createTexture(minWidth, minHeight, multisample);
    }
    renderTexture.filterPoolKey = key;
    renderTexture.setResolution(resolution);
    return renderTexture;
  }
  getFilterTexture(input, resolution, multisample) {
    const filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || constants.MSAA_QUALITY.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  }
  returnTexture(renderTexture) {
    const key = renderTexture.filterPoolKey;
    renderTexture.filterFrame = null;
    this.texturePool[key].push(renderTexture);
  }
  returnFilterTexture(renderTexture) {
    this.returnTexture(renderTexture);
  }
  clear(destroyTextures) {
    destroyTextures = destroyTextures !== false;
    if (destroyTextures) {
      for (const i in this.texturePool) {
        const textures = this.texturePool[i];
        if (textures) {
          for (let j = 0; j < textures.length; j++) {
            textures[j].destroy(true);
          }
        }
      }
    }
    this.texturePool = {};
  }
  setScreenSize(size) {
    if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {
      return;
    }
    this.enableFullScreen = size.width > 0 && size.height > 0;
    for (const i in this.texturePool) {
      if (!(Number(i) < 0)) {
        continue;
      }
      const textures = this.texturePool[i];
      if (textures) {
        for (let j = 0; j < textures.length; j++) {
          textures[j].destroy(true);
        }
      }
      this.texturePool[i] = [];
    }
    this._pixelsWidth = size.width;
    this._pixelsHeight = size.height;
  }
}
RenderTexturePool.SCREEN_KEY = -1;

exports.RenderTexturePool = RenderTexturePool;
//# sourceMappingURL=RenderTexturePool.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var color = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.js");
var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
var math = __webpack_require__(/*! @pixi/math */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/index.js");

const tempRect = new math.Rectangle();
const tempRect2 = new math.Rectangle();
class RenderTextureSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.defaultMaskStack = [];
    this.current = null;
    this.sourceFrame = new math.Rectangle();
    this.destinationFrame = new math.Rectangle();
    this.viewportFrame = new math.Rectangle();
  }
  contextChange() {
    const attributes = this.renderer?.gl.getContextAttributes();
    this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);
  }
  bind(renderTexture = null, sourceFrame, destinationFrame) {
    const renderer = this.renderer;
    this.current = renderTexture;
    let baseTexture;
    let framebuffer;
    let resolution;
    if (renderTexture) {
      baseTexture = renderTexture.baseTexture;
      resolution = baseTexture.resolution;
      if (!sourceFrame) {
        tempRect.width = renderTexture.frame.width;
        tempRect.height = renderTexture.frame.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        tempRect2.x = renderTexture.frame.x;
        tempRect2.y = renderTexture.frame.y;
        tempRect2.width = sourceFrame.width;
        tempRect2.height = sourceFrame.height;
        destinationFrame = tempRect2;
      }
      framebuffer = baseTexture.framebuffer;
    } else {
      resolution = renderer.resolution;
      if (!sourceFrame) {
        tempRect.width = renderer._view.screen.width;
        tempRect.height = renderer._view.screen.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        destinationFrame = tempRect;
        destinationFrame.width = sourceFrame.width;
        destinationFrame.height = sourceFrame.height;
      }
    }
    const viewportFrame = this.viewportFrame;
    viewportFrame.x = destinationFrame.x * resolution;
    viewportFrame.y = destinationFrame.y * resolution;
    viewportFrame.width = destinationFrame.width * resolution;
    viewportFrame.height = destinationFrame.height * resolution;
    if (!renderTexture) {
      viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);
    }
    viewportFrame.ceil();
    this.renderer.framebuffer.bind(framebuffer, viewportFrame);
    this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
    if (renderTexture) {
      this.renderer.mask.setMaskStack(baseTexture.maskStack);
    } else {
      this.renderer.mask.setMaskStack(this.defaultMaskStack);
    }
    this.sourceFrame.copyFrom(sourceFrame);
    this.destinationFrame.copyFrom(destinationFrame);
  }
  clear(clearColor, mask) {
    const fallbackColor = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor;
    const color$1 = color.Color.shared.setValue(clearColor ? clearColor : fallbackColor);
    if (this.current && this.current.baseTexture.alphaMode > 0 || !this.current && this._rendererPremultipliedAlpha) {
      color$1.premultiply(color$1.alpha);
    }
    const destinationFrame = this.destinationFrame;
    const baseFrame = this.current ? this.current.baseTexture : this.renderer._view.screen;
    const clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
    if (clearMask) {
      let { x, y, width, height } = this.viewportFrame;
      x = Math.round(x);
      y = Math.round(y);
      width = Math.round(width);
      height = Math.round(height);
      this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
      this.renderer.gl.scissor(x, y, width, height);
    }
    this.renderer.framebuffer.clear(color$1.red, color$1.green, color$1.blue, color$1.alpha, mask);
    if (clearMask) {
      this.renderer.scissor.pop();
    }
  }
  resize() {
    this.bind(null);
  }
  reset() {
    this.bind(null);
  }
  destroy() {
    this.renderer = null;
  }
}
RenderTextureSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "renderTexture"
};
extensions.extensions.add(RenderTextureSystem);

exports.RenderTextureSystem = RenderTextureSystem;
//# sourceMappingURL=RenderTextureSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/render/ObjectRendererSystem.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/render/ObjectRendererSystem.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");

class ObjectRendererSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  render(displayObject, options) {
    const renderer = this.renderer;
    let renderTexture;
    let clear;
    let transform;
    let skipUpdateTransform;
    if (options) {
      renderTexture = options.renderTexture;
      clear = options.clear;
      transform = options.transform;
      skipUpdateTransform = options.skipUpdateTransform;
    }
    this.renderingToScreen = !renderTexture;
    renderer.runners.prerender.emit();
    renderer.emit("prerender");
    renderer.projection.transform = transform;
    if (renderer.context.isLost) {
      return;
    }
    if (!renderTexture) {
      this.lastObjectRendered = displayObject;
    }
    if (!skipUpdateTransform) {
      const cacheParent = displayObject.enableTempParent();
      displayObject.updateTransform();
      displayObject.disableTempParent(cacheParent);
    }
    renderer.renderTexture.bind(renderTexture);
    renderer.batch.currentRenderer.start();
    if (clear ?? renderer.background.clearBeforeRender) {
      renderer.renderTexture.clear();
    }
    displayObject.render(renderer);
    renderer.batch.currentRenderer.flush();
    if (renderTexture) {
      if (options.blit) {
        renderer.framebuffer.blit();
      }
      renderTexture.baseTexture.update();
    }
    renderer.runners.postrender.emit();
    renderer.projection.transform = null;
    renderer.emit("postrender");
  }
  destroy() {
    this.renderer = null;
    this.lastObjectRendered = null;
  }
}
ObjectRendererSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "objectRenderer"
};
extensions.extensions.add(ObjectRendererSystem);

exports.ObjectRendererSystem = ObjectRendererSystem;
//# sourceMappingURL=ObjectRendererSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/settings.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/settings.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");
var utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/index.js");
var BatchRenderer = __webpack_require__(/*! ./batch/BatchRenderer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchRenderer.js");
var Filter = __webpack_require__(/*! ./filters/Filter.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/Filter.js");
var Program = __webpack_require__(/*! ./shader/Program.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/Program.js");
__webpack_require__(/*! ./systems.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/systems.js");
var BaseTexture = __webpack_require__(/*! ./textures/BaseTexture.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/BaseTexture.js");
var ContextSystem = __webpack_require__(/*! ./context/ContextSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/context/ContextSystem.js");
var BackgroundSystem = __webpack_require__(/*! ./background/BackgroundSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/background/BackgroundSystem.js");
var ViewSystem = __webpack_require__(/*! ./view/ViewSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/view/ViewSystem.js");
var StartupSystem = __webpack_require__(/*! ./startup/StartupSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/startup/StartupSystem.js");
var TextureGCSystem = __webpack_require__(/*! ./textures/TextureGCSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/TextureGCSystem.js");

settings.settings.PREFER_ENV = constants.ENV.WEBGL2;
settings.settings.STRICT_TEXTURE_CACHE = false;
settings.settings.RENDER_OPTIONS = {
  ...ContextSystem.ContextSystem.defaultOptions,
  ...BackgroundSystem.BackgroundSystem.defaultOptions,
  ...ViewSystem.ViewSystem.defaultOptions,
  ...StartupSystem.StartupSystem.defaultOptions
};
Object.defineProperties(settings.settings, {
  WRAP_MODE: {
    get() {
      return BaseTexture.BaseTexture.defaultOptions.wrapMode;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode");
      BaseTexture.BaseTexture.defaultOptions.wrapMode = value;
    }
  },
  SCALE_MODE: {
    get() {
      return BaseTexture.BaseTexture.defaultOptions.scaleMode;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode");
      BaseTexture.BaseTexture.defaultOptions.scaleMode = value;
    }
  },
  MIPMAP_TEXTURES: {
    get() {
      return BaseTexture.BaseTexture.defaultOptions.mipmap;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap");
      BaseTexture.BaseTexture.defaultOptions.mipmap = value;
    }
  },
  ANISOTROPIC_LEVEL: {
    get() {
      return BaseTexture.BaseTexture.defaultOptions.anisotropicLevel;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel");
      BaseTexture.BaseTexture.defaultOptions.anisotropicLevel = value;
    }
  },
  FILTER_RESOLUTION: {
    get() {
      utils.deprecation("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution");
      return Filter.Filter.defaultResolution;
    },
    set(value) {
      Filter.Filter.defaultResolution = value;
    }
  },
  FILTER_MULTISAMPLE: {
    get() {
      utils.deprecation("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample");
      return Filter.Filter.defaultMultisample;
    },
    set(value) {
      Filter.Filter.defaultMultisample = value;
    }
  },
  SPRITE_MAX_TEXTURES: {
    get() {
      return BatchRenderer.BatchRenderer.defaultMaxTextures;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures");
      BatchRenderer.BatchRenderer.defaultMaxTextures = value;
    }
  },
  SPRITE_BATCH_SIZE: {
    get() {
      return BatchRenderer.BatchRenderer.defaultBatchSize;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize");
      BatchRenderer.BatchRenderer.defaultBatchSize = value;
    }
  },
  CAN_UPLOAD_SAME_BUFFER: {
    get() {
      return BatchRenderer.BatchRenderer.canUploadSameBuffer;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer");
      BatchRenderer.BatchRenderer.canUploadSameBuffer = value;
    }
  },
  GC_MODE: {
    get() {
      return TextureGCSystem.TextureGCSystem.defaultMode;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode");
      TextureGCSystem.TextureGCSystem.defaultMode = value;
    }
  },
  GC_MAX_IDLE: {
    get() {
      return TextureGCSystem.TextureGCSystem.defaultMaxIdle;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle");
      TextureGCSystem.TextureGCSystem.defaultMaxIdle = value;
    }
  },
  GC_MAX_CHECK_COUNT: {
    get() {
      return TextureGCSystem.TextureGCSystem.defaultCheckCountMax;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax");
      TextureGCSystem.TextureGCSystem.defaultCheckCountMax = value;
    }
  },
  PRECISION_VERTEX: {
    get() {
      return Program.Program.defaultVertexPrecision;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision");
      Program.Program.defaultVertexPrecision = value;
    }
  },
  PRECISION_FRAGMENT: {
    get() {
      return Program.Program.defaultFragmentPrecision;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision");
      Program.Program.defaultFragmentPrecision = value;
    }
  }
});
//# sourceMappingURL=settings.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/GLProgram.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/GLProgram.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class IGLUniformData {
}
class GLProgram {
  constructor(program, uniformData) {
    this.program = program;
    this.uniformData = uniformData;
    this.uniformGroups = {};
    this.uniformDirtyGroups = {};
    this.uniformBufferBindings = {};
  }
  destroy() {
    this.uniformData = null;
    this.uniformGroups = null;
    this.uniformDirtyGroups = null;
    this.uniformBufferBindings = null;
    this.program = null;
  }
}

exports.GLProgram = GLProgram;
exports.IGLUniformData = IGLUniformData;
//# sourceMappingURL=GLProgram.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/Program.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/Program.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/index.js");
var defaultProgram$1 = __webpack_require__(/*! ./defaultProgram.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/defaultProgram.js");
var defaultProgram = __webpack_require__(/*! ./defaultProgram2.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/defaultProgram2.js");
__webpack_require__(/*! ./utils/index.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/index.js");
var setPrecision = __webpack_require__(/*! ./utils/setPrecision.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/setPrecision.js");
var getMaxFragmentPrecision = __webpack_require__(/*! ./utils/getMaxFragmentPrecision.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.js");

let UID = 0;
const nameCache = {};
const _Program = class {
  constructor(vertexSrc, fragmentSrc, name = "pixi-shader", extra = {}) {
    this.extra = {};
    this.id = UID++;
    this.vertexSrc = vertexSrc || _Program.defaultVertexSrc;
    this.fragmentSrc = fragmentSrc || _Program.defaultFragmentSrc;
    this.vertexSrc = this.vertexSrc.trim();
    this.fragmentSrc = this.fragmentSrc.trim();
    this.extra = extra;
    if (this.vertexSrc.substring(0, 8) !== "#version") {
      name = name.replace(/\s+/g, "-");
      if (nameCache[name]) {
        nameCache[name]++;
        name += `-${nameCache[name]}`;
      } else {
        nameCache[name] = 1;
      }
      this.vertexSrc = `#define SHADER_NAME ${name}
${this.vertexSrc}`;
      this.fragmentSrc = `#define SHADER_NAME ${name}
${this.fragmentSrc}`;
      this.vertexSrc = setPrecision.setPrecision(this.vertexSrc, _Program.defaultVertexPrecision, constants.PRECISION.HIGH);
      this.fragmentSrc = setPrecision.setPrecision(this.fragmentSrc, _Program.defaultFragmentPrecision, getMaxFragmentPrecision.getMaxFragmentPrecision());
    }
    this.glPrograms = {};
    this.syncUniforms = null;
  }
  static get defaultVertexSrc() {
    return defaultProgram["default"];
  }
  static get defaultFragmentSrc() {
    return defaultProgram$1["default"];
  }
  static from(vertexSrc, fragmentSrc, name) {
    const key = vertexSrc + fragmentSrc;
    let program = utils.ProgramCache[key];
    if (!program) {
      utils.ProgramCache[key] = program = new _Program(vertexSrc, fragmentSrc, name);
    }
    return program;
  }
};
let Program = _Program;
Program.defaultVertexPrecision = constants.PRECISION.HIGH;
Program.defaultFragmentPrecision = utils.isMobile.apple.device ? constants.PRECISION.HIGH : constants.PRECISION.MEDIUM;

exports.Program = Program;
//# sourceMappingURL=Program.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/Shader.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/Shader.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var runner = __webpack_require__(/*! @pixi/runner */ "./node_modules/pixi.js/node_modules/@pixi/runner/lib/index.js");
var Program = __webpack_require__(/*! ./Program.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/Program.js");
var UniformGroup = __webpack_require__(/*! ./UniformGroup.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/UniformGroup.js");

class Shader {
  constructor(program, uniforms) {
    this.uniformBindCount = 0;
    this.program = program;
    if (uniforms) {
      if (uniforms instanceof UniformGroup.UniformGroup) {
        this.uniformGroup = uniforms;
      } else {
        this.uniformGroup = new UniformGroup.UniformGroup(uniforms);
      }
    } else {
      this.uniformGroup = new UniformGroup.UniformGroup({});
    }
    this.disposeRunner = new runner.Runner("disposeShader");
  }
  checkUniformExists(name, group) {
    if (group.uniforms[name]) {
      return true;
    }
    for (const i in group.uniforms) {
      const uniform = group.uniforms[i];
      if (uniform.group) {
        if (this.checkUniformExists(name, uniform)) {
          return true;
        }
      }
    }
    return false;
  }
  destroy() {
    this.uniformGroup = null;
    this.disposeRunner.emit(this);
    this.disposeRunner.destroy();
  }
  get uniforms() {
    return this.uniformGroup.uniforms;
  }
  static from(vertexSrc, fragmentSrc, uniforms) {
    const program = Program.Program.from(vertexSrc, fragmentSrc);
    return new Shader(program, uniforms);
  }
}

exports.Shader = Shader;
//# sourceMappingURL=Shader.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/ShaderSystem.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/ShaderSystem.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
__webpack_require__(/*! ./utils/index.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/index.js");
var generateProgram = __webpack_require__(/*! ./utils/generateProgram.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/generateProgram.js");
var generateUniformBufferSync = __webpack_require__(/*! ./utils/generateUniformBufferSync.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.js");
var unsafeEvalSupported = __webpack_require__(/*! ./utils/unsafeEvalSupported.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.js");
var generateUniformsSync = __webpack_require__(/*! ./utils/generateUniformsSync.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.js");

let UID = 0;
const defaultSyncData = { textureCount: 0, uboCount: 0 };
class ShaderSystem {
  constructor(renderer) {
    this.destroyed = false;
    this.renderer = renderer;
    this.systemCheck();
    this.gl = null;
    this.shader = null;
    this.program = null;
    this.cache = {};
    this._uboCache = {};
    this.id = UID++;
  }
  systemCheck() {
    if (!unsafeEvalSupported.unsafeEvalSupported()) {
      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
    }
  }
  contextChange(gl) {
    this.gl = gl;
    this.reset();
  }
  bind(shader, dontSync) {
    shader.disposeRunner.add(this);
    shader.uniforms.globals = this.renderer.globalUniforms;
    const program = shader.program;
    const glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
    this.shader = shader;
    if (this.program !== program) {
      this.program = program;
      this.gl.useProgram(glProgram.program);
    }
    if (!dontSync) {
      defaultSyncData.textureCount = 0;
      defaultSyncData.uboCount = 0;
      this.syncUniformGroup(shader.uniformGroup, defaultSyncData);
    }
    return glProgram;
  }
  setUniforms(uniforms) {
    const shader = this.shader.program;
    const glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
    shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
  }
  syncUniformGroup(group, syncData) {
    const glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {
      glProgram.uniformDirtyGroups[group.id] = group.dirtyId;
      this.syncUniforms(group, glProgram, syncData);
    }
  }
  syncUniforms(group, glProgram, syncData) {
    const syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
    syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);
  }
  createSyncGroups(group) {
    const id = this.getSignature(group, this.shader.program.uniformData, "u");
    if (!this.cache[id]) {
      this.cache[id] = generateUniformsSync.generateUniformsSync(group, this.shader.program.uniformData);
    }
    group.syncUniforms[this.shader.program.id] = this.cache[id];
    return group.syncUniforms[this.shader.program.id];
  }
  syncUniformBufferGroup(group, name) {
    const glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {
      group.dirtyId = 0;
      const syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);
      group.buffer.update();
      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);
    }
    this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);
  }
  createSyncBufferGroup(group, glProgram, name) {
    const { gl } = this.renderer;
    this.renderer.buffer.bind(group.buffer);
    const uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);
    glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount;
    gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);
    this.shader.uniformBindCount++;
    const id = this.getSignature(group, this.shader.program.uniformData, "ubo");
    let uboData = this._uboCache[id];
    if (!uboData) {
      uboData = this._uboCache[id] = generateUniformBufferSync.generateUniformBufferSync(group, this.shader.program.uniformData);
    }
    if (group.autoManage) {
      const data = new Float32Array(uboData.size / 4);
      group.buffer.update(data);
    }
    glProgram.uniformGroups[group.id] = uboData.syncFunc;
    return glProgram.uniformGroups[group.id];
  }
  getSignature(group, uniformData, preFix) {
    const uniforms = group.uniforms;
    const strings = [`${preFix}-`];
    for (const i in uniforms) {
      strings.push(i);
      if (uniformData[i]) {
        strings.push(uniformData[i].type);
      }
    }
    return strings.join("-");
  }
  getGlProgram() {
    if (this.shader) {
      return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
    }
    return null;
  }
  generateProgram(shader) {
    const gl = this.gl;
    const program = shader.program;
    const glProgram = generateProgram.generateProgram(gl, program);
    program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
    return glProgram;
  }
  reset() {
    this.program = null;
    this.shader = null;
  }
  disposeShader(shader) {
    if (this.shader === shader) {
      this.shader = null;
    }
  }
  destroy() {
    this.renderer = null;
    this.destroyed = true;
  }
}
ShaderSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "shader"
};
extensions.extensions.add(ShaderSystem);

exports.ShaderSystem = ShaderSystem;
//# sourceMappingURL=ShaderSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/UniformGroup.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/UniformGroup.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var Buffer = __webpack_require__(/*! ../geometry/Buffer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/Buffer.js");

let UID = 0;
class UniformGroup {
  constructor(uniforms, isStatic, isUbo) {
    this.group = true;
    this.syncUniforms = {};
    this.dirtyId = 0;
    this.id = UID++;
    this.static = !!isStatic;
    this.ubo = !!isUbo;
    if (uniforms instanceof Buffer.Buffer) {
      this.buffer = uniforms;
      this.buffer.type = constants.BUFFER_TYPE.UNIFORM_BUFFER;
      this.autoManage = false;
      this.ubo = true;
    } else {
      this.uniforms = uniforms;
      if (this.ubo) {
        this.buffer = new Buffer.Buffer(new Float32Array(1));
        this.buffer.type = constants.BUFFER_TYPE.UNIFORM_BUFFER;
        this.autoManage = true;
      }
    }
  }
  update() {
    this.dirtyId++;
    if (!this.autoManage && this.buffer) {
      this.buffer.update();
    }
  }
  add(name, uniforms, _static) {
    if (!this.ubo) {
      this.uniforms[name] = new UniformGroup(uniforms, _static);
    } else {
      throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
    }
  }
  static from(uniforms, _static, _ubo) {
    return new UniformGroup(uniforms, _static, _ubo);
  }
  static uboFrom(uniforms, _static) {
    return new UniformGroup(uniforms, _static ?? true, true);
  }
}

exports.UniformGroup = UniformGroup;
//# sourceMappingURL=UniformGroup.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/defaultProgram.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/defaultProgram.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var defaultFragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";

exports["default"] = defaultFragment;
//# sourceMappingURL=defaultProgram.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/defaultProgram2.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/defaultProgram2.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";

exports["default"] = defaultVertex;
//# sourceMappingURL=defaultProgram2.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const fragTemplate = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join("\n");
function generateIfTestSrc(maxIfs) {
  let src = "";
  for (let i = 0; i < maxIfs; ++i) {
    if (i > 0) {
      src += "\nelse ";
    }
    if (i < maxIfs - 1) {
      src += `if(test == ${i}.0){}`;
    }
  }
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  const shader = gl.createShader(gl.FRAGMENT_SHADER);
  while (true) {
    const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
    gl.shaderSource(shader, fragmentSrc);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      maxIfs = maxIfs / 2 | 0;
    } else {
      break;
    }
  }
  return maxIfs;
}

exports.checkMaxIfStatementsInShader = checkMaxIfStatementsInShader;
//# sourceMappingURL=checkMaxIfStatementsInShader.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/compileShader.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/compileShader.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function compileShader(gl, type, src) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}

exports.compileShader = compileShader;
//# sourceMappingURL=compileShader.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/defaultValue.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/defaultValue.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function booleanArray(size) {
  const array = new Array(size);
  for (let i = 0; i < array.length; i++) {
    array[i] = false;
  }
  return array;
}
function defaultValue(type, size) {
  switch (type) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size);
    case "vec3":
      return new Float32Array(3 * size);
    case "vec4":
      return new Float32Array(4 * size);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size);
    case "ivec3":
      return new Int32Array(3 * size);
    case "ivec4":
      return new Int32Array(4 * size);
    case "uvec2":
      return new Uint32Array(2 * size);
    case "uvec3":
      return new Uint32Array(3 * size);
    case "uvec4":
      return new Uint32Array(4 * size);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size);
    case "bvec3":
      return booleanArray(3 * size);
    case "bvec4":
      return booleanArray(4 * size);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}

exports.defaultValue = defaultValue;
//# sourceMappingURL=defaultValue.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/generateProgram.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/generateProgram.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var GLProgram = __webpack_require__(/*! ../GLProgram.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/GLProgram.js");
var compileShader = __webpack_require__(/*! ./compileShader.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/compileShader.js");
var defaultValue = __webpack_require__(/*! ./defaultValue.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/defaultValue.js");
var getAttributeData = __webpack_require__(/*! ./getAttributeData.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/getAttributeData.js");
var getUniformData = __webpack_require__(/*! ./getUniformData.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/getUniformData.js");
var logProgramError = __webpack_require__(/*! ./logProgramError.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/logProgramError.js");

function generateProgram(gl, program) {
  const glVertShader = compileShader.compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc);
  const glFragShader = compileShader.compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);
  const webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  const transformFeedbackVaryings = program.extra?.transformFeedbackVaryings;
  if (transformFeedbackVaryings) {
    if (typeof gl.transformFeedbackVaryings !== "function") {
      console.warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
    } else {
      gl.transformFeedbackVaryings(webGLProgram, transformFeedbackVaryings.names, transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS);
    }
  }
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    logProgramError.logProgramError(gl, webGLProgram, glVertShader, glFragShader);
  }
  program.attributeData = getAttributeData.getAttributeData(webGLProgram, gl);
  program.uniformData = getUniformData.getUniformData(webGLProgram, gl);
  if (!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
    const keys = Object.keys(program.attributeData);
    keys.sort((a, b) => a > b ? 1 : -1);
    for (let i = 0; i < keys.length; i++) {
      program.attributeData[keys[i]].location = i;
      gl.bindAttribLocation(webGLProgram, i, keys[i]);
    }
    gl.linkProgram(webGLProgram);
  }
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  const uniformData = {};
  for (const i in program.uniformData) {
    const data = program.uniformData[i];
    uniformData[i] = {
      location: gl.getUniformLocation(webGLProgram, i),
      value: defaultValue.defaultValue(data.type, data.size)
    };
  }
  const glProgram = new GLProgram.GLProgram(webGLProgram, uniformData);
  return glProgram;
}

exports.generateProgram = generateProgram;
//# sourceMappingURL=generateProgram.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(/*! ./index.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/index.js");
var uniformParsers = __webpack_require__(/*! ./uniformParsers.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/uniformParsers.js");
var mapSize = __webpack_require__(/*! ./mapSize.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/mapSize.js");

function uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {
  _renderer.buffer.update(buffer);
}
const UBO_TO_SINGLE_SETTERS = {
  float: `
        data[offset] = v;
    `,
  vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
  vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
  vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
  mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
  mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
  mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
};
const GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function createUBOElements(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    dataLen: 0,
    dirty: 0
  }));
  let size = 0;
  let chunkSize = 0;
  let offset = 0;
  for (let i = 0; i < uboElements.length; i++) {
    const uboElement = uboElements[i];
    size = GLSL_TO_STD40_SIZE[uboElement.data.type];
    if (uboElement.data.size > 1) {
      size = Math.max(size, 16) * uboElement.data.size;
    }
    uboElement.dataLen = size;
    if (chunkSize % size !== 0 && chunkSize < 16) {
      const lineUpValue = chunkSize % size % 16;
      chunkSize += lineUpValue;
      offset += lineUpValue;
    }
    if (chunkSize + size > 16) {
      offset = Math.ceil(offset / 16) * 16;
      uboElement.offset = offset;
      offset += size;
      chunkSize = size;
    } else {
      uboElement.offset = offset;
      chunkSize += size;
      offset += size;
    }
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
function getUBOData(uniforms, uniformData) {
  const usedUniformDatas = [];
  for (const i in uniforms) {
    if (uniformData[i]) {
      usedUniformDatas.push(uniformData[i]);
    }
  }
  usedUniformDatas.sort((a, b) => a.index - b.index);
  return usedUniformDatas;
}
function generateUniformBufferSync(group, uniformData) {
  if (!group.autoManage) {
    return { size: 0, syncFunc: uboUpdate };
  }
  const usedUniformDatas = getUBOData(group.uniforms, uniformData);
  const { uboElements, size } = createUBOElements(usedUniformDatas);
  const funcFragments = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
  for (let i = 0; i < uboElements.length; i++) {
    const uboElement = uboElements[i];
    const uniform = group.uniforms[uboElement.data.name];
    const name = uboElement.data.name;
    let parsed = false;
    for (let j = 0; j < uniformParsers.uniformParsers.length; j++) {
      const uniformParser = uniformParsers.uniformParsers[j];
      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
        funcFragments.push(`offset = ${uboElement.offset / 4};`, uniformParsers.uniformParsers[j].codeUbo(uboElement.data.name, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        const size2 = mapSize.mapSize(uboElement.data.type);
        const rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
        const elementSize = size2 / rowSize;
        const remainder = (4 - elementSize % 4) % 4;
        funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};

                t = 0;

                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
                {
                    for(var j = 0; j < ${elementSize}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${remainder};
                }

                `);
      } else {
        const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
        funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};
                ${template};
                `);
      }
    }
  }
  funcFragments.push(`
       renderer.buffer.update(buffer);
    `);
  return {
    size,
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", funcFragments.join("\n"))
  };
}

exports.createUBOElements = createUBOElements;
exports.generateUniformBufferSync = generateUniformBufferSync;
exports.getUBOData = getUBOData;
//# sourceMappingURL=generateUniformBufferSync.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var uniformParsers = __webpack_require__(/*! ./uniformParsers.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/uniformParsers.js");

const GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
  vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
  vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
  vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
  int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
  uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
  uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
  uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
  bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
  bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
};
const GLSL_TO_ARRAY_SETTERS = {
  float: `gl.uniform1fv(location, v)`,
  vec2: `gl.uniform2fv(location, v)`,
  vec3: `gl.uniform3fv(location, v)`,
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync(group, uniformData) {
  const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (const i in group.uniforms) {
    const data = uniformData[i];
    if (!data) {
      if (group.uniforms[i]?.group) {
        if (group.uniforms[i].ubo) {
          funcFragments.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${i}, '${i}');
                    `);
        } else {
          funcFragments.push(`
                        renderer.shader.syncUniformGroup(uv.${i}, syncData);
                    `);
        }
      }
      continue;
    }
    const uniform = group.uniforms[i];
    let parsed = false;
    for (let j = 0; j < uniformParsers.uniformParsers.length; j++) {
      if (uniformParsers.uniformParsers[j].test(data, uniform)) {
        funcFragments.push(uniformParsers.uniformParsers[j].code(i, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      const templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
      const template = templateType[data.type].replace("location", `ud["${i}"].location`);
      funcFragments.push(`
            cu = ud["${i}"];
            cv = cu.value;
            v = uv["${i}"];
            ${template};`);
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}

exports.generateUniformsSync = generateUniformsSync;
//# sourceMappingURL=generateUniformsSync.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/getAttributeData.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/getAttributeData.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var mapSize = __webpack_require__(/*! ./mapSize.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/mapSize.js");
var mapType = __webpack_require__(/*! ./mapType.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/mapType.js");

function getAttributeData(program, gl) {
  const attributes = {};
  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < totalAttributes; i++) {
    const attribData = gl.getActiveAttrib(program, i);
    if (attribData.name.startsWith("gl_")) {
      continue;
    }
    const type = mapType.mapType(gl, attribData.type);
    const data = {
      type,
      name: attribData.name,
      size: mapSize.mapSize(type),
      location: gl.getAttribLocation(program, attribData.name)
    };
    attributes[attribData.name] = data;
  }
  return attributes;
}

exports.getAttributeData = getAttributeData;
//# sourceMappingURL=getAttributeData.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var getTestContext = __webpack_require__(/*! ./getTestContext.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/getTestContext.js");

let maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = constants.PRECISION.MEDIUM;
    const gl = getTestContext.getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? constants.PRECISION.HIGH : constants.PRECISION.MEDIUM;
      }
    }
  }
  return maxFragmentPrecision;
}

exports.getMaxFragmentPrecision = getMaxFragmentPrecision;
//# sourceMappingURL=getMaxFragmentPrecision.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/getTestContext.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/getTestContext.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");

const unknownContext = {};
let context = unknownContext;
function getTestContext() {
  if (context === unknownContext || context?.isContextLost()) {
    const canvas = settings.settings.ADAPTER.createCanvas();
    let gl;
    if (settings.settings.PREFER_ENV >= constants.ENV.WEBGL2) {
      gl = canvas.getContext("webgl2", {});
    }
    if (!gl) {
      gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {});
      if (!gl) {
        gl = null;
      } else {
        gl.getExtension("WEBGL_draw_buffers");
      }
    }
    context = gl;
  }
  return context;
}

exports.getTestContext = getTestContext;
//# sourceMappingURL=getTestContext.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/getUniformData.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/getUniformData.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var defaultValue = __webpack_require__(/*! ./defaultValue.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/defaultValue.js");
var mapType = __webpack_require__(/*! ./mapType.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/mapType.js");

function getUniformData(program, gl) {
  const uniforms = {};
  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i = 0; i < totalUniforms; i++) {
    const uniformData = gl.getActiveUniform(program, i);
    const name = uniformData.name.replace(/\[.*?\]$/, "");
    const isArray = !!uniformData.name.match(/\[.*?\]$/);
    const type = mapType.mapType(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i,
      type,
      size: uniformData.size,
      isArray,
      value: defaultValue.defaultValue(type, uniformData.size)
    };
  }
  return uniforms;
}

exports.getUniformData = getUniformData;
//# sourceMappingURL=getUniformData.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/index.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var checkMaxIfStatementsInShader = __webpack_require__(/*! ./checkMaxIfStatementsInShader.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.js");
var compileShader = __webpack_require__(/*! ./compileShader.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/compileShader.js");
var defaultValue = __webpack_require__(/*! ./defaultValue.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/defaultValue.js");
var generateUniformsSync = __webpack_require__(/*! ./generateUniformsSync.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.js");
var getMaxFragmentPrecision = __webpack_require__(/*! ./getMaxFragmentPrecision.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.js");
var getTestContext = __webpack_require__(/*! ./getTestContext.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/getTestContext.js");
var logProgramError = __webpack_require__(/*! ./logProgramError.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/logProgramError.js");
var mapSize = __webpack_require__(/*! ./mapSize.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/mapSize.js");
var mapType = __webpack_require__(/*! ./mapType.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/mapType.js");
var setPrecision = __webpack_require__(/*! ./setPrecision.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/setPrecision.js");
var uniformParsers = __webpack_require__(/*! ./uniformParsers.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/uniformParsers.js");
var unsafeEvalSupported = __webpack_require__(/*! ./unsafeEvalSupported.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.js");



exports.checkMaxIfStatementsInShader = checkMaxIfStatementsInShader.checkMaxIfStatementsInShader;
exports.compileShader = compileShader.compileShader;
exports.defaultValue = defaultValue.defaultValue;
exports.generateUniformsSync = generateUniformsSync.generateUniformsSync;
exports.getMaxFragmentPrecision = getMaxFragmentPrecision.getMaxFragmentPrecision;
exports.getTestContext = getTestContext.getTestContext;
exports.logProgramError = logProgramError.logProgramError;
exports.mapSize = mapSize.mapSize;
exports.mapType = mapType.mapType;
exports.setPrecision = setPrecision.setPrecision;
exports.uniformParsers = uniformParsers.uniformParsers;
exports.unsafeEvalSupported = unsafeEvalSupported.unsafeEvalSupported;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/logProgramError.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/logProgramError.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function logPrettyShaderError(gl, shader) {
  const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index) => `${index}: ${line}`);
  const shaderLog = gl.getShaderInfoLog(shader);
  const splitShader = shaderLog.split("\n");
  const dedupe = {};
  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n) => {
    if (n && !dedupe[n]) {
      dedupe[n] = true;
      return true;
    }
    return false;
  });
  const logArgs = [""];
  lineNumbers.forEach((number) => {
    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  const fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn(...logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}

exports.logProgramError = logProgramError;
//# sourceMappingURL=logProgramError.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/mapSize.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/mapSize.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(type) {
  return GLSL_TO_SIZE[type];
}

exports.mapSize = mapSize;
//# sourceMappingURL=mapSize.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/mapType.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/mapType.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

let GL_TABLE = null;
const GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType(gl, type) {
  if (!GL_TABLE) {
    const typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (let i = 0; i < typeNames.length; ++i) {
      const tn = typeNames[i];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type];
}

exports.mapType = mapType;
//# sourceMappingURL=mapType.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/setPrecision.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/setPrecision.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");

function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
  if (src.substring(0, 9) !== "precision") {
    let precision = requestedPrecision;
    if (requestedPrecision === constants.PRECISION.HIGH && maxSupportedPrecision !== constants.PRECISION.HIGH) {
      precision = constants.PRECISION.MEDIUM;
    }
    return `precision ${precision} float;
${src}`;
  } else if (maxSupportedPrecision !== constants.PRECISION.HIGH && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}

exports.setPrecision = setPrecision;
//# sourceMappingURL=setPrecision.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/uniformParsers.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/uniformParsers.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const uniformParsers = [
  {
    test: (data) => data.type === "float" && data.size === 1 && !data.isArray,
    code: (name) => `
            if(uv["${name}"] !== ud["${name}"].value)
            {
                ud["${name}"].value = uv["${name}"]
                gl.uniform1f(ud["${name}"].location, uv["${name}"])
            }
            `
  },
  {
    test: (data, uniform) => (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== void 0),
    code: (name) => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${name}"], t);

            if(ud["${name}"].value !== t)
            {
                ud["${name}"].value = t;
                gl.uniform1i(ud["${name}"].location, t);
; // eslint-disable-line max-len
            }`
  },
  {
    test: (data, uniform) => data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0,
    code: (name) => `
            gl.uniformMatrix3fv(ud["${name}"].location, false, uv["${name}"].toArray(true));
            `,
    codeUbo: (name) => `
                var ${name}_matrix = uv.${name}.toArray(true);

                data[offset] = ${name}_matrix[0];
                data[offset+1] = ${name}_matrix[1];
                data[offset+2] = ${name}_matrix[2];
        
                data[offset + 4] = ${name}_matrix[3];
                data[offset + 5] = ${name}_matrix[4];
                data[offset + 6] = ${name}_matrix[5];
        
                data[offset + 8] = ${name}_matrix[6];
                data[offset + 9] = ${name}_matrix[7];
                data[offset + 10] = ${name}_matrix[8];
            `
  },
  {
    test: (data, uniform) => data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${name}"].location, v.x, v.y);
                }`,
    codeUbo: (name) => `
                v = uv.${name};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
  },
  {
    test: (data) => data.type === "vec2" && data.size === 1 && !data.isArray,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${name}"].location, v[0], v[1]);
                }
            `
  },
  {
    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${name}"].location, v.x, v.y, v.width, v.height)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
  },
  {
    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.red !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${name}"].location, v.red, v.green, v.blue, v.alpha)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                    data[offset+3] = v.alpha;
                `
  },
  {
    test: (data, uniform) => data.type === "vec3" && data.size === 1 && !data.isArray && uniform.red !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${name}"].location, v.red, v.green, v.blue)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                `
  },
  {
    test: (data) => data.type === "vec4" && data.size === 1 && !data.isArray,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])
                }`
  }
];

exports.uniformParsers = uniformParsers;
//# sourceMappingURL=uniformParsers.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

let unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (e) {
    unsafeEval = false;
  }
  return unsafeEval;
}

exports.unsafeEvalSupported = unsafeEvalSupported;
//# sourceMappingURL=unsafeEvalSupported.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/startup/StartupSystem.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/startup/StartupSystem.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");

class StartupSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  run(options) {
    const { renderer } = this;
    renderer.runners.init.emit(renderer.options);
    if (options.hello) {
      console.log(`PixiJS ${"7.2.4"} - ${renderer.rendererLogId} - https://pixijs.com`);
    }
    renderer.resize(renderer.screen.width, renderer.screen.height);
  }
  destroy() {
  }
}
StartupSystem.defaultOptions = {
  hello: false
};
StartupSystem.extension = {
  type: [
    extensions.ExtensionType.RendererSystem,
    extensions.ExtensionType.CanvasRendererSystem
  ],
  name: "startup"
};
extensions.extensions.add(StartupSystem);

exports.StartupSystem = StartupSystem;
//# sourceMappingURL=StartupSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/state/State.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/state/State.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");

const BLEND = 0;
const OFFSET = 1;
const CULLING = 2;
const DEPTH_TEST = 3;
const WINDING = 4;
const DEPTH_MASK = 5;
class State {
  constructor() {
    this.data = 0;
    this.blendMode = constants.BLEND_MODES.NORMAL;
    this.polygonOffset = 0;
    this.blend = true;
    this.depthMask = true;
  }
  get blend() {
    return !!(this.data & 1 << BLEND);
  }
  set blend(value) {
    if (!!(this.data & 1 << BLEND) !== value) {
      this.data ^= 1 << BLEND;
    }
  }
  get offsets() {
    return !!(this.data & 1 << OFFSET);
  }
  set offsets(value) {
    if (!!(this.data & 1 << OFFSET) !== value) {
      this.data ^= 1 << OFFSET;
    }
  }
  get culling() {
    return !!(this.data & 1 << CULLING);
  }
  set culling(value) {
    if (!!(this.data & 1 << CULLING) !== value) {
      this.data ^= 1 << CULLING;
    }
  }
  get depthTest() {
    return !!(this.data & 1 << DEPTH_TEST);
  }
  set depthTest(value) {
    if (!!(this.data & 1 << DEPTH_TEST) !== value) {
      this.data ^= 1 << DEPTH_TEST;
    }
  }
  get depthMask() {
    return !!(this.data & 1 << DEPTH_MASK);
  }
  set depthMask(value) {
    if (!!(this.data & 1 << DEPTH_MASK) !== value) {
      this.data ^= 1 << DEPTH_MASK;
    }
  }
  get clockwiseFrontFace() {
    return !!(this.data & 1 << WINDING);
  }
  set clockwiseFrontFace(value) {
    if (!!(this.data & 1 << WINDING) !== value) {
      this.data ^= 1 << WINDING;
    }
  }
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(value) {
    this.blend = value !== constants.BLEND_MODES.NONE;
    this._blendMode = value;
  }
  get polygonOffset() {
    return this._polygonOffset;
  }
  set polygonOffset(value) {
    this.offsets = !!value;
    this._polygonOffset = value;
  }
  toString() {
    return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
  }
  static for2d() {
    const state = new State();
    state.depthTest = false;
    state.blend = true;
    return state;
  }
}

exports.State = State;
//# sourceMappingURL=State.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/state/StateSystem.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/state/StateSystem.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
var State = __webpack_require__(/*! ./State.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/state/State.js");
var mapWebGLBlendModesToPixi = __webpack_require__(/*! ./utils/mapWebGLBlendModesToPixi.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/state/utils/mapWebGLBlendModesToPixi.js");

const BLEND = 0;
const OFFSET = 1;
const CULLING = 2;
const DEPTH_TEST = 3;
const WINDING = 4;
const DEPTH_MASK = 5;
const _StateSystem = class {
  constructor() {
    this.gl = null;
    this.stateId = 0;
    this.polygonOffset = 0;
    this.blendMode = constants.BLEND_MODES.NONE;
    this._blendEq = false;
    this.map = [];
    this.map[BLEND] = this.setBlend;
    this.map[OFFSET] = this.setOffset;
    this.map[CULLING] = this.setCullFace;
    this.map[DEPTH_TEST] = this.setDepthTest;
    this.map[WINDING] = this.setFrontFace;
    this.map[DEPTH_MASK] = this.setDepthMask;
    this.checks = [];
    this.defaultState = new State.State();
    this.defaultState.blend = true;
  }
  contextChange(gl) {
    this.gl = gl;
    this.blendModes = mapWebGLBlendModesToPixi.mapWebGLBlendModesToPixi(gl);
    this.set(this.defaultState);
    this.reset();
  }
  set(state) {
    state = state || this.defaultState;
    if (this.stateId !== state.data) {
      let diff = this.stateId ^ state.data;
      let i = 0;
      while (diff) {
        if (diff & 1) {
          this.map[i].call(this, !!(state.data & 1 << i));
        }
        diff = diff >> 1;
        i++;
      }
      this.stateId = state.data;
    }
    for (let i = 0; i < this.checks.length; i++) {
      this.checks[i](this, state);
    }
  }
  forceState(state) {
    state = state || this.defaultState;
    for (let i = 0; i < this.map.length; i++) {
      this.map[i].call(this, !!(state.data & 1 << i));
    }
    for (let i = 0; i < this.checks.length; i++) {
      this.checks[i](this, state);
    }
    this.stateId = state.data;
  }
  setBlend(value) {
    this.updateCheck(_StateSystem.checkBlendMode, value);
    this.gl[value ? "enable" : "disable"](this.gl.BLEND);
  }
  setOffset(value) {
    this.updateCheck(_StateSystem.checkPolygonOffset, value);
    this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  }
  setDepthTest(value) {
    this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
  }
  setDepthMask(value) {
    this.gl.depthMask(value);
  }
  setCullFace(value) {
    this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
  }
  setFrontFace(value) {
    this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
  }
  setBlendMode(value) {
    if (value === this.blendMode) {
      return;
    }
    this.blendMode = value;
    const mode = this.blendModes[value];
    const gl = this.gl;
    if (mode.length === 2) {
      gl.blendFunc(mode[0], mode[1]);
    } else {
      gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
    }
    if (mode.length === 6) {
      this._blendEq = true;
      gl.blendEquationSeparate(mode[4], mode[5]);
    } else if (this._blendEq) {
      this._blendEq = false;
      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    }
  }
  setPolygonOffset(value, scale) {
    this.gl.polygonOffset(value, scale);
  }
  reset() {
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
    this.forceState(this.defaultState);
    this._blendEq = true;
    this.blendMode = -1;
    this.setBlendMode(0);
  }
  updateCheck(func, value) {
    const index = this.checks.indexOf(func);
    if (value && index === -1) {
      this.checks.push(func);
    } else if (!value && index !== -1) {
      this.checks.splice(index, 1);
    }
  }
  static checkBlendMode(system, state) {
    system.setBlendMode(state.blendMode);
  }
  static checkPolygonOffset(system, state) {
    system.setPolygonOffset(1, state.polygonOffset);
  }
  destroy() {
    this.gl = null;
  }
};
let StateSystem = _StateSystem;
StateSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "state"
};
extensions.extensions.add(StateSystem);

exports.StateSystem = StateSystem;
//# sourceMappingURL=StateSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/state/utils/mapWebGLBlendModesToPixi.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/state/utils/mapWebGLBlendModesToPixi.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");

function mapWebGLBlendModesToPixi(gl, array = []) {
  array[constants.BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.ADD] = [gl.ONE, gl.ONE];
  array[constants.BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.NONE] = [0, 0];
  array[constants.BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  array[constants.BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
  array[constants.BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
  array[constants.BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
  array[constants.BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
  array[constants.BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
  array[constants.BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
  return array;
}

exports.mapWebGLBlendModesToPixi = mapWebGLBlendModesToPixi;
//# sourceMappingURL=mapWebGLBlendModesToPixi.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/system/ISystem.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/system/ISystem.js ***!
  \****************************************************************************/
/***/ (() => {

"use strict";


//# sourceMappingURL=ISystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/system/SystemManager.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/system/SystemManager.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var runner = __webpack_require__(/*! @pixi/runner */ "./node_modules/pixi.js/node_modules/@pixi/runner/lib/index.js");
var utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/index.js");

class SystemManager extends utils.EventEmitter {
  constructor() {
    super(...arguments);
    this.runners = {};
    this._systemsHash = {};
  }
  setup(config) {
    this.addRunners(...config.runners);
    const priority = (config.priority ?? []).filter((key) => config.systems[key]);
    const orderByPriority = [
      ...priority,
      ...Object.keys(config.systems).filter((key) => !priority.includes(key))
    ];
    for (const i of orderByPriority) {
      this.addSystem(config.systems[i], i);
    }
  }
  addRunners(...runnerIds) {
    runnerIds.forEach((runnerId) => {
      this.runners[runnerId] = new runner.Runner(runnerId);
    });
  }
  addSystem(ClassRef, name) {
    const system = new ClassRef(this);
    if (this[name]) {
      throw new Error(`Whoops! The name "${name}" is already in use`);
    }
    this[name] = system;
    this._systemsHash[name] = system;
    for (const i in this.runners) {
      this.runners[i].add(system);
    }
    return this;
  }
  emitWithCustomOptions(runner, options) {
    const systemHashKeys = Object.keys(this._systemsHash);
    runner.items.forEach((system) => {
      const systemName = systemHashKeys.find((systemId) => this._systemsHash[systemId] === system);
      system[runner.name](options[systemName]);
    });
  }
  destroy() {
    Object.values(this.runners).forEach((runner) => {
      runner.destroy();
    });
    this._systemsHash = {};
  }
}

exports.SystemManager = SystemManager;
//# sourceMappingURL=SystemManager.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/systems.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/systems.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var BackgroundSystem = __webpack_require__(/*! ./background/BackgroundSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/background/BackgroundSystem.js");
var BatchSystem = __webpack_require__(/*! ./batch/BatchSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/batch/BatchSystem.js");
var ContextSystem = __webpack_require__(/*! ./context/ContextSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/context/ContextSystem.js");
var FilterSystem = __webpack_require__(/*! ./filters/FilterSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/filters/FilterSystem.js");
var FramebufferSystem = __webpack_require__(/*! ./framebuffer/FramebufferSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.js");
var GeometrySystem = __webpack_require__(/*! ./geometry/GeometrySystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/GeometrySystem.js");
var MaskSystem = __webpack_require__(/*! ./mask/MaskSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/mask/MaskSystem.js");
var ScissorSystem = __webpack_require__(/*! ./mask/ScissorSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/mask/ScissorSystem.js");
var StencilSystem = __webpack_require__(/*! ./mask/StencilSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/mask/StencilSystem.js");
var PluginSystem = __webpack_require__(/*! ./plugin/PluginSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/plugin/PluginSystem.js");
var ProjectionSystem = __webpack_require__(/*! ./projection/ProjectionSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/projection/ProjectionSystem.js");
var GenerateTextureSystem = __webpack_require__(/*! ./renderTexture/GenerateTextureSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.js");
var RenderTextureSystem = __webpack_require__(/*! ./renderTexture/RenderTextureSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.js");
var ShaderSystem = __webpack_require__(/*! ./shader/ShaderSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/shader/ShaderSystem.js");
var StartupSystem = __webpack_require__(/*! ./startup/StartupSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/startup/StartupSystem.js");
var StateSystem = __webpack_require__(/*! ./state/StateSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/state/StateSystem.js");
var SystemManager = __webpack_require__(/*! ./system/SystemManager.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/system/SystemManager.js");
var TextureGCSystem = __webpack_require__(/*! ./textures/TextureGCSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/TextureGCSystem.js");
var TextureSystem = __webpack_require__(/*! ./textures/TextureSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/TextureSystem.js");
var TransformFeedbackSystem = __webpack_require__(/*! ./transformFeedback/TransformFeedbackSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.js");
var ViewSystem = __webpack_require__(/*! ./view/ViewSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/view/ViewSystem.js");



exports.BackgroundSystem = BackgroundSystem.BackgroundSystem;
exports.BatchSystem = BatchSystem.BatchSystem;
exports.ContextSystem = ContextSystem.ContextSystem;
exports.FilterSystem = FilterSystem.FilterSystem;
exports.FramebufferSystem = FramebufferSystem.FramebufferSystem;
exports.GeometrySystem = GeometrySystem.GeometrySystem;
exports.MaskSystem = MaskSystem.MaskSystem;
exports.ScissorSystem = ScissorSystem.ScissorSystem;
exports.StencilSystem = StencilSystem.StencilSystem;
exports.PluginSystem = PluginSystem.PluginSystem;
exports.ProjectionSystem = ProjectionSystem.ProjectionSystem;
exports.GenerateTextureSystem = GenerateTextureSystem.GenerateTextureSystem;
exports.RenderTextureSystem = RenderTextureSystem.RenderTextureSystem;
exports.ShaderSystem = ShaderSystem.ShaderSystem;
exports.StartupSystem = StartupSystem.StartupSystem;
exports.StateSystem = StateSystem.StateSystem;
exports.SystemManager = SystemManager.SystemManager;
exports.TextureGCSystem = TextureGCSystem.TextureGCSystem;
exports.TextureSystem = TextureSystem.TextureSystem;
exports.TransformFeedbackSystem = TransformFeedbackSystem.TransformFeedbackSystem;
exports.ViewSystem = ViewSystem.ViewSystem;
//# sourceMappingURL=systems.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/BaseTexture.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/BaseTexture.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");
var utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/index.js");
var autoDetectResource = __webpack_require__(/*! ./resources/autoDetectResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/autoDetectResource.js");
var BufferResource = __webpack_require__(/*! ./resources/BufferResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/BufferResource.js");
var Resource = __webpack_require__(/*! ./resources/Resource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/Resource.js");

const defaultBufferOptions = {
  scaleMode: constants.SCALE_MODES.NEAREST,
  format: constants.FORMATS.RGBA,
  alphaMode: constants.ALPHA_MODES.NPM
};
const _BaseTexture = class extends utils.EventEmitter {
  constructor(resource = null, options = null) {
    super();
    options = Object.assign({}, _BaseTexture.defaultOptions, options);
    const {
      alphaMode,
      mipmap,
      anisotropicLevel,
      scaleMode,
      width,
      height,
      wrapMode,
      format,
      type,
      target,
      resolution,
      resourceOptions
    } = options;
    if (resource && !(resource instanceof Resource.Resource)) {
      resource = autoDetectResource.autoDetectResource(resource, resourceOptions);
      resource.internal = true;
    }
    this.resolution = resolution || settings.settings.RESOLUTION;
    this.width = Math.round((width || 0) * this.resolution) / this.resolution;
    this.height = Math.round((height || 0) * this.resolution) / this.resolution;
    this._mipmap = mipmap;
    this.anisotropicLevel = anisotropicLevel;
    this._wrapMode = wrapMode;
    this._scaleMode = scaleMode;
    this.format = format;
    this.type = type;
    this.target = target;
    this.alphaMode = alphaMode;
    this.uid = utils.uid();
    this.touched = 0;
    this.isPowerOfTwo = false;
    this._refreshPOT();
    this._glTextures = {};
    this.dirtyId = 0;
    this.dirtyStyleId = 0;
    this.cacheId = null;
    this.valid = width > 0 && height > 0;
    this.textureCacheIds = [];
    this.destroyed = false;
    this.resource = null;
    this._batchEnabled = 0;
    this._batchLocation = 0;
    this.parentTextureArray = null;
    this.setResource(resource);
  }
  get realWidth() {
    return Math.round(this.width * this.resolution);
  }
  get realHeight() {
    return Math.round(this.height * this.resolution);
  }
  get mipmap() {
    return this._mipmap;
  }
  set mipmap(value) {
    if (this._mipmap !== value) {
      this._mipmap = value;
      this.dirtyStyleId++;
    }
  }
  get scaleMode() {
    return this._scaleMode;
  }
  set scaleMode(value) {
    if (this._scaleMode !== value) {
      this._scaleMode = value;
      this.dirtyStyleId++;
    }
  }
  get wrapMode() {
    return this._wrapMode;
  }
  set wrapMode(value) {
    if (this._wrapMode !== value) {
      this._wrapMode = value;
      this.dirtyStyleId++;
    }
  }
  setStyle(scaleMode, mipmap) {
    let dirty;
    if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
      this.scaleMode = scaleMode;
      dirty = true;
    }
    if (mipmap !== void 0 && mipmap !== this.mipmap) {
      this.mipmap = mipmap;
      dirty = true;
    }
    if (dirty) {
      this.dirtyStyleId++;
    }
    return this;
  }
  setSize(desiredWidth, desiredHeight, resolution) {
    resolution = resolution || this.resolution;
    return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
  }
  setRealSize(realWidth, realHeight, resolution) {
    this.resolution = resolution || this.resolution;
    this.width = Math.round(realWidth) / this.resolution;
    this.height = Math.round(realHeight) / this.resolution;
    this._refreshPOT();
    this.update();
    return this;
  }
  _refreshPOT() {
    this.isPowerOfTwo = utils.isPow2(this.realWidth) && utils.isPow2(this.realHeight);
  }
  setResolution(resolution) {
    const oldResolution = this.resolution;
    if (oldResolution === resolution) {
      return this;
    }
    this.resolution = resolution;
    if (this.valid) {
      this.width = Math.round(this.width * oldResolution) / resolution;
      this.height = Math.round(this.height * oldResolution) / resolution;
      this.emit("update", this);
    }
    this._refreshPOT();
    return this;
  }
  setResource(resource) {
    if (this.resource === resource) {
      return this;
    }
    if (this.resource) {
      throw new Error("Resource can be set only once");
    }
    resource.bind(this);
    this.resource = resource;
    return this;
  }
  update() {
    if (!this.valid) {
      if (this.width > 0 && this.height > 0) {
        this.valid = true;
        this.emit("loaded", this);
        this.emit("update", this);
      }
    } else {
      this.dirtyId++;
      this.dirtyStyleId++;
      this.emit("update", this);
    }
  }
  onError(event) {
    this.emit("error", this, event);
  }
  destroy() {
    if (this.resource) {
      this.resource.unbind(this);
      if (this.resource.internal) {
        this.resource.destroy();
      }
      this.resource = null;
    }
    if (this.cacheId) {
      delete utils.BaseTextureCache[this.cacheId];
      delete utils.TextureCache[this.cacheId];
      this.cacheId = null;
    }
    this.dispose();
    _BaseTexture.removeFromCache(this);
    this.textureCacheIds = null;
    this.destroyed = true;
  }
  dispose() {
    this.emit("dispose", this);
  }
  castToBaseTexture() {
    return this;
  }
  static from(source, options, strict = settings.settings.STRICT_TEXTURE_CACHE) {
    const isFrame = typeof source === "string";
    let cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else {
      if (!source._pixiId) {
        const prefix = options?.pixiIdPrefix || "pixiid";
        source._pixiId = `${prefix}_${utils.uid()}`;
      }
      cacheId = source._pixiId;
    }
    let baseTexture = utils.BaseTextureCache[cacheId];
    if (isFrame && strict && !baseTexture) {
      throw new Error(`The cacheId "${cacheId}" does not exist in BaseTextureCache.`);
    }
    if (!baseTexture) {
      baseTexture = new _BaseTexture(source, options);
      baseTexture.cacheId = cacheId;
      _BaseTexture.addToCache(baseTexture, cacheId);
    }
    return baseTexture;
  }
  static fromBuffer(buffer, width, height, options) {
    buffer = buffer || new Float32Array(width * height * 4);
    const resource = new BufferResource.BufferResource(buffer, { width, height });
    const type = buffer instanceof Float32Array ? constants.TYPES.FLOAT : constants.TYPES.UNSIGNED_BYTE;
    return new _BaseTexture(resource, Object.assign({}, defaultBufferOptions, { type }, options));
  }
  static addToCache(baseTexture, id) {
    if (id) {
      if (!baseTexture.textureCacheIds.includes(id)) {
        baseTexture.textureCacheIds.push(id);
      }
      if (utils.BaseTextureCache[id] && utils.BaseTextureCache[id] !== baseTexture) {
        console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`);
      }
      utils.BaseTextureCache[id] = baseTexture;
    }
  }
  static removeFromCache(baseTexture) {
    if (typeof baseTexture === "string") {
      const baseTextureFromCache = utils.BaseTextureCache[baseTexture];
      if (baseTextureFromCache) {
        const index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
        if (index > -1) {
          baseTextureFromCache.textureCacheIds.splice(index, 1);
        }
        delete utils.BaseTextureCache[baseTexture];
        return baseTextureFromCache;
      }
    } else if (baseTexture?.textureCacheIds) {
      for (let i = 0; i < baseTexture.textureCacheIds.length; ++i) {
        delete utils.BaseTextureCache[baseTexture.textureCacheIds[i]];
      }
      baseTexture.textureCacheIds.length = 0;
      return baseTexture;
    }
    return null;
  }
};
let BaseTexture = _BaseTexture;
BaseTexture.defaultOptions = {
  mipmap: constants.MIPMAP_MODES.POW2,
  anisotropicLevel: 0,
  scaleMode: constants.SCALE_MODES.LINEAR,
  wrapMode: constants.WRAP_MODES.CLAMP,
  alphaMode: constants.ALPHA_MODES.UNPACK,
  target: constants.TARGETS.TEXTURE_2D,
  format: constants.FORMATS.RGBA,
  type: constants.TYPES.UNSIGNED_BYTE
};
BaseTexture._globalBatch = 0;

exports.BaseTexture = BaseTexture;
//# sourceMappingURL=BaseTexture.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/GLTexture.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/GLTexture.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");

class GLTexture {
  constructor(texture) {
    this.texture = texture;
    this.width = -1;
    this.height = -1;
    this.dirtyId = -1;
    this.dirtyStyleId = -1;
    this.mipmap = false;
    this.wrapMode = 33071;
    this.type = constants.TYPES.UNSIGNED_BYTE;
    this.internalFormat = constants.FORMATS.RGBA;
    this.samplerType = 0;
  }
}

exports.GLTexture = GLTexture;
//# sourceMappingURL=GLTexture.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/Texture.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/Texture.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var math = __webpack_require__(/*! @pixi/math */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/index.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");
var utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/index.js");
var BaseTexture = __webpack_require__(/*! ./BaseTexture.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/BaseTexture.js");
var ImageResource = __webpack_require__(/*! ./resources/ImageResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/ImageResource.js");
var TextureUvs = __webpack_require__(/*! ./TextureUvs.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/TextureUvs.js");

const DEFAULT_UVS = new TextureUvs.TextureUvs();
function removeAllHandlers(tex) {
  tex.destroy = function _emptyDestroy() {
  };
  tex.on = function _emptyOn() {
  };
  tex.once = function _emptyOnce() {
  };
  tex.emit = function _emptyEmit() {
  };
}
class Texture extends utils.EventEmitter {
  constructor(baseTexture, frame, orig, trim, rotate, anchor, borders) {
    super();
    this.noFrame = false;
    if (!frame) {
      this.noFrame = true;
      frame = new math.Rectangle(0, 0, 1, 1);
    }
    if (baseTexture instanceof Texture) {
      baseTexture = baseTexture.baseTexture;
    }
    this.baseTexture = baseTexture;
    this._frame = frame;
    this.trim = trim;
    this.valid = false;
    this._uvs = DEFAULT_UVS;
    this.uvMatrix = null;
    this.orig = orig || frame;
    this._rotate = Number(rotate || 0);
    if (rotate === true) {
      this._rotate = 2;
    } else if (this._rotate % 2 !== 0) {
      throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
    }
    this.defaultAnchor = anchor ? new math.Point(anchor.x, anchor.y) : new math.Point(0, 0);
    this.defaultBorders = borders;
    this._updateID = 0;
    this.textureCacheIds = [];
    if (!baseTexture.valid) {
      baseTexture.once("loaded", this.onBaseTextureUpdated, this);
    } else if (this.noFrame) {
      if (baseTexture.valid) {
        this.onBaseTextureUpdated(baseTexture);
      }
    } else {
      this.frame = frame;
    }
    if (this.noFrame) {
      baseTexture.on("update", this.onBaseTextureUpdated, this);
    }
  }
  update() {
    if (this.baseTexture.resource) {
      this.baseTexture.resource.update();
    }
  }
  onBaseTextureUpdated(baseTexture) {
    if (this.noFrame) {
      if (!this.baseTexture.valid) {
        return;
      }
      this._frame.width = baseTexture.width;
      this._frame.height = baseTexture.height;
      this.valid = true;
      this.updateUvs();
    } else {
      this.frame = this._frame;
    }
    this.emit("update", this);
  }
  destroy(destroyBase) {
    if (this.baseTexture) {
      if (destroyBase) {
        const { resource } = this.baseTexture;
        if (resource?.url && utils.TextureCache[resource.url]) {
          Texture.removeFromCache(resource.url);
        }
        this.baseTexture.destroy();
      }
      this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
      this.baseTexture.off("update", this.onBaseTextureUpdated, this);
      this.baseTexture = null;
    }
    this._frame = null;
    this._uvs = null;
    this.trim = null;
    this.orig = null;
    this.valid = false;
    Texture.removeFromCache(this);
    this.textureCacheIds = null;
  }
  clone() {
    const clonedFrame = this._frame.clone();
    const clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();
    const clonedTexture = new Texture(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, this.trim?.clone(), this.rotate, this.defaultAnchor, this.defaultBorders);
    if (this.noFrame) {
      clonedTexture._frame = clonedFrame;
    }
    return clonedTexture;
  }
  updateUvs() {
    if (this._uvs === DEFAULT_UVS) {
      this._uvs = new TextureUvs.TextureUvs();
    }
    this._uvs.set(this._frame, this.baseTexture, this.rotate);
    this._updateID++;
  }
  static from(source, options = {}, strict = settings.settings.STRICT_TEXTURE_CACHE) {
    const isFrame = typeof source === "string";
    let cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else if (source instanceof BaseTexture.BaseTexture) {
      if (!source.cacheId) {
        const prefix = options?.pixiIdPrefix || "pixiid";
        source.cacheId = `${prefix}-${utils.uid()}`;
        BaseTexture.BaseTexture.addToCache(source, source.cacheId);
      }
      cacheId = source.cacheId;
    } else {
      if (!source._pixiId) {
        const prefix = options?.pixiIdPrefix || "pixiid";
        source._pixiId = `${prefix}_${utils.uid()}`;
      }
      cacheId = source._pixiId;
    }
    let texture = utils.TextureCache[cacheId];
    if (isFrame && strict && !texture) {
      throw new Error(`The cacheId "${cacheId}" does not exist in TextureCache.`);
    }
    if (!texture && !(source instanceof BaseTexture.BaseTexture)) {
      if (!options.resolution) {
        options.resolution = utils.getResolutionOfUrl(source);
      }
      texture = new Texture(new BaseTexture.BaseTexture(source, options));
      texture.baseTexture.cacheId = cacheId;
      BaseTexture.BaseTexture.addToCache(texture.baseTexture, cacheId);
      Texture.addToCache(texture, cacheId);
    } else if (!texture && source instanceof BaseTexture.BaseTexture) {
      texture = new Texture(source);
      Texture.addToCache(texture, cacheId);
    }
    return texture;
  }
  static fromURL(url, options) {
    const resourceOptions = Object.assign({ autoLoad: false }, options?.resourceOptions);
    const texture = Texture.from(url, Object.assign({ resourceOptions }, options), false);
    const resource = texture.baseTexture.resource;
    if (texture.baseTexture.valid) {
      return Promise.resolve(texture);
    }
    return resource.load().then(() => Promise.resolve(texture));
  }
  static fromBuffer(buffer, width, height, options) {
    return new Texture(BaseTexture.BaseTexture.fromBuffer(buffer, width, height, options));
  }
  static fromLoader(source, imageUrl, name, options) {
    const baseTexture = new BaseTexture.BaseTexture(source, Object.assign({
      scaleMode: BaseTexture.BaseTexture.defaultOptions.scaleMode,
      resolution: utils.getResolutionOfUrl(imageUrl)
    }, options));
    const { resource } = baseTexture;
    if (resource instanceof ImageResource.ImageResource) {
      resource.url = imageUrl;
    }
    const texture = new Texture(baseTexture);
    if (!name) {
      name = imageUrl;
    }
    BaseTexture.BaseTexture.addToCache(texture.baseTexture, name);
    Texture.addToCache(texture, name);
    if (name !== imageUrl) {
      BaseTexture.BaseTexture.addToCache(texture.baseTexture, imageUrl);
      Texture.addToCache(texture, imageUrl);
    }
    if (texture.baseTexture.valid) {
      return Promise.resolve(texture);
    }
    return new Promise((resolve) => {
      texture.baseTexture.once("loaded", () => resolve(texture));
    });
  }
  static addToCache(texture, id) {
    if (id) {
      if (!texture.textureCacheIds.includes(id)) {
        texture.textureCacheIds.push(id);
      }
      if (utils.TextureCache[id] && utils.TextureCache[id] !== texture) {
        console.warn(`Texture added to the cache with an id [${id}] that already had an entry`);
      }
      utils.TextureCache[id] = texture;
    }
  }
  static removeFromCache(texture) {
    if (typeof texture === "string") {
      const textureFromCache = utils.TextureCache[texture];
      if (textureFromCache) {
        const index = textureFromCache.textureCacheIds.indexOf(texture);
        if (index > -1) {
          textureFromCache.textureCacheIds.splice(index, 1);
        }
        delete utils.TextureCache[texture];
        return textureFromCache;
      }
    } else if (texture?.textureCacheIds) {
      for (let i = 0; i < texture.textureCacheIds.length; ++i) {
        if (utils.TextureCache[texture.textureCacheIds[i]] === texture) {
          delete utils.TextureCache[texture.textureCacheIds[i]];
        }
      }
      texture.textureCacheIds.length = 0;
      return texture;
    }
    return null;
  }
  get resolution() {
    return this.baseTexture.resolution;
  }
  get frame() {
    return this._frame;
  }
  set frame(frame) {
    this._frame = frame;
    this.noFrame = false;
    const { x, y, width, height } = frame;
    const xNotFit = x + width > this.baseTexture.width;
    const yNotFit = y + height > this.baseTexture.height;
    if (xNotFit || yNotFit) {
      const relationship = xNotFit && yNotFit ? "and" : "or";
      const errorX = `X: ${x} + ${width} = ${x + width} > ${this.baseTexture.width}`;
      const errorY = `Y: ${y} + ${height} = ${y + height} > ${this.baseTexture.height}`;
      throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${errorX} ${relationship} ${errorY}`);
    }
    this.valid = width && height && this.baseTexture.valid;
    if (!this.trim && !this.rotate) {
      this.orig = frame;
    }
    if (this.valid) {
      this.updateUvs();
    }
  }
  get rotate() {
    return this._rotate;
  }
  set rotate(rotate) {
    this._rotate = rotate;
    if (this.valid) {
      this.updateUvs();
    }
  }
  get width() {
    return this.orig.width;
  }
  get height() {
    return this.orig.height;
  }
  castToBaseTexture() {
    return this.baseTexture;
  }
  static get EMPTY() {
    if (!Texture._EMPTY) {
      Texture._EMPTY = new Texture(new BaseTexture.BaseTexture());
      removeAllHandlers(Texture._EMPTY);
      removeAllHandlers(Texture._EMPTY.baseTexture);
    }
    return Texture._EMPTY;
  }
  static get WHITE() {
    if (!Texture._WHITE) {
      const canvas = settings.settings.ADAPTER.createCanvas(16, 16);
      const context = canvas.getContext("2d");
      canvas.width = 16;
      canvas.height = 16;
      context.fillStyle = "white";
      context.fillRect(0, 0, 16, 16);
      Texture._WHITE = new Texture(BaseTexture.BaseTexture.from(canvas));
      removeAllHandlers(Texture._WHITE);
      removeAllHandlers(Texture._WHITE.baseTexture);
    }
    return Texture._WHITE;
  }
}

exports.Texture = Texture;
//# sourceMappingURL=Texture.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/TextureGCSystem.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/TextureGCSystem.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");

const _TextureGCSystem = class {
  constructor(renderer) {
    this.renderer = renderer;
    this.count = 0;
    this.checkCount = 0;
    this.maxIdle = _TextureGCSystem.defaultMaxIdle;
    this.checkCountMax = _TextureGCSystem.defaultCheckCountMax;
    this.mode = _TextureGCSystem.defaultMode;
  }
  postrender() {
    if (!this.renderer.objectRenderer.renderingToScreen) {
      return;
    }
    this.count++;
    if (this.mode === constants.GC_MODES.MANUAL) {
      return;
    }
    this.checkCount++;
    if (this.checkCount > this.checkCountMax) {
      this.checkCount = 0;
      this.run();
    }
  }
  run() {
    const tm = this.renderer.texture;
    const managedTextures = tm.managedTextures;
    let wasRemoved = false;
    for (let i = 0; i < managedTextures.length; i++) {
      const texture = managedTextures[i];
      if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
        tm.destroyTexture(texture, true);
        managedTextures[i] = null;
        wasRemoved = true;
      }
    }
    if (wasRemoved) {
      let j = 0;
      for (let i = 0; i < managedTextures.length; i++) {
        if (managedTextures[i] !== null) {
          managedTextures[j++] = managedTextures[i];
        }
      }
      managedTextures.length = j;
    }
  }
  unload(displayObject) {
    const tm = this.renderer.texture;
    const texture = displayObject._texture;
    if (texture && !texture.framebuffer) {
      tm.destroyTexture(texture);
    }
    for (let i = displayObject.children.length - 1; i >= 0; i--) {
      this.unload(displayObject.children[i]);
    }
  }
  destroy() {
    this.renderer = null;
  }
};
let TextureGCSystem = _TextureGCSystem;
TextureGCSystem.defaultMode = constants.GC_MODES.AUTO;
TextureGCSystem.defaultMaxIdle = 60 * 60;
TextureGCSystem.defaultCheckCountMax = 60 * 10;
TextureGCSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "textureGC"
};
extensions.extensions.add(TextureGCSystem);

exports.TextureGCSystem = TextureGCSystem;
//# sourceMappingURL=TextureGCSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/TextureMatrix.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/TextureMatrix.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var math = __webpack_require__(/*! @pixi/math */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/index.js");

const tempMat = new math.Matrix();
class TextureMatrix {
  constructor(texture, clampMargin) {
    this._texture = texture;
    this.mapCoord = new math.Matrix();
    this.uClampFrame = new Float32Array(4);
    this.uClampOffset = new Float32Array(2);
    this._textureID = -1;
    this._updateID = 0;
    this.clampOffset = 0;
    this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
    this.isSimple = false;
  }
  get texture() {
    return this._texture;
  }
  set texture(value) {
    this._texture = value;
    this._textureID = -1;
  }
  multiplyUvs(uvs, out) {
    if (out === void 0) {
      out = uvs;
    }
    const mat = this.mapCoord;
    for (let i = 0; i < uvs.length; i += 2) {
      const x = uvs[i];
      const y = uvs[i + 1];
      out[i] = x * mat.a + y * mat.c + mat.tx;
      out[i + 1] = x * mat.b + y * mat.d + mat.ty;
    }
    return out;
  }
  update(forceUpdate) {
    const tex = this._texture;
    if (!tex || !tex.valid) {
      return false;
    }
    if (!forceUpdate && this._textureID === tex._updateID) {
      return false;
    }
    this._textureID = tex._updateID;
    this._updateID++;
    const uvs = tex._uvs;
    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
    const orig = tex.orig;
    const trim = tex.trim;
    if (trim) {
      tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
      this.mapCoord.append(tempMat);
    }
    const texBase = tex.baseTexture;
    const frame = this.uClampFrame;
    const margin = this.clampMargin / texBase.resolution;
    const offset = this.clampOffset;
    frame[0] = (tex._frame.x + margin + offset) / texBase.width;
    frame[1] = (tex._frame.y + margin + offset) / texBase.height;
    frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
    frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
    this.uClampOffset[0] = offset / texBase.realWidth;
    this.uClampOffset[1] = offset / texBase.realHeight;
    this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
    return true;
  }
}

exports.TextureMatrix = TextureMatrix;
//# sourceMappingURL=TextureMatrix.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/TextureSystem.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/TextureSystem.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
var utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/index.js");
var BaseTexture = __webpack_require__(/*! ./BaseTexture.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/BaseTexture.js");
var GLTexture = __webpack_require__(/*! ./GLTexture.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/GLTexture.js");
var mapTypeAndFormatToInternalFormat = __webpack_require__(/*! ./utils/mapTypeAndFormatToInternalFormat.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/utils/mapTypeAndFormatToInternalFormat.js");

class TextureSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.boundTextures = [];
    this.currentLocation = -1;
    this.managedTextures = [];
    this._unknownBoundTextures = false;
    this.unknownTexture = new BaseTexture.BaseTexture();
    this.hasIntegerTextures = false;
  }
  contextChange() {
    const gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.webGLVersion = this.renderer.context.webGLVersion;
    this.internalFormats = mapTypeAndFormatToInternalFormat.mapTypeAndFormatToInternalFormat(gl);
    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.boundTextures.length = maxTextures;
    for (let i = 0; i < maxTextures; i++) {
      this.boundTextures[i] = null;
    }
    this.emptyTextures = {};
    const emptyTexture2D = new GLTexture.GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
    this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
    this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture.GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
    for (let i = 0; i < 6; i++) {
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    }
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    for (let i = 0; i < this.boundTextures.length; i++) {
      this.bind(null, i);
    }
  }
  bind(texture, location = 0) {
    const { gl } = this;
    texture = texture?.castToBaseTexture();
    if (texture?.valid && !texture.parentTextureArray) {
      texture.touched = this.renderer.textureGC.count;
      const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
      if (this.boundTextures[location] !== texture) {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        gl.bindTexture(texture.target, glTexture.texture);
      }
      if (glTexture.dirtyId !== texture.dirtyId) {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        this.updateTexture(texture);
      } else if (glTexture.dirtyStyleId !== texture.dirtyStyleId) {
        this.updateTextureStyle(texture);
      }
      this.boundTextures[location] = texture;
    } else {
      if (this.currentLocation !== location) {
        this.currentLocation = location;
        gl.activeTexture(gl.TEXTURE0 + location);
      }
      gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
      this.boundTextures[location] = null;
    }
  }
  reset() {
    this._unknownBoundTextures = true;
    this.hasIntegerTextures = false;
    this.currentLocation = -1;
    for (let i = 0; i < this.boundTextures.length; i++) {
      this.boundTextures[i] = this.unknownTexture;
    }
  }
  unbind(texture) {
    const { gl, boundTextures } = this;
    if (this._unknownBoundTextures) {
      this._unknownBoundTextures = false;
      for (let i = 0; i < boundTextures.length; i++) {
        if (boundTextures[i] === this.unknownTexture) {
          this.bind(null, i);
        }
      }
    }
    for (let i = 0; i < boundTextures.length; i++) {
      if (boundTextures[i] === texture) {
        if (this.currentLocation !== i) {
          gl.activeTexture(gl.TEXTURE0 + i);
          this.currentLocation = i;
        }
        gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);
        boundTextures[i] = null;
      }
    }
  }
  ensureSamplerType(maxTextures) {
    const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;
    if (!hasIntegerTextures) {
      return;
    }
    for (let i = maxTextures - 1; i >= 0; --i) {
      const tex = boundTextures[i];
      if (tex) {
        const glTexture = tex._glTextures[CONTEXT_UID];
        if (glTexture.samplerType !== constants.SAMPLER_TYPES.FLOAT) {
          this.renderer.texture.unbind(tex);
        }
      }
    }
  }
  initTexture(texture) {
    const glTexture = new GLTexture.GLTexture(this.gl.createTexture());
    glTexture.dirtyId = -1;
    texture._glTextures[this.CONTEXT_UID] = glTexture;
    this.managedTextures.push(texture);
    texture.on("dispose", this.destroyTexture, this);
    return glTexture;
  }
  initTextureType(texture, glTexture) {
    glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format;
    if (this.webGLVersion === 2 && texture.type === constants.TYPES.HALF_FLOAT) {
      glTexture.type = this.gl.HALF_FLOAT;
    } else {
      glTexture.type = texture.type;
    }
  }
  updateTexture(texture) {
    const glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    const renderer = this.renderer;
    this.initTextureType(texture, glTexture);
    if (texture.resource?.upload(renderer, texture, glTexture)) {
      if (glTexture.samplerType !== constants.SAMPLER_TYPES.FLOAT) {
        this.hasIntegerTextures = true;
      }
    } else {
      const width = texture.realWidth;
      const height = texture.realHeight;
      const gl = renderer.gl;
      if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);
      }
    }
    if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
      this.updateTextureStyle(texture);
    }
    glTexture.dirtyId = texture.dirtyId;
  }
  destroyTexture(texture, skipRemove) {
    const { gl } = this;
    texture = texture.castToBaseTexture();
    if (texture._glTextures[this.CONTEXT_UID]) {
      this.unbind(texture);
      gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
      texture.off("dispose", this.destroyTexture, this);
      delete texture._glTextures[this.CONTEXT_UID];
      if (!skipRemove) {
        const i = this.managedTextures.indexOf(texture);
        if (i !== -1) {
          utils.removeItems(this.managedTextures, i, 1);
        }
      }
    }
  }
  updateTextureStyle(texture) {
    const glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    if ((texture.mipmap === constants.MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
      glTexture.mipmap = false;
    } else {
      glTexture.mipmap = texture.mipmap >= 1;
    }
    if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
      glTexture.wrapMode = constants.WRAP_MODES.CLAMP;
    } else {
      glTexture.wrapMode = texture.wrapMode;
    }
    if (texture.resource?.style(this.renderer, texture, glTexture)) {
    } else {
      this.setStyle(texture, glTexture);
    }
    glTexture.dirtyStyleId = texture.dirtyStyleId;
  }
  setStyle(texture, glTexture) {
    const gl = this.gl;
    if (glTexture.mipmap && texture.mipmap !== constants.MIPMAP_MODES.ON_MANUAL) {
      gl.generateMipmap(texture.target);
    }
    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
    if (glTexture.mipmap) {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
      const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === constants.SCALE_MODES.LINEAR) {
        const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
        gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
      }
    } else {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
    }
    gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
  }
  destroy() {
    this.renderer = null;
  }
}
TextureSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "texture"
};
extensions.extensions.add(TextureSystem);

exports.TextureSystem = TextureSystem;
//# sourceMappingURL=TextureSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/TextureUvs.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/TextureUvs.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var math = __webpack_require__(/*! @pixi/math */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/index.js");

class TextureUvs {
  constructor() {
    this.x0 = 0;
    this.y0 = 0;
    this.x1 = 1;
    this.y1 = 0;
    this.x2 = 1;
    this.y2 = 1;
    this.x3 = 0;
    this.y3 = 1;
    this.uvsFloat32 = new Float32Array(8);
  }
  set(frame, baseFrame, rotate) {
    const tw = baseFrame.width;
    const th = baseFrame.height;
    if (rotate) {
      const w2 = frame.width / 2 / tw;
      const h2 = frame.height / 2 / th;
      const cX = frame.x / tw + w2;
      const cY = frame.y / th + h2;
      rotate = math.groupD8.add(rotate, math.groupD8.NW);
      this.x0 = cX + w2 * math.groupD8.uX(rotate);
      this.y0 = cY + h2 * math.groupD8.uY(rotate);
      rotate = math.groupD8.add(rotate, 2);
      this.x1 = cX + w2 * math.groupD8.uX(rotate);
      this.y1 = cY + h2 * math.groupD8.uY(rotate);
      rotate = math.groupD8.add(rotate, 2);
      this.x2 = cX + w2 * math.groupD8.uX(rotate);
      this.y2 = cY + h2 * math.groupD8.uY(rotate);
      rotate = math.groupD8.add(rotate, 2);
      this.x3 = cX + w2 * math.groupD8.uX(rotate);
      this.y3 = cY + h2 * math.groupD8.uY(rotate);
    } else {
      this.x0 = frame.x / tw;
      this.y0 = frame.y / th;
      this.x1 = (frame.x + frame.width) / tw;
      this.y1 = frame.y / th;
      this.x2 = (frame.x + frame.width) / tw;
      this.y2 = (frame.y + frame.height) / th;
      this.x3 = frame.x / tw;
      this.y3 = (frame.y + frame.height) / th;
    }
    this.uvsFloat32[0] = this.x0;
    this.uvsFloat32[1] = this.y0;
    this.uvsFloat32[2] = this.x1;
    this.uvsFloat32[3] = this.y1;
    this.uvsFloat32[4] = this.x2;
    this.uvsFloat32[5] = this.y2;
    this.uvsFloat32[6] = this.x3;
    this.uvsFloat32[7] = this.y3;
  }
  toString() {
    return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;
  }
}

exports.TextureUvs = TextureUvs;
//# sourceMappingURL=TextureUvs.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var BaseTexture = __webpack_require__(/*! ../BaseTexture.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/BaseTexture.js");
var autoDetectResource = __webpack_require__(/*! ./autoDetectResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/autoDetectResource.js");
var Resource = __webpack_require__(/*! ./Resource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/Resource.js");

class AbstractMultiResource extends Resource.Resource {
  constructor(length, options) {
    const { width, height } = options || {};
    super(width, height);
    this.items = [];
    this.itemDirtyIds = [];
    for (let i = 0; i < length; i++) {
      const partTexture = new BaseTexture.BaseTexture();
      this.items.push(partTexture);
      this.itemDirtyIds.push(-2);
    }
    this.length = length;
    this._load = null;
    this.baseTexture = null;
  }
  initFromArray(resources, options) {
    for (let i = 0; i < this.length; i++) {
      if (!resources[i]) {
        continue;
      }
      if (resources[i].castToBaseTexture) {
        this.addBaseTextureAt(resources[i].castToBaseTexture(), i);
      } else if (resources[i] instanceof Resource.Resource) {
        this.addResourceAt(resources[i], i);
      } else {
        this.addResourceAt(autoDetectResource.autoDetectResource(resources[i], options), i);
      }
    }
  }
  dispose() {
    for (let i = 0, len = this.length; i < len; i++) {
      this.items[i].destroy();
    }
    this.items = null;
    this.itemDirtyIds = null;
    this._load = null;
  }
  addResourceAt(resource, index) {
    if (!this.items[index]) {
      throw new Error(`Index ${index} is out of bounds`);
    }
    if (resource.valid && !this.valid) {
      this.resize(resource.width, resource.height);
    }
    this.items[index].setResource(resource);
    return this;
  }
  bind(baseTexture) {
    if (this.baseTexture !== null) {
      throw new Error("Only one base texture per TextureArray is allowed");
    }
    super.bind(baseTexture);
    for (let i = 0; i < this.length; i++) {
      this.items[i].parentTextureArray = baseTexture;
      this.items[i].on("update", baseTexture.update, baseTexture);
    }
  }
  unbind(baseTexture) {
    super.unbind(baseTexture);
    for (let i = 0; i < this.length; i++) {
      this.items[i].parentTextureArray = null;
      this.items[i].off("update", baseTexture.update, baseTexture);
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    const resources = this.items.map((item) => item.resource).filter((item) => item);
    const promises = resources.map((item) => item.load());
    this._load = Promise.all(promises).then(() => {
      const { realWidth, realHeight } = this.items[0];
      this.resize(realWidth, realHeight);
      return Promise.resolve(this);
    });
    return this._load;
  }
}

exports.AbstractMultiResource = AbstractMultiResource;
//# sourceMappingURL=AbstractMultiResource.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/ArrayResource.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/ArrayResource.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var AbstractMultiResource = __webpack_require__(/*! ./AbstractMultiResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.js");

class ArrayResource extends AbstractMultiResource.AbstractMultiResource {
  constructor(source, options) {
    const { width, height } = options || {};
    let urls;
    let length;
    if (Array.isArray(source)) {
      urls = source;
      length = source.length;
    } else {
      length = source;
    }
    super(length, { width, height });
    if (urls) {
      this.initFromArray(urls, options);
    }
  }
  addBaseTextureAt(baseTexture, index) {
    if (baseTexture.resource) {
      this.addResourceAt(baseTexture.resource, index);
    } else {
      throw new Error("ArrayResource does not support RenderTexture");
    }
    return this;
  }
  bind(baseTexture) {
    super.bind(baseTexture);
    baseTexture.target = constants.TARGETS.TEXTURE_2D_ARRAY;
  }
  upload(renderer, texture, glTexture) {
    const { length, itemDirtyIds, items } = this;
    const { gl } = renderer;
    if (glTexture.dirtyId < 0) {
      gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length, 0, texture.format, glTexture.type, null);
    }
    for (let i = 0; i < length; i++) {
      const item = items[i];
      if (itemDirtyIds[i] < item.dirtyId) {
        itemDirtyIds[i] = item.dirtyId;
        if (item.valid) {
          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i, item.resource.width, item.resource.height, 1, texture.format, glTexture.type, item.resource.source);
        }
      }
    }
    return true;
  }
}

exports.ArrayResource = ArrayResource;
//# sourceMappingURL=ArrayResource.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/index.js");
var Resource = __webpack_require__(/*! ./Resource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/Resource.js");

class BaseImageResource extends Resource.Resource {
  constructor(source) {
    const sourceAny = source;
    const width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
    const height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
    super(width, height);
    this.source = source;
    this.noSubImage = false;
  }
  static crossOrigin(element, url, crossorigin) {
    if (crossorigin === void 0 && !url.startsWith("data:")) {
      element.crossOrigin = utils.determineCrossOrigin(url);
    } else if (crossorigin !== false) {
      element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
    }
  }
  upload(renderer, baseTexture, glTexture, source) {
    const gl = renderer.gl;
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    source = source || this.source;
    if (typeof HTMLImageElement !== "undefined" && source instanceof HTMLImageElement) {
      if (!source.complete || source.naturalWidth === 0) {
        return false;
      }
    } else if (typeof HTMLVideoElement !== "undefined" && source instanceof HTMLVideoElement) {
      if (source.readyState <= 1 && source.buffered.length === 0) {
        return false;
      }
    }
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === constants.ALPHA_MODES.UNPACK);
    if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);
    }
    return true;
  }
  update() {
    if (this.destroyed) {
      return;
    }
    const source = this.source;
    const width = source.naturalWidth || source.videoWidth || source.width;
    const height = source.naturalHeight || source.videoHeight || source.height;
    this.resize(width, height);
    super.update();
  }
  dispose() {
    this.source = null;
  }
}

exports.BaseImageResource = BaseImageResource;
//# sourceMappingURL=BaseImageResource.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/BufferResource.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/BufferResource.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var Resource = __webpack_require__(/*! ./Resource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/Resource.js");

class BufferResource extends Resource.Resource {
  constructor(source, options) {
    const { width, height } = options || {};
    if (!width || !height) {
      throw new Error("BufferResource width or height invalid");
    }
    super(width, height);
    this.data = source;
  }
  upload(renderer, baseTexture, glTexture) {
    const gl = renderer.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === constants.ALPHA_MODES.UNPACK);
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  }
  dispose() {
    this.data = null;
  }
  static test(source) {
    return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
  }
}

exports.BufferResource = BufferResource;
//# sourceMappingURL=BufferResource.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/CanvasResource.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/CanvasResource.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var BaseImageResource = __webpack_require__(/*! ./BaseImageResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js");

class CanvasResource extends BaseImageResource.BaseImageResource {
  constructor(source) {
    super(source);
  }
  static test(source) {
    const { OffscreenCanvas } = globalThis;
    if (OffscreenCanvas && source instanceof OffscreenCanvas) {
      return true;
    }
    return globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;
  }
}

exports.CanvasResource = CanvasResource;
//# sourceMappingURL=CanvasResource.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/CubeResource.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/CubeResource.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var AbstractMultiResource = __webpack_require__(/*! ./AbstractMultiResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.js");

const _CubeResource = class extends AbstractMultiResource.AbstractMultiResource {
  constructor(source, options) {
    const { width, height, autoLoad, linkBaseTexture } = options || {};
    if (source && source.length !== _CubeResource.SIDES) {
      throw new Error(`Invalid length. Got ${source.length}, expected 6`);
    }
    super(6, { width, height });
    for (let i = 0; i < _CubeResource.SIDES; i++) {
      this.items[i].target = constants.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;
    }
    this.linkBaseTexture = linkBaseTexture !== false;
    if (source) {
      this.initFromArray(source, options);
    }
    if (autoLoad !== false) {
      this.load();
    }
  }
  bind(baseTexture) {
    super.bind(baseTexture);
    baseTexture.target = constants.TARGETS.TEXTURE_CUBE_MAP;
  }
  addBaseTextureAt(baseTexture, index, linkBaseTexture) {
    if (linkBaseTexture === void 0) {
      linkBaseTexture = this.linkBaseTexture;
    }
    if (!this.items[index]) {
      throw new Error(`Index ${index} is out of bounds`);
    }
    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
      if (baseTexture.resource) {
        this.addResourceAt(baseTexture.resource, index);
      } else {
        throw new Error(`CubeResource does not support copying of renderTexture.`);
      }
    } else {
      baseTexture.target = constants.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index;
      baseTexture.parentTextureArray = this.baseTexture;
      this.items[index] = baseTexture;
    }
    if (baseTexture.valid && !this.valid) {
      this.resize(baseTexture.realWidth, baseTexture.realHeight);
    }
    this.items[index] = baseTexture;
    return this;
  }
  upload(renderer, _baseTexture, glTexture) {
    const dirty = this.itemDirtyIds;
    for (let i = 0; i < _CubeResource.SIDES; i++) {
      const side = this.items[i];
      if (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) {
        if (side.valid && side.resource) {
          side.resource.upload(renderer, side, glTexture);
          dirty[i] = side.dirtyId;
        } else if (dirty[i] < -1) {
          renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
          dirty[i] = -1;
        }
      }
    }
    return true;
  }
  static test(source) {
    return Array.isArray(source) && source.length === _CubeResource.SIDES;
  }
};
let CubeResource = _CubeResource;
CubeResource.SIDES = 6;

exports.CubeResource = CubeResource;
//# sourceMappingURL=CubeResource.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/DepthResource.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/DepthResource.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var BufferResource = __webpack_require__(/*! ./BufferResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/BufferResource.js");

class DepthResource extends BufferResource.BufferResource {
  upload(renderer, baseTexture, glTexture) {
    const gl = renderer.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === constants.ALPHA_MODES.UNPACK);
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  }
}

exports.DepthResource = DepthResource;
//# sourceMappingURL=DepthResource.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");
var BaseImageResource = __webpack_require__(/*! ./BaseImageResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js");

class ImageBitmapResource extends BaseImageResource.BaseImageResource {
  constructor(source, options) {
    options = options || {};
    let baseSource;
    let url;
    if (typeof source === "string") {
      baseSource = ImageBitmapResource.EMPTY;
      url = source;
    } else {
      baseSource = source;
      url = null;
    }
    super(baseSource);
    this.url = url;
    this.crossOrigin = options.crossOrigin ?? true;
    this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
    this._load = null;
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = new Promise(async (resolve, reject) => {
      if (this.url === null) {
        resolve(this);
        return;
      }
      try {
        const response = await settings.settings.ADAPTER.fetch(this.url, {
          mode: this.crossOrigin ? "cors" : "no-cors"
        });
        if (this.destroyed)
          return;
        const imageBlob = await response.blob();
        if (this.destroyed)
          return;
        const imageBitmap = await createImageBitmap(imageBlob, {
          premultiplyAlpha: this.alphaMode === null || this.alphaMode === constants.ALPHA_MODES.UNPACK ? "premultiply" : "none"
        });
        if (this.destroyed)
          return;
        this.source = imageBitmap;
        this.update();
        resolve(this);
      } catch (e) {
        if (this.destroyed)
          return;
        reject(e);
        this.onError.emit(e);
      }
    });
    return this._load;
  }
  upload(renderer, baseTexture, glTexture) {
    if (!(this.source instanceof ImageBitmap)) {
      this.load();
      return false;
    }
    if (typeof this.alphaMode === "number") {
      baseTexture.alphaMode = this.alphaMode;
    }
    return super.upload(renderer, baseTexture, glTexture);
  }
  dispose() {
    if (this.source instanceof ImageBitmap) {
      this.source.close();
    }
    super.dispose();
    this._load = null;
  }
  static test(source) {
    return !!globalThis.createImageBitmap && typeof ImageBitmap !== "undefined" && (typeof source === "string" || source instanceof ImageBitmap);
  }
  static get EMPTY() {
    ImageBitmapResource._EMPTY = ImageBitmapResource._EMPTY ?? settings.settings.ADAPTER.createCanvas(0, 0);
    return ImageBitmapResource._EMPTY;
  }
}

exports.ImageBitmapResource = ImageBitmapResource;
//# sourceMappingURL=ImageBitmapResource.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/ImageResource.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/ImageResource.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");
var BaseImageResource = __webpack_require__(/*! ./BaseImageResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js");

class ImageResource extends BaseImageResource.BaseImageResource {
  constructor(source, options) {
    options = options || {};
    if (typeof source === "string") {
      const imageElement = new Image();
      BaseImageResource.BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
      imageElement.src = source;
      source = imageElement;
    }
    super(source);
    if (!source.complete && !!this._width && !!this._height) {
      this._width = 0;
      this._height = 0;
    }
    this.url = source.src;
    this._process = null;
    this.preserveBitmap = false;
    this.createBitmap = (options.createBitmap ?? settings.settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;
    this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
    this.bitmap = null;
    this._load = null;
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  load(createBitmap) {
    if (this._load) {
      return this._load;
    }
    if (createBitmap !== void 0) {
      this.createBitmap = createBitmap;
    }
    this._load = new Promise((resolve, reject) => {
      const source = this.source;
      this.url = source.src;
      const completed = () => {
        if (this.destroyed) {
          return;
        }
        source.onload = null;
        source.onerror = null;
        this.resize(source.width, source.height);
        this._load = null;
        if (this.createBitmap) {
          resolve(this.process());
        } else {
          resolve(this);
        }
      };
      if (source.complete && source.src) {
        completed();
      } else {
        source.onload = completed;
        source.onerror = (event) => {
          reject(event);
          this.onError.emit(event);
        };
      }
    });
    return this._load;
  }
  process() {
    const source = this.source;
    if (this._process !== null) {
      return this._process;
    }
    if (this.bitmap !== null || !globalThis.createImageBitmap) {
      return Promise.resolve(this);
    }
    const createImageBitmap = globalThis.createImageBitmap;
    const cors = !source.crossOrigin || source.crossOrigin === "anonymous";
    this._process = fetch(source.src, {
      mode: cors ? "cors" : "no-cors"
    }).then((r) => r.blob()).then((blob) => createImageBitmap(blob, 0, 0, source.width, source.height, {
      premultiplyAlpha: this.alphaMode === null || this.alphaMode === constants.ALPHA_MODES.UNPACK ? "premultiply" : "none"
    })).then((bitmap) => {
      if (this.destroyed) {
        return Promise.reject();
      }
      this.bitmap = bitmap;
      this.update();
      this._process = null;
      return Promise.resolve(this);
    });
    return this._process;
  }
  upload(renderer, baseTexture, glTexture) {
    if (typeof this.alphaMode === "number") {
      baseTexture.alphaMode = this.alphaMode;
    }
    if (!this.createBitmap) {
      return super.upload(renderer, baseTexture, glTexture);
    }
    if (!this.bitmap) {
      this.process();
      if (!this.bitmap) {
        return false;
      }
    }
    super.upload(renderer, baseTexture, glTexture, this.bitmap);
    if (!this.preserveBitmap) {
      let flag = true;
      const glTextures = baseTexture._glTextures;
      for (const key in glTextures) {
        const otherTex = glTextures[key];
        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
          flag = false;
          break;
        }
      }
      if (flag) {
        if (this.bitmap.close) {
          this.bitmap.close();
        }
        this.bitmap = null;
      }
    }
    return true;
  }
  dispose() {
    this.source.onload = null;
    this.source.onerror = null;
    super.dispose();
    if (this.bitmap) {
      this.bitmap.close();
      this.bitmap = null;
    }
    this._process = null;
    this._load = null;
  }
  static test(source) {
    return typeof HTMLImageElement !== "undefined" && (typeof source === "string" || source instanceof HTMLImageElement);
  }
}

exports.ImageResource = ImageResource;
//# sourceMappingURL=ImageResource.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/Resource.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/Resource.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var runner = __webpack_require__(/*! @pixi/runner */ "./node_modules/pixi.js/node_modules/@pixi/runner/lib/index.js");

class Resource {
  constructor(width = 0, height = 0) {
    this._width = width;
    this._height = height;
    this.destroyed = false;
    this.internal = false;
    this.onResize = new runner.Runner("setRealSize");
    this.onUpdate = new runner.Runner("update");
    this.onError = new runner.Runner("onError");
  }
  bind(baseTexture) {
    this.onResize.add(baseTexture);
    this.onUpdate.add(baseTexture);
    this.onError.add(baseTexture);
    if (this._width || this._height) {
      this.onResize.emit(this._width, this._height);
    }
  }
  unbind(baseTexture) {
    this.onResize.remove(baseTexture);
    this.onUpdate.remove(baseTexture);
    this.onError.remove(baseTexture);
  }
  resize(width, height) {
    if (width !== this._width || height !== this._height) {
      this._width = width;
      this._height = height;
      this.onResize.emit(width, height);
    }
  }
  get valid() {
    return !!this._width && !!this._height;
  }
  update() {
    if (!this.destroyed) {
      this.onUpdate.emit();
    }
  }
  load() {
    return Promise.resolve(this);
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  style(_renderer, _baseTexture, _glTexture) {
    return false;
  }
  dispose() {
  }
  destroy() {
    if (!this.destroyed) {
      this.destroyed = true;
      this.dispose();
      this.onError.removeAll();
      this.onError = null;
      this.onResize.removeAll();
      this.onResize = null;
      this.onUpdate.removeAll();
      this.onUpdate = null;
    }
  }
  static test(_source, _extension) {
    return false;
  }
}

exports.Resource = Resource;
//# sourceMappingURL=Resource.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/SVGResource.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/SVGResource.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");
var utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/index.js");
var BaseImageResource = __webpack_require__(/*! ./BaseImageResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js");

const _SVGResource = class extends BaseImageResource.BaseImageResource {
  constructor(sourceBase64, options) {
    options = options || {};
    super(settings.settings.ADAPTER.createCanvas());
    this._width = 0;
    this._height = 0;
    this.svg = sourceBase64;
    this.scale = options.scale || 1;
    this._overrideWidth = options.width;
    this._overrideHeight = options.height;
    this._resolve = null;
    this._crossorigin = options.crossorigin;
    this._load = null;
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = new Promise((resolve) => {
      this._resolve = () => {
        this.resize(this.source.width, this.source.height);
        resolve(this);
      };
      if (_SVGResource.SVG_XML.test(this.svg.trim())) {
        if (!btoa) {
          throw new Error("Your browser doesn't support base64 conversions.");
        }
        this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;
      }
      this._loadSvg();
    });
    return this._load;
  }
  _loadSvg() {
    const tempImage = new Image();
    BaseImageResource.BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
    tempImage.src = this.svg;
    tempImage.onerror = (event) => {
      if (!this._resolve) {
        return;
      }
      tempImage.onerror = null;
      this.onError.emit(event);
    };
    tempImage.onload = () => {
      if (!this._resolve) {
        return;
      }
      const svgWidth = tempImage.width;
      const svgHeight = tempImage.height;
      if (!svgWidth || !svgHeight) {
        throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
      }
      let width = svgWidth * this.scale;
      let height = svgHeight * this.scale;
      if (this._overrideWidth || this._overrideHeight) {
        width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth;
        height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight;
      }
      width = Math.round(width);
      height = Math.round(height);
      const canvas = this.source;
      canvas.width = width;
      canvas.height = height;
      canvas._pixiId = `canvas_${utils.uid()}`;
      canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
      this._resolve();
      this._resolve = null;
    };
  }
  static getSize(svgString) {
    const sizeMatch = _SVGResource.SVG_SIZE.exec(svgString);
    const size = {};
    if (sizeMatch) {
      size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
      size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
    }
    return size;
  }
  dispose() {
    super.dispose();
    this._resolve = null;
    this._crossorigin = null;
  }
  static test(source, extension) {
    return extension === "svg" || typeof source === "string" && source.startsWith("data:image/svg+xml") || typeof source === "string" && _SVGResource.SVG_XML.test(source);
  }
};
let SVGResource = _SVGResource;
SVGResource.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
SVGResource.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;

exports.SVGResource = SVGResource;
//# sourceMappingURL=SVGResource.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/VideoResource.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/VideoResource.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var ticker = __webpack_require__(/*! @pixi/ticker */ "./node_modules/pixi.js/node_modules/@pixi/ticker/lib/index.js");
var BaseImageResource = __webpack_require__(/*! ./BaseImageResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js");

const _VideoResource = class extends BaseImageResource.BaseImageResource {
  constructor(source, options) {
    options = options || {};
    if (!(source instanceof HTMLVideoElement)) {
      const videoElement = document.createElement("video");
      videoElement.setAttribute("preload", "auto");
      videoElement.setAttribute("webkit-playsinline", "");
      videoElement.setAttribute("playsinline", "");
      if (typeof source === "string") {
        source = [source];
      }
      const firstSrc = source[0].src || source[0];
      BaseImageResource.BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
      for (let i = 0; i < source.length; ++i) {
        const sourceElement = document.createElement("source");
        let { src, mime } = source[i];
        src = src || source[i];
        const baseSrc = src.split("?").shift().toLowerCase();
        const ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
        mime = mime || _VideoResource.MIME_TYPES[ext] || `video/${ext}`;
        sourceElement.src = src;
        sourceElement.type = mime;
        videoElement.appendChild(sourceElement);
      }
      source = videoElement;
    }
    super(source);
    this.noSubImage = true;
    this._autoUpdate = true;
    this._isConnectedToTicker = false;
    this._updateFPS = options.updateFPS || 0;
    this._msToNextUpdate = 0;
    this.autoPlay = options.autoPlay !== false;
    this._load = null;
    this._resolve = null;
    this._onCanPlay = this._onCanPlay.bind(this);
    this._onError = this._onError.bind(this);
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  update(_deltaTime = 0) {
    if (!this.destroyed) {
      const elapsedMS = ticker.Ticker.shared.elapsedMS * this.source.playbackRate;
      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
      if (!this._updateFPS || this._msToNextUpdate <= 0) {
        super.update();
        this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
      }
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    const source = this.source;
    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
      source.complete = true;
    }
    source.addEventListener("play", this._onPlayStart.bind(this));
    source.addEventListener("pause", this._onPlayStop.bind(this));
    if (!this._isSourceReady()) {
      source.addEventListener("canplay", this._onCanPlay);
      source.addEventListener("canplaythrough", this._onCanPlay);
      source.addEventListener("error", this._onError, true);
    } else {
      this._onCanPlay();
    }
    this._load = new Promise((resolve) => {
      if (this.valid) {
        resolve(this);
      } else {
        this._resolve = resolve;
        source.load();
      }
    });
    return this._load;
  }
  _onError(event) {
    this.source.removeEventListener("error", this._onError, true);
    this.onError.emit(event);
  }
  _isSourcePlaying() {
    const source = this.source;
    return !source.paused && !source.ended && this._isSourceReady();
  }
  _isSourceReady() {
    const source = this.source;
    return source.readyState > 2;
  }
  _onPlayStart() {
    if (!this.valid) {
      this._onCanPlay();
    }
    if (this.autoUpdate && !this._isConnectedToTicker) {
      ticker.Ticker.shared.add(this.update, this);
      this._isConnectedToTicker = true;
    }
  }
  _onPlayStop() {
    if (this._isConnectedToTicker) {
      ticker.Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  }
  _onCanPlay() {
    const source = this.source;
    source.removeEventListener("canplay", this._onCanPlay);
    source.removeEventListener("canplaythrough", this._onCanPlay);
    const valid = this.valid;
    this.resize(source.videoWidth, source.videoHeight);
    if (!valid && this._resolve) {
      this._resolve(this);
      this._resolve = null;
    }
    if (this._isSourcePlaying()) {
      this._onPlayStart();
    } else if (this.autoPlay) {
      source.play();
    }
  }
  dispose() {
    if (this._isConnectedToTicker) {
      ticker.Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
    const source = this.source;
    if (source) {
      source.removeEventListener("error", this._onError, true);
      source.pause();
      source.src = "";
      source.load();
    }
    super.dispose();
  }
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      if (!this._autoUpdate && this._isConnectedToTicker) {
        ticker.Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
        ticker.Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    }
  }
  get updateFPS() {
    return this._updateFPS;
  }
  set updateFPS(value) {
    if (value !== this._updateFPS) {
      this._updateFPS = value;
    }
  }
  static test(source, extension) {
    return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || _VideoResource.TYPES.includes(extension);
  }
};
let VideoResource = _VideoResource;
VideoResource.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
VideoResource.MIME_TYPES = {
  ogv: "video/ogg",
  mov: "video/quicktime",
  m4v: "video/mp4"
};

exports.VideoResource = VideoResource;
//# sourceMappingURL=VideoResource.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/autoDetectResource.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/autoDetectResource.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const INSTALLED = [];
function autoDetectResource(source, options) {
  if (!source) {
    return null;
  }
  let extension = "";
  if (typeof source === "string") {
    const result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
    if (result) {
      extension = result[1].toLowerCase();
    }
  }
  for (let i = INSTALLED.length - 1; i >= 0; --i) {
    const ResourcePlugin = INSTALLED[i];
    if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
      return new ResourcePlugin(source, options);
    }
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}

exports.INSTALLED = INSTALLED;
exports.autoDetectResource = autoDetectResource;
//# sourceMappingURL=autoDetectResource.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/index.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var ArrayResource = __webpack_require__(/*! ./ArrayResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/ArrayResource.js");
var autoDetectResource = __webpack_require__(/*! ./autoDetectResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/autoDetectResource.js");
var BufferResource = __webpack_require__(/*! ./BufferResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/BufferResource.js");
var CanvasResource = __webpack_require__(/*! ./CanvasResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/CanvasResource.js");
var CubeResource = __webpack_require__(/*! ./CubeResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/CubeResource.js");
var ImageBitmapResource = __webpack_require__(/*! ./ImageBitmapResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.js");
var ImageResource = __webpack_require__(/*! ./ImageResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/ImageResource.js");
var SVGResource = __webpack_require__(/*! ./SVGResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/SVGResource.js");
var VideoResource = __webpack_require__(/*! ./VideoResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/VideoResource.js");
var BaseImageResource = __webpack_require__(/*! ./BaseImageResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js");
var Resource = __webpack_require__(/*! ./Resource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/Resource.js");
var AbstractMultiResource = __webpack_require__(/*! ./AbstractMultiResource.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.js");

autoDetectResource.INSTALLED.push(ImageBitmapResource.ImageBitmapResource, ImageResource.ImageResource, CanvasResource.CanvasResource, VideoResource.VideoResource, SVGResource.SVGResource, BufferResource.BufferResource, CubeResource.CubeResource, ArrayResource.ArrayResource);

exports.ArrayResource = ArrayResource.ArrayResource;
exports.INSTALLED = autoDetectResource.INSTALLED;
exports.autoDetectResource = autoDetectResource.autoDetectResource;
exports.BufferResource = BufferResource.BufferResource;
exports.CanvasResource = CanvasResource.CanvasResource;
exports.CubeResource = CubeResource.CubeResource;
exports.ImageBitmapResource = ImageBitmapResource.ImageBitmapResource;
exports.ImageResource = ImageResource.ImageResource;
exports.SVGResource = SVGResource.SVGResource;
exports.VideoResource = VideoResource.VideoResource;
exports.BaseImageResource = BaseImageResource.BaseImageResource;
exports.Resource = Resource.Resource;
exports.AbstractMultiResource = AbstractMultiResource.AbstractMultiResource;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/utils/mapTypeAndFormatToInternalFormat.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/textures/utils/mapTypeAndFormatToInternalFormat.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");

function mapTypeAndFormatToInternalFormat(gl) {
  let table;
  if ("WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext) {
    table = {
      [constants.TYPES.UNSIGNED_BYTE]: {
        [constants.FORMATS.RGBA]: gl.RGBA8,
        [constants.FORMATS.RGB]: gl.RGB8,
        [constants.FORMATS.RG]: gl.RG8,
        [constants.FORMATS.RED]: gl.R8,
        [constants.FORMATS.RGBA_INTEGER]: gl.RGBA8UI,
        [constants.FORMATS.RGB_INTEGER]: gl.RGB8UI,
        [constants.FORMATS.RG_INTEGER]: gl.RG8UI,
        [constants.FORMATS.RED_INTEGER]: gl.R8UI,
        [constants.FORMATS.ALPHA]: gl.ALPHA,
        [constants.FORMATS.LUMINANCE]: gl.LUMINANCE,
        [constants.FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
      },
      [constants.TYPES.BYTE]: {
        [constants.FORMATS.RGBA]: gl.RGBA8_SNORM,
        [constants.FORMATS.RGB]: gl.RGB8_SNORM,
        [constants.FORMATS.RG]: gl.RG8_SNORM,
        [constants.FORMATS.RED]: gl.R8_SNORM,
        [constants.FORMATS.RGBA_INTEGER]: gl.RGBA8I,
        [constants.FORMATS.RGB_INTEGER]: gl.RGB8I,
        [constants.FORMATS.RG_INTEGER]: gl.RG8I,
        [constants.FORMATS.RED_INTEGER]: gl.R8I
      },
      [constants.TYPES.UNSIGNED_SHORT]: {
        [constants.FORMATS.RGBA_INTEGER]: gl.RGBA16UI,
        [constants.FORMATS.RGB_INTEGER]: gl.RGB16UI,
        [constants.FORMATS.RG_INTEGER]: gl.RG16UI,
        [constants.FORMATS.RED_INTEGER]: gl.R16UI,
        [constants.FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT16
      },
      [constants.TYPES.SHORT]: {
        [constants.FORMATS.RGBA_INTEGER]: gl.RGBA16I,
        [constants.FORMATS.RGB_INTEGER]: gl.RGB16I,
        [constants.FORMATS.RG_INTEGER]: gl.RG16I,
        [constants.FORMATS.RED_INTEGER]: gl.R16I
      },
      [constants.TYPES.UNSIGNED_INT]: {
        [constants.FORMATS.RGBA_INTEGER]: gl.RGBA32UI,
        [constants.FORMATS.RGB_INTEGER]: gl.RGB32UI,
        [constants.FORMATS.RG_INTEGER]: gl.RG32UI,
        [constants.FORMATS.RED_INTEGER]: gl.R32UI,
        [constants.FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT24
      },
      [constants.TYPES.INT]: {
        [constants.FORMATS.RGBA_INTEGER]: gl.RGBA32I,
        [constants.FORMATS.RGB_INTEGER]: gl.RGB32I,
        [constants.FORMATS.RG_INTEGER]: gl.RG32I,
        [constants.FORMATS.RED_INTEGER]: gl.R32I
      },
      [constants.TYPES.FLOAT]: {
        [constants.FORMATS.RGBA]: gl.RGBA32F,
        [constants.FORMATS.RGB]: gl.RGB32F,
        [constants.FORMATS.RG]: gl.RG32F,
        [constants.FORMATS.RED]: gl.R32F,
        [constants.FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT32F
      },
      [constants.TYPES.HALF_FLOAT]: {
        [constants.FORMATS.RGBA]: gl.RGBA16F,
        [constants.FORMATS.RGB]: gl.RGB16F,
        [constants.FORMATS.RG]: gl.RG16F,
        [constants.FORMATS.RED]: gl.R16F
      },
      [constants.TYPES.UNSIGNED_SHORT_5_6_5]: {
        [constants.FORMATS.RGB]: gl.RGB565
      },
      [constants.TYPES.UNSIGNED_SHORT_4_4_4_4]: {
        [constants.FORMATS.RGBA]: gl.RGBA4
      },
      [constants.TYPES.UNSIGNED_SHORT_5_5_5_1]: {
        [constants.FORMATS.RGBA]: gl.RGB5_A1
      },
      [constants.TYPES.UNSIGNED_INT_2_10_10_10_REV]: {
        [constants.FORMATS.RGBA]: gl.RGB10_A2,
        [constants.FORMATS.RGBA_INTEGER]: gl.RGB10_A2UI
      },
      [constants.TYPES.UNSIGNED_INT_10F_11F_11F_REV]: {
        [constants.FORMATS.RGB]: gl.R11F_G11F_B10F
      },
      [constants.TYPES.UNSIGNED_INT_5_9_9_9_REV]: {
        [constants.FORMATS.RGB]: gl.RGB9_E5
      },
      [constants.TYPES.UNSIGNED_INT_24_8]: {
        [constants.FORMATS.DEPTH_STENCIL]: gl.DEPTH24_STENCIL8
      },
      [constants.TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
        [constants.FORMATS.DEPTH_STENCIL]: gl.DEPTH32F_STENCIL8
      }
    };
  } else {
    table = {
      [constants.TYPES.UNSIGNED_BYTE]: {
        [constants.FORMATS.RGBA]: gl.RGBA,
        [constants.FORMATS.RGB]: gl.RGB,
        [constants.FORMATS.ALPHA]: gl.ALPHA,
        [constants.FORMATS.LUMINANCE]: gl.LUMINANCE,
        [constants.FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
      },
      [constants.TYPES.UNSIGNED_SHORT_5_6_5]: {
        [constants.FORMATS.RGB]: gl.RGB
      },
      [constants.TYPES.UNSIGNED_SHORT_4_4_4_4]: {
        [constants.FORMATS.RGBA]: gl.RGBA
      },
      [constants.TYPES.UNSIGNED_SHORT_5_5_5_1]: {
        [constants.FORMATS.RGBA]: gl.RGBA
      }
    };
  }
  return table;
}

exports.mapTypeAndFormatToInternalFormat = mapTypeAndFormatToInternalFormat;
//# sourceMappingURL=mapTypeAndFormatToInternalFormat.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/transformFeedback/TransformFeedback.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/transformFeedback/TransformFeedback.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var runner = __webpack_require__(/*! @pixi/runner */ "./node_modules/pixi.js/node_modules/@pixi/runner/lib/index.js");

class TransformFeedback {
  constructor() {
    this._glTransformFeedbacks = {};
    this.buffers = [];
    this.disposeRunner = new runner.Runner("disposeTransformFeedback");
  }
  bindBuffer(index, buffer) {
    this.buffers[index] = buffer;
  }
  destroy() {
    this.disposeRunner.emit(this, false);
  }
}

exports.TransformFeedback = TransformFeedback;
//# sourceMappingURL=TransformFeedback.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");

class TransformFeedbackSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  contextChange() {
    this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }
  bind(transformFeedback) {
    const { gl, CONTEXT_UID } = this;
    const glTransformFeedback = transformFeedback._glTransformFeedbacks[CONTEXT_UID] || this.createGLTransformFeedback(transformFeedback);
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
  }
  unbind() {
    const { gl } = this;
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
  }
  beginTransformFeedback(drawMode, shader) {
    const { gl, renderer } = this;
    if (shader) {
      renderer.shader.bind(shader);
    }
    gl.beginTransformFeedback(drawMode);
  }
  endTransformFeedback() {
    const { gl } = this;
    gl.endTransformFeedback();
  }
  createGLTransformFeedback(tf) {
    const { gl, renderer, CONTEXT_UID } = this;
    const glTransformFeedback = gl.createTransformFeedback();
    tf._glTransformFeedbacks[CONTEXT_UID] = glTransformFeedback;
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
    for (let i = 0; i < tf.buffers.length; i++) {
      const buffer = tf.buffers[i];
      if (!buffer)
        continue;
      renderer.buffer.update(buffer);
      buffer._glBuffers[CONTEXT_UID].refCount++;
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, buffer._glBuffers[CONTEXT_UID].buffer || null);
    }
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    tf.disposeRunner.add(this);
    return glTransformFeedback;
  }
  disposeTransformFeedback(tf, contextLost) {
    const glTF = tf._glTransformFeedbacks[this.CONTEXT_UID];
    const gl = this.gl;
    tf.disposeRunner.remove(this);
    const bufferSystem = this.renderer.buffer;
    if (bufferSystem) {
      for (let i = 0; i < tf.buffers.length; i++) {
        const buffer = tf.buffers[i];
        if (!buffer)
          continue;
        const buf = buffer._glBuffers[this.CONTEXT_UID];
        if (buf) {
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            bufferSystem.dispose(buffer, contextLost);
          }
        }
      }
    }
    if (!glTF) {
      return;
    }
    if (!contextLost) {
      gl.deleteTransformFeedback(glTF);
    }
    delete tf._glTransformFeedbacks[this.CONTEXT_UID];
  }
  destroy() {
    this.renderer = null;
  }
}
TransformFeedbackSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "transformFeedback"
};
extensions.extensions.add(TransformFeedbackSystem);

exports.TransformFeedbackSystem = TransformFeedbackSystem;
//# sourceMappingURL=TransformFeedbackSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/utils/Quad.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/utils/Quad.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Geometry = __webpack_require__(/*! ../geometry/Geometry.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/Geometry.js");

class Quad extends Geometry.Geometry {
  constructor() {
    super();
    this.addAttribute("aVertexPosition", new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ])).addIndex([0, 1, 3, 2]);
  }
}

exports.Quad = Quad;
//# sourceMappingURL=Quad.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/utils/QuadUv.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/utils/QuadUv.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Buffer = __webpack_require__(/*! ../geometry/Buffer.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/Buffer.js");
var Geometry = __webpack_require__(/*! ../geometry/Geometry.js */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/geometry/Geometry.js");

class QuadUv extends Geometry.Geometry {
  constructor() {
    super();
    this.vertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1
    ]);
    this.uvs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ]);
    this.vertexBuffer = new Buffer.Buffer(this.vertices);
    this.uvBuffer = new Buffer.Buffer(this.uvs);
    this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
  }
  map(targetTextureFrame, destinationFrame) {
    let x = 0;
    let y = 0;
    this.uvs[0] = x;
    this.uvs[1] = y;
    this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width;
    this.uvs[3] = y;
    this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width;
    this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height;
    this.uvs[6] = x;
    this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height;
    x = destinationFrame.x;
    y = destinationFrame.y;
    this.vertices[0] = x;
    this.vertices[1] = y;
    this.vertices[2] = x + destinationFrame.width;
    this.vertices[3] = y;
    this.vertices[4] = x + destinationFrame.width;
    this.vertices[5] = y + destinationFrame.height;
    this.vertices[6] = x;
    this.vertices[7] = y + destinationFrame.height;
    this.invalidate();
    return this;
  }
  invalidate() {
    this.vertexBuffer._updateID++;
    this.uvBuffer._updateID++;
    return this;
  }
}

exports.QuadUv = QuadUv;
//# sourceMappingURL=QuadUv.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/core/lib/view/ViewSystem.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/core/lib/view/ViewSystem.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
var math = __webpack_require__(/*! @pixi/math */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/index.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");

class ViewSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  init(options) {
    this.screen = new math.Rectangle(0, 0, options.width, options.height);
    this.element = options.view || settings.settings.ADAPTER.createCanvas();
    this.resolution = options.resolution || settings.settings.RESOLUTION;
    this.autoDensity = !!options.autoDensity;
  }
  resizeView(desiredScreenWidth, desiredScreenHeight) {
    this.element.width = Math.round(desiredScreenWidth * this.resolution);
    this.element.height = Math.round(desiredScreenHeight * this.resolution);
    const screenWidth = this.element.width / this.resolution;
    const screenHeight = this.element.height / this.resolution;
    this.screen.width = screenWidth;
    this.screen.height = screenHeight;
    if (this.autoDensity) {
      this.element.style.width = `${screenWidth}px`;
      this.element.style.height = `${screenHeight}px`;
    }
    this.renderer.emit("resize", screenWidth, screenHeight);
    this.renderer.runners.resize.emit(this.screen.width, this.screen.height);
  }
  destroy(removeView) {
    if (removeView) {
      this.element.parentNode?.removeChild(this.element);
    }
    this.renderer = null;
    this.element = null;
    this.screen = null;
  }
}
ViewSystem.defaultOptions = {
  width: 800,
  height: 600,
  resolution: settings.settings.RESOLUTION,
  autoDensity: false
};
ViewSystem.extension = {
  type: [
    extensions.ExtensionType.RendererSystem,
    extensions.ExtensionType.CanvasRendererSystem
  ],
  name: "_view"
};
extensions.extensions.add(ViewSystem);

exports.ViewSystem = ViewSystem;
//# sourceMappingURL=ViewSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/display/lib/Bounds.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/display/lib/Bounds.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

class Bounds {
  constructor() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
    this.rect = null;
    this.updateID = -1;
  }
  isEmpty() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }
  clear() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
  }
  getRectangle(rect) {
    if (this.minX > this.maxX || this.minY > this.maxY) {
      return core.Rectangle.EMPTY;
    }
    rect = rect || new core.Rectangle(0, 0, 1, 1);
    rect.x = this.minX;
    rect.y = this.minY;
    rect.width = this.maxX - this.minX;
    rect.height = this.maxY - this.minY;
    return rect;
  }
  addPoint(point) {
    this.minX = Math.min(this.minX, point.x);
    this.maxX = Math.max(this.maxX, point.x);
    this.minY = Math.min(this.minY, point.y);
    this.maxY = Math.max(this.maxY, point.y);
  }
  addPointMatrix(matrix, point) {
    const { a, b, c, d, tx, ty } = matrix;
    const x = a * point.x + c * point.y + tx;
    const y = b * point.x + d * point.y + ty;
    this.minX = Math.min(this.minX, x);
    this.maxX = Math.max(this.maxX, x);
    this.minY = Math.min(this.minY, y);
    this.maxY = Math.max(this.maxY, y);
  }
  addQuad(vertices) {
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    let x = vertices[0];
    let y = vertices[1];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = vertices[2];
    y = vertices[3];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = vertices[4];
    y = vertices[5];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = vertices[6];
    y = vertices[7];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addFrame(transform, x0, y0, x1, y1) {
    this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
  }
  addFrameMatrix(matrix, x0, y0, x1, y1) {
    const a = matrix.a;
    const b = matrix.b;
    const c = matrix.c;
    const d = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    let x = a * x0 + c * y0 + tx;
    let y = b * x0 + d * y0 + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = a * x1 + c * y0 + tx;
    y = b * x1 + d * y0 + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = a * x0 + c * y1 + tx;
    y = b * x0 + d * y1 + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = a * x1 + c * y1 + tx;
    y = b * x1 + d * y1 + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addVertexData(vertexData, beginOffset, endOffset) {
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    for (let i = beginOffset; i < endOffset; i += 2) {
      const x = vertexData[i];
      const y = vertexData[i + 1];
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addVertices(transform, vertices, beginOffset, endOffset) {
    this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
  }
  addVerticesMatrix(matrix, vertices, beginOffset, endOffset, padX = 0, padY = padX) {
    const a = matrix.a;
    const b = matrix.b;
    const c = matrix.c;
    const d = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    for (let i = beginOffset; i < endOffset; i += 2) {
      const rawX = vertices[i];
      const rawY = vertices[i + 1];
      const x = a * rawX + c * rawY + tx;
      const y = d * rawY + b * rawX + ty;
      minX = Math.min(minX, x - padX);
      maxX = Math.max(maxX, x + padX);
      minY = Math.min(minY, y - padY);
      maxY = Math.max(maxY, y + padY);
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addBounds(bounds) {
    const minX = this.minX;
    const minY = this.minY;
    const maxX = this.maxX;
    const maxY = this.maxY;
    this.minX = bounds.minX < minX ? bounds.minX : minX;
    this.minY = bounds.minY < minY ? bounds.minY : minY;
    this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
    this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
  }
  addBoundsMask(bounds, mask) {
    const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
    const _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
    const _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
    const _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
    if (_minX <= _maxX && _minY <= _maxY) {
      const minX = this.minX;
      const minY = this.minY;
      const maxX = this.maxX;
      const maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX;
      this.minY = _minY < minY ? _minY : minY;
      this.maxX = _maxX > maxX ? _maxX : maxX;
      this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  }
  addBoundsMatrix(bounds, matrix) {
    this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
  }
  addBoundsArea(bounds, area) {
    const _minX = bounds.minX > area.x ? bounds.minX : area.x;
    const _minY = bounds.minY > area.y ? bounds.minY : area.y;
    const _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;
    const _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;
    if (_minX <= _maxX && _minY <= _maxY) {
      const minX = this.minX;
      const minY = this.minY;
      const maxX = this.maxX;
      const maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX;
      this.minY = _minY < minY ? _minY : minY;
      this.maxX = _maxX > maxX ? _maxX : maxX;
      this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  }
  pad(paddingX = 0, paddingY = paddingX) {
    if (!this.isEmpty()) {
      this.minX -= paddingX;
      this.maxX += paddingX;
      this.minY -= paddingY;
      this.maxY += paddingY;
    }
  }
  addFramePad(x0, y0, x1, y1, padX, padY) {
    x0 -= padX;
    y0 -= padY;
    x1 += padX;
    y1 += padY;
    this.minX = this.minX < x0 ? this.minX : x0;
    this.maxX = this.maxX > x1 ? this.maxX : x1;
    this.minY = this.minY < y0 ? this.minY : y0;
    this.maxY = this.maxY > y1 ? this.maxY : y1;
  }
}

exports.Bounds = Bounds;
//# sourceMappingURL=Bounds.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/display/lib/Container.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/display/lib/Container.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var DisplayObject = __webpack_require__(/*! ./DisplayObject.js */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/DisplayObject.js");

const tempMatrix = new core.Matrix();
function sortChildren(a, b) {
  if (a.zIndex === b.zIndex) {
    return a._lastSortedIndex - b._lastSortedIndex;
  }
  return a.zIndex - b.zIndex;
}
const _Container = class extends DisplayObject.DisplayObject {
  constructor() {
    super();
    this.children = [];
    this.sortableChildren = _Container.defaultSortableChildren;
    this.sortDirty = false;
  }
  onChildrenChange(_length) {
  }
  addChild(...children) {
    if (children.length > 1) {
      for (let i = 0; i < children.length; i++) {
        this.addChild(children[i]);
      }
    } else {
      const child = children[0];
      if (child.parent) {
        child.parent.removeChild(child);
      }
      child.parent = this;
      this.sortDirty = true;
      child.transform._parentID = -1;
      this.children.push(child);
      this._boundsID++;
      this.onChildrenChange(this.children.length - 1);
      this.emit("childAdded", child, this, this.children.length - 1);
      child.emit("added", this);
    }
    return children[0];
  }
  addChildAt(child, index) {
    if (index < 0 || index > this.children.length) {
      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${this.children.length}`);
    }
    if (child.parent) {
      child.parent.removeChild(child);
    }
    child.parent = this;
    this.sortDirty = true;
    child.transform._parentID = -1;
    this.children.splice(index, 0, child);
    this._boundsID++;
    this.onChildrenChange(index);
    child.emit("added", this);
    this.emit("childAdded", child, this, index);
    return child;
  }
  swapChildren(child, child2) {
    if (child === child2) {
      return;
    }
    const index1 = this.getChildIndex(child);
    const index2 = this.getChildIndex(child2);
    this.children[index1] = child2;
    this.children[index2] = child;
    this.onChildrenChange(index1 < index2 ? index1 : index2);
  }
  getChildIndex(child) {
    const index = this.children.indexOf(child);
    if (index === -1) {
      throw new Error("The supplied DisplayObject must be a child of the caller");
    }
    return index;
  }
  setChildIndex(child, index) {
    if (index < 0 || index >= this.children.length) {
      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
    }
    const currentIndex = this.getChildIndex(child);
    core.utils.removeItems(this.children, currentIndex, 1);
    this.children.splice(index, 0, child);
    this.onChildrenChange(index);
  }
  getChildAt(index) {
    if (index < 0 || index >= this.children.length) {
      throw new Error(`getChildAt: Index (${index}) does not exist.`);
    }
    return this.children[index];
  }
  removeChild(...children) {
    if (children.length > 1) {
      for (let i = 0; i < children.length; i++) {
        this.removeChild(children[i]);
      }
    } else {
      const child = children[0];
      const index = this.children.indexOf(child);
      if (index === -1)
        return null;
      child.parent = null;
      child.transform._parentID = -1;
      core.utils.removeItems(this.children, index, 1);
      this._boundsID++;
      this.onChildrenChange(index);
      child.emit("removed", this);
      this.emit("childRemoved", child, this, index);
    }
    return children[0];
  }
  removeChildAt(index) {
    const child = this.getChildAt(index);
    child.parent = null;
    child.transform._parentID = -1;
    core.utils.removeItems(this.children, index, 1);
    this._boundsID++;
    this.onChildrenChange(index);
    child.emit("removed", this);
    this.emit("childRemoved", child, this, index);
    return child;
  }
  removeChildren(beginIndex = 0, endIndex = this.children.length) {
    const begin = beginIndex;
    const end = endIndex;
    const range = end - begin;
    let removed;
    if (range > 0 && range <= end) {
      removed = this.children.splice(begin, range);
      for (let i = 0; i < removed.length; ++i) {
        removed[i].parent = null;
        if (removed[i].transform) {
          removed[i].transform._parentID = -1;
        }
      }
      this._boundsID++;
      this.onChildrenChange(beginIndex);
      for (let i = 0; i < removed.length; ++i) {
        removed[i].emit("removed", this);
        this.emit("childRemoved", removed[i], this, i);
      }
      return removed;
    } else if (range === 0 && this.children.length === 0) {
      return [];
    }
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  }
  sortChildren() {
    let sortRequired = false;
    for (let i = 0, j = this.children.length; i < j; ++i) {
      const child = this.children[i];
      child._lastSortedIndex = i;
      if (!sortRequired && child.zIndex !== 0) {
        sortRequired = true;
      }
    }
    if (sortRequired && this.children.length > 1) {
      this.children.sort(sortChildren);
    }
    this.sortDirty = false;
  }
  updateTransform() {
    if (this.sortableChildren && this.sortDirty) {
      this.sortChildren();
    }
    this._boundsID++;
    this.transform.updateTransform(this.parent.transform);
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
    for (let i = 0, j = this.children.length; i < j; ++i) {
      const child = this.children[i];
      if (child.visible) {
        child.updateTransform();
      }
    }
  }
  calculateBounds() {
    this._bounds.clear();
    this._calculateBounds();
    for (let i = 0; i < this.children.length; i++) {
      const child = this.children[i];
      if (!child.visible || !child.renderable) {
        continue;
      }
      child.calculateBounds();
      if (child._mask) {
        const maskObject = child._mask.isMaskData ? child._mask.maskObject : child._mask;
        if (maskObject) {
          maskObject.calculateBounds();
          this._bounds.addBoundsMask(child._bounds, maskObject._bounds);
        } else {
          this._bounds.addBounds(child._bounds);
        }
      } else if (child.filterArea) {
        this._bounds.addBoundsArea(child._bounds, child.filterArea);
      } else {
        this._bounds.addBounds(child._bounds);
      }
    }
    this._bounds.updateID = this._boundsID;
  }
  getLocalBounds(rect, skipChildrenUpdate = false) {
    const result = super.getLocalBounds(rect);
    if (!skipChildrenUpdate) {
      for (let i = 0, j = this.children.length; i < j; ++i) {
        const child = this.children[i];
        if (child.visible) {
          child.updateTransform();
        }
      }
    }
    return result;
  }
  _calculateBounds() {
  }
  _renderWithCulling(renderer) {
    const sourceFrame = renderer.renderTexture.sourceFrame;
    if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {
      return;
    }
    let bounds;
    let transform;
    if (this.cullArea) {
      bounds = this.cullArea;
      transform = this.worldTransform;
    } else if (this._render !== _Container.prototype._render) {
      bounds = this.getBounds(true);
    }
    const projectionTransform = renderer.projection.transform;
    if (projectionTransform) {
      if (transform) {
        transform = tempMatrix.copyFrom(transform);
        transform.prepend(projectionTransform);
      } else {
        transform = projectionTransform;
      }
    }
    if (bounds && sourceFrame.intersects(bounds, transform)) {
      this._render(renderer);
    } else if (this.cullArea) {
      return;
    }
    for (let i = 0, j = this.children.length; i < j; ++i) {
      const child = this.children[i];
      const childCullable = child.cullable;
      child.cullable = childCullable || !this.cullArea;
      child.render(renderer);
      child.cullable = childCullable;
    }
  }
  render(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
      return;
    }
    if (this._mask || this.filters?.length) {
      this.renderAdvanced(renderer);
    } else if (this.cullable) {
      this._renderWithCulling(renderer);
    } else {
      this._render(renderer);
      for (let i = 0, j = this.children.length; i < j; ++i) {
        this.children[i].render(renderer);
      }
    }
  }
  renderAdvanced(renderer) {
    const filters = this.filters;
    const mask = this._mask;
    if (filters) {
      if (!this._enabledFilters) {
        this._enabledFilters = [];
      }
      this._enabledFilters.length = 0;
      for (let i = 0; i < filters.length; i++) {
        if (filters[i].enabled) {
          this._enabledFilters.push(filters[i]);
        }
      }
    }
    const flush = filters && this._enabledFilters?.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== core.MASK_TYPES.NONE));
    if (flush) {
      renderer.batch.flush();
    }
    if (filters && this._enabledFilters?.length) {
      renderer.filter.push(this, this._enabledFilters);
    }
    if (mask) {
      renderer.mask.push(this, this._mask);
    }
    if (this.cullable) {
      this._renderWithCulling(renderer);
    } else {
      this._render(renderer);
      for (let i = 0, j = this.children.length; i < j; ++i) {
        this.children[i].render(renderer);
      }
    }
    if (flush) {
      renderer.batch.flush();
    }
    if (mask) {
      renderer.mask.pop(this);
    }
    if (filters && this._enabledFilters?.length) {
      renderer.filter.pop();
    }
  }
  _render(_renderer) {
  }
  destroy(options) {
    super.destroy();
    this.sortDirty = false;
    const destroyChildren = typeof options === "boolean" ? options : options?.children;
    const oldChildren = this.removeChildren(0, this.children.length);
    if (destroyChildren) {
      for (let i = 0; i < oldChildren.length; ++i) {
        oldChildren[i].destroy(options);
      }
    }
  }
  get width() {
    return this.scale.x * this.getLocalBounds().width;
  }
  set width(value) {
    const width = this.getLocalBounds().width;
    if (width !== 0) {
      this.scale.x = value / width;
    } else {
      this.scale.x = 1;
    }
    this._width = value;
  }
  get height() {
    return this.scale.y * this.getLocalBounds().height;
  }
  set height(value) {
    const height = this.getLocalBounds().height;
    if (height !== 0) {
      this.scale.y = value / height;
    } else {
      this.scale.y = 1;
    }
    this._height = value;
  }
};
let Container = _Container;
Container.defaultSortableChildren = false;
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;

exports.Container = Container;
//# sourceMappingURL=Container.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/display/lib/DisplayObject.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/display/lib/DisplayObject.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var Bounds = __webpack_require__(/*! ./Bounds.js */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/Bounds.js");

class DisplayObject extends core.utils.EventEmitter {
  constructor() {
    super();
    this.tempDisplayObjectParent = null;
    this.transform = new core.Transform();
    this.alpha = 1;
    this.visible = true;
    this.renderable = true;
    this.cullable = false;
    this.cullArea = null;
    this.parent = null;
    this.worldAlpha = 1;
    this._lastSortedIndex = 0;
    this._zIndex = 0;
    this.filterArea = null;
    this.filters = null;
    this._enabledFilters = null;
    this._bounds = new Bounds.Bounds();
    this._localBounds = null;
    this._boundsID = 0;
    this._boundsRect = null;
    this._localBoundsRect = null;
    this._mask = null;
    this._maskRefCount = 0;
    this._destroyed = false;
    this.isSprite = false;
    this.isMask = false;
  }
  static mixin(source) {
    const keys = Object.keys(source);
    for (let i = 0; i < keys.length; ++i) {
      const propertyName = keys[i];
      Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
    }
  }
  get destroyed() {
    return this._destroyed;
  }
  _recursivePostUpdateTransform() {
    if (this.parent) {
      this.parent._recursivePostUpdateTransform();
      this.transform.updateTransform(this.parent.transform);
    } else {
      this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }
  }
  updateTransform() {
    this._boundsID++;
    this.transform.updateTransform(this.parent.transform);
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
  }
  getBounds(skipUpdate, rect) {
    if (!skipUpdate) {
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.updateTransform();
        this.parent = null;
      } else {
        this._recursivePostUpdateTransform();
        this.updateTransform();
      }
    }
    if (this._bounds.updateID !== this._boundsID) {
      this.calculateBounds();
      this._bounds.updateID = this._boundsID;
    }
    if (!rect) {
      if (!this._boundsRect) {
        this._boundsRect = new core.Rectangle();
      }
      rect = this._boundsRect;
    }
    return this._bounds.getRectangle(rect);
  }
  getLocalBounds(rect) {
    if (!rect) {
      if (!this._localBoundsRect) {
        this._localBoundsRect = new core.Rectangle();
      }
      rect = this._localBoundsRect;
    }
    if (!this._localBounds) {
      this._localBounds = new Bounds.Bounds();
    }
    const transformRef = this.transform;
    const parentRef = this.parent;
    this.parent = null;
    this.transform = this._tempDisplayObjectParent.transform;
    const worldBounds = this._bounds;
    const worldBoundsID = this._boundsID;
    this._bounds = this._localBounds;
    const bounds = this.getBounds(false, rect);
    this.parent = parentRef;
    this.transform = transformRef;
    this._bounds = worldBounds;
    this._bounds.updateID += this._boundsID - worldBoundsID;
    return bounds;
  }
  toGlobal(position, point, skipUpdate = false) {
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    return this.worldTransform.apply(position, point);
  }
  toLocal(position, from, point, skipUpdate) {
    if (from) {
      position = from.toGlobal(position, point, skipUpdate);
    }
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    return this.worldTransform.applyInverse(position, point);
  }
  setParent(container) {
    if (!container || !container.addChild) {
      throw new Error("setParent: Argument must be a Container");
    }
    container.addChild(this);
    return container;
  }
  removeFromParent() {
    this.parent?.removeChild(this);
  }
  setTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0) {
    this.position.x = x;
    this.position.y = y;
    this.scale.x = !scaleX ? 1 : scaleX;
    this.scale.y = !scaleY ? 1 : scaleY;
    this.rotation = rotation;
    this.skew.x = skewX;
    this.skew.y = skewY;
    this.pivot.x = pivotX;
    this.pivot.y = pivotY;
    return this;
  }
  destroy(_options) {
    this.removeFromParent();
    this._destroyed = true;
    this.transform = null;
    this.parent = null;
    this._bounds = null;
    this.mask = null;
    this.cullArea = null;
    this.filters = null;
    this.filterArea = null;
    this.hitArea = null;
    this.eventMode = "auto";
    this.interactiveChildren = false;
    this.emit("destroyed");
    this.removeAllListeners();
  }
  get _tempDisplayObjectParent() {
    if (this.tempDisplayObjectParent === null) {
      this.tempDisplayObjectParent = new TemporaryDisplayObject();
    }
    return this.tempDisplayObjectParent;
  }
  enableTempParent() {
    const myParent = this.parent;
    this.parent = this._tempDisplayObjectParent;
    return myParent;
  }
  disableTempParent(cacheParent) {
    this.parent = cacheParent;
  }
  get x() {
    return this.position.x;
  }
  set x(value) {
    this.transform.position.x = value;
  }
  get y() {
    return this.position.y;
  }
  set y(value) {
    this.transform.position.y = value;
  }
  get worldTransform() {
    return this.transform.worldTransform;
  }
  get localTransform() {
    return this.transform.localTransform;
  }
  get position() {
    return this.transform.position;
  }
  set position(value) {
    this.transform.position.copyFrom(value);
  }
  get scale() {
    return this.transform.scale;
  }
  set scale(value) {
    this.transform.scale.copyFrom(value);
  }
  get pivot() {
    return this.transform.pivot;
  }
  set pivot(value) {
    this.transform.pivot.copyFrom(value);
  }
  get skew() {
    return this.transform.skew;
  }
  set skew(value) {
    this.transform.skew.copyFrom(value);
  }
  get rotation() {
    return this.transform.rotation;
  }
  set rotation(value) {
    this.transform.rotation = value;
  }
  get angle() {
    return this.transform.rotation * core.RAD_TO_DEG;
  }
  set angle(value) {
    this.transform.rotation = value * core.DEG_TO_RAD;
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    if (this.parent) {
      this.parent.sortDirty = true;
    }
  }
  get worldVisible() {
    let item = this;
    do {
      if (!item.visible) {
        return false;
      }
      item = item.parent;
    } while (item);
    return true;
  }
  get mask() {
    return this._mask;
  }
  set mask(value) {
    if (this._mask === value) {
      return;
    }
    if (this._mask) {
      const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
      if (maskObject) {
        maskObject._maskRefCount--;
        if (maskObject._maskRefCount === 0) {
          maskObject.renderable = true;
          maskObject.isMask = false;
        }
      }
    }
    this._mask = value;
    if (this._mask) {
      const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
      if (maskObject) {
        if (maskObject._maskRefCount === 0) {
          maskObject.renderable = false;
          maskObject.isMask = true;
        }
        maskObject._maskRefCount++;
      }
    }
  }
}
class TemporaryDisplayObject extends DisplayObject {
  constructor() {
    super(...arguments);
    this.sortDirty = null;
  }
}
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;

exports.DisplayObject = DisplayObject;
exports.TemporaryDisplayObject = TemporaryDisplayObject;
//# sourceMappingURL=DisplayObject.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/display/lib/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/display/lib/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(/*! ./settings.js */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/settings.js");
var Bounds = __webpack_require__(/*! ./Bounds.js */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/Bounds.js");
var Container = __webpack_require__(/*! ./Container.js */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/Container.js");
var DisplayObject = __webpack_require__(/*! ./DisplayObject.js */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/DisplayObject.js");



exports.Bounds = Bounds.Bounds;
exports.Container = Container.Container;
exports.DisplayObject = DisplayObject.DisplayObject;
exports.TemporaryDisplayObject = DisplayObject.TemporaryDisplayObject;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/display/lib/settings.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/display/lib/settings.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var Container = __webpack_require__(/*! ./Container.js */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/Container.js");

Object.defineProperties(core.settings, {
  SORTABLE_CHILDREN: {
    get() {
      return Container.Container.defaultSortableChildren;
    },
    set(value) {
      core.utils.deprecation("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren");
      Container.Container.defaultSortableChildren = value;
    }
  }
});

Object.defineProperty(exports, "settings", ({
    enumerable: true,
    get: function () { return core.settings; }
}));
//# sourceMappingURL=settings.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/events/lib/EventBoundary.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/events/lib/EventBoundary.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var EventTicker = __webpack_require__(/*! ./EventTicker.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/EventTicker.js");
var FederatedMouseEvent = __webpack_require__(/*! ./FederatedMouseEvent.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedMouseEvent.js");
var FederatedPointerEvent = __webpack_require__(/*! ./FederatedPointerEvent.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedPointerEvent.js");
var FederatedWheelEvent = __webpack_require__(/*! ./FederatedWheelEvent.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedWheelEvent.js");

const PROPAGATION_LIMIT = 2048;
const tempHitLocation = new core.Point();
const tempLocalMapping = new core.Point();
class EventBoundary {
  constructor(rootTarget) {
    this.dispatch = new core.utils.EventEmitter();
    this.moveOnAll = false;
    this.enableGlobalMoveEvents = true;
    this.mappingState = {
      trackingData: {}
    };
    this.eventPool = /* @__PURE__ */ new Map();
    this._allInteractiveElements = [];
    this._hitElements = [];
    this._isPointerMoveEvent = false;
    this.rootTarget = rootTarget;
    this.hitPruneFn = this.hitPruneFn.bind(this);
    this.hitTestFn = this.hitTestFn.bind(this);
    this.mapPointerDown = this.mapPointerDown.bind(this);
    this.mapPointerMove = this.mapPointerMove.bind(this);
    this.mapPointerOut = this.mapPointerOut.bind(this);
    this.mapPointerOver = this.mapPointerOver.bind(this);
    this.mapPointerUp = this.mapPointerUp.bind(this);
    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
    this.mapWheel = this.mapWheel.bind(this);
    this.mappingTable = {};
    this.addEventMapping("pointerdown", this.mapPointerDown);
    this.addEventMapping("pointermove", this.mapPointerMove);
    this.addEventMapping("pointerout", this.mapPointerOut);
    this.addEventMapping("pointerleave", this.mapPointerOut);
    this.addEventMapping("pointerover", this.mapPointerOver);
    this.addEventMapping("pointerup", this.mapPointerUp);
    this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
    this.addEventMapping("wheel", this.mapWheel);
  }
  addEventMapping(type, fn) {
    if (!this.mappingTable[type]) {
      this.mappingTable[type] = [];
    }
    this.mappingTable[type].push({
      fn,
      priority: 0
    });
    this.mappingTable[type].sort((a, b) => a.priority - b.priority);
  }
  dispatchEvent(e, type) {
    e.propagationStopped = false;
    e.propagationImmediatelyStopped = false;
    this.propagate(e, type);
    this.dispatch.emit(type || e.type, e);
  }
  mapEvent(e) {
    if (!this.rootTarget) {
      return;
    }
    const mappers = this.mappingTable[e.type];
    if (mappers) {
      for (let i = 0, j = mappers.length; i < j; i++) {
        mappers[i].fn(e);
      }
    } else {
      console.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);
    }
  }
  hitTest(x, y) {
    EventTicker.EventsTicker.pauseUpdate = true;
    const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
    const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
    const invertedPath = this[fn](this.rootTarget, this.rootTarget.eventMode, tempHitLocation.set(x, y), this.hitTestFn, this.hitPruneFn);
    return invertedPath && invertedPath[0];
  }
  propagate(e, type) {
    if (!e.target) {
      return;
    }
    const composedPath = e.composedPath();
    e.eventPhase = e.CAPTURING_PHASE;
    for (let i = 0, j = composedPath.length - 1; i < j; i++) {
      e.currentTarget = composedPath[i];
      this.notifyTarget(e, type);
      if (e.propagationStopped || e.propagationImmediatelyStopped)
        return;
    }
    e.eventPhase = e.AT_TARGET;
    e.currentTarget = e.target;
    this.notifyTarget(e, type);
    if (e.propagationStopped || e.propagationImmediatelyStopped)
      return;
    e.eventPhase = e.BUBBLING_PHASE;
    for (let i = composedPath.length - 2; i >= 0; i--) {
      e.currentTarget = composedPath[i];
      this.notifyTarget(e, type);
      if (e.propagationStopped || e.propagationImmediatelyStopped)
        return;
    }
  }
  all(e, type, targets = this._allInteractiveElements) {
    if (targets.length === 0)
      return;
    e.eventPhase = e.BUBBLING_PHASE;
    const events = Array.isArray(type) ? type : [type];
    for (let i = targets.length - 1; i >= 0; i--) {
      events.forEach((event) => {
        e.currentTarget = targets[i];
        this.notifyTarget(e, event);
      });
    }
  }
  propagationPath(target) {
    const propagationPath = [target];
    for (let i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {
      if (!target.parent) {
        throw new Error("Cannot find propagation path to disconnected target");
      }
      propagationPath.push(target.parent);
      target = target.parent;
    }
    propagationPath.reverse();
    return propagationPath;
  }
  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
    let shouldReturn = false;
    if (this._interactivePrune(currentTarget))
      return null;
    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
      EventTicker.EventsTicker.pauseUpdate = false;
    }
    if (currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i = children.length - 1; i >= 0; i--) {
        const child = children[i];
        const nestedHit = this.hitTestMoveRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn, ignore || pruneFn(currentTarget, location));
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
            continue;
          }
          const isInteractive = currentTarget.isInteractive();
          if (nestedHit.length > 0 || isInteractive) {
            if (isInteractive)
              this._allInteractiveElements.push(currentTarget);
            nestedHit.push(currentTarget);
          }
          if (this._hitElements.length === 0)
            this._hitElements = nestedHit;
          shouldReturn = true;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode);
    const isInteractiveTarget = currentTarget.isInteractive();
    if (isInteractiveTarget && isInteractiveTarget)
      this._allInteractiveElements.push(currentTarget);
    if (ignore || this._hitElements.length > 0)
      return null;
    if (shouldReturn)
      return this._hitElements;
    if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {
      return isInteractiveTarget ? [currentTarget] : [];
    }
    return null;
  }
  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
      return null;
    }
    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
      EventTicker.EventsTicker.pauseUpdate = false;
    }
    if (currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i = children.length - 1; i >= 0; i--) {
        const child = children[i];
        const nestedHit = this.hitTestRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn);
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
            continue;
          }
          const isInteractive = currentTarget.isInteractive();
          if (nestedHit.length > 0 || isInteractive)
            nestedHit.push(currentTarget);
          return nestedHit;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode);
    const isInteractiveTarget = currentTarget.isInteractive();
    if (isInteractiveMode && testFn(currentTarget, location)) {
      return isInteractiveTarget ? [currentTarget] : [];
    }
    return null;
  }
  _isInteractive(int) {
    return int === "static" || int === "dynamic";
  }
  _interactivePrune(displayObject) {
    if (!displayObject || displayObject.isMask || !displayObject.visible || !displayObject.renderable) {
      return true;
    }
    if (displayObject.eventMode === "none") {
      return true;
    }
    if (displayObject.eventMode === "passive" && !displayObject.interactiveChildren) {
      return true;
    }
    if (displayObject.isMask) {
      return true;
    }
    return false;
  }
  hitPruneFn(displayObject, location) {
    if (displayObject.hitArea) {
      displayObject.worldTransform.applyInverse(location, tempLocalMapping);
      if (!displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
        return true;
      }
    }
    if (displayObject._mask) {
      const maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;
      if (maskObject && !maskObject.containsPoint?.(location)) {
        return true;
      }
    }
    return false;
  }
  hitTestFn(displayObject, location) {
    if (displayObject.eventMode === "passive") {
      return false;
    }
    if (displayObject.hitArea) {
      return true;
    }
    if (displayObject.containsPoint) {
      return displayObject.containsPoint(location);
    }
    return false;
  }
  notifyTarget(e, type) {
    type = type ?? e.type;
    const handlerKey = `on${type}`;
    e.currentTarget[handlerKey]?.(e);
    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;
    this.notifyListeners(e, key);
    if (e.eventPhase === e.AT_TARGET) {
      this.notifyListeners(e, type);
    }
  }
  mapPointerDown(from) {
    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const e = this.createPointerEvent(from);
    this.dispatchEvent(e, "pointerdown");
    if (e.pointerType === "touch") {
      this.dispatchEvent(e, "touchstart");
    } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
      const isRightButton = e.button === 2;
      this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
    }
    const trackingData = this.trackingData(from.pointerId);
    trackingData.pressTargetsByButton[from.button] = e.composedPath();
    this.freeEvent(e);
  }
  mapPointerMove(from) {
    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    this._allInteractiveElements.length = 0;
    this._hitElements.length = 0;
    this._isPointerMoveEvent = true;
    const e = this.createPointerEvent(from);
    this._isPointerMoveEvent = false;
    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
    const trackingData = this.trackingData(from.pointerId);
    const outTarget = this.findMountedTarget(trackingData.overTargets);
    if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {
      const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
      const outEvent = this.createPointerEvent(from, outType, outTarget);
      this.dispatchEvent(outEvent, "pointerout");
      if (isMouse)
        this.dispatchEvent(outEvent, "mouseout");
      if (!e.composedPath().includes(outTarget)) {
        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
        leaveEvent.eventPhase = leaveEvent.AT_TARGET;
        while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {
          leaveEvent.currentTarget = leaveEvent.target;
          this.notifyTarget(leaveEvent);
          if (isMouse)
            this.notifyTarget(leaveEvent, "mouseleave");
          leaveEvent.target = leaveEvent.target.parent;
        }
        this.freeEvent(leaveEvent);
      }
      this.freeEvent(outEvent);
    }
    if (outTarget !== e.target) {
      const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
      const overEvent = this.clonePointerEvent(e, overType);
      this.dispatchEvent(overEvent, "pointerover");
      if (isMouse)
        this.dispatchEvent(overEvent, "mouseover");
      let overTargetAncestor = outTarget?.parent;
      while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
        if (overTargetAncestor === e.target)
          break;
        overTargetAncestor = overTargetAncestor.parent;
      }
      const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
      if (didPointerEnter) {
        const enterEvent = this.clonePointerEvent(e, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
          enterEvent.currentTarget = enterEvent.target;
          this.notifyTarget(enterEvent);
          if (isMouse)
            this.notifyTarget(enterEvent, "mouseenter");
          enterEvent.target = enterEvent.target.parent;
        }
        this.freeEvent(enterEvent);
      }
      this.freeEvent(overEvent);
    }
    const allMethods = [];
    const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
    this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e, "pointermove");
    allowGlobalPointerEvents && allMethods.push("globalpointermove");
    if (e.pointerType === "touch") {
      this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove");
      allowGlobalPointerEvents && allMethods.push("globaltouchmove");
    }
    if (isMouse) {
      this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove");
      allowGlobalPointerEvents && allMethods.push("globalmousemove");
      this.cursor = e.target?.cursor;
    }
    if (allMethods.length > 0) {
      this.all(e, allMethods);
    }
    this._allInteractiveElements.length = 0;
    this._hitElements.length = 0;
    trackingData.overTargets = e.composedPath();
    this.freeEvent(e);
  }
  mapPointerOver(from) {
    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    const e = this.createPointerEvent(from);
    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
    this.dispatchEvent(e, "pointerover");
    if (isMouse)
      this.dispatchEvent(e, "mouseover");
    if (e.pointerType === "mouse")
      this.cursor = e.target?.cursor;
    const enterEvent = this.clonePointerEvent(e, "pointerenter");
    enterEvent.eventPhase = enterEvent.AT_TARGET;
    while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
      enterEvent.currentTarget = enterEvent.target;
      this.notifyTarget(enterEvent);
      if (isMouse)
        this.notifyTarget(enterEvent, "mouseenter");
      enterEvent.target = enterEvent.target.parent;
    }
    trackingData.overTargets = e.composedPath();
    this.freeEvent(e);
    this.freeEvent(enterEvent);
  }
  mapPointerOut(from) {
    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    if (trackingData.overTargets) {
      const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
      const outTarget = this.findMountedTarget(trackingData.overTargets);
      const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
      this.dispatchEvent(outEvent);
      if (isMouse)
        this.dispatchEvent(outEvent, "mouseout");
      const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
      leaveEvent.eventPhase = leaveEvent.AT_TARGET;
      while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
        leaveEvent.currentTarget = leaveEvent.target;
        this.notifyTarget(leaveEvent);
        if (isMouse)
          this.notifyTarget(leaveEvent, "mouseleave");
        leaveEvent.target = leaveEvent.target.parent;
      }
      trackingData.overTargets = null;
      this.freeEvent(outEvent);
      this.freeEvent(leaveEvent);
    }
    this.cursor = null;
  }
  mapPointerUp(from) {
    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const now = performance.now();
    const e = this.createPointerEvent(from);
    this.dispatchEvent(e, "pointerup");
    if (e.pointerType === "touch") {
      this.dispatchEvent(e, "touchend");
    } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
      const isRightButton = e.button === 2;
      this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
    }
    const trackingData = this.trackingData(from.pointerId);
    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
    let clickTarget = pressTarget;
    if (pressTarget && !e.composedPath().includes(pressTarget)) {
      let currentTarget = pressTarget;
      while (currentTarget && !e.composedPath().includes(currentTarget)) {
        e.currentTarget = currentTarget;
        this.notifyTarget(e, "pointerupoutside");
        if (e.pointerType === "touch") {
          this.notifyTarget(e, "touchendoutside");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
          const isRightButton = e.button === 2;
          this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from.button];
      clickTarget = currentTarget;
    }
    if (clickTarget) {
      const clickEvent = this.clonePointerEvent(e, "click");
      clickEvent.target = clickTarget;
      clickEvent.path = null;
      if (!trackingData.clicksByButton[from.button]) {
        trackingData.clicksByButton[from.button] = {
          clickCount: 0,
          target: clickEvent.target,
          timeStamp: now
        };
      }
      const clickHistory = trackingData.clicksByButton[from.button];
      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
        ++clickHistory.clickCount;
      } else {
        clickHistory.clickCount = 1;
      }
      clickHistory.target = clickEvent.target;
      clickHistory.timeStamp = now;
      clickEvent.detail = clickHistory.clickCount;
      if (clickEvent.pointerType === "mouse") {
        const isRightButton = clickEvent.button === 2;
        this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
      } else if (clickEvent.pointerType === "touch") {
        this.dispatchEvent(clickEvent, "tap");
      }
      this.dispatchEvent(clickEvent, "pointertap");
      this.freeEvent(clickEvent);
    }
    this.freeEvent(e);
  }
  mapPointerUpOutside(from) {
    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
    const e = this.createPointerEvent(from);
    if (pressTarget) {
      let currentTarget = pressTarget;
      while (currentTarget) {
        e.currentTarget = currentTarget;
        this.notifyTarget(e, "pointerupoutside");
        if (e.pointerType === "touch") {
          this.notifyTarget(e, "touchendoutside");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
          this.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from.button];
    }
    this.freeEvent(e);
  }
  mapWheel(from) {
    if (!(from instanceof FederatedWheelEvent.FederatedWheelEvent)) {
      console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
      return;
    }
    const wheelEvent = this.createWheelEvent(from);
    this.dispatchEvent(wheelEvent);
    this.freeEvent(wheelEvent);
  }
  findMountedTarget(propagationPath) {
    if (!propagationPath) {
      return null;
    }
    let currentTarget = propagationPath[0];
    for (let i = 1; i < propagationPath.length; i++) {
      if (propagationPath[i].parent === currentTarget) {
        currentTarget = propagationPath[i];
      } else {
        break;
      }
    }
    return currentTarget;
  }
  createPointerEvent(from, type, target) {
    const event = this.allocateEvent(FederatedPointerEvent.FederatedPointerEvent);
    this.copyPointerData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from;
    event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
    if (typeof type === "string") {
      event.type = type;
    }
    return event;
  }
  createWheelEvent(from) {
    const event = this.allocateEvent(FederatedWheelEvent.FederatedWheelEvent);
    this.copyWheelData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from;
    event.target = this.hitTest(event.global.x, event.global.y);
    return event;
  }
  clonePointerEvent(from, type) {
    const event = this.allocateEvent(FederatedPointerEvent.FederatedPointerEvent);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from.originalEvent;
    this.copyPointerData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.target = from.target;
    event.path = from.composedPath().slice();
    event.type = type ?? event.type;
    return event;
  }
  copyWheelData(from, to) {
    to.deltaMode = from.deltaMode;
    to.deltaX = from.deltaX;
    to.deltaY = from.deltaY;
    to.deltaZ = from.deltaZ;
  }
  copyPointerData(from, to) {
    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent && to instanceof FederatedPointerEvent.FederatedPointerEvent))
      return;
    to.pointerId = from.pointerId;
    to.width = from.width;
    to.height = from.height;
    to.isPrimary = from.isPrimary;
    to.pointerType = from.pointerType;
    to.pressure = from.pressure;
    to.tangentialPressure = from.tangentialPressure;
    to.tiltX = from.tiltX;
    to.tiltY = from.tiltY;
    to.twist = from.twist;
  }
  copyMouseData(from, to) {
    if (!(from instanceof FederatedMouseEvent.FederatedMouseEvent && to instanceof FederatedMouseEvent.FederatedMouseEvent))
      return;
    to.altKey = from.altKey;
    to.button = from.button;
    to.buttons = from.buttons;
    to.client.copyFrom(from.client);
    to.ctrlKey = from.ctrlKey;
    to.metaKey = from.metaKey;
    to.movement.copyFrom(from.movement);
    to.screen.copyFrom(from.screen);
    to.shiftKey = from.shiftKey;
    to.global.copyFrom(from.global);
  }
  copyData(from, to) {
    to.isTrusted = from.isTrusted;
    to.srcElement = from.srcElement;
    to.timeStamp = performance.now();
    to.type = from.type;
    to.detail = from.detail;
    to.view = from.view;
    to.which = from.which;
    to.layer.copyFrom(from.layer);
    to.page.copyFrom(from.page);
  }
  trackingData(id) {
    if (!this.mappingState.trackingData[id]) {
      this.mappingState.trackingData[id] = {
        pressTargetsByButton: {},
        clicksByButton: {},
        overTarget: null
      };
    }
    return this.mappingState.trackingData[id];
  }
  allocateEvent(constructor) {
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    const event = this.eventPool.get(constructor).pop() || new constructor(this);
    event.eventPhase = event.NONE;
    event.currentTarget = null;
    event.path = null;
    event.target = null;
    return event;
  }
  freeEvent(event) {
    if (event.manager !== this)
      throw new Error("It is illegal to free an event not managed by this EventBoundary!");
    const constructor = event.constructor;
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    this.eventPool.get(constructor).push(event);
  }
  notifyListeners(e, type) {
    const listeners = e.currentTarget._events[type];
    if (!listeners)
      return;
    if (!e.currentTarget.isInteractive())
      return;
    if ("fn" in listeners) {
      if (listeners.once)
        e.currentTarget.removeListener(type, listeners.fn, void 0, true);
      listeners.fn.call(listeners.context, e);
    } else {
      for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {
        if (listeners[i].once)
          e.currentTarget.removeListener(type, listeners[i].fn, void 0, true);
        listeners[i].fn.call(listeners[i].context, e);
      }
    }
  }
}

exports.EventBoundary = EventBoundary;
//# sourceMappingURL=EventBoundary.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/events/lib/EventSystem.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/events/lib/EventSystem.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var EventBoundary = __webpack_require__(/*! ./EventBoundary.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/EventBoundary.js");
var EventTicker = __webpack_require__(/*! ./EventTicker.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/EventTicker.js");
var FederatedPointerEvent = __webpack_require__(/*! ./FederatedPointerEvent.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedPointerEvent.js");
var FederatedWheelEvent = __webpack_require__(/*! ./FederatedWheelEvent.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedWheelEvent.js");

const MOUSE_POINTER_ID = 1;
const TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
};
const _EventSystem = class {
  constructor(renderer) {
    this.supportsTouchEvents = "ontouchstart" in globalThis;
    this.supportsPointerEvents = !!globalThis.PointerEvent;
    this.domElement = null;
    this.resolution = 1;
    this.renderer = renderer;
    this.rootBoundary = new EventBoundary.EventBoundary(null);
    EventTicker.EventsTicker.init(this);
    this.autoPreventDefault = true;
    this.eventsAdded = false;
    this.rootPointerEvent = new FederatedPointerEvent.FederatedPointerEvent(null);
    this.rootWheelEvent = new FederatedWheelEvent.FederatedWheelEvent(null);
    this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    };
    this.features = new Proxy({ ..._EventSystem.defaultEventFeatures }, {
      set: (target, key, value) => {
        if (key === "globalMove") {
          this.rootBoundary.enableGlobalMoveEvents = value;
        }
        target[key] = value;
        return true;
      }
    });
    this.onPointerDown = this.onPointerDown.bind(this);
    this.onPointerMove = this.onPointerMove.bind(this);
    this.onPointerUp = this.onPointerUp.bind(this);
    this.onPointerOverOut = this.onPointerOverOut.bind(this);
    this.onWheel = this.onWheel.bind(this);
  }
  static get defaultEventMode() {
    return this._defaultEventMode;
  }
  init(options) {
    const { view, resolution } = this.renderer;
    this.setTargetElement(view);
    this.resolution = resolution;
    _EventSystem._defaultEventMode = options.eventMode ?? "auto";
    Object.assign(this.features, options.eventFeatures ?? {});
    this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
  }
  resolutionChange(resolution) {
    this.resolution = resolution;
  }
  destroy() {
    this.setTargetElement(null);
    this.renderer = null;
  }
  setCursor(mode) {
    mode = mode || "default";
    let applyStyles = true;
    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
      applyStyles = false;
    }
    if (this.currentCursor === mode) {
      return;
    }
    this.currentCursor = mode;
    const style = this.cursorStyles[mode];
    if (style) {
      switch (typeof style) {
        case "string":
          if (applyStyles) {
            this.domElement.style.cursor = style;
          }
          break;
        case "function":
          style(mode);
          break;
        case "object":
          if (applyStyles) {
            Object.assign(this.domElement.style, style);
          }
          break;
      }
    } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
      this.domElement.style.cursor = mode;
    }
  }
  get pointer() {
    return this.rootPointerEvent;
  }
  onPointerDown(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    const events = this.normalizeToPointerData(nativeEvent);
    if (this.autoPreventDefault && events[0].isNormalized) {
      const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
      if (cancelable) {
        nativeEvent.preventDefault();
      }
    }
    for (let i = 0, j = events.length; i < j; i++) {
      const nativeEvent2 = events[i];
      const federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);
      this.rootBoundary.mapEvent(federatedEvent);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerMove(nativeEvent) {
    if (!this.features.move)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    EventTicker.EventsTicker.pointerMoved();
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerUp(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    let target = nativeEvent.target;
    if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
      target = nativeEvent.composedPath()[0];
    }
    const outside = target !== this.domElement ? "outside" : "";
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
      event.type += outside;
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerOverOut(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onWheel(nativeEvent) {
    if (!this.features.wheel)
      return;
    const wheelEvent = this.normalizeWheelEvent(nativeEvent);
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    this.rootBoundary.mapEvent(wheelEvent);
  }
  setTargetElement(element) {
    this.removeEvents();
    this.domElement = element;
    EventTicker.EventsTicker.domElement = element;
    this.addEvents();
  }
  addEvents() {
    if (this.eventsAdded || !this.domElement) {
      return;
    }
    EventTicker.EventsTicker.addTickerListener();
    const style = this.domElement.style;
    if (style) {
      if (globalThis.navigator.msPointerEnabled) {
        style.msContentZooming = "none";
        style.msTouchAction = "none";
      } else if (this.supportsPointerEvents) {
        style.touchAction = "none";
      }
    }
    if (this.supportsPointerEvents) {
      globalThis.document.addEventListener("pointermove", this.onPointerMove, true);
      this.domElement.addEventListener("pointerdown", this.onPointerDown, true);
      this.domElement.addEventListener("pointerleave", this.onPointerOverOut, true);
      this.domElement.addEventListener("pointerover", this.onPointerOverOut, true);
      globalThis.addEventListener("pointerup", this.onPointerUp, true);
    } else {
      globalThis.document.addEventListener("mousemove", this.onPointerMove, true);
      this.domElement.addEventListener("mousedown", this.onPointerDown, true);
      this.domElement.addEventListener("mouseout", this.onPointerOverOut, true);
      this.domElement.addEventListener("mouseover", this.onPointerOverOut, true);
      globalThis.addEventListener("mouseup", this.onPointerUp, true);
    }
    if (this.supportsTouchEvents) {
      this.domElement.addEventListener("touchstart", this.onPointerDown, true);
      this.domElement.addEventListener("touchend", this.onPointerUp, true);
      this.domElement.addEventListener("touchmove", this.onPointerMove, true);
    }
    this.domElement.addEventListener("wheel", this.onWheel, {
      passive: true,
      capture: true
    });
    this.eventsAdded = true;
  }
  removeEvents() {
    if (!this.eventsAdded || !this.domElement) {
      return;
    }
    EventTicker.EventsTicker.removeTickerListener();
    const style = this.domElement.style;
    if (globalThis.navigator.msPointerEnabled) {
      style.msContentZooming = "";
      style.msTouchAction = "";
    } else if (this.supportsPointerEvents) {
      style.touchAction = "";
    }
    if (this.supportsPointerEvents) {
      globalThis.document.removeEventListener("pointermove", this.onPointerMove, true);
      this.domElement.removeEventListener("pointerdown", this.onPointerDown, true);
      this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, true);
      this.domElement.removeEventListener("pointerover", this.onPointerOverOut, true);
      globalThis.removeEventListener("pointerup", this.onPointerUp, true);
    } else {
      globalThis.document.removeEventListener("mousemove", this.onPointerMove, true);
      this.domElement.removeEventListener("mousedown", this.onPointerDown, true);
      this.domElement.removeEventListener("mouseout", this.onPointerOverOut, true);
      this.domElement.removeEventListener("mouseover", this.onPointerOverOut, true);
      globalThis.removeEventListener("mouseup", this.onPointerUp, true);
    }
    if (this.supportsTouchEvents) {
      this.domElement.removeEventListener("touchstart", this.onPointerDown, true);
      this.domElement.removeEventListener("touchend", this.onPointerUp, true);
      this.domElement.removeEventListener("touchmove", this.onPointerMove, true);
    }
    this.domElement.removeEventListener("wheel", this.onWheel, true);
    this.domElement = null;
    this.eventsAdded = false;
  }
  mapPositionToPoint(point, x, y) {
    let rect;
    if (!this.domElement.parentElement) {
      rect = {
        x: 0,
        y: 0,
        width: this.domElement.width,
        height: this.domElement.height,
        left: 0,
        top: 0
      };
    } else {
      rect = this.domElement.getBoundingClientRect();
    }
    const resolutionMultiplier = 1 / this.resolution;
    point.x = (x - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
    point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
  }
  normalizeToPointerData(event) {
    const normalizedEvents = [];
    if (this.supportsTouchEvents && event instanceof TouchEvent) {
      for (let i = 0, li = event.changedTouches.length; i < li; i++) {
        const touch = event.changedTouches[i];
        if (typeof touch.button === "undefined")
          touch.button = 0;
        if (typeof touch.buttons === "undefined")
          touch.buttons = 1;
        if (typeof touch.isPrimary === "undefined") {
          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
        }
        if (typeof touch.width === "undefined")
          touch.width = touch.radiusX || 1;
        if (typeof touch.height === "undefined")
          touch.height = touch.radiusY || 1;
        if (typeof touch.tiltX === "undefined")
          touch.tiltX = 0;
        if (typeof touch.tiltY === "undefined")
          touch.tiltY = 0;
        if (typeof touch.pointerType === "undefined")
          touch.pointerType = "touch";
        if (typeof touch.pointerId === "undefined")
          touch.pointerId = touch.identifier || 0;
        if (typeof touch.pressure === "undefined")
          touch.pressure = touch.force || 0.5;
        if (typeof touch.twist === "undefined")
          touch.twist = 0;
        if (typeof touch.tangentialPressure === "undefined")
          touch.tangentialPressure = 0;
        if (typeof touch.layerX === "undefined")
          touch.layerX = touch.offsetX = touch.clientX;
        if (typeof touch.layerY === "undefined")
          touch.layerY = touch.offsetY = touch.clientY;
        touch.isNormalized = true;
        touch.type = event.type;
        normalizedEvents.push(touch);
      }
    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
      const tempEvent = event;
      if (typeof tempEvent.isPrimary === "undefined")
        tempEvent.isPrimary = true;
      if (typeof tempEvent.width === "undefined")
        tempEvent.width = 1;
      if (typeof tempEvent.height === "undefined")
        tempEvent.height = 1;
      if (typeof tempEvent.tiltX === "undefined")
        tempEvent.tiltX = 0;
      if (typeof tempEvent.tiltY === "undefined")
        tempEvent.tiltY = 0;
      if (typeof tempEvent.pointerType === "undefined")
        tempEvent.pointerType = "mouse";
      if (typeof tempEvent.pointerId === "undefined")
        tempEvent.pointerId = MOUSE_POINTER_ID;
      if (typeof tempEvent.pressure === "undefined")
        tempEvent.pressure = 0.5;
      if (typeof tempEvent.twist === "undefined")
        tempEvent.twist = 0;
      if (typeof tempEvent.tangentialPressure === "undefined")
        tempEvent.tangentialPressure = 0;
      tempEvent.isNormalized = true;
      normalizedEvents.push(tempEvent);
    } else {
      normalizedEvents.push(event);
    }
    return normalizedEvents;
  }
  normalizeWheelEvent(nativeEvent) {
    const event = this.rootWheelEvent;
    this.transferMouseData(event, nativeEvent);
    event.deltaX = nativeEvent.deltaX;
    event.deltaY = nativeEvent.deltaY;
    event.deltaZ = nativeEvent.deltaZ;
    event.deltaMode = nativeEvent.deltaMode;
    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
    event.global.copyFrom(event.screen);
    event.offset.copyFrom(event.screen);
    event.nativeEvent = nativeEvent;
    event.type = nativeEvent.type;
    return event;
  }
  bootstrapEvent(event, nativeEvent) {
    event.originalEvent = null;
    event.nativeEvent = nativeEvent;
    event.pointerId = nativeEvent.pointerId;
    event.width = nativeEvent.width;
    event.height = nativeEvent.height;
    event.isPrimary = nativeEvent.isPrimary;
    event.pointerType = nativeEvent.pointerType;
    event.pressure = nativeEvent.pressure;
    event.tangentialPressure = nativeEvent.tangentialPressure;
    event.tiltX = nativeEvent.tiltX;
    event.tiltY = nativeEvent.tiltY;
    event.twist = nativeEvent.twist;
    this.transferMouseData(event, nativeEvent);
    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
    event.global.copyFrom(event.screen);
    event.offset.copyFrom(event.screen);
    event.isTrusted = nativeEvent.isTrusted;
    if (event.type === "pointerleave") {
      event.type = "pointerout";
    }
    if (event.type.startsWith("mouse")) {
      event.type = event.type.replace("mouse", "pointer");
    }
    if (event.type.startsWith("touch")) {
      event.type = TOUCH_TO_POINTER[event.type] || event.type;
    }
    return event;
  }
  transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted;
    event.srcElement = nativeEvent.srcElement;
    event.timeStamp = performance.now();
    event.type = nativeEvent.type;
    event.altKey = nativeEvent.altKey;
    event.button = nativeEvent.button;
    event.buttons = nativeEvent.buttons;
    event.client.x = nativeEvent.clientX;
    event.client.y = nativeEvent.clientY;
    event.ctrlKey = nativeEvent.ctrlKey;
    event.metaKey = nativeEvent.metaKey;
    event.movement.x = nativeEvent.movementX;
    event.movement.y = nativeEvent.movementY;
    event.page.x = nativeEvent.pageX;
    event.page.y = nativeEvent.pageY;
    event.relatedTarget = null;
    event.shiftKey = nativeEvent.shiftKey;
  }
};
let EventSystem = _EventSystem;
EventSystem.extension = {
  name: "events",
  type: [
    core.ExtensionType.RendererSystem,
    core.ExtensionType.CanvasRendererSystem
  ]
};
EventSystem.defaultEventFeatures = {
  move: true,
  globalMove: true,
  click: true,
  wheel: true
};
core.extensions.add(EventSystem);

exports.EventSystem = EventSystem;
//# sourceMappingURL=EventSystem.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/events/lib/EventTicker.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/events/lib/EventTicker.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

class EventsTickerClass {
  constructor() {
    this.interactionFrequency = 10;
    this._deltaTime = 0;
    this._didMove = false;
    this.tickerAdded = false;
    this._pauseUpdate = true;
  }
  init(events) {
    this.removeTickerListener();
    this.events = events;
    this.interactionFrequency = 10;
    this._deltaTime = 0;
    this._didMove = false;
    this.tickerAdded = false;
    this._pauseUpdate = true;
  }
  get pauseUpdate() {
    return this._pauseUpdate;
  }
  set pauseUpdate(paused) {
    this._pauseUpdate = paused;
  }
  addTickerListener() {
    if (this.tickerAdded || !this.domElement) {
      return;
    }
    core.Ticker.system.add(this.tickerUpdate, this, core.UPDATE_PRIORITY.INTERACTION);
    this.tickerAdded = true;
  }
  removeTickerListener() {
    if (!this.tickerAdded) {
      return;
    }
    core.Ticker.system.remove(this.tickerUpdate, this);
    this.tickerAdded = false;
  }
  pointerMoved() {
    this._didMove = true;
  }
  update() {
    if (!this.domElement || this._pauseUpdate) {
      return;
    }
    if (this._didMove) {
      this._didMove = false;
      return;
    }
    const rootPointerEvent = this.events["rootPointerEvent"];
    if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
      return;
    }
    globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
      clientX: rootPointerEvent.clientX,
      clientY: rootPointerEvent.clientY
    }));
  }
  tickerUpdate(deltaTime) {
    this._deltaTime += deltaTime;
    if (this._deltaTime < this.interactionFrequency) {
      return;
    }
    this._deltaTime = 0;
    this.update();
  }
}
const EventsTicker = new EventsTickerClass();

exports.EventsTicker = EventsTicker;
//# sourceMappingURL=EventTicker.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedEvent.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedEvent.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

class FederatedEvent {
  constructor(manager) {
    this.bubbles = true;
    this.cancelBubble = true;
    this.cancelable = false;
    this.composed = false;
    this.defaultPrevented = false;
    this.eventPhase = FederatedEvent.prototype.NONE;
    this.propagationStopped = false;
    this.propagationImmediatelyStopped = false;
    this.layer = new core.Point();
    this.page = new core.Point();
    this.NONE = 0;
    this.CAPTURING_PHASE = 1;
    this.AT_TARGET = 2;
    this.BUBBLING_PHASE = 3;
    this.manager = manager;
  }
  get layerX() {
    return this.layer.x;
  }
  get layerY() {
    return this.layer.y;
  }
  get pageX() {
    return this.page.x;
  }
  get pageY() {
    return this.page.y;
  }
  get data() {
    return this;
  }
  composedPath() {
    if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
      this.path = this.target ? this.manager.propagationPath(this.target) : [];
    }
    return this.path;
  }
  initEvent(_type, _bubbles, _cancelable) {
    throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
    throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  preventDefault() {
    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
      this.nativeEvent.preventDefault();
    }
    this.defaultPrevented = true;
  }
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = true;
  }
  stopPropagation() {
    this.propagationStopped = true;
  }
}

exports.FederatedEvent = FederatedEvent;
//# sourceMappingURL=FederatedEvent.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedEventMap.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedEventMap.js ***!
  \*********************************************************************************/
/***/ (() => {

"use strict";


//# sourceMappingURL=FederatedEventMap.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedEventTarget.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedEventTarget.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var display = __webpack_require__(/*! @pixi/display */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/index.js");
var EventSystem = __webpack_require__(/*! ./EventSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/EventSystem.js");
var FederatedEvent = __webpack_require__(/*! ./FederatedEvent.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedEvent.js");

function convertEventModeToInteractiveMode(mode) {
  return mode === "dynamic" || mode === "static";
}
const FederatedDisplayObject = {
  onclick: null,
  onmousedown: null,
  onmouseenter: null,
  onmouseleave: null,
  onmousemove: null,
  onglobalmousemove: null,
  onmouseout: null,
  onmouseover: null,
  onmouseup: null,
  onmouseupoutside: null,
  onpointercancel: null,
  onpointerdown: null,
  onpointerenter: null,
  onpointerleave: null,
  onpointermove: null,
  onglobalpointermove: null,
  onpointerout: null,
  onpointerover: null,
  onpointertap: null,
  onpointerup: null,
  onpointerupoutside: null,
  onrightclick: null,
  onrightdown: null,
  onrightup: null,
  onrightupoutside: null,
  ontap: null,
  ontouchcancel: null,
  ontouchend: null,
  ontouchendoutside: null,
  ontouchmove: null,
  onglobaltouchmove: null,
  ontouchstart: null,
  onwheel: null,
  _internalInteractive: void 0,
  get interactive() {
    return this._internalInteractive ?? convertEventModeToInteractiveMode(EventSystem.EventSystem.defaultEventMode);
  },
  set interactive(value) {
    core.utils.deprecation("7.2.0", `Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead.`);
    this._internalInteractive = value;
    this.eventMode = value ? "static" : "auto";
  },
  _internalEventMode: void 0,
  get eventMode() {
    return this._internalEventMode ?? EventSystem.EventSystem.defaultEventMode;
  },
  set eventMode(value) {
    this._internalInteractive = convertEventModeToInteractiveMode(value);
    this._internalEventMode = value;
  },
  isInteractive() {
    return this.eventMode === "static" || this.eventMode === "dynamic";
  },
  interactiveChildren: true,
  hitArea: null,
  addEventListener(type, listener, options) {
    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
    const context = typeof listener === "function" ? void 0 : listener;
    type = capture ? `${type}capture` : type;
    listener = typeof listener === "function" ? listener : listener.handleEvent;
    this.on(type, listener, context);
  },
  removeEventListener(type, listener, options) {
    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
    const context = typeof listener === "function" ? void 0 : listener;
    type = capture ? `${type}capture` : type;
    listener = typeof listener === "function" ? listener : listener.handleEvent;
    this.off(type, listener, context);
  },
  dispatchEvent(e) {
    if (!(e instanceof FederatedEvent.FederatedEvent)) {
      throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
    }
    e.defaultPrevented = false;
    e.path = null;
    e.target = this;
    e.manager.dispatchEvent(e);
    return !e.defaultPrevented;
  }
};
display.DisplayObject.mixin(FederatedDisplayObject);

exports.FederatedDisplayObject = FederatedDisplayObject;
//# sourceMappingURL=FederatedEventTarget.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedMouseEvent.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedMouseEvent.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var FederatedEvent = __webpack_require__(/*! ./FederatedEvent.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedEvent.js");

class FederatedMouseEvent extends FederatedEvent.FederatedEvent {
  constructor() {
    super(...arguments);
    this.client = new core.Point();
    this.movement = new core.Point();
    this.offset = new core.Point();
    this.global = new core.Point();
    this.screen = new core.Point();
  }
  get clientX() {
    return this.client.x;
  }
  get clientY() {
    return this.client.y;
  }
  get x() {
    return this.clientX;
  }
  get y() {
    return this.clientY;
  }
  get movementX() {
    return this.movement.x;
  }
  get movementY() {
    return this.movement.y;
  }
  get offsetX() {
    return this.offset.x;
  }
  get offsetY() {
    return this.offset.y;
  }
  get globalX() {
    return this.global.x;
  }
  get globalY() {
    return this.global.y;
  }
  get screenX() {
    return this.screen.x;
  }
  get screenY() {
    return this.screen.y;
  }
  getLocalPosition(displayObject, point, globalPos) {
    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
  }
  getModifierState(key) {
    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
  }
  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
    throw new Error("Method not implemented.");
  }
}

exports.FederatedMouseEvent = FederatedMouseEvent;
//# sourceMappingURL=FederatedMouseEvent.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedPointerEvent.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedPointerEvent.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var FederatedMouseEvent = __webpack_require__(/*! ./FederatedMouseEvent.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedMouseEvent.js");

class FederatedPointerEvent extends FederatedMouseEvent.FederatedMouseEvent {
  constructor() {
    super(...arguments);
    this.width = 0;
    this.height = 0;
    this.isPrimary = false;
  }
  getCoalescedEvents() {
    if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
      return [this];
    }
    return [];
  }
  getPredictedEvents() {
    throw new Error("getPredictedEvents is not supported!");
  }
}

exports.FederatedPointerEvent = FederatedPointerEvent;
//# sourceMappingURL=FederatedPointerEvent.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedWheelEvent.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedWheelEvent.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var FederatedMouseEvent = __webpack_require__(/*! ./FederatedMouseEvent.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedMouseEvent.js");

class FederatedWheelEvent extends FederatedMouseEvent.FederatedMouseEvent {
  constructor() {
    super(...arguments);
    this.DOM_DELTA_PIXEL = 0;
    this.DOM_DELTA_LINE = 1;
    this.DOM_DELTA_PAGE = 2;
  }
}
FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
FederatedWheelEvent.DOM_DELTA_LINE = 1;
FederatedWheelEvent.DOM_DELTA_PAGE = 2;

exports.FederatedWheelEvent = FederatedWheelEvent;
//# sourceMappingURL=FederatedWheelEvent.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/events/lib/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/events/lib/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var EventBoundary = __webpack_require__(/*! ./EventBoundary.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/EventBoundary.js");
var EventSystem = __webpack_require__(/*! ./EventSystem.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/EventSystem.js");
var FederatedEvent = __webpack_require__(/*! ./FederatedEvent.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedEvent.js");
__webpack_require__(/*! ./FederatedEventMap.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedEventMap.js");
var FederatedEventTarget = __webpack_require__(/*! ./FederatedEventTarget.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedEventTarget.js");
var FederatedMouseEvent = __webpack_require__(/*! ./FederatedMouseEvent.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedMouseEvent.js");
var FederatedPointerEvent = __webpack_require__(/*! ./FederatedPointerEvent.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedPointerEvent.js");
var FederatedWheelEvent = __webpack_require__(/*! ./FederatedWheelEvent.js */ "./node_modules/pixi.js/node_modules/@pixi/events/lib/FederatedWheelEvent.js");



exports.EventBoundary = EventBoundary.EventBoundary;
exports.EventSystem = EventSystem.EventSystem;
exports.FederatedEvent = FederatedEvent.FederatedEvent;
exports.FederatedDisplayObject = FederatedEventTarget.FederatedDisplayObject;
exports.FederatedMouseEvent = FederatedMouseEvent.FederatedMouseEvent;
exports.FederatedPointerEvent = FederatedPointerEvent.FederatedPointerEvent;
exports.FederatedWheelEvent = FederatedWheelEvent.FederatedWheelEvent;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
  ExtensionType2["Renderer"] = "renderer";
  ExtensionType2["Application"] = "application";
  ExtensionType2["RendererSystem"] = "renderer-webgl-system";
  ExtensionType2["RendererPlugin"] = "renderer-webgl-plugin";
  ExtensionType2["CanvasRendererSystem"] = "renderer-canvas-system";
  ExtensionType2["CanvasRendererPlugin"] = "renderer-canvas-plugin";
  ExtensionType2["Asset"] = "asset";
  ExtensionType2["LoadParser"] = "load-parser";
  ExtensionType2["ResolveParser"] = "resolve-parser";
  ExtensionType2["CacheParser"] = "cache-parser";
  ExtensionType2["DetectionParser"] = "detection-parser";
  return ExtensionType2;
})(ExtensionType || {});
const normalizeExtension = (ext) => {
  if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
    if (!ext.extension) {
      throw new Error("Extension class must have an extension object");
    }
    const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
    ext = { ...metadata, ref: ext };
  }
  if (typeof ext === "object") {
    ext = { ...ext };
  } else {
    throw new Error("Invalid extension type");
  }
  if (typeof ext.type === "string") {
    ext.type = [ext.type];
  }
  return ext;
};
const normalizePriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
const extensions = {
  _addHandlers: {},
  _removeHandlers: {},
  _queue: {},
  remove(...extensions2) {
    extensions2.map(normalizeExtension).forEach((ext) => {
      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
    });
    return this;
  },
  add(...extensions2) {
    extensions2.map(normalizeExtension).forEach((ext) => {
      ext.type.forEach((type) => {
        const handlers = this._addHandlers;
        const queue = this._queue;
        if (!handlers[type]) {
          queue[type] = queue[type] || [];
          queue[type].push(ext);
        } else {
          handlers[type](ext);
        }
      });
    });
    return this;
  },
  handle(type, onAdd, onRemove) {
    const addHandlers = this._addHandlers;
    const removeHandlers = this._removeHandlers;
    if (addHandlers[type] || removeHandlers[type]) {
      throw new Error(`Extension type ${type} already has a handler`);
    }
    addHandlers[type] = onAdd;
    removeHandlers[type] = onRemove;
    const queue = this._queue;
    if (queue[type]) {
      queue[type].forEach((ext) => onAdd(ext));
      delete queue[type];
    }
    return this;
  },
  handleByMap(type, map) {
    return this.handle(type, (extension) => {
      map[extension.name] = extension.ref;
    }, (extension) => {
      delete map[extension.name];
    });
  },
  handleByList(type, list, defaultPriority = -1) {
    return this.handle(type, (extension) => {
      if (list.includes(extension.ref)) {
        return;
      }
      list.push(extension.ref);
      list.sort((a, b) => normalizePriority(b, defaultPriority) - normalizePriority(a, defaultPriority));
    }, (extension) => {
      const index = list.indexOf(extension.ref);
      if (index !== -1) {
        list.splice(index, 1);
      }
    });
  }
};

exports.ExtensionType = ExtensionType;
exports.extensions = extensions;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/extract/lib/Extract.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/extract/lib/Extract.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

const TEMP_RECT = new core.Rectangle();
const BYTES_PER_PIXEL = 4;
const _Extract = class {
  constructor(renderer) {
    this.renderer = renderer;
  }
  async image(target, format, quality) {
    const image = new Image();
    image.src = await this.base64(target, format, quality);
    return image;
  }
  async base64(target, format, quality) {
    const canvas = this.canvas(target);
    if (canvas.toBlob !== void 0) {
      return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if (!blob) {
            reject(new Error("ICanvas.toBlob failed!"));
            return;
          }
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        }, format, quality);
      });
    }
    if (canvas.toDataURL !== void 0) {
      return canvas.toDataURL(format, quality);
    }
    if (canvas.convertToBlob !== void 0) {
      const blob = await canvas.convertToBlob({ type: format, quality });
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }
    throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
  }
  canvas(target, frame) {
    const { pixels, width, height, flipY } = this._rawPixels(target, frame);
    if (flipY) {
      _Extract._flipY(pixels, width, height);
    }
    _Extract._unpremultiplyAlpha(pixels);
    const canvasBuffer = new core.utils.CanvasRenderTarget(width, height, 1);
    const imageData = new ImageData(new Uint8ClampedArray(pixels.buffer), width, height);
    canvasBuffer.context.putImageData(imageData, 0, 0);
    return canvasBuffer.canvas;
  }
  pixels(target, frame) {
    const { pixels, width, height, flipY } = this._rawPixels(target, frame);
    if (flipY) {
      _Extract._flipY(pixels, width, height);
    }
    _Extract._unpremultiplyAlpha(pixels);
    return pixels;
  }
  _rawPixels(target, frame) {
    const renderer = this.renderer;
    if (!renderer) {
      throw new Error("The Extract has already been destroyed");
    }
    let resolution;
    let flipY = false;
    let renderTexture;
    let generated = false;
    if (target) {
      if (target instanceof core.RenderTexture) {
        renderTexture = target;
      } else {
        renderTexture = renderer.generateTexture(target, {
          resolution: renderer.resolution,
          multisample: renderer.multisample
        });
        generated = true;
      }
    }
    if (renderTexture) {
      resolution = renderTexture.baseTexture.resolution;
      frame = frame ?? renderTexture.frame;
      flipY = false;
      if (!generated) {
        renderer.renderTexture.bind(renderTexture);
        const fbo = renderTexture.framebuffer.glFramebuffers[renderer.CONTEXT_UID];
        if (fbo.blitFramebuffer) {
          renderer.framebuffer.bind(fbo.blitFramebuffer);
        }
      }
    } else {
      resolution = renderer.resolution;
      if (!frame) {
        frame = TEMP_RECT;
        frame.width = renderer.width / resolution;
        frame.height = renderer.height / resolution;
      }
      flipY = true;
      renderer.renderTexture.bind();
    }
    const width = Math.round(frame.width * resolution);
    const height = Math.round(frame.height * resolution);
    const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
    const gl = renderer.gl;
    gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    if (generated) {
      renderTexture?.destroy(true);
    }
    return { pixels, width, height, flipY };
  }
  destroy() {
    this.renderer = null;
  }
  static _flipY(pixels, width, height) {
    const w = width << 2;
    const h = height >> 1;
    const temp = new Uint8Array(w);
    for (let y = 0; y < h; y++) {
      const t = y * w;
      const b = (height - y - 1) * w;
      temp.set(pixels.subarray(t, t + w));
      pixels.copyWithin(t, b, b + w);
      pixels.set(temp, b);
    }
  }
  static _unpremultiplyAlpha(pixels) {
    if (pixels instanceof Uint8ClampedArray) {
      pixels = new Uint8Array(pixels.buffer);
    }
    const n = pixels.length;
    for (let i = 0; i < n; i += 4) {
      const alpha = pixels[i + 3];
      if (alpha !== 0) {
        const a = 255.001 / alpha;
        pixels[i] = pixels[i] * a + 0.5;
        pixels[i + 1] = pixels[i + 1] * a + 0.5;
        pixels[i + 2] = pixels[i + 2] * a + 0.5;
      }
    }
  }
};
let Extract = _Extract;
Extract.extension = {
  name: "extract",
  type: core.ExtensionType.RendererSystem
};
core.extensions.add(Extract);

exports.Extract = Extract;
//# sourceMappingURL=Extract.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/extract/lib/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/extract/lib/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Extract = __webpack_require__(/*! ./Extract.js */ "./node_modules/pixi.js/node_modules/@pixi/extract/lib/Extract.js");



exports.Extract = Extract.Extract;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-alpha/lib/AlphaFilter.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-alpha/lib/AlphaFilter.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var alpha = __webpack_require__(/*! ./alpha.js */ "./node_modules/pixi.js/node_modules/@pixi/filter-alpha/lib/alpha.js");

class AlphaFilter extends core.Filter {
  constructor(alpha$1 = 1) {
    super(core.defaultVertex, alpha["default"], { uAlpha: 1 });
    this.alpha = alpha$1;
  }
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
}

exports.AlphaFilter = AlphaFilter;
//# sourceMappingURL=AlphaFilter.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-alpha/lib/alpha.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-alpha/lib/alpha.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var fragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n";

exports["default"] = fragment;
//# sourceMappingURL=alpha.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-alpha/lib/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-alpha/lib/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var AlphaFilter = __webpack_require__(/*! ./AlphaFilter.js */ "./node_modules/pixi.js/node_modules/@pixi/filter-alpha/lib/AlphaFilter.js");



exports.AlphaFilter = AlphaFilter.AlphaFilter;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-blur/lib/BlurFilter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-blur/lib/BlurFilter.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var BlurFilterPass = __webpack_require__(/*! ./BlurFilterPass.js */ "./node_modules/pixi.js/node_modules/@pixi/filter-blur/lib/BlurFilterPass.js");

class BlurFilter extends core.Filter {
  constructor(strength = 8, quality = 4, resolution = core.Filter.defaultResolution, kernelSize = 5) {
    super();
    this._repeatEdgePixels = false;
    this.blurXFilter = new BlurFilterPass.BlurFilterPass(true, strength, quality, resolution, kernelSize);
    this.blurYFilter = new BlurFilterPass.BlurFilterPass(false, strength, quality, resolution, kernelSize);
    this.resolution = resolution;
    this.quality = quality;
    this.blur = strength;
    this.repeatEdgePixels = false;
  }
  apply(filterManager, input, output, clearMode) {
    const xStrength = Math.abs(this.blurXFilter.strength);
    const yStrength = Math.abs(this.blurYFilter.strength);
    if (xStrength && yStrength) {
      const renderTarget = filterManager.getFilterTexture();
      this.blurXFilter.apply(filterManager, input, renderTarget, core.CLEAR_MODES.CLEAR);
      this.blurYFilter.apply(filterManager, renderTarget, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    } else if (yStrength) {
      this.blurYFilter.apply(filterManager, input, output, clearMode);
    } else {
      this.blurXFilter.apply(filterManager, input, output, clearMode);
    }
  }
  updatePadding() {
    if (this._repeatEdgePixels) {
      this.padding = 0;
    } else {
      this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
    }
  }
  get blur() {
    return this.blurXFilter.blur;
  }
  set blur(value) {
    this.blurXFilter.blur = this.blurYFilter.blur = value;
    this.updatePadding();
  }
  get quality() {
    return this.blurXFilter.quality;
  }
  set quality(value) {
    this.blurXFilter.quality = this.blurYFilter.quality = value;
  }
  get blurX() {
    return this.blurXFilter.blur;
  }
  set blurX(value) {
    this.blurXFilter.blur = value;
    this.updatePadding();
  }
  get blurY() {
    return this.blurYFilter.blur;
  }
  set blurY(value) {
    this.blurYFilter.blur = value;
    this.updatePadding();
  }
  get blendMode() {
    return this.blurYFilter.blendMode;
  }
  set blendMode(value) {
    this.blurYFilter.blendMode = value;
  }
  get repeatEdgePixels() {
    return this._repeatEdgePixels;
  }
  set repeatEdgePixels(value) {
    this._repeatEdgePixels = value;
    this.updatePadding();
  }
}

exports.BlurFilter = BlurFilter;
//# sourceMappingURL=BlurFilter.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-blur/lib/BlurFilterPass.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-blur/lib/BlurFilterPass.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var generateBlurFragSource = __webpack_require__(/*! ./generateBlurFragSource.js */ "./node_modules/pixi.js/node_modules/@pixi/filter-blur/lib/generateBlurFragSource.js");
var generateBlurVertSource = __webpack_require__(/*! ./generateBlurVertSource.js */ "./node_modules/pixi.js/node_modules/@pixi/filter-blur/lib/generateBlurVertSource.js");

class BlurFilterPass extends core.Filter {
  constructor(horizontal, strength = 8, quality = 4, resolution = core.Filter.defaultResolution, kernelSize = 5) {
    const vertSrc = generateBlurVertSource.generateBlurVertSource(kernelSize, horizontal);
    const fragSrc = generateBlurFragSource.generateBlurFragSource(kernelSize);
    super(vertSrc, fragSrc);
    this.horizontal = horizontal;
    this.resolution = resolution;
    this._quality = 0;
    this.quality = quality;
    this.blur = strength;
  }
  apply(filterManager, input, output, clearMode) {
    if (output) {
      if (this.horizontal) {
        this.uniforms.strength = 1 / output.width * (output.width / input.width);
      } else {
        this.uniforms.strength = 1 / output.height * (output.height / input.height);
      }
    } else {
      if (this.horizontal) {
        this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);
      } else {
        this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);
      }
    }
    this.uniforms.strength *= this.strength;
    this.uniforms.strength /= this.passes;
    if (this.passes === 1) {
      filterManager.applyFilter(this, input, output, clearMode);
    } else {
      const renderTarget = filterManager.getFilterTexture();
      const renderer = filterManager.renderer;
      let flip = input;
      let flop = renderTarget;
      this.state.blend = false;
      filterManager.applyFilter(this, flip, flop, core.CLEAR_MODES.CLEAR);
      for (let i = 1; i < this.passes - 1; i++) {
        filterManager.bindAndClear(flip, core.CLEAR_MODES.BLIT);
        this.uniforms.uSampler = flop;
        const temp = flop;
        flop = flip;
        flip = temp;
        renderer.shader.bind(this);
        renderer.geometry.draw(5);
      }
      this.state.blend = true;
      filterManager.applyFilter(this, flop, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    }
  }
  get blur() {
    return this.strength;
  }
  set blur(value) {
    this.padding = 1 + Math.abs(value) * 2;
    this.strength = value;
  }
  get quality() {
    return this._quality;
  }
  set quality(value) {
    this._quality = value;
    this.passes = value;
  }
}

exports.BlurFilterPass = BlurFilterPass;
//# sourceMappingURL=BlurFilterPass.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-blur/lib/generateBlurFragSource.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-blur/lib/generateBlurFragSource.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const GAUSSIAN_VALUES = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
};
const fragTemplate = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join("\n");
function generateBlurFragSource(kernelSize) {
  const kernel = GAUSSIAN_VALUES[kernelSize];
  const halfLength = kernel.length;
  let fragSource = fragTemplate;
  let blurLoop = "";
  const template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
  let value;
  for (let i = 0; i < kernelSize; i++) {
    let blur = template.replace("%index%", i.toString());
    value = i;
    if (i >= halfLength) {
      value = kernelSize - i - 1;
    }
    blur = blur.replace("%value%", kernel[value].toString());
    blurLoop += blur;
    blurLoop += "\n";
  }
  fragSource = fragSource.replace("%blur%", blurLoop);
  fragSource = fragSource.replace("%size%", kernelSize.toString());
  return fragSource;
}

exports.generateBlurFragSource = generateBlurFragSource;
//# sourceMappingURL=generateBlurFragSource.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-blur/lib/generateBlurVertSource.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-blur/lib/generateBlurVertSource.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const vertTemplate = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function generateBlurVertSource(kernelSize, x) {
  const halfLength = Math.ceil(kernelSize / 2);
  let vertSource = vertTemplate;
  let blurLoop = "";
  let template;
  if (x) {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);";
  } else {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  }
  for (let i = 0; i < kernelSize; i++) {
    let blur = template.replace("%index%", i.toString());
    blur = blur.replace("%sampleIndex%", `${i - (halfLength - 1)}.0`);
    blurLoop += blur;
    blurLoop += "\n";
  }
  vertSource = vertSource.replace("%blur%", blurLoop);
  vertSource = vertSource.replace("%size%", kernelSize.toString());
  return vertSource;
}

exports.generateBlurVertSource = generateBlurVertSource;
//# sourceMappingURL=generateBlurVertSource.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-blur/lib/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-blur/lib/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var BlurFilter = __webpack_require__(/*! ./BlurFilter.js */ "./node_modules/pixi.js/node_modules/@pixi/filter-blur/lib/BlurFilter.js");
var BlurFilterPass = __webpack_require__(/*! ./BlurFilterPass.js */ "./node_modules/pixi.js/node_modules/@pixi/filter-blur/lib/BlurFilterPass.js");



exports.BlurFilter = BlurFilter.BlurFilter;
exports.BlurFilterPass = BlurFilterPass.BlurFilterPass;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-color-matrix/lib/ColorMatrixFilter.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-color-matrix/lib/ColorMatrixFilter.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var colorMatrix = __webpack_require__(/*! ./colorMatrix.js */ "./node_modules/pixi.js/node_modules/@pixi/filter-color-matrix/lib/colorMatrix.js");

class ColorMatrixFilter extends core.Filter {
  constructor() {
    const uniforms = {
      m: new Float32Array([
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]),
      uAlpha: 1
    };
    super(core.defaultFilterVertex, colorMatrix["default"], uniforms);
    this.alpha = 1;
  }
  _loadMatrix(matrix, multiply = false) {
    let newMatrix = matrix;
    if (multiply) {
      this._multiply(newMatrix, this.uniforms.m, matrix);
      newMatrix = this._colorMatrix(newMatrix);
    }
    this.uniforms.m = newMatrix;
  }
  _multiply(out, a, b) {
    out[0] = a[0] * b[0] + a[1] * b[5] + a[2] * b[10] + a[3] * b[15];
    out[1] = a[0] * b[1] + a[1] * b[6] + a[2] * b[11] + a[3] * b[16];
    out[2] = a[0] * b[2] + a[1] * b[7] + a[2] * b[12] + a[3] * b[17];
    out[3] = a[0] * b[3] + a[1] * b[8] + a[2] * b[13] + a[3] * b[18];
    out[4] = a[0] * b[4] + a[1] * b[9] + a[2] * b[14] + a[3] * b[19] + a[4];
    out[5] = a[5] * b[0] + a[6] * b[5] + a[7] * b[10] + a[8] * b[15];
    out[6] = a[5] * b[1] + a[6] * b[6] + a[7] * b[11] + a[8] * b[16];
    out[7] = a[5] * b[2] + a[6] * b[7] + a[7] * b[12] + a[8] * b[17];
    out[8] = a[5] * b[3] + a[6] * b[8] + a[7] * b[13] + a[8] * b[18];
    out[9] = a[5] * b[4] + a[6] * b[9] + a[7] * b[14] + a[8] * b[19] + a[9];
    out[10] = a[10] * b[0] + a[11] * b[5] + a[12] * b[10] + a[13] * b[15];
    out[11] = a[10] * b[1] + a[11] * b[6] + a[12] * b[11] + a[13] * b[16];
    out[12] = a[10] * b[2] + a[11] * b[7] + a[12] * b[12] + a[13] * b[17];
    out[13] = a[10] * b[3] + a[11] * b[8] + a[12] * b[13] + a[13] * b[18];
    out[14] = a[10] * b[4] + a[11] * b[9] + a[12] * b[14] + a[13] * b[19] + a[14];
    out[15] = a[15] * b[0] + a[16] * b[5] + a[17] * b[10] + a[18] * b[15];
    out[16] = a[15] * b[1] + a[16] * b[6] + a[17] * b[11] + a[18] * b[16];
    out[17] = a[15] * b[2] + a[16] * b[7] + a[17] * b[12] + a[18] * b[17];
    out[18] = a[15] * b[3] + a[16] * b[8] + a[17] * b[13] + a[18] * b[18];
    out[19] = a[15] * b[4] + a[16] * b[9] + a[17] * b[14] + a[18] * b[19] + a[19];
    return out;
  }
  _colorMatrix(matrix) {
    const m = new Float32Array(matrix);
    m[4] /= 255;
    m[9] /= 255;
    m[14] /= 255;
    m[19] /= 255;
    return m;
  }
  brightness(b, multiply) {
    const matrix = [
      b,
      0,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  tint(color, multiply) {
    const [r, g, b] = core.Color.shared.setValue(color).toArray();
    const matrix = [
      r,
      0,
      0,
      0,
      0,
      0,
      g,
      0,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  greyscale(scale, multiply) {
    const matrix = [
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  blackAndWhite(multiply) {
    const matrix = [
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  hue(rotation, multiply) {
    rotation = (rotation || 0) / 180 * Math.PI;
    const cosR = Math.cos(rotation);
    const sinR = Math.sin(rotation);
    const sqrt = Math.sqrt;
    const w = 1 / 3;
    const sqrW = sqrt(w);
    const a00 = cosR + (1 - cosR) * w;
    const a01 = w * (1 - cosR) - sqrW * sinR;
    const a02 = w * (1 - cosR) + sqrW * sinR;
    const a10 = w * (1 - cosR) + sqrW * sinR;
    const a11 = cosR + w * (1 - cosR);
    const a12 = w * (1 - cosR) - sqrW * sinR;
    const a20 = w * (1 - cosR) - sqrW * sinR;
    const a21 = w * (1 - cosR) + sqrW * sinR;
    const a22 = cosR + w * (1 - cosR);
    const matrix = [
      a00,
      a01,
      a02,
      0,
      0,
      a10,
      a11,
      a12,
      0,
      0,
      a20,
      a21,
      a22,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  contrast(amount, multiply) {
    const v = (amount || 0) + 1;
    const o = -0.5 * (v - 1);
    const matrix = [
      v,
      0,
      0,
      0,
      o,
      0,
      v,
      0,
      0,
      o,
      0,
      0,
      v,
      0,
      o,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  saturate(amount = 0, multiply) {
    const x = amount * 2 / 3 + 1;
    const y = (x - 1) * -0.5;
    const matrix = [
      x,
      y,
      y,
      0,
      0,
      y,
      x,
      y,
      0,
      0,
      y,
      y,
      x,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  desaturate() {
    this.saturate(-1);
  }
  negative(multiply) {
    const matrix = [
      -1,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      -1,
      1,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  sepia(multiply) {
    const matrix = [
      0.393,
      0.7689999,
      0.18899999,
      0,
      0,
      0.349,
      0.6859999,
      0.16799999,
      0,
      0,
      0.272,
      0.5339999,
      0.13099999,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  technicolor(multiply) {
    const matrix = [
      1.9125277891456083,
      -0.8545344976951645,
      -0.09155508482755585,
      0,
      11.793603434377337,
      -0.3087833385928097,
      1.7658908555458428,
      -0.10601743074722245,
      0,
      -70.35205161461398,
      -0.231103377548616,
      -0.7501899197440212,
      1.847597816108189,
      0,
      30.950940869491138,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  polaroid(multiply) {
    const matrix = [
      1.438,
      -0.062,
      -0.062,
      0,
      0,
      -0.122,
      1.378,
      -0.122,
      0,
      0,
      -0.016,
      -0.016,
      1.483,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  toBGR(multiply) {
    const matrix = [
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  kodachrome(multiply) {
    const matrix = [
      1.1285582396593525,
      -0.3967382283601348,
      -0.03992559172921793,
      0,
      63.72958762196502,
      -0.16404339962244616,
      1.0835251566291304,
      -0.05498805115633132,
      0,
      24.732407896706203,
      -0.16786010706155763,
      -0.5603416277695248,
      1.6014850761964943,
      0,
      35.62982807460946,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  browni(multiply) {
    const matrix = [
      0.5997023498159715,
      0.34553243048391263,
      -0.2708298674538042,
      0,
      47.43192855600873,
      -0.037703249837783157,
      0.8609577587992641,
      0.15059552388459913,
      0,
      -36.96841498319127,
      0.24113635128153335,
      -0.07441037908422492,
      0.44972182064877153,
      0,
      -7.562075277591283,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  vintage(multiply) {
    const matrix = [
      0.6279345635605994,
      0.3202183420819367,
      -0.03965408211312453,
      0,
      9.651285835294123,
      0.02578397704808868,
      0.6441188644374771,
      0.03259127616149294,
      0,
      7.462829176470591,
      0.0466055556782719,
      -0.0851232987247891,
      0.5241648018700465,
      0,
      5.159190588235296,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  colorTone(desaturation, toned, lightColor, darkColor, multiply) {
    desaturation = desaturation || 0.2;
    toned = toned || 0.15;
    lightColor = lightColor || 16770432;
    darkColor = darkColor || 3375104;
    const temp = core.Color.shared;
    const [lR, lG, lB] = temp.setValue(lightColor).toArray();
    const [dR, dG, dB] = temp.setValue(darkColor).toArray();
    const matrix = [
      0.3,
      0.59,
      0.11,
      0,
      0,
      lR,
      lG,
      lB,
      desaturation,
      0,
      dR,
      dG,
      dB,
      toned,
      0,
      lR - dR,
      lG - dG,
      lB - dB,
      0,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  night(intensity, multiply) {
    intensity = intensity || 0.1;
    const matrix = [
      intensity * -2,
      -intensity,
      0,
      0,
      0,
      -intensity,
      0,
      intensity,
      0,
      0,
      0,
      intensity,
      intensity * 2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  predator(amount, multiply) {
    const matrix = [
      11.224130630493164 * amount,
      -4.794486999511719 * amount,
      -2.8746118545532227 * amount,
      0 * amount,
      0.40342438220977783 * amount,
      -3.6330697536468506 * amount,
      9.193157196044922 * amount,
      -2.951810836791992 * amount,
      0 * amount,
      -1.316135048866272 * amount,
      -3.2184197902679443 * amount,
      -4.2375030517578125 * amount,
      7.476448059082031 * amount,
      0 * amount,
      0.8044459223747253 * amount,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  lsd(multiply) {
    const matrix = [
      2,
      -0.4,
      0.5,
      0,
      0,
      -0.5,
      2,
      -0.4,
      0,
      0,
      -0.4,
      -0.5,
      3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  reset() {
    const matrix = [
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, false);
  }
  get matrix() {
    return this.uniforms.m;
  }
  set matrix(value) {
    this.uniforms.m = value;
  }
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
}
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;

exports.ColorMatrixFilter = ColorMatrixFilter;
//# sourceMappingURL=ColorMatrixFilter.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-color-matrix/lib/colorMatrix.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-color-matrix/lib/colorMatrix.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var fragment = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n";

exports["default"] = fragment;
//# sourceMappingURL=colorMatrix.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-color-matrix/lib/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-color-matrix/lib/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var ColorMatrixFilter = __webpack_require__(/*! ./ColorMatrixFilter.js */ "./node_modules/pixi.js/node_modules/@pixi/filter-color-matrix/lib/ColorMatrixFilter.js");



exports.ColorMatrixFilter = ColorMatrixFilter.ColorMatrixFilter;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-displacement/lib/DisplacementFilter.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-displacement/lib/DisplacementFilter.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var displacement$1 = __webpack_require__(/*! ./displacement.js */ "./node_modules/pixi.js/node_modules/@pixi/filter-displacement/lib/displacement.js");
var displacement = __webpack_require__(/*! ./displacement2.js */ "./node_modules/pixi.js/node_modules/@pixi/filter-displacement/lib/displacement2.js");

class DisplacementFilter extends core.Filter {
  constructor(sprite, scale) {
    const maskMatrix = new core.Matrix();
    sprite.renderable = false;
    super(displacement["default"], displacement$1["default"], {
      mapSampler: sprite._texture,
      filterMatrix: maskMatrix,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    });
    this.maskSprite = sprite;
    this.maskMatrix = maskMatrix;
    if (scale === null || scale === void 0) {
      scale = 20;
    }
    this.scale = new core.Point(scale, scale);
  }
  apply(filterManager, input, output, clearMode) {
    this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
    this.uniforms.scale.x = this.scale.x;
    this.uniforms.scale.y = this.scale.y;
    const wt = this.maskSprite.worldTransform;
    const lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
    const lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
    if (lenX !== 0 && lenY !== 0) {
      this.uniforms.rotation[0] = wt.a / lenX;
      this.uniforms.rotation[1] = wt.b / lenX;
      this.uniforms.rotation[2] = wt.c / lenY;
      this.uniforms.rotation[3] = wt.d / lenY;
    }
    filterManager.applyFilter(this, input, output, clearMode);
  }
  get map() {
    return this.uniforms.mapSampler;
  }
  set map(value) {
    this.uniforms.mapSampler = value;
  }
}

exports.DisplacementFilter = DisplacementFilter;
//# sourceMappingURL=DisplacementFilter.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-displacement/lib/displacement.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-displacement/lib/displacement.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var fragment = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n";

exports["default"] = fragment;
//# sourceMappingURL=displacement.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-displacement/lib/displacement2.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-displacement/lib/displacement2.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var vertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n";

exports["default"] = vertex;
//# sourceMappingURL=displacement2.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-displacement/lib/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-displacement/lib/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var DisplacementFilter = __webpack_require__(/*! ./DisplacementFilter.js */ "./node_modules/pixi.js/node_modules/@pixi/filter-displacement/lib/DisplacementFilter.js");



exports.DisplacementFilter = DisplacementFilter.DisplacementFilter;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-fxaa/lib/FXAAFilter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-fxaa/lib/FXAAFilter.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var fxaa$1 = __webpack_require__(/*! ./fxaa.js */ "./node_modules/pixi.js/node_modules/@pixi/filter-fxaa/lib/fxaa.js");
var fxaa = __webpack_require__(/*! ./fxaa2.js */ "./node_modules/pixi.js/node_modules/@pixi/filter-fxaa/lib/fxaa2.js");

class FXAAFilter extends core.Filter {
  constructor() {
    super(fxaa["default"], fxaa$1["default"]);
  }
}

exports.FXAAFilter = FXAAFilter;
//# sourceMappingURL=FXAAFilter.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-fxaa/lib/fxaa.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-fxaa/lib/fxaa.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var fragment = "varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it's\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n";

exports["default"] = fragment;
//# sourceMappingURL=fxaa.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-fxaa/lib/fxaa2.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-fxaa/lib/fxaa2.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var vertex = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n";

exports["default"] = vertex;
//# sourceMappingURL=fxaa2.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-fxaa/lib/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-fxaa/lib/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var FXAAFilter = __webpack_require__(/*! ./FXAAFilter.js */ "./node_modules/pixi.js/node_modules/@pixi/filter-fxaa/lib/FXAAFilter.js");



exports.FXAAFilter = FXAAFilter.FXAAFilter;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-noise/lib/NoiseFilter.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-noise/lib/NoiseFilter.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var noise = __webpack_require__(/*! ./noise.js */ "./node_modules/pixi.js/node_modules/@pixi/filter-noise/lib/noise.js");

class NoiseFilter extends core.Filter {
  constructor(noise$1 = 0.5, seed = Math.random()) {
    super(core.defaultFilterVertex, noise["default"], {
      uNoise: 0,
      uSeed: 0
    });
    this.noise = noise$1;
    this.seed = seed;
  }
  get noise() {
    return this.uniforms.uNoise;
  }
  set noise(value) {
    this.uniforms.uNoise = value;
  }
  get seed() {
    return this.uniforms.uSeed;
  }
  set seed(value) {
    this.uniforms.uSeed = value;
  }
}

exports.NoiseFilter = NoiseFilter;
//# sourceMappingURL=NoiseFilter.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-noise/lib/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-noise/lib/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var NoiseFilter = __webpack_require__(/*! ./NoiseFilter.js */ "./node_modules/pixi.js/node_modules/@pixi/filter-noise/lib/NoiseFilter.js");



exports.NoiseFilter = NoiseFilter.NoiseFilter;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/filter-noise/lib/noise.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/filter-noise/lib/noise.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var fragment = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n";

exports["default"] = fragment;
//# sourceMappingURL=noise.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/Graphics.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/graphics/lib/Graphics.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var display = __webpack_require__(/*! @pixi/display */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/index.js");
var _const = __webpack_require__(/*! ./const.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/const.js");
var GraphicsGeometry = __webpack_require__(/*! ./GraphicsGeometry.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/GraphicsGeometry.js");
var FillStyle = __webpack_require__(/*! ./styles/FillStyle.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/styles/FillStyle.js");
var LineStyle = __webpack_require__(/*! ./styles/LineStyle.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/styles/LineStyle.js");
__webpack_require__(/*! ./utils/index.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/index.js");
var QuadraticUtils = __webpack_require__(/*! ./utils/QuadraticUtils.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/QuadraticUtils.js");
var BezierUtils = __webpack_require__(/*! ./utils/BezierUtils.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/BezierUtils.js");
var ArcUtils = __webpack_require__(/*! ./utils/ArcUtils.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/ArcUtils.js");

const DEFAULT_SHADERS = {};
const _Graphics = class extends display.Container {
  constructor(geometry = null) {
    super();
    this.shader = null;
    this.pluginName = "batch";
    this.currentPath = null;
    this.batches = [];
    this.batchTint = -1;
    this.batchDirty = -1;
    this.vertexData = null;
    this._fillStyle = new FillStyle.FillStyle();
    this._lineStyle = new LineStyle.LineStyle();
    this._matrix = null;
    this._holeMode = false;
    this.state = core.State.for2d();
    this._geometry = geometry || new GraphicsGeometry.GraphicsGeometry();
    this._geometry.refCount++;
    this._transformID = -1;
    this._tintColor = new core.Color(16777215);
    this.blendMode = core.BLEND_MODES.NORMAL;
  }
  get geometry() {
    return this._geometry;
  }
  clone() {
    this.finishPoly();
    return new _Graphics(this._geometry);
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get blendMode() {
    return this.state.blendMode;
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value);
  }
  get fill() {
    return this._fillStyle;
  }
  get line() {
    return this._lineStyle;
  }
  lineStyle(options = null, color = 0, alpha, alignment = 0.5, native = false) {
    if (typeof options === "number") {
      options = { width: options, color, alpha, alignment, native };
    }
    return this.lineTextureStyle(options);
  }
  lineTextureStyle(options) {
    const defaultLineStyleOptions = {
      width: 0,
      texture: core.Texture.WHITE,
      color: options?.texture ? 16777215 : 0,
      matrix: null,
      alignment: 0.5,
      native: false,
      cap: _const.LINE_CAP.BUTT,
      join: _const.LINE_JOIN.MITER,
      miterLimit: 10
    };
    options = Object.assign(defaultLineStyleOptions, options);
    this.normalizeColor(options);
    if (this.currentPath) {
      this.startPoly();
    }
    const visible = options.width > 0 && options.alpha > 0;
    if (!visible) {
      this._lineStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._lineStyle, { visible }, options);
    }
    return this;
  }
  startPoly() {
    if (this.currentPath) {
      const points = this.currentPath.points;
      const len = this.currentPath.points.length;
      if (len > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = new core.Polygon();
        this.currentPath.closeStroke = false;
        this.currentPath.points.push(points[len - 2], points[len - 1]);
      }
    } else {
      this.currentPath = new core.Polygon();
      this.currentPath.closeStroke = false;
    }
  }
  finishPoly() {
    if (this.currentPath) {
      if (this.currentPath.points.length > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = null;
      } else {
        this.currentPath.points.length = 0;
      }
    }
  }
  moveTo(x, y) {
    this.startPoly();
    this.currentPath.points[0] = x;
    this.currentPath.points[1] = y;
    return this;
  }
  lineTo(x, y) {
    if (!this.currentPath) {
      this.moveTo(0, 0);
    }
    const points = this.currentPath.points;
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    if (fromX !== x || fromY !== y) {
      points.push(x, y);
    }
    return this;
  }
  _initCurve(x = 0, y = 0) {
    if (this.currentPath) {
      if (this.currentPath.points.length === 0) {
        this.currentPath.points = [x, y];
      }
    } else {
      this.moveTo(x, y);
    }
  }
  quadraticCurveTo(cpX, cpY, toX, toY) {
    this._initCurve();
    const points = this.currentPath.points;
    if (points.length === 0) {
      this.moveTo(0, 0);
    }
    QuadraticUtils.QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
    return this;
  }
  bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
    this._initCurve();
    BezierUtils.BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
    return this;
  }
  arcTo(x1, y1, x2, y2, radius) {
    this._initCurve(x1, y1);
    const points = this.currentPath.points;
    const result = ArcUtils.ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
    if (result) {
      const { cx, cy, radius: radius2, startAngle, endAngle, anticlockwise } = result;
      this.arc(cx, cy, radius2, startAngle, endAngle, anticlockwise);
    }
    return this;
  }
  arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {
    if (startAngle === endAngle) {
      return this;
    }
    if (!anticlockwise && endAngle <= startAngle) {
      endAngle += core.PI_2;
    } else if (anticlockwise && startAngle <= endAngle) {
      startAngle += core.PI_2;
    }
    const sweep = endAngle - startAngle;
    if (sweep === 0) {
      return this;
    }
    const startX = cx + Math.cos(startAngle) * radius;
    const startY = cy + Math.sin(startAngle) * radius;
    const eps = this._geometry.closePointEps;
    let points = this.currentPath ? this.currentPath.points : null;
    if (points) {
      const xDiff = Math.abs(points[points.length - 2] - startX);
      const yDiff = Math.abs(points[points.length - 1] - startY);
      if (xDiff < eps && yDiff < eps) {
      } else {
        points.push(startX, startY);
      }
    } else {
      this.moveTo(startX, startY);
      points = this.currentPath.points;
    }
    ArcUtils.ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
    return this;
  }
  beginFill(color = 0, alpha) {
    return this.beginTextureFill({ texture: core.Texture.WHITE, color, alpha });
  }
  normalizeColor(options) {
    const temp = core.Color.shared.setValue(options.color ?? 0);
    options.color = temp.toNumber();
    options.alpha ?? (options.alpha = temp.alpha);
  }
  beginTextureFill(options) {
    const defaultOptions = {
      texture: core.Texture.WHITE,
      color: 16777215,
      matrix: null
    };
    options = Object.assign(defaultOptions, options);
    this.normalizeColor(options);
    if (this.currentPath) {
      this.startPoly();
    }
    const visible = options.alpha > 0;
    if (!visible) {
      this._fillStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._fillStyle, { visible }, options);
    }
    return this;
  }
  endFill() {
    this.finishPoly();
    this._fillStyle.reset();
    return this;
  }
  drawRect(x, y, width, height) {
    return this.drawShape(new core.Rectangle(x, y, width, height));
  }
  drawRoundedRect(x, y, width, height, radius) {
    return this.drawShape(new core.RoundedRectangle(x, y, width, height, radius));
  }
  drawCircle(x, y, radius) {
    return this.drawShape(new core.Circle(x, y, radius));
  }
  drawEllipse(x, y, width, height) {
    return this.drawShape(new core.Ellipse(x, y, width, height));
  }
  drawPolygon(...path) {
    let points;
    let closeStroke = true;
    const poly = path[0];
    if (poly.points) {
      closeStroke = poly.closeStroke;
      points = poly.points;
    } else if (Array.isArray(path[0])) {
      points = path[0];
    } else {
      points = path;
    }
    const shape = new core.Polygon(points);
    shape.closeStroke = closeStroke;
    this.drawShape(shape);
    return this;
  }
  drawShape(shape) {
    if (!this._holeMode) {
      this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
    } else {
      this._geometry.drawHole(shape, this._matrix);
    }
    return this;
  }
  clear() {
    this._geometry.clear();
    this._lineStyle.reset();
    this._fillStyle.reset();
    this._boundsID++;
    this._matrix = null;
    this._holeMode = false;
    this.currentPath = null;
    return this;
  }
  isFastRect() {
    const data = this._geometry.graphicsData;
    return data.length === 1 && data[0].shape.type === core.SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
  }
  _render(renderer) {
    this.finishPoly();
    const geometry = this._geometry;
    geometry.updateBatches();
    if (geometry.batchable) {
      if (this.batchDirty !== geometry.batchDirty) {
        this._populateBatches();
      }
      this._renderBatched(renderer);
    } else {
      renderer.batch.flush();
      this._renderDirect(renderer);
    }
  }
  _populateBatches() {
    const geometry = this._geometry;
    const blendMode = this.blendMode;
    const len = geometry.batches.length;
    this.batchTint = -1;
    this._transformID = -1;
    this.batchDirty = geometry.batchDirty;
    this.batches.length = len;
    this.vertexData = new Float32Array(geometry.points);
    for (let i = 0; i < len; i++) {
      const gI = geometry.batches[i];
      const color = gI.style.color;
      const vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
      const uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
      const indices = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
      const batch = {
        vertexData,
        blendMode,
        indices,
        uvs,
        _batchRGB: core.Color.shared.setValue(color).toRgbArray(),
        _tintRGB: color,
        _texture: gI.style.texture,
        alpha: gI.style.alpha,
        worldAlpha: 1
      };
      this.batches[i] = batch;
    }
  }
  _renderBatched(renderer) {
    if (!this.batches.length) {
      return;
    }
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    this.calculateVertices();
    this.calculateTints();
    for (let i = 0, l = this.batches.length; i < l; i++) {
      const batch = this.batches[i];
      batch.worldAlpha = this.worldAlpha * batch.alpha;
      renderer.plugins[this.pluginName].render(batch);
    }
  }
  _renderDirect(renderer) {
    const shader = this._resolveDirectShader(renderer);
    const geometry = this._geometry;
    const worldAlpha = this.worldAlpha;
    const uniforms = shader.uniforms;
    const drawCalls = geometry.drawCalls;
    uniforms.translationMatrix = this.transform.worldTransform;
    core.Color.shared.setValue(this._tintColor).premultiply(worldAlpha).toArray(uniforms.tint);
    renderer.shader.bind(shader);
    renderer.geometry.bind(geometry, shader);
    renderer.state.set(this.state);
    for (let i = 0, l = drawCalls.length; i < l; i++) {
      this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);
    }
  }
  _renderDrawCallDirect(renderer, drawCall) {
    const { texArray, type, size, start } = drawCall;
    const groupTextureCount = texArray.count;
    for (let j = 0; j < groupTextureCount; j++) {
      renderer.texture.bind(texArray.elements[j], j);
    }
    renderer.geometry.draw(type, size, start);
  }
  _resolveDirectShader(renderer) {
    let shader = this.shader;
    const pluginName = this.pluginName;
    if (!shader) {
      if (!DEFAULT_SHADERS[pluginName]) {
        const { maxTextures } = renderer.plugins[pluginName];
        const sampleValues = new Int32Array(maxTextures);
        for (let i = 0; i < maxTextures; i++) {
          sampleValues[i] = i;
        }
        const uniforms = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new core.Matrix(),
          default: core.UniformGroup.from({ uSamplers: sampleValues }, true)
        };
        const program = renderer.plugins[pluginName]._shader.program;
        DEFAULT_SHADERS[pluginName] = new core.Shader(program, uniforms);
      }
      shader = DEFAULT_SHADERS[pluginName];
    }
    return shader;
  }
  _calculateBounds() {
    this.finishPoly();
    const geometry = this._geometry;
    if (!geometry.graphicsData.length) {
      return;
    }
    const { minX, minY, maxX, maxY } = geometry.bounds;
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, _Graphics._TEMP_POINT);
    return this._geometry.containsPoint(_Graphics._TEMP_POINT);
  }
  calculateTints() {
    if (this.batchTint !== this.tint) {
      this.batchTint = this._tintColor.toNumber();
      for (let i = 0; i < this.batches.length; i++) {
        const batch = this.batches[i];
        batch._tintRGB = core.Color.shared.setValue(this._tintColor).multiply(batch._batchRGB).toLittleEndianNumber();
      }
    }
  }
  calculateVertices() {
    const wtID = this.transform._worldID;
    if (this._transformID === wtID) {
      return;
    }
    this._transformID = wtID;
    const wt = this.transform.worldTransform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const data = this._geometry.points;
    const vertexData = this.vertexData;
    let count = 0;
    for (let i = 0; i < data.length; i += 2) {
      const x = data[i];
      const y = data[i + 1];
      vertexData[count++] = a * x + c * y + tx;
      vertexData[count++] = d * y + b * x + ty;
    }
  }
  closePath() {
    const currentPath = this.currentPath;
    if (currentPath) {
      currentPath.closeStroke = true;
      this.finishPoly();
    }
    return this;
  }
  setMatrix(matrix) {
    this._matrix = matrix;
    return this;
  }
  beginHole() {
    this.finishPoly();
    this._holeMode = true;
    return this;
  }
  endHole() {
    this.finishPoly();
    this._holeMode = false;
    return this;
  }
  destroy(options) {
    this._geometry.refCount--;
    if (this._geometry.refCount === 0) {
      this._geometry.dispose();
    }
    this._matrix = null;
    this.currentPath = null;
    this._lineStyle.destroy();
    this._lineStyle = null;
    this._fillStyle.destroy();
    this._fillStyle = null;
    this._geometry = null;
    this.shader = null;
    this.vertexData = null;
    this.batches.length = 0;
    this.batches = null;
    super.destroy(options);
  }
};
let Graphics = _Graphics;
Graphics.curves = _const.curves;
Graphics._TEMP_POINT = new core.Point();

exports.Graphics = Graphics;
//# sourceMappingURL=Graphics.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/GraphicsData.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/graphics/lib/GraphicsData.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class GraphicsData {
  constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {
    this.points = [];
    this.holes = [];
    this.shape = shape;
    this.lineStyle = lineStyle;
    this.fillStyle = fillStyle;
    this.matrix = matrix;
    this.type = shape.type;
  }
  clone() {
    return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);
  }
  destroy() {
    this.shape = null;
    this.holes.length = 0;
    this.holes = null;
    this.points.length = 0;
    this.points = null;
    this.lineStyle = null;
    this.fillStyle = null;
  }
}

exports.GraphicsData = GraphicsData;
//# sourceMappingURL=GraphicsData.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/GraphicsGeometry.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/graphics/lib/GraphicsGeometry.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var display = __webpack_require__(/*! @pixi/display */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/index.js");
var GraphicsData = __webpack_require__(/*! ./GraphicsData.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/GraphicsData.js");
var index = __webpack_require__(/*! ./utils/index.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/index.js");
var BatchPart = __webpack_require__(/*! ./utils/BatchPart.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/BatchPart.js");
var buildPoly = __webpack_require__(/*! ./utils/buildPoly.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildPoly.js");
var buildLine = __webpack_require__(/*! ./utils/buildLine.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildLine.js");

const tmpPoint = new core.Point();
const _GraphicsGeometry = class extends core.BatchGeometry {
  constructor() {
    super();
    this.closePointEps = 1e-4;
    this.boundsPadding = 0;
    this.uvsFloat32 = null;
    this.indicesUint16 = null;
    this.batchable = false;
    this.points = [];
    this.colors = [];
    this.uvs = [];
    this.indices = [];
    this.textureIds = [];
    this.graphicsData = [];
    this.drawCalls = [];
    this.batchDirty = -1;
    this.batches = [];
    this.dirty = 0;
    this.cacheDirty = -1;
    this.clearDirty = 0;
    this.shapeIndex = 0;
    this._bounds = new display.Bounds();
    this.boundsDirty = -1;
  }
  get bounds() {
    this.updateBatches();
    if (this.boundsDirty !== this.dirty) {
      this.boundsDirty = this.dirty;
      this.calculateBounds();
    }
    return this._bounds;
  }
  invalidate() {
    this.boundsDirty = -1;
    this.dirty++;
    this.batchDirty++;
    this.shapeIndex = 0;
    this.points.length = 0;
    this.colors.length = 0;
    this.uvs.length = 0;
    this.indices.length = 0;
    this.textureIds.length = 0;
    for (let i = 0; i < this.drawCalls.length; i++) {
      this.drawCalls[i].texArray.clear();
      index.DRAW_CALL_POOL.push(this.drawCalls[i]);
    }
    this.drawCalls.length = 0;
    for (let i = 0; i < this.batches.length; i++) {
      const batchPart = this.batches[i];
      batchPart.reset();
      index.BATCH_POOL.push(batchPart);
    }
    this.batches.length = 0;
  }
  clear() {
    if (this.graphicsData.length > 0) {
      this.invalidate();
      this.clearDirty++;
      this.graphicsData.length = 0;
    }
    return this;
  }
  drawShape(shape, fillStyle = null, lineStyle = null, matrix = null) {
    const data = new GraphicsData.GraphicsData(shape, fillStyle, lineStyle, matrix);
    this.graphicsData.push(data);
    this.dirty++;
    return this;
  }
  drawHole(shape, matrix = null) {
    if (!this.graphicsData.length) {
      return null;
    }
    const data = new GraphicsData.GraphicsData(shape, null, null, matrix);
    const lastShape = this.graphicsData[this.graphicsData.length - 1];
    data.lineStyle = lastShape.lineStyle;
    lastShape.holes.push(data);
    this.dirty++;
    return this;
  }
  destroy() {
    super.destroy();
    for (let i = 0; i < this.graphicsData.length; ++i) {
      this.graphicsData[i].destroy();
    }
    this.points.length = 0;
    this.points = null;
    this.colors.length = 0;
    this.colors = null;
    this.uvs.length = 0;
    this.uvs = null;
    this.indices.length = 0;
    this.indices = null;
    this.indexBuffer.destroy();
    this.indexBuffer = null;
    this.graphicsData.length = 0;
    this.graphicsData = null;
    this.drawCalls.length = 0;
    this.drawCalls = null;
    this.batches.length = 0;
    this.batches = null;
    this._bounds = null;
  }
  containsPoint(point) {
    const graphicsData = this.graphicsData;
    for (let i = 0; i < graphicsData.length; ++i) {
      const data = graphicsData[i];
      if (!data.fillStyle.visible) {
        continue;
      }
      if (data.shape) {
        if (data.matrix) {
          data.matrix.applyInverse(point, tmpPoint);
        } else {
          tmpPoint.copyFrom(point);
        }
        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {
          let hitHole = false;
          if (data.holes) {
            for (let i2 = 0; i2 < data.holes.length; i2++) {
              const hole = data.holes[i2];
              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {
                hitHole = true;
                break;
              }
            }
          }
          if (!hitHole) {
            return true;
          }
        }
      }
    }
    return false;
  }
  updateBatches() {
    if (!this.graphicsData.length) {
      this.batchable = true;
      return;
    }
    if (!this.validateBatching()) {
      return;
    }
    this.cacheDirty = this.dirty;
    const uvs = this.uvs;
    const graphicsData = this.graphicsData;
    let batchPart = null;
    let currentStyle = null;
    if (this.batches.length > 0) {
      batchPart = this.batches[this.batches.length - 1];
      currentStyle = batchPart.style;
    }
    for (let i = this.shapeIndex; i < graphicsData.length; i++) {
      this.shapeIndex++;
      const data = graphicsData[i];
      const fillStyle = data.fillStyle;
      const lineStyle = data.lineStyle;
      const command = index.FILL_COMMANDS[data.type];
      command.build(data);
      if (data.matrix) {
        this.transformPoints(data.points, data.matrix);
      }
      if (fillStyle.visible || lineStyle.visible) {
        this.processHoles(data.holes);
      }
      for (let j = 0; j < 2; j++) {
        const style = j === 0 ? fillStyle : lineStyle;
        if (!style.visible)
          continue;
        const nextTexture = style.texture.baseTexture;
        const index2 = this.indices.length;
        const attribIndex = this.points.length / 2;
        nextTexture.wrapMode = core.WRAP_MODES.REPEAT;
        if (j === 0) {
          this.processFill(data);
        } else {
          this.processLine(data);
        }
        const size = this.points.length / 2 - attribIndex;
        if (size === 0)
          continue;
        if (batchPart && !this._compareStyles(currentStyle, style)) {
          batchPart.end(index2, attribIndex);
          batchPart = null;
        }
        if (!batchPart) {
          batchPart = index.BATCH_POOL.pop() || new BatchPart.BatchPart();
          batchPart.begin(style, index2, attribIndex);
          this.batches.push(batchPart);
          currentStyle = style;
        }
        this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);
      }
    }
    const index$1 = this.indices.length;
    const attrib = this.points.length / 2;
    if (batchPart) {
      batchPart.end(index$1, attrib);
    }
    if (this.batches.length === 0) {
      this.batchable = true;
      return;
    }
    const need32 = attrib > 65535;
    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2) {
      this.indicesUint16.set(this.indices);
    } else {
      this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
    }
    this.batchable = this.isBatchable();
    if (this.batchable) {
      this.packBatches();
    } else {
      this.buildDrawCalls();
    }
  }
  _compareStyles(styleA, styleB) {
    if (!styleA || !styleB) {
      return false;
    }
    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
      return false;
    }
    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
      return false;
    }
    if (!!styleA.native !== !!styleB.native) {
      return false;
    }
    return true;
  }
  validateBatching() {
    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
      return false;
    }
    for (let i = 0, l = this.graphicsData.length; i < l; i++) {
      const data = this.graphicsData[i];
      const fill = data.fillStyle;
      const line = data.lineStyle;
      if (fill && !fill.texture.baseTexture.valid)
        return false;
      if (line && !line.texture.baseTexture.valid)
        return false;
    }
    return true;
  }
  packBatches() {
    this.batchDirty++;
    this.uvsFloat32 = new Float32Array(this.uvs);
    const batches = this.batches;
    for (let i = 0, l = batches.length; i < l; i++) {
      const batch = batches[i];
      for (let j = 0; j < batch.size; j++) {
        const index = batch.start + j;
        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;
      }
    }
  }
  isBatchable() {
    if (this.points.length > 65535 * 2) {
      return false;
    }
    const batches = this.batches;
    for (let i = 0; i < batches.length; i++) {
      if (batches[i].style.native) {
        return false;
      }
    }
    return this.points.length < _GraphicsGeometry.BATCHABLE_SIZE * 2;
  }
  buildDrawCalls() {
    let TICK = ++core.BaseTexture._globalBatch;
    for (let i = 0; i < this.drawCalls.length; i++) {
      this.drawCalls[i].texArray.clear();
      index.DRAW_CALL_POOL.push(this.drawCalls[i]);
    }
    this.drawCalls.length = 0;
    const colors = this.colors;
    const textureIds = this.textureIds;
    let currentGroup = index.DRAW_CALL_POOL.pop();
    if (!currentGroup) {
      currentGroup = new core.BatchDrawCall();
      currentGroup.texArray = new core.BatchTextureArray();
    }
    currentGroup.texArray.count = 0;
    currentGroup.start = 0;
    currentGroup.size = 0;
    currentGroup.type = core.DRAW_MODES.TRIANGLES;
    let textureCount = 0;
    let currentTexture = null;
    let textureId = 0;
    let native = false;
    let drawMode = core.DRAW_MODES.TRIANGLES;
    let index$1 = 0;
    this.drawCalls.push(currentGroup);
    for (let i = 0; i < this.batches.length; i++) {
      const data = this.batches[i];
      const maxTextures = 8;
      const style = data.style;
      const nextTexture = style.texture.baseTexture;
      if (native !== !!style.native) {
        native = !!style.native;
        drawMode = native ? core.DRAW_MODES.LINES : core.DRAW_MODES.TRIANGLES;
        currentTexture = null;
        textureCount = maxTextures;
        TICK++;
      }
      if (currentTexture !== nextTexture) {
        currentTexture = nextTexture;
        if (nextTexture._batchEnabled !== TICK) {
          if (textureCount === maxTextures) {
            TICK++;
            textureCount = 0;
            if (currentGroup.size > 0) {
              currentGroup = index.DRAW_CALL_POOL.pop();
              if (!currentGroup) {
                currentGroup = new core.BatchDrawCall();
                currentGroup.texArray = new core.BatchTextureArray();
              }
              this.drawCalls.push(currentGroup);
            }
            currentGroup.start = index$1;
            currentGroup.size = 0;
            currentGroup.texArray.count = 0;
            currentGroup.type = drawMode;
          }
          nextTexture.touched = 1;
          nextTexture._batchEnabled = TICK;
          nextTexture._batchLocation = textureCount;
          nextTexture.wrapMode = core.WRAP_MODES.REPEAT;
          currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;
          textureCount++;
        }
      }
      currentGroup.size += data.size;
      index$1 += data.size;
      textureId = nextTexture._batchLocation;
      this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);
      this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
    }
    core.BaseTexture._globalBatch = TICK;
    this.packAttributes();
  }
  packAttributes() {
    const verts = this.points;
    const uvs = this.uvs;
    const colors = this.colors;
    const textureIds = this.textureIds;
    const glPoints = new ArrayBuffer(verts.length * 3 * 4);
    const f32 = new Float32Array(glPoints);
    const u32 = new Uint32Array(glPoints);
    let p = 0;
    for (let i = 0; i < verts.length / 2; i++) {
      f32[p++] = verts[i * 2];
      f32[p++] = verts[i * 2 + 1];
      f32[p++] = uvs[i * 2];
      f32[p++] = uvs[i * 2 + 1];
      u32[p++] = colors[i];
      f32[p++] = textureIds[i];
    }
    this._buffer.update(glPoints);
    this._indexBuffer.update(this.indicesUint16);
  }
  processFill(data) {
    if (data.holes.length) {
      buildPoly.buildPoly.triangulate(data, this);
    } else {
      const command = index.FILL_COMMANDS[data.type];
      command.triangulate(data, this);
    }
  }
  processLine(data) {
    buildLine.buildLine(data, this);
    for (let i = 0; i < data.holes.length; i++) {
      buildLine.buildLine(data.holes[i], this);
    }
  }
  processHoles(holes) {
    for (let i = 0; i < holes.length; i++) {
      const hole = holes[i];
      const command = index.FILL_COMMANDS[hole.type];
      command.build(hole);
      if (hole.matrix) {
        this.transformPoints(hole.points, hole.matrix);
      }
    }
  }
  calculateBounds() {
    const bounds = this._bounds;
    bounds.clear();
    bounds.addVertexData(this.points, 0, this.points.length);
    bounds.pad(this.boundsPadding, this.boundsPadding);
  }
  transformPoints(points, matrix) {
    for (let i = 0; i < points.length / 2; i++) {
      const x = points[i * 2];
      const y = points[i * 2 + 1];
      points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;
      points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;
    }
  }
  addColors(colors, color, alpha, size, offset = 0) {
    const bgr = core.Color.shared.setValue(color).toLittleEndianNumber();
    const result = core.Color.shared.setValue(bgr).toPremultiplied(alpha);
    colors.length = Math.max(colors.length, offset + size);
    for (let i = 0; i < size; i++) {
      colors[offset + i] = result;
    }
  }
  addTextureIds(textureIds, id, size, offset = 0) {
    textureIds.length = Math.max(textureIds.length, offset + size);
    for (let i = 0; i < size; i++) {
      textureIds[offset + i] = id;
    }
  }
  addUvs(verts, uvs, texture, start, size, matrix = null) {
    let index = 0;
    const uvsStart = uvs.length;
    const frame = texture.frame;
    while (index < size) {
      let x = verts[(start + index) * 2];
      let y = verts[(start + index) * 2 + 1];
      if (matrix) {
        const nx = matrix.a * x + matrix.c * y + matrix.tx;
        y = matrix.b * x + matrix.d * y + matrix.ty;
        x = nx;
      }
      index++;
      uvs.push(x / frame.width, y / frame.height);
    }
    const baseTexture = texture.baseTexture;
    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {
      this.adjustUvs(uvs, texture, uvsStart, size);
    }
  }
  adjustUvs(uvs, texture, start, size) {
    const baseTexture = texture.baseTexture;
    const eps = 1e-6;
    const finish = start + size * 2;
    const frame = texture.frame;
    const scaleX = frame.width / baseTexture.width;
    const scaleY = frame.height / baseTexture.height;
    let offsetX = frame.x / frame.width;
    let offsetY = frame.y / frame.height;
    let minX = Math.floor(uvs[start] + eps);
    let minY = Math.floor(uvs[start + 1] + eps);
    for (let i = start + 2; i < finish; i += 2) {
      minX = Math.min(minX, Math.floor(uvs[i] + eps));
      minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));
    }
    offsetX -= minX;
    offsetY -= minY;
    for (let i = start; i < finish; i += 2) {
      uvs[i] = (uvs[i] + offsetX) * scaleX;
      uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;
    }
  }
};
let GraphicsGeometry = _GraphicsGeometry;
GraphicsGeometry.BATCHABLE_SIZE = 100;

exports.GraphicsGeometry = GraphicsGeometry;
//# sourceMappingURL=GraphicsGeometry.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/const.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/graphics/lib/const.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var LINE_JOIN = /* @__PURE__ */ ((LINE_JOIN2) => {
  LINE_JOIN2["MITER"] = "miter";
  LINE_JOIN2["BEVEL"] = "bevel";
  LINE_JOIN2["ROUND"] = "round";
  return LINE_JOIN2;
})(LINE_JOIN || {});
var LINE_CAP = /* @__PURE__ */ ((LINE_CAP2) => {
  LINE_CAP2["BUTT"] = "butt";
  LINE_CAP2["ROUND"] = "round";
  LINE_CAP2["SQUARE"] = "square";
  return LINE_CAP2;
})(LINE_CAP || {});
const curves = {
  adaptive: true,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount(length, defaultSegments = 20) {
    if (!this.adaptive || !length || isNaN(length)) {
      return defaultSegments;
    }
    let result = Math.ceil(length / this.maxLength);
    if (result < this.minSegments) {
      result = this.minSegments;
    } else if (result > this.maxSegments) {
      result = this.maxSegments;
    }
    return result;
  }
};
const GRAPHICS_CURVES = curves;

exports.GRAPHICS_CURVES = GRAPHICS_CURVES;
exports.LINE_CAP = LINE_CAP;
exports.LINE_JOIN = LINE_JOIN;
exports.curves = curves;
//# sourceMappingURL=const.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/graphics/lib/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var index = __webpack_require__(/*! ./utils/index.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/index.js");
var _const = __webpack_require__(/*! ./const.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/const.js");
var Graphics = __webpack_require__(/*! ./Graphics.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/Graphics.js");
var GraphicsData = __webpack_require__(/*! ./GraphicsData.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/GraphicsData.js");
var GraphicsGeometry = __webpack_require__(/*! ./GraphicsGeometry.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/GraphicsGeometry.js");
var FillStyle = __webpack_require__(/*! ./styles/FillStyle.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/styles/FillStyle.js");
var LineStyle = __webpack_require__(/*! ./styles/LineStyle.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/styles/LineStyle.js");
var buildPoly = __webpack_require__(/*! ./utils/buildPoly.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildPoly.js");
var buildCircle = __webpack_require__(/*! ./utils/buildCircle.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildCircle.js");
var buildRectangle = __webpack_require__(/*! ./utils/buildRectangle.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildRectangle.js");
var buildRoundedRectangle = __webpack_require__(/*! ./utils/buildRoundedRectangle.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildRoundedRectangle.js");
var buildLine = __webpack_require__(/*! ./utils/buildLine.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildLine.js");
var ArcUtils = __webpack_require__(/*! ./utils/ArcUtils.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/ArcUtils.js");
var BezierUtils = __webpack_require__(/*! ./utils/BezierUtils.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/BezierUtils.js");
var QuadraticUtils = __webpack_require__(/*! ./utils/QuadraticUtils.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/QuadraticUtils.js");
var BatchPart = __webpack_require__(/*! ./utils/BatchPart.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/BatchPart.js");

const graphicsUtils = {
  buildPoly: buildPoly.buildPoly,
  buildCircle: buildCircle.buildCircle,
  buildRectangle: buildRectangle.buildRectangle,
  buildRoundedRectangle: buildRoundedRectangle.buildRoundedRectangle,
  buildLine: buildLine.buildLine,
  ArcUtils: ArcUtils.ArcUtils,
  BezierUtils: BezierUtils.BezierUtils,
  QuadraticUtils: QuadraticUtils.QuadraticUtils,
  BatchPart: BatchPart.BatchPart,
  FILL_COMMANDS: index.FILL_COMMANDS,
  BATCH_POOL: index.BATCH_POOL,
  DRAW_CALL_POOL: index.DRAW_CALL_POOL
};

exports.GRAPHICS_CURVES = _const.GRAPHICS_CURVES;
exports.LINE_CAP = _const.LINE_CAP;
exports.LINE_JOIN = _const.LINE_JOIN;
exports.curves = _const.curves;
exports.Graphics = Graphics.Graphics;
exports.GraphicsData = GraphicsData.GraphicsData;
exports.GraphicsGeometry = GraphicsGeometry.GraphicsGeometry;
exports.FillStyle = FillStyle.FillStyle;
exports.LineStyle = LineStyle.LineStyle;
exports.graphicsUtils = graphicsUtils;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/styles/FillStyle.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/graphics/lib/styles/FillStyle.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

class FillStyle {
  constructor() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = core.Texture.WHITE;
    this.matrix = null;
    this.visible = false;
    this.reset();
  }
  clone() {
    const obj = new FillStyle();
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    return obj;
  }
  reset() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = core.Texture.WHITE;
    this.matrix = null;
    this.visible = false;
  }
  destroy() {
    this.texture = null;
    this.matrix = null;
  }
}

exports.FillStyle = FillStyle;
//# sourceMappingURL=FillStyle.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/styles/LineStyle.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/graphics/lib/styles/LineStyle.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/const.js");
var FillStyle = __webpack_require__(/*! ./FillStyle.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/styles/FillStyle.js");

class LineStyle extends FillStyle.FillStyle {
  constructor() {
    super(...arguments);
    this.width = 0;
    this.alignment = 0.5;
    this.native = false;
    this.cap = _const.LINE_CAP.BUTT;
    this.join = _const.LINE_JOIN.MITER;
    this.miterLimit = 10;
  }
  clone() {
    const obj = new LineStyle();
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    obj.width = this.width;
    obj.alignment = this.alignment;
    obj.native = this.native;
    obj.cap = this.cap;
    obj.join = this.join;
    obj.miterLimit = this.miterLimit;
    return obj;
  }
  reset() {
    super.reset();
    this.color = 0;
    this.alignment = 0.5;
    this.width = 0;
    this.native = false;
  }
}

exports.LineStyle = LineStyle;
//# sourceMappingURL=LineStyle.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/ArcUtils.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/ArcUtils.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var _const = __webpack_require__(/*! ../const.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/const.js");

class ArcUtils {
  static curveTo(x1, y1, x2, y2, radius, points) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const a1 = fromY - y1;
    const b1 = fromX - x1;
    const a2 = y2 - y1;
    const b2 = x2 - x1;
    const mm = Math.abs(a1 * b2 - b1 * a2);
    if (mm < 1e-8 || radius === 0) {
      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
        points.push(x1, y1);
      }
      return null;
    }
    const dd = a1 * a1 + b1 * b1;
    const cc = a2 * a2 + b2 * b2;
    const tt = a1 * a2 + b1 * b2;
    const k1 = radius * Math.sqrt(dd) / mm;
    const k2 = radius * Math.sqrt(cc) / mm;
    const j1 = k1 * tt / dd;
    const j2 = k2 * tt / cc;
    const cx = k1 * b2 + k2 * b1;
    const cy = k1 * a2 + k2 * a1;
    const px = b1 * (k2 + j1);
    const py = a1 * (k2 + j1);
    const qx = b2 * (k1 + j2);
    const qy = a2 * (k1 + j2);
    const startAngle = Math.atan2(py - cy, px - cx);
    const endAngle = Math.atan2(qy - cy, qx - cx);
    return {
      cx: cx + x1,
      cy: cy + y1,
      radius,
      startAngle,
      endAngle,
      anticlockwise: b1 * a2 > b2 * a1
    };
  }
  static arc(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
    const sweep = endAngle - startAngle;
    const n = _const.curves._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / core.PI_2) * 40);
    const theta = sweep / (n * 2);
    const theta2 = theta * 2;
    const cTheta = Math.cos(theta);
    const sTheta = Math.sin(theta);
    const segMinus = n - 1;
    const remainder = segMinus % 1 / segMinus;
    for (let i = 0; i <= segMinus; ++i) {
      const real = i + remainder * i;
      const angle = theta + startAngle + theta2 * real;
      const c = Math.cos(angle);
      const s = -Math.sin(angle);
      points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
    }
  }
}

exports.ArcUtils = ArcUtils;
//# sourceMappingURL=ArcUtils.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/BatchPart.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/BatchPart.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class BatchPart {
  constructor() {
    this.reset();
  }
  begin(style, startIndex, attribStart) {
    this.reset();
    this.style = style;
    this.start = startIndex;
    this.attribStart = attribStart;
  }
  end(endIndex, endAttrib) {
    this.attribSize = endAttrib - this.attribStart;
    this.size = endIndex - this.start;
  }
  reset() {
    this.style = null;
    this.size = 0;
    this.start = 0;
    this.attribStart = 0;
    this.attribSize = 0;
  }
}

exports.BatchPart = BatchPart;
//# sourceMappingURL=BatchPart.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/BezierUtils.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/BezierUtils.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/const.js");

class BezierUtils {
  static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
    const n = 10;
    let result = 0;
    let t = 0;
    let t2 = 0;
    let t3 = 0;
    let nt = 0;
    let nt2 = 0;
    let nt3 = 0;
    let x = 0;
    let y = 0;
    let dx = 0;
    let dy = 0;
    let prevX = fromX;
    let prevY = fromY;
    for (let i = 1; i <= n; ++i) {
      t = i / n;
      t2 = t * t;
      t3 = t2 * t;
      nt = 1 - t;
      nt2 = nt * nt;
      nt3 = nt2 * nt;
      x = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX;
      y = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;
      dx = prevX - x;
      dy = prevY - y;
      prevX = x;
      prevY = y;
      result += Math.sqrt(dx * dx + dy * dy);
    }
    return result;
  }
  static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    points.length -= 2;
    const n = _const.curves._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
    let dt = 0;
    let dt2 = 0;
    let dt3 = 0;
    let t2 = 0;
    let t3 = 0;
    points.push(fromX, fromY);
    for (let i = 1, j = 0; i <= n; ++i) {
      j = i / n;
      dt = 1 - j;
      dt2 = dt * dt;
      dt3 = dt2 * dt;
      t2 = j * j;
      t3 = t2 * j;
      points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
    }
  }
}

exports.BezierUtils = BezierUtils;
//# sourceMappingURL=BezierUtils.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/QuadraticUtils.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/QuadraticUtils.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/const.js");

class QuadraticUtils {
  static curveLength(fromX, fromY, cpX, cpY, toX, toY) {
    const ax = fromX - 2 * cpX + toX;
    const ay = fromY - 2 * cpY + toY;
    const bx = 2 * cpX - 2 * fromX;
    const by = 2 * cpY - 2 * fromY;
    const a = 4 * (ax * ax + ay * ay);
    const b = 4 * (ax * bx + ay * by);
    const c = bx * bx + by * by;
    const s = 2 * Math.sqrt(a + b + c);
    const a2 = Math.sqrt(a);
    const a32 = 2 * a * a2;
    const c2 = 2 * Math.sqrt(c);
    const ba = b / a2;
    return (a32 * s + a2 * b * (s - c2) + (4 * c * a - b * b) * Math.log((2 * a2 + ba + s) / (ba + c2))) / (4 * a32);
  }
  static curveTo(cpX, cpY, toX, toY, points) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const n = _const.curves._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));
    let xa = 0;
    let ya = 0;
    for (let i = 1; i <= n; ++i) {
      const j = i / n;
      xa = fromX + (cpX - fromX) * j;
      ya = fromY + (cpY - fromY) * j;
      points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
    }
  }
}

exports.QuadraticUtils = QuadraticUtils;
//# sourceMappingURL=QuadraticUtils.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildCircle.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildCircle.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

const buildCircle = {
  build(graphicsData) {
    const points = graphicsData.points;
    let x;
    let y;
    let dx;
    let dy;
    let rx;
    let ry;
    if (graphicsData.type === core.SHAPES.CIRC) {
      const circle = graphicsData.shape;
      x = circle.x;
      y = circle.y;
      rx = ry = circle.radius;
      dx = dy = 0;
    } else if (graphicsData.type === core.SHAPES.ELIP) {
      const ellipse = graphicsData.shape;
      x = ellipse.x;
      y = ellipse.y;
      rx = ellipse.width;
      ry = ellipse.height;
      dx = dy = 0;
    } else {
      const roundedRect = graphicsData.shape;
      const halfWidth = roundedRect.width / 2;
      const halfHeight = roundedRect.height / 2;
      x = roundedRect.x + halfWidth;
      y = roundedRect.y + halfHeight;
      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
      dx = halfWidth - rx;
      dy = halfHeight - ry;
    }
    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
      points.length = 0;
      return;
    }
    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));
    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
    points.length = m;
    if (m === 0) {
      return;
    }
    if (n === 0) {
      points.length = 8;
      points[0] = points[6] = x + dx;
      points[1] = points[3] = y + dy;
      points[2] = points[4] = x - dx;
      points[5] = points[7] = y - dy;
      return;
    }
    let j1 = 0;
    let j2 = n * 4 + (dx ? 2 : 0) + 2;
    let j3 = j2;
    let j4 = m;
    {
      const x0 = dx + rx;
      const y0 = dy;
      const x1 = x + x0;
      const x2 = x - x0;
      const y1 = y + y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x2;
      if (dy) {
        const y2 = y - y0;
        points[j3++] = x2;
        points[j3++] = y2;
        points[--j4] = y2;
        points[--j4] = x1;
      }
    }
    for (let i = 1; i < n; i++) {
      const a = Math.PI / 2 * (i / n);
      const x0 = dx + Math.cos(a) * rx;
      const y0 = dy + Math.sin(a) * ry;
      const x1 = x + x0;
      const x2 = x - x0;
      const y1 = y + y0;
      const y2 = y - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x2;
      points[j3++] = x2;
      points[j3++] = y2;
      points[--j4] = y2;
      points[--j4] = x1;
    }
    {
      const x0 = dx;
      const y0 = dy + ry;
      const x1 = x + x0;
      const x2 = x - x0;
      const y1 = y + y0;
      const y2 = y - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j4] = y2;
      points[--j4] = x1;
      if (dx) {
        points[j1++] = x2;
        points[j1++] = y1;
        points[--j4] = y2;
        points[--j4] = x2;
      }
    }
  },
  triangulate(graphicsData, graphicsGeometry) {
    const points = graphicsData.points;
    const verts = graphicsGeometry.points;
    const indices = graphicsGeometry.indices;
    if (points.length === 0) {
      return;
    }
    let vertPos = verts.length / 2;
    const center = vertPos;
    let x;
    let y;
    if (graphicsData.type !== core.SHAPES.RREC) {
      const circle = graphicsData.shape;
      x = circle.x;
      y = circle.y;
    } else {
      const roundedRect = graphicsData.shape;
      x = roundedRect.x + roundedRect.width / 2;
      y = roundedRect.y + roundedRect.height / 2;
    }
    const matrix = graphicsData.matrix;
    verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);
    vertPos++;
    verts.push(points[0], points[1]);
    for (let i = 2; i < points.length; i += 2) {
      verts.push(points[i], points[i + 1]);
      indices.push(vertPos++, center, vertPos);
    }
    indices.push(center + 1, center, vertPos);
  }
};

exports.buildCircle = buildCircle;
//# sourceMappingURL=buildCircle.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildLine.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildLine.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var _const = __webpack_require__(/*! ../const.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/const.js");

function square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  const ix = x - nx * innerWeight;
  const iy = y - ny * innerWeight;
  const ox = x + nx * outerWeight;
  const oy = y + ny * outerWeight;
  let exx;
  let eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  const eix = ix + exx;
  const eiy = iy + eyy;
  const eox = ox + exx;
  const eoy = oy + eyy;
  verts.push(eix, eiy, eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  const cx2p0x = sx - cx;
  const cy2p0y = sy - cy;
  let angle0 = Math.atan2(cx2p0x, cy2p0y);
  let angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  let startAngle = angle0;
  const angleDiff = angle1 - angle0;
  const absAngleDiff = Math.abs(angleDiff);
  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  const angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy, sx, sy);
    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(cx, cy, cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
    }
    verts.push(cx, cy, ex, ey);
  } else {
    verts.push(sx, sy, cx, cy);
    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius, cx, cy);
    }
    verts.push(ex, ey, cx, cy);
  }
  return segCount * 2;
}
function buildNonNativeLine(graphicsData, graphicsGeometry) {
  const shape = graphicsData.shape;
  let points = graphicsData.points || shape.points.slice();
  const eps = graphicsGeometry.closePointEps;
  if (points.length === 0) {
    return;
  }
  const style = graphicsData.lineStyle;
  const firstPoint = new core.Point(points[0], points[1]);
  const lastPoint = new core.Point(points[points.length - 2], points[points.length - 1]);
  const closedShape = shape.type !== core.SHAPES.POLY || shape.closeStroke;
  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  const verts = graphicsGeometry.points;
  const length = points.length / 2;
  let indexCount = points.length;
  const indexStart = verts.length / 2;
  const width = style.width / 2;
  const widthSquared = width * width;
  const miterLimitSquared = style.miterLimit * style.miterLimit;
  let x0 = points[0];
  let y0 = points[1];
  let x1 = points[2];
  let y1 = points[3];
  let x2 = 0;
  let y2 = 0;
  let perpx = -(y0 - y1);
  let perpy = x0 - x1;
  let perp1x = 0;
  let perp1y = 0;
  let dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  const ratio = style.alignment;
  const innerWeight = (1 - ratio) * 2;
  const outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === _const.LINE_CAP.ROUND) {
      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;
    } else if (style.cap === _const.LINE_CAP.SQUARE) {
      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight);
  for (let i = 1; i < length - 1; ++i) {
    x0 = points[(i - 1) * 2];
    y0 = points[(i - 1) * 2 + 1];
    x1 = points[i * 2];
    y1 = points[i * 2 + 1];
    x2 = points[(i + 1) * 2];
    y2 = points[(i + 1) * 2 + 1];
    perpx = -(y0 - y1);
    perpy = x0 - x1;
    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x2;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    const dx0 = x1 - x0;
    const dy0 = y0 - y1;
    const dx1 = x1 - x2;
    const dy1 = y2 - y1;
    const dot = dx0 * dx1 + dy0 * dy1;
    const cross = dy0 * dx1 - dy1 * dx0;
    const clockwise = cross < 0;
    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      if (dot >= 0) {
        if (style.join === _const.LINE_JOIN.ROUND) {
          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
        } else {
          indexCount += 2;
        }
        verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight, x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);
      }
      continue;
    }
    const c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);
    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    const px = (dx0 * c2 - dx1 * c1) / cross;
    const py = (dy1 * c1 - dy0 * c2) / cross;
    const pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    const imx = x1 + (px - x1) * innerWeight;
    const imy = y1 + (py - y1) * innerWeight;
    const omx = x1 - (px - x1) * outerWeight;
    const omy = y1 - (py - y1) * outerWeight;
    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    const insideWeight = clockwise ? innerWeight : outerWeight;
    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    const insideMiterOk = pdist <= smallerInsideDiagonalSq;
    let join = style.join;
    if (join === _const.LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared) {
      join = _const.LINE_JOIN.BEVEL;
    }
    if (insideMiterOk) {
      switch (join) {
        case _const.LINE_JOIN.MITER: {
          verts.push(imx, imy, omx, omy);
          break;
        }
        case _const.LINE_JOIN.BEVEL: {
          if (clockwise) {
            verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight, imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);
          }
          indexCount += 2;
          break;
        }
        case _const.LINE_JOIN.ROUND: {
          if (clockwise) {
            verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
            verts.push(imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy);
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);
          }
          break;
        }
      }
    } else {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      switch (join) {
        case _const.LINE_JOIN.MITER: {
          if (clockwise) {
            verts.push(omx, omy, omx, omy);
          } else {
            verts.push(imx, imy, imx, imy);
          }
          indexCount += 2;
          break;
        }
        case _const.LINE_JOIN.ROUND: {
          if (clockwise) {
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
          } else {
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
          }
          break;
        }
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2];
  y0 = points[(length - 2) * 2 + 1];
  x1 = points[(length - 1) * 2];
  y1 = points[(length - 1) * 2 + 1];
  perpx = -(y0 - y1);
  perpy = x0 - x1;
  dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
  if (!closedShape) {
    if (style.cap === _const.LINE_CAP.ROUND) {
      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;
    } else if (style.cap === _const.LINE_CAP.SQUARE) {
      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);
    }
  }
  const indices = graphicsGeometry.indices;
  const eps2 = _const.curves.epsilon * _const.curves.epsilon;
  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {
    x0 = verts[i * 2];
    y0 = verts[i * 2 + 1];
    x1 = verts[(i + 1) * 2];
    y1 = verts[(i + 1) * 2 + 1];
    x2 = verts[(i + 2) * 2];
    y2 = verts[(i + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
      continue;
    }
    indices.push(i, i + 1, i + 2);
  }
}
function buildNativeLine(graphicsData, graphicsGeometry) {
  let i = 0;
  const shape = graphicsData.shape;
  const points = graphicsData.points || shape.points;
  const closedShape = shape.type !== core.SHAPES.POLY || shape.closeStroke;
  if (points.length === 0)
    return;
  const verts = graphicsGeometry.points;
  const indices = graphicsGeometry.indices;
  const length = points.length / 2;
  const startIndex = verts.length / 2;
  let currentIndex = startIndex;
  verts.push(points[0], points[1]);
  for (i = 1; i < length; i++) {
    verts.push(points[i * 2], points[i * 2 + 1]);
    indices.push(currentIndex, currentIndex + 1);
    currentIndex++;
  }
  if (closedShape) {
    indices.push(currentIndex, startIndex);
  }
}
function buildLine(graphicsData, graphicsGeometry) {
  if (graphicsData.lineStyle.native) {
    buildNativeLine(graphicsData, graphicsGeometry);
  } else {
    buildNonNativeLine(graphicsData, graphicsGeometry);
  }
}

exports.buildLine = buildLine;
//# sourceMappingURL=buildLine.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildPoly.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildPoly.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

function fixOrientation(points, hole = false) {
  const m = points.length;
  if (m < 6) {
    return;
  }
  let area = 0;
  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {
    const x2 = points[i];
    const y2 = points[i + 1];
    area += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  if (!hole && area > 0 || hole && area <= 0) {
    const n = m / 2;
    for (let i = n + n % 2; i < m; i += 2) {
      const i1 = m - i - 2;
      const i2 = m - i - 1;
      const i3 = i;
      const i4 = i + 1;
      [points[i1], points[i3]] = [points[i3], points[i1]];
      [points[i2], points[i4]] = [points[i4], points[i2]];
    }
  }
}
const buildPoly = {
  build(graphicsData) {
    graphicsData.points = graphicsData.shape.points.slice();
  },
  triangulate(graphicsData, graphicsGeometry) {
    let points = graphicsData.points;
    const holes = graphicsData.holes;
    const verts = graphicsGeometry.points;
    const indices = graphicsGeometry.indices;
    if (points.length >= 6) {
      fixOrientation(points, false);
      const holeArray = [];
      for (let i = 0; i < holes.length; i++) {
        const hole = holes[i];
        fixOrientation(hole.points, true);
        holeArray.push(points.length / 2);
        points = points.concat(hole.points);
      }
      const triangles = core.utils.earcut(points, holeArray, 2);
      if (!triangles) {
        return;
      }
      const vertPos = verts.length / 2;
      for (let i = 0; i < triangles.length; i += 3) {
        indices.push(triangles[i] + vertPos);
        indices.push(triangles[i + 1] + vertPos);
        indices.push(triangles[i + 2] + vertPos);
      }
      for (let i = 0; i < points.length; i++) {
        verts.push(points[i]);
      }
    }
  }
};

exports.buildPoly = buildPoly;
//# sourceMappingURL=buildPoly.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildRectangle.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildRectangle.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const buildRectangle = {
  build(graphicsData) {
    const rectData = graphicsData.shape;
    const x = rectData.x;
    const y = rectData.y;
    const width = rectData.width;
    const height = rectData.height;
    const points = graphicsData.points;
    points.length = 0;
    if (!(width >= 0 && height >= 0)) {
      return;
    }
    points.push(x, y, x + width, y, x + width, y + height, x, y + height);
  },
  triangulate(graphicsData, graphicsGeometry) {
    const points = graphicsData.points;
    const verts = graphicsGeometry.points;
    if (points.length === 0) {
      return;
    }
    const vertPos = verts.length / 2;
    verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
  }
};

exports.buildRectangle = buildRectangle;
//# sourceMappingURL=buildRectangle.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildRoundedRectangle.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildRoundedRectangle.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var buildCircle = __webpack_require__(/*! ./buildCircle.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildCircle.js");

const buildRoundedRectangle = {
  build(graphicsData) {
    buildCircle.buildCircle.build(graphicsData);
  },
  triangulate(graphicsData, graphicsGeometry) {
    buildCircle.buildCircle.triangulate(graphicsData, graphicsGeometry);
  }
};

exports.buildRoundedRectangle = buildRoundedRectangle;
//# sourceMappingURL=buildRoundedRectangle.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var buildCircle = __webpack_require__(/*! ./buildCircle.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildCircle.js");
var buildPoly = __webpack_require__(/*! ./buildPoly.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildPoly.js");
var buildRectangle = __webpack_require__(/*! ./buildRectangle.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildRectangle.js");
var buildRoundedRectangle = __webpack_require__(/*! ./buildRoundedRectangle.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildRoundedRectangle.js");
var ArcUtils = __webpack_require__(/*! ./ArcUtils.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/ArcUtils.js");
var BatchPart = __webpack_require__(/*! ./BatchPart.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/BatchPart.js");
var BezierUtils = __webpack_require__(/*! ./BezierUtils.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/BezierUtils.js");
var buildLine = __webpack_require__(/*! ./buildLine.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/buildLine.js");
var QuadraticUtils = __webpack_require__(/*! ./QuadraticUtils.js */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/utils/QuadraticUtils.js");

const FILL_COMMANDS = {
  [core.SHAPES.POLY]: buildPoly.buildPoly,
  [core.SHAPES.CIRC]: buildCircle.buildCircle,
  [core.SHAPES.ELIP]: buildCircle.buildCircle,
  [core.SHAPES.RECT]: buildRectangle.buildRectangle,
  [core.SHAPES.RREC]: buildRoundedRectangle.buildRoundedRectangle
};
const BATCH_POOL = [];
const DRAW_CALL_POOL = [];

exports.buildCircle = buildCircle.buildCircle;
exports.buildPoly = buildPoly.buildPoly;
exports.buildRectangle = buildRectangle.buildRectangle;
exports.buildRoundedRectangle = buildRoundedRectangle.buildRoundedRectangle;
exports.ArcUtils = ArcUtils.ArcUtils;
exports.BatchPart = BatchPart.BatchPart;
exports.BezierUtils = BezierUtils.BezierUtils;
exports.buildLine = buildLine.buildLine;
exports.QuadraticUtils = QuadraticUtils.QuadraticUtils;
exports.BATCH_POOL = BATCH_POOL;
exports.DRAW_CALL_POOL = DRAW_CALL_POOL;
exports.FILL_COMMANDS = FILL_COMMANDS;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/math/lib/IPoint.js":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/math/lib/IPoint.js ***!
  \********************************************************************/
/***/ (() => {

"use strict";


//# sourceMappingURL=IPoint.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/math/lib/IPointData.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/math/lib/IPointData.js ***!
  \************************************************************************/
/***/ (() => {

"use strict";


//# sourceMappingURL=IPointData.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/math/lib/Matrix.js":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/math/lib/Matrix.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(/*! ./const.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/const.js");
var Point = __webpack_require__(/*! ./Point.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/Point.js");

class Matrix {
  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
    this.array = null;
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
  }
  fromArray(array) {
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
  }
  set(a, b, c, d, tx, ty) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
    return this;
  }
  toArray(transpose, out) {
    if (!this.array) {
      this.array = new Float32Array(9);
    }
    const array = out || this.array;
    if (transpose) {
      array[0] = this.a;
      array[1] = this.b;
      array[2] = 0;
      array[3] = this.c;
      array[4] = this.d;
      array[5] = 0;
      array[6] = this.tx;
      array[7] = this.ty;
      array[8] = 1;
    } else {
      array[0] = this.a;
      array[1] = this.c;
      array[2] = this.tx;
      array[3] = this.b;
      array[4] = this.d;
      array[5] = this.ty;
      array[6] = 0;
      array[7] = 0;
      array[8] = 1;
    }
    return array;
  }
  apply(pos, newPos) {
    newPos = newPos || new Point.Point();
    const x = pos.x;
    const y = pos.y;
    newPos.x = this.a * x + this.c * y + this.tx;
    newPos.y = this.b * x + this.d * y + this.ty;
    return newPos;
  }
  applyInverse(pos, newPos) {
    newPos = newPos || new Point.Point();
    const id = 1 / (this.a * this.d + this.c * -this.b);
    const x = pos.x;
    const y = pos.y;
    newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
    newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;
    return newPos;
  }
  translate(x, y) {
    this.tx += x;
    this.ty += y;
    return this;
  }
  scale(x, y) {
    this.a *= x;
    this.d *= y;
    this.c *= x;
    this.b *= y;
    this.tx *= x;
    this.ty *= y;
    return this;
  }
  rotate(angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const a1 = this.a;
    const c1 = this.c;
    const tx1 = this.tx;
    this.a = a1 * cos - this.b * sin;
    this.b = a1 * sin + this.b * cos;
    this.c = c1 * cos - this.d * sin;
    this.d = c1 * sin + this.d * cos;
    this.tx = tx1 * cos - this.ty * sin;
    this.ty = tx1 * sin + this.ty * cos;
    return this;
  }
  append(matrix) {
    const a1 = this.a;
    const b1 = this.b;
    const c1 = this.c;
    const d1 = this.d;
    this.a = matrix.a * a1 + matrix.b * c1;
    this.b = matrix.a * b1 + matrix.b * d1;
    this.c = matrix.c * a1 + matrix.d * c1;
    this.d = matrix.c * b1 + matrix.d * d1;
    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
    return this;
  }
  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
    this.a = Math.cos(rotation + skewY) * scaleX;
    this.b = Math.sin(rotation + skewY) * scaleX;
    this.c = -Math.sin(rotation - skewX) * scaleY;
    this.d = Math.cos(rotation - skewX) * scaleY;
    this.tx = x - (pivotX * this.a + pivotY * this.c);
    this.ty = y - (pivotX * this.b + pivotY * this.d);
    return this;
  }
  prepend(matrix) {
    const tx1 = this.tx;
    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
      const a1 = this.a;
      const c1 = this.c;
      this.a = a1 * matrix.a + this.b * matrix.c;
      this.b = a1 * matrix.b + this.b * matrix.d;
      this.c = c1 * matrix.a + this.d * matrix.c;
      this.d = c1 * matrix.b + this.d * matrix.d;
    }
    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
    return this;
  }
  decompose(transform) {
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const d = this.d;
    const pivot = transform.pivot;
    const skewX = -Math.atan2(-c, d);
    const skewY = Math.atan2(b, a);
    const delta = Math.abs(skewX + skewY);
    if (delta < 1e-5 || Math.abs(_const.PI_2 - delta) < 1e-5) {
      transform.rotation = skewY;
      transform.skew.x = transform.skew.y = 0;
    } else {
      transform.rotation = 0;
      transform.skew.x = skewX;
      transform.skew.y = skewY;
    }
    transform.scale.x = Math.sqrt(a * a + b * b);
    transform.scale.y = Math.sqrt(c * c + d * d);
    transform.position.x = this.tx + (pivot.x * a + pivot.y * c);
    transform.position.y = this.ty + (pivot.x * b + pivot.y * d);
    return transform;
  }
  invert() {
    const a1 = this.a;
    const b1 = this.b;
    const c1 = this.c;
    const d1 = this.d;
    const tx1 = this.tx;
    const n = a1 * d1 - b1 * c1;
    this.a = d1 / n;
    this.b = -b1 / n;
    this.c = -c1 / n;
    this.d = a1 / n;
    this.tx = (c1 * this.ty - d1 * tx1) / n;
    this.ty = -(a1 * this.ty - b1 * tx1) / n;
    return this;
  }
  identity() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;
    return this;
  }
  clone() {
    const matrix = new Matrix();
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  copyTo(matrix) {
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  copyFrom(matrix) {
    this.a = matrix.a;
    this.b = matrix.b;
    this.c = matrix.c;
    this.d = matrix.d;
    this.tx = matrix.tx;
    this.ty = matrix.ty;
    return this;
  }
  toString() {
    return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
  }
  static get IDENTITY() {
    return new Matrix();
  }
  static get TEMP_MATRIX() {
    return new Matrix();
  }
}

exports.Matrix = Matrix;
//# sourceMappingURL=Matrix.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/math/lib/ObservablePoint.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/math/lib/ObservablePoint.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class ObservablePoint {
  constructor(cb, scope, x = 0, y = 0) {
    this._x = x;
    this._y = y;
    this.cb = cb;
    this.scope = scope;
  }
  clone(cb = this.cb, scope = this.scope) {
    return new ObservablePoint(cb, scope, this._x, this._y);
  }
  set(x = 0, y = x) {
    if (this._x !== x || this._y !== y) {
      this._x = x;
      this._y = y;
      this.cb.call(this.scope);
    }
    return this;
  }
  copyFrom(p) {
    if (this._x !== p.x || this._y !== p.y) {
      this._x = p.x;
      this._y = p.y;
      this.cb.call(this.scope);
    }
    return this;
  }
  copyTo(p) {
    p.set(this._x, this._y);
    return p;
  }
  equals(p) {
    return p.x === this._x && p.y === this._y;
  }
  toString() {
    return `[@pixi/math:ObservablePoint x=${0} y=${0} scope=${this.scope}]`;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    if (this._x !== value) {
      this._x = value;
      this.cb.call(this.scope);
    }
  }
  get y() {
    return this._y;
  }
  set y(value) {
    if (this._y !== value) {
      this._y = value;
      this.cb.call(this.scope);
    }
  }
}

exports.ObservablePoint = ObservablePoint;
//# sourceMappingURL=ObservablePoint.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/math/lib/Point.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/math/lib/Point.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class Point {
  constructor(x = 0, y = 0) {
    this.x = 0;
    this.y = 0;
    this.x = x;
    this.y = y;
  }
  clone() {
    return new Point(this.x, this.y);
  }
  copyFrom(p) {
    this.set(p.x, p.y);
    return this;
  }
  copyTo(p) {
    p.set(this.x, this.y);
    return p;
  }
  equals(p) {
    return p.x === this.x && p.y === this.y;
  }
  set(x = 0, y = x) {
    this.x = x;
    this.y = y;
    return this;
  }
  toString() {
    return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
  }
}

exports.Point = Point;
//# sourceMappingURL=Point.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/math/lib/Transform.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/math/lib/Transform.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Matrix = __webpack_require__(/*! ./Matrix.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/Matrix.js");
var ObservablePoint = __webpack_require__(/*! ./ObservablePoint.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/ObservablePoint.js");

const _Transform = class {
  constructor() {
    this.worldTransform = new Matrix.Matrix();
    this.localTransform = new Matrix.Matrix();
    this.position = new ObservablePoint.ObservablePoint(this.onChange, this, 0, 0);
    this.scale = new ObservablePoint.ObservablePoint(this.onChange, this, 1, 1);
    this.pivot = new ObservablePoint.ObservablePoint(this.onChange, this, 0, 0);
    this.skew = new ObservablePoint.ObservablePoint(this.updateSkew, this, 0, 0);
    this._rotation = 0;
    this._cx = 1;
    this._sx = 0;
    this._cy = 0;
    this._sy = 1;
    this._localID = 0;
    this._currentLocalID = 0;
    this._worldID = 0;
    this._parentID = 0;
  }
  onChange() {
    this._localID++;
  }
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y);
    this._sx = Math.sin(this._rotation + this.skew.y);
    this._cy = -Math.sin(this._rotation - this.skew.x);
    this._sy = Math.cos(this._rotation - this.skew.x);
    this._localID++;
  }
  toString() {
    return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
  }
  updateLocalTransform() {
    const lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
  }
  updateTransform(parentTransform) {
    const lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
    if (this._parentID !== parentTransform._worldID) {
      const pt = parentTransform.worldTransform;
      const wt = this.worldTransform;
      wt.a = lt.a * pt.a + lt.b * pt.c;
      wt.b = lt.a * pt.b + lt.b * pt.d;
      wt.c = lt.c * pt.a + lt.d * pt.c;
      wt.d = lt.c * pt.b + lt.d * pt.d;
      wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
      wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
      this._parentID = parentTransform._worldID;
      this._worldID++;
    }
  }
  setFromMatrix(matrix) {
    matrix.decompose(this);
    this._localID++;
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    if (this._rotation !== value) {
      this._rotation = value;
      this.updateSkew();
    }
  }
};
let Transform = _Transform;
Transform.IDENTITY = new _Transform();

exports.Transform = Transform;
//# sourceMappingURL=Transform.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/math/lib/const.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/math/lib/const.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const PI_2 = Math.PI * 2;
const RAD_TO_DEG = 180 / Math.PI;
const DEG_TO_RAD = Math.PI / 180;
var SHAPES = /* @__PURE__ */ ((SHAPES2) => {
  SHAPES2[SHAPES2["POLY"] = 0] = "POLY";
  SHAPES2[SHAPES2["RECT"] = 1] = "RECT";
  SHAPES2[SHAPES2["CIRC"] = 2] = "CIRC";
  SHAPES2[SHAPES2["ELIP"] = 3] = "ELIP";
  SHAPES2[SHAPES2["RREC"] = 4] = "RREC";
  return SHAPES2;
})(SHAPES || {});

exports.DEG_TO_RAD = DEG_TO_RAD;
exports.PI_2 = PI_2;
exports.RAD_TO_DEG = RAD_TO_DEG;
exports.SHAPES = SHAPES;
//# sourceMappingURL=const.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/math/lib/groupD8.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/math/lib/groupD8.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Matrix = __webpack_require__(/*! ./Matrix.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/Matrix.js");

const ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
const uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
const vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
const vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
const rotationCayley = [];
const rotationMatrices = [];
const signum = Math.sign;
function init() {
  for (let i = 0; i < 16; i++) {
    const row = [];
    rotationCayley.push(row);
    for (let j = 0; j < 16; j++) {
      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
      const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
      const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
      const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);
      for (let k = 0; k < 16; k++) {
        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
          row.push(k);
          break;
        }
      }
    }
  }
  for (let i = 0; i < 16; i++) {
    const mat = new Matrix.Matrix();
    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);
    rotationMatrices.push(mat);
  }
}
init();
const groupD8 = {
  E: 0,
  SE: 1,
  S: 2,
  SW: 3,
  W: 4,
  NW: 5,
  N: 6,
  NE: 7,
  MIRROR_VERTICAL: 8,
  MAIN_DIAGONAL: 10,
  MIRROR_HORIZONTAL: 12,
  REVERSE_DIAGONAL: 14,
  uX: (ind) => ux[ind],
  uY: (ind) => uy[ind],
  vX: (ind) => vx[ind],
  vY: (ind) => vy[ind],
  inv: (rotation) => {
    if (rotation & 8) {
      return rotation & 15;
    }
    return -rotation & 7;
  },
  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
  rotate180: (rotation) => rotation ^ 4,
  isVertical: (rotation) => (rotation & 3) === 2,
  byDirection: (dx, dy) => {
    if (Math.abs(dx) * 2 <= Math.abs(dy)) {
      if (dy >= 0) {
        return groupD8.S;
      }
      return groupD8.N;
    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
      if (dx > 0) {
        return groupD8.E;
      }
      return groupD8.W;
    } else if (dy > 0) {
      if (dx > 0) {
        return groupD8.SE;
      }
      return groupD8.SW;
    } else if (dx > 0) {
      return groupD8.NE;
    }
    return groupD8.NW;
  },
  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
    const mat = rotationMatrices[groupD8.inv(rotation)];
    mat.tx = tx;
    mat.ty = ty;
    matrix.append(mat);
  }
};

exports.groupD8 = groupD8;
//# sourceMappingURL=groupD8.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/math/lib/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/math/lib/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Circle = __webpack_require__(/*! ./shapes/Circle.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/shapes/Circle.js");
var Ellipse = __webpack_require__(/*! ./shapes/Ellipse.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/shapes/Ellipse.js");
var Polygon = __webpack_require__(/*! ./shapes/Polygon.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/shapes/Polygon.js");
var Rectangle = __webpack_require__(/*! ./shapes/Rectangle.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/shapes/Rectangle.js");
var RoundedRectangle = __webpack_require__(/*! ./shapes/RoundedRectangle.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/shapes/RoundedRectangle.js");
var groupD8 = __webpack_require__(/*! ./groupD8.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/groupD8.js");
__webpack_require__(/*! ./IPoint.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/IPoint.js");
__webpack_require__(/*! ./IPointData.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/IPointData.js");
var Matrix = __webpack_require__(/*! ./Matrix.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/Matrix.js");
var ObservablePoint = __webpack_require__(/*! ./ObservablePoint.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/ObservablePoint.js");
var Point = __webpack_require__(/*! ./Point.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/Point.js");
var Transform = __webpack_require__(/*! ./Transform.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/Transform.js");
var _const = __webpack_require__(/*! ./const.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/const.js");



exports.Circle = Circle.Circle;
exports.Ellipse = Ellipse.Ellipse;
exports.Polygon = Polygon.Polygon;
exports.Rectangle = Rectangle.Rectangle;
exports.RoundedRectangle = RoundedRectangle.RoundedRectangle;
exports.groupD8 = groupD8.groupD8;
exports.Matrix = Matrix.Matrix;
exports.ObservablePoint = ObservablePoint.ObservablePoint;
exports.Point = Point.Point;
exports.Transform = Transform.Transform;
exports.DEG_TO_RAD = _const.DEG_TO_RAD;
exports.PI_2 = _const.PI_2;
exports.RAD_TO_DEG = _const.RAD_TO_DEG;
exports.SHAPES = _const.SHAPES;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/math/lib/shapes/Circle.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/math/lib/shapes/Circle.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/const.js");
var Rectangle = __webpack_require__(/*! ./Rectangle.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/shapes/Rectangle.js");

class Circle {
  constructor(x = 0, y = 0, radius = 0) {
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.type = _const.SHAPES.CIRC;
  }
  clone() {
    return new Circle(this.x, this.y, this.radius);
  }
  contains(x, y) {
    if (this.radius <= 0) {
      return false;
    }
    const r2 = this.radius * this.radius;
    let dx = this.x - x;
    let dy = this.y - y;
    dx *= dx;
    dy *= dy;
    return dx + dy <= r2;
  }
  getBounds() {
    return new Rectangle.Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  }
  toString() {
    return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
  }
}

exports.Circle = Circle;
//# sourceMappingURL=Circle.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/math/lib/shapes/Ellipse.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/math/lib/shapes/Ellipse.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/const.js");
var Rectangle = __webpack_require__(/*! ./Rectangle.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/shapes/Rectangle.js");

class Ellipse {
  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {
    this.x = x;
    this.y = y;
    this.width = halfWidth;
    this.height = halfHeight;
    this.type = _const.SHAPES.ELIP;
  }
  clone() {
    return new Ellipse(this.x, this.y, this.width, this.height);
  }
  contains(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    let normx = (x - this.x) / this.width;
    let normy = (y - this.y) / this.height;
    normx *= normx;
    normy *= normy;
    return normx + normy <= 1;
  }
  getBounds() {
    return new Rectangle.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
  }
  toString() {
    return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}

exports.Ellipse = Ellipse;
//# sourceMappingURL=Ellipse.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/math/lib/shapes/Polygon.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/math/lib/shapes/Polygon.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/const.js");

class Polygon {
  constructor(...points) {
    let flat = Array.isArray(points[0]) ? points[0] : points;
    if (typeof flat[0] !== "number") {
      const p = [];
      for (let i = 0, il = flat.length; i < il; i++) {
        p.push(flat[i].x, flat[i].y);
      }
      flat = p;
    }
    this.points = flat;
    this.type = _const.SHAPES.POLY;
    this.closeStroke = true;
  }
  clone() {
    const points = this.points.slice();
    const polygon = new Polygon(points);
    polygon.closeStroke = this.closeStroke;
    return polygon;
  }
  contains(x, y) {
    let inside = false;
    const length = this.points.length / 2;
    for (let i = 0, j = length - 1; i < length; j = i++) {
      const xi = this.points[i * 2];
      const yi = this.points[i * 2 + 1];
      const xj = this.points[j * 2];
      const yj = this.points[j * 2 + 1];
      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;
      if (intersect) {
        inside = !inside;
      }
    }
    return inside;
  }
  toString() {
    return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
  }
}

exports.Polygon = Polygon;
//# sourceMappingURL=Polygon.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/math/lib/shapes/Rectangle.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/math/lib/shapes/Rectangle.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/const.js");
var Point = __webpack_require__(/*! ../Point.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/Point.js");

const tempPoints = [new Point.Point(), new Point.Point(), new Point.Point(), new Point.Point()];
class Rectangle {
  constructor(x = 0, y = 0, width = 0, height = 0) {
    this.x = Number(x);
    this.y = Number(y);
    this.width = Number(width);
    this.height = Number(height);
    this.type = _const.SHAPES.RECT;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  static get EMPTY() {
    return new Rectangle(0, 0, 0, 0);
  }
  clone() {
    return new Rectangle(this.x, this.y, this.width, this.height);
  }
  copyFrom(rectangle) {
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;
    return this;
  }
  copyTo(rectangle) {
    rectangle.x = this.x;
    rectangle.y = this.y;
    rectangle.width = this.width;
    rectangle.height = this.height;
    return rectangle;
  }
  contains(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x >= this.x && x < this.x + this.width) {
      if (y >= this.y && y < this.y + this.height) {
        return true;
      }
    }
    return false;
  }
  intersects(other, transform) {
    if (!transform) {
      const x02 = this.x < other.x ? other.x : this.x;
      const x12 = this.right > other.right ? other.right : this.right;
      if (x12 <= x02) {
        return false;
      }
      const y02 = this.y < other.y ? other.y : this.y;
      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
      return y12 > y02;
    }
    const x0 = this.left;
    const x1 = this.right;
    const y0 = this.top;
    const y1 = this.bottom;
    if (x1 <= x0 || y1 <= y0) {
      return false;
    }
    const lt = tempPoints[0].set(other.left, other.top);
    const lb = tempPoints[1].set(other.left, other.bottom);
    const rt = tempPoints[2].set(other.right, other.top);
    const rb = tempPoints[3].set(other.right, other.bottom);
    if (rt.x <= lt.x || lb.y <= lt.y) {
      return false;
    }
    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);
    if (s === 0) {
      return false;
    }
    transform.apply(lt, lt);
    transform.apply(lb, lb);
    transform.apply(rt, rt);
    transform.apply(rb, rb);
    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
      return false;
    }
    const nx = s * (lb.y - lt.y);
    const ny = s * (lt.x - lb.x);
    const n00 = nx * x0 + ny * y0;
    const n10 = nx * x1 + ny * y0;
    const n01 = nx * x0 + ny * y1;
    const n11 = nx * x1 + ny * y1;
    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
      return false;
    }
    const mx = s * (lt.y - rt.y);
    const my = s * (rt.x - lt.x);
    const m00 = mx * x0 + my * y0;
    const m10 = mx * x1 + my * y0;
    const m01 = mx * x0 + my * y1;
    const m11 = mx * x1 + my * y1;
    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
      return false;
    }
    return true;
  }
  pad(paddingX = 0, paddingY = paddingX) {
    this.x -= paddingX;
    this.y -= paddingY;
    this.width += paddingX * 2;
    this.height += paddingY * 2;
    return this;
  }
  fit(rectangle) {
    const x1 = Math.max(this.x, rectangle.x);
    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.max(this.y, rectangle.y);
    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = Math.max(x2 - x1, 0);
    this.y = y1;
    this.height = Math.max(y2 - y1, 0);
    return this;
  }
  ceil(resolution = 1, eps = 1e-3) {
    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
    this.x = Math.floor((this.x + eps) * resolution) / resolution;
    this.y = Math.floor((this.y + eps) * resolution) / resolution;
    this.width = x2 - this.x;
    this.height = y2 - this.y;
    return this;
  }
  enlarge(rectangle) {
    const x1 = Math.min(this.x, rectangle.x);
    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.min(this.y, rectangle.y);
    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = x2 - x1;
    this.y = y1;
    this.height = y2 - y1;
    return this;
  }
  toString() {
    return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}

exports.Rectangle = Rectangle;
//# sourceMappingURL=Rectangle.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/math/lib/shapes/RoundedRectangle.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/math/lib/shapes/RoundedRectangle.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/pixi.js/node_modules/@pixi/math/lib/const.js");

class RoundedRectangle {
  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.radius = radius;
    this.type = _const.SHAPES.RREC;
  }
  clone() {
    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
  }
  contains(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x >= this.x && x <= this.x + this.width) {
      if (y >= this.y && y <= this.y + this.height) {
        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {
          return true;
        }
        let dx = x - (this.x + radius);
        let dy = y - (this.y + radius);
        const radius2 = radius * radius;
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x - (this.x + this.width - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dy = y - (this.y + this.height - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x - (this.x + radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
      }
    }
    return false;
  }
  toString() {
    return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
  }
}

exports.RoundedRectangle = RoundedRectangle;
//# sourceMappingURL=RoundedRectangle.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/NineSlicePlane.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/NineSlicePlane.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var SimplePlane = __webpack_require__(/*! ./SimplePlane.js */ "./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/SimplePlane.js");

const DEFAULT_BORDER_SIZE = 10;
class NineSlicePlane extends SimplePlane.SimplePlane {
  constructor(texture, leftWidth, topHeight, rightWidth, bottomHeight) {
    super(core.Texture.WHITE, 4, 4);
    this._origWidth = texture.orig.width;
    this._origHeight = texture.orig.height;
    this._width = this._origWidth;
    this._height = this._origHeight;
    this._leftWidth = leftWidth ?? texture.defaultBorders?.left ?? DEFAULT_BORDER_SIZE;
    this._rightWidth = rightWidth ?? texture.defaultBorders?.right ?? DEFAULT_BORDER_SIZE;
    this._topHeight = topHeight ?? texture.defaultBorders?.top ?? DEFAULT_BORDER_SIZE;
    this._bottomHeight = bottomHeight ?? texture.defaultBorders?.bottom ?? DEFAULT_BORDER_SIZE;
    this.texture = texture;
  }
  textureUpdated() {
    this._textureID = this.shader.texture._updateID;
    this._refresh();
  }
  get vertices() {
    return this.geometry.getBuffer("aVertexPosition").data;
  }
  set vertices(value) {
    this.geometry.getBuffer("aVertexPosition").data = value;
  }
  updateHorizontalVertices() {
    const vertices = this.vertices;
    const scale = this._getMinScale();
    vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;
    vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;
    vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
  }
  updateVerticalVertices() {
    const vertices = this.vertices;
    const scale = this._getMinScale();
    vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;
    vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;
    vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
  }
  _getMinScale() {
    const w = this._leftWidth + this._rightWidth;
    const scaleW = this._width > w ? 1 : this._width / w;
    const h = this._topHeight + this._bottomHeight;
    const scaleH = this._height > h ? 1 : this._height / h;
    const scale = Math.min(scaleW, scaleH);
    return scale;
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
    this._refresh();
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
    this._refresh();
  }
  get leftWidth() {
    return this._leftWidth;
  }
  set leftWidth(value) {
    this._leftWidth = value;
    this._refresh();
  }
  get rightWidth() {
    return this._rightWidth;
  }
  set rightWidth(value) {
    this._rightWidth = value;
    this._refresh();
  }
  get topHeight() {
    return this._topHeight;
  }
  set topHeight(value) {
    this._topHeight = value;
    this._refresh();
  }
  get bottomHeight() {
    return this._bottomHeight;
  }
  set bottomHeight(value) {
    this._bottomHeight = value;
    this._refresh();
  }
  _refresh() {
    const texture = this.texture;
    const uvs = this.geometry.buffers[1].data;
    this._origWidth = texture.orig.width;
    this._origHeight = texture.orig.height;
    const _uvw = 1 / this._origWidth;
    const _uvh = 1 / this._origHeight;
    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
    this.updateHorizontalVertices();
    this.updateVerticalVertices();
    this.geometry.buffers[0].update();
    this.geometry.buffers[1].update();
  }
}

exports.NineSlicePlane = NineSlicePlane;
//# sourceMappingURL=NineSlicePlane.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/SimpleMesh.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/SimpleMesh.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var mesh = __webpack_require__(/*! @pixi/mesh */ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/index.js");

class SimpleMesh extends mesh.Mesh {
  constructor(texture = core.Texture.EMPTY, vertices, uvs, indices, drawMode) {
    const geometry = new mesh.MeshGeometry(vertices, uvs, indices);
    geometry.getBuffer("aVertexPosition").static = false;
    const meshMaterial = new mesh.MeshMaterial(texture);
    super(geometry, meshMaterial, null, drawMode);
    this.autoUpdate = true;
  }
  get vertices() {
    return this.geometry.getBuffer("aVertexPosition").data;
  }
  set vertices(value) {
    this.geometry.getBuffer("aVertexPosition").data = value;
  }
  _render(renderer) {
    if (this.autoUpdate) {
      this.geometry.getBuffer("aVertexPosition").update();
    }
    super._render(renderer);
  }
}

exports.SimpleMesh = SimpleMesh;
//# sourceMappingURL=SimpleMesh.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/SimplePlane.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/SimplePlane.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var mesh = __webpack_require__(/*! @pixi/mesh */ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/index.js");
var PlaneGeometry = __webpack_require__(/*! ./geometry/PlaneGeometry.js */ "./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.js");

class SimplePlane extends mesh.Mesh {
  constructor(texture, verticesX, verticesY) {
    const planeGeometry = new PlaneGeometry.PlaneGeometry(texture.width, texture.height, verticesX, verticesY);
    const meshMaterial = new mesh.MeshMaterial(core.Texture.WHITE);
    super(planeGeometry, meshMaterial);
    this.texture = texture;
    this.autoResize = true;
  }
  textureUpdated() {
    this._textureID = this.shader.texture._updateID;
    const geometry = this.geometry;
    const { width, height } = this.shader.texture;
    if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
      geometry.width = this.shader.texture.width;
      geometry.height = this.shader.texture.height;
      geometry.build();
    }
  }
  set texture(value) {
    if (this.shader.texture === value) {
      return;
    }
    this.shader.texture = value;
    this._textureID = -1;
    if (value.baseTexture.valid) {
      this.textureUpdated();
    } else {
      value.once("update", this.textureUpdated, this);
    }
  }
  get texture() {
    return this.shader.texture;
  }
  _render(renderer) {
    if (this._textureID !== this.shader.texture._updateID) {
      this.textureUpdated();
    }
    super._render(renderer);
  }
  destroy(options) {
    this.shader.texture.off("update", this.textureUpdated, this);
    super.destroy(options);
  }
}

exports.SimplePlane = SimplePlane;
//# sourceMappingURL=SimplePlane.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/SimpleRope.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/SimpleRope.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var mesh = __webpack_require__(/*! @pixi/mesh */ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/index.js");
var RopeGeometry = __webpack_require__(/*! ./geometry/RopeGeometry.js */ "./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.js");

class SimpleRope extends mesh.Mesh {
  constructor(texture, points, textureScale = 0) {
    const ropeGeometry = new RopeGeometry.RopeGeometry(texture.height, points, textureScale);
    const meshMaterial = new mesh.MeshMaterial(texture);
    if (textureScale > 0) {
      texture.baseTexture.wrapMode = core.WRAP_MODES.REPEAT;
    }
    super(ropeGeometry, meshMaterial);
    this.autoUpdate = true;
  }
  _render(renderer) {
    const geometry = this.geometry;
    if (this.autoUpdate || geometry._width !== this.shader.texture.height) {
      geometry._width = this.shader.texture.height;
      geometry.update();
    }
    super._render(renderer);
  }
}

exports.SimpleRope = SimpleRope;
//# sourceMappingURL=SimpleRope.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var mesh = __webpack_require__(/*! @pixi/mesh */ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/index.js");

class PlaneGeometry extends mesh.MeshGeometry {
  constructor(width = 100, height = 100, segWidth = 10, segHeight = 10) {
    super();
    this.segWidth = segWidth;
    this.segHeight = segHeight;
    this.width = width;
    this.height = height;
    this.build();
  }
  build() {
    const total = this.segWidth * this.segHeight;
    const verts = [];
    const uvs = [];
    const indices = [];
    const segmentsX = this.segWidth - 1;
    const segmentsY = this.segHeight - 1;
    const sizeX = this.width / segmentsX;
    const sizeY = this.height / segmentsY;
    for (let i = 0; i < total; i++) {
      const x = i % this.segWidth;
      const y = i / this.segWidth | 0;
      verts.push(x * sizeX, y * sizeY);
      uvs.push(x / segmentsX, y / segmentsY);
    }
    const totalSub = segmentsX * segmentsY;
    for (let i = 0; i < totalSub; i++) {
      const xpos = i % segmentsX;
      const ypos = i / segmentsX | 0;
      const value = ypos * this.segWidth + xpos;
      const value2 = ypos * this.segWidth + xpos + 1;
      const value3 = (ypos + 1) * this.segWidth + xpos;
      const value4 = (ypos + 1) * this.segWidth + xpos + 1;
      indices.push(value, value2, value3, value2, value4, value3);
    }
    this.buffers[0].data = new Float32Array(verts);
    this.buffers[1].data = new Float32Array(uvs);
    this.indexBuffer.data = new Uint16Array(indices);
    this.buffers[0].update();
    this.buffers[1].update();
    this.indexBuffer.update();
  }
}

exports.PlaneGeometry = PlaneGeometry;
//# sourceMappingURL=PlaneGeometry.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var mesh = __webpack_require__(/*! @pixi/mesh */ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/index.js");

class RopeGeometry extends mesh.MeshGeometry {
  constructor(width = 200, points, textureScale = 0) {
    super(new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6));
    this.points = points;
    this._width = width;
    this.textureScale = textureScale;
    this.build();
  }
  get width() {
    return this._width;
  }
  build() {
    const points = this.points;
    if (!points)
      return;
    const vertexBuffer = this.getBuffer("aVertexPosition");
    const uvBuffer = this.getBuffer("aTextureCoord");
    const indexBuffer = this.getIndex();
    if (points.length < 1) {
      return;
    }
    if (vertexBuffer.data.length / 4 !== points.length) {
      vertexBuffer.data = new Float32Array(points.length * 4);
      uvBuffer.data = new Float32Array(points.length * 4);
      indexBuffer.data = new Uint16Array((points.length - 1) * 6);
    }
    const uvs = uvBuffer.data;
    const indices = indexBuffer.data;
    uvs[0] = 0;
    uvs[1] = 0;
    uvs[2] = 0;
    uvs[3] = 1;
    let amount = 0;
    let prev = points[0];
    const textureWidth = this._width * this.textureScale;
    const total = points.length;
    for (let i = 0; i < total; i++) {
      const index = i * 4;
      if (this.textureScale > 0) {
        const dx = prev.x - points[i].x;
        const dy = prev.y - points[i].y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        prev = points[i];
        amount += distance / textureWidth;
      } else {
        amount = i / (total - 1);
      }
      uvs[index] = amount;
      uvs[index + 1] = 0;
      uvs[index + 2] = amount;
      uvs[index + 3] = 1;
    }
    let indexCount = 0;
    for (let i = 0; i < total - 1; i++) {
      const index = i * 2;
      indices[indexCount++] = index;
      indices[indexCount++] = index + 1;
      indices[indexCount++] = index + 2;
      indices[indexCount++] = index + 2;
      indices[indexCount++] = index + 1;
      indices[indexCount++] = index + 3;
    }
    uvBuffer.update();
    indexBuffer.update();
    this.updateVertices();
  }
  updateVertices() {
    const points = this.points;
    if (points.length < 1) {
      return;
    }
    let lastPoint = points[0];
    let nextPoint;
    let perpX = 0;
    let perpY = 0;
    const vertices = this.buffers[0].data;
    const total = points.length;
    const halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
    for (let i = 0; i < total; i++) {
      const point = points[i];
      const index = i * 4;
      if (i < points.length - 1) {
        nextPoint = points[i + 1];
      } else {
        nextPoint = point;
      }
      perpY = -(nextPoint.x - lastPoint.x);
      perpX = nextPoint.y - lastPoint.y;
      let ratio = (1 - i / (total - 1)) * 10;
      if (ratio > 1) {
        ratio = 1;
      }
      const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
      if (perpLength < 1e-6) {
        perpX = 0;
        perpY = 0;
      } else {
        perpX /= perpLength;
        perpY /= perpLength;
        perpX *= halfWidth;
        perpY *= halfWidth;
      }
      vertices[index] = point.x + perpX;
      vertices[index + 1] = point.y + perpY;
      vertices[index + 2] = point.x - perpX;
      vertices[index + 3] = point.y - perpY;
      lastPoint = point;
    }
    this.buffers[0].update();
  }
  update() {
    if (this.textureScale > 0) {
      this.build();
    } else {
      this.updateVertices();
    }
  }
}

exports.RopeGeometry = RopeGeometry;
//# sourceMappingURL=RopeGeometry.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var PlaneGeometry = __webpack_require__(/*! ./geometry/PlaneGeometry.js */ "./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.js");
var RopeGeometry = __webpack_require__(/*! ./geometry/RopeGeometry.js */ "./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.js");
var NineSlicePlane = __webpack_require__(/*! ./NineSlicePlane.js */ "./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/NineSlicePlane.js");
var SimpleMesh = __webpack_require__(/*! ./SimpleMesh.js */ "./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/SimpleMesh.js");
var SimplePlane = __webpack_require__(/*! ./SimplePlane.js */ "./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/SimplePlane.js");
var SimpleRope = __webpack_require__(/*! ./SimpleRope.js */ "./node_modules/pixi.js/node_modules/@pixi/mesh-extras/lib/SimpleRope.js");



exports.PlaneGeometry = PlaneGeometry.PlaneGeometry;
exports.RopeGeometry = RopeGeometry.RopeGeometry;
exports.NineSlicePlane = NineSlicePlane.NineSlicePlane;
exports.SimpleMesh = SimpleMesh.SimpleMesh;
exports.SimplePlane = SimplePlane.SimplePlane;
exports.SimpleRope = SimpleRope.SimpleRope;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/Mesh.js":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/mesh/lib/Mesh.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var display = __webpack_require__(/*! @pixi/display */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/index.js");
var MeshBatchUvs = __webpack_require__(/*! ./MeshBatchUvs.js */ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/MeshBatchUvs.js");

const tempPoint = new core.Point();
const tempPolygon = new core.Polygon();
const _Mesh = class extends display.Container {
  constructor(geometry, shader, state, drawMode = core.DRAW_MODES.TRIANGLES) {
    super();
    this.geometry = geometry;
    this.shader = shader;
    this.state = state || core.State.for2d();
    this.drawMode = drawMode;
    this.start = 0;
    this.size = 0;
    this.uvs = null;
    this.indices = null;
    this.vertexData = new Float32Array(1);
    this.vertexDirty = -1;
    this._transformID = -1;
    this._roundPixels = core.settings.ROUND_PIXELS;
    this.batchUvs = null;
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(value) {
    if (this._geometry === value) {
      return;
    }
    if (this._geometry) {
      this._geometry.refCount--;
      if (this._geometry.refCount === 0) {
        this._geometry.dispose();
      }
    }
    this._geometry = value;
    if (this._geometry) {
      this._geometry.refCount++;
    }
    this.vertexDirty = -1;
  }
  get uvBuffer() {
    return this.geometry.buffers[1];
  }
  get verticesBuffer() {
    return this.geometry.buffers[0];
  }
  set material(value) {
    this.shader = value;
  }
  get material() {
    return this.shader;
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get blendMode() {
    return this.state.blendMode;
  }
  set roundPixels(value) {
    if (this._roundPixels !== value) {
      this._transformID = -1;
    }
    this._roundPixels = value;
  }
  get roundPixels() {
    return this._roundPixels;
  }
  get tint() {
    return "tint" in this.shader ? this.shader.tint : null;
  }
  set tint(value) {
    this.shader.tint = value;
  }
  get tintValue() {
    return this.shader.tintValue;
  }
  get texture() {
    return "texture" in this.shader ? this.shader.texture : null;
  }
  set texture(value) {
    this.shader.texture = value;
  }
  _render(renderer) {
    const vertices = this.geometry.buffers[0].data;
    const shader = this.shader;
    if (shader.batchable && this.drawMode === core.DRAW_MODES.TRIANGLES && vertices.length < _Mesh.BATCHABLE_SIZE * 2) {
      this._renderToBatch(renderer);
    } else {
      this._renderDefault(renderer);
    }
  }
  _renderDefault(renderer) {
    const shader = this.shader;
    shader.alpha = this.worldAlpha;
    if (shader.update) {
      shader.update();
    }
    renderer.batch.flush();
    shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
    renderer.shader.bind(shader);
    renderer.state.set(this.state);
    renderer.geometry.bind(this.geometry, shader);
    renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
  }
  _renderToBatch(renderer) {
    const geometry = this.geometry;
    const shader = this.shader;
    if (shader.uvMatrix) {
      shader.uvMatrix.update();
      this.calculateUvs();
    }
    this.calculateVertices();
    this.indices = geometry.indexBuffer.data;
    this._tintRGB = shader._tintRGB;
    this._texture = shader.texture;
    const pluginName = this.material.pluginName;
    renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
    renderer.plugins[pluginName].render(this);
  }
  calculateVertices() {
    const geometry = this.geometry;
    const verticesBuffer = geometry.buffers[0];
    const vertices = verticesBuffer.data;
    const vertexDirtyId = verticesBuffer._updateID;
    if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
      return;
    }
    this._transformID = this.transform._worldID;
    if (this.vertexData.length !== vertices.length) {
      this.vertexData = new Float32Array(vertices.length);
    }
    const wt = this.transform.worldTransform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const vertexData = this.vertexData;
    for (let i = 0; i < vertexData.length / 2; i++) {
      const x = vertices[i * 2];
      const y = vertices[i * 2 + 1];
      vertexData[i * 2] = a * x + c * y + tx;
      vertexData[i * 2 + 1] = b * x + d * y + ty;
    }
    if (this._roundPixels) {
      const resolution = core.settings.RESOLUTION;
      for (let i = 0; i < vertexData.length; ++i) {
        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;
      }
    }
    this.vertexDirty = vertexDirtyId;
  }
  calculateUvs() {
    const geomUvs = this.geometry.buffers[1];
    const shader = this.shader;
    if (!shader.uvMatrix.isSimple) {
      if (!this.batchUvs) {
        this.batchUvs = new MeshBatchUvs.MeshBatchUvs(geomUvs, shader.uvMatrix);
      }
      this.batchUvs.update();
      this.uvs = this.batchUvs.data;
    } else {
      this.uvs = geomUvs.data;
    }
  }
  _calculateBounds() {
    this.calculateVertices();
    this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
  }
  containsPoint(point) {
    if (!this.getBounds().contains(point.x, point.y)) {
      return false;
    }
    this.worldTransform.applyInverse(point, tempPoint);
    const vertices = this.geometry.getBuffer("aVertexPosition").data;
    const points = tempPolygon.points;
    const indices = this.geometry.getIndex().data;
    const len = indices.length;
    const step = this.drawMode === 4 ? 3 : 1;
    for (let i = 0; i + 2 < len; i += step) {
      const ind0 = indices[i] * 2;
      const ind1 = indices[i + 1] * 2;
      const ind2 = indices[i + 2] * 2;
      points[0] = vertices[ind0];
      points[1] = vertices[ind0 + 1];
      points[2] = vertices[ind1];
      points[3] = vertices[ind1 + 1];
      points[4] = vertices[ind2];
      points[5] = vertices[ind2 + 1];
      if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
        return true;
      }
    }
    return false;
  }
  destroy(options) {
    super.destroy(options);
    if (this._cachedTexture) {
      this._cachedTexture.destroy();
      this._cachedTexture = null;
    }
    this.geometry = null;
    this.shader = null;
    this.state = null;
    this.uvs = null;
    this.indices = null;
    this.vertexData = null;
  }
};
let Mesh = _Mesh;
Mesh.BATCHABLE_SIZE = 100;

exports.Mesh = Mesh;
//# sourceMappingURL=Mesh.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/MeshBatchUvs.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/mesh/lib/MeshBatchUvs.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class MeshBatchUvs {
  constructor(uvBuffer, uvMatrix) {
    this.uvBuffer = uvBuffer;
    this.uvMatrix = uvMatrix;
    this.data = null;
    this._bufferUpdateId = -1;
    this._textureUpdateId = -1;
    this._updateID = 0;
  }
  update(forceUpdate) {
    if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {
      return;
    }
    this._bufferUpdateId = this.uvBuffer._updateID;
    this._textureUpdateId = this.uvMatrix._updateID;
    const data = this.uvBuffer.data;
    if (!this.data || this.data.length !== data.length) {
      this.data = new Float32Array(data.length);
    }
    this.uvMatrix.multiplyUvs(data, this.data);
    this._updateID++;
  }
}

exports.MeshBatchUvs = MeshBatchUvs;
//# sourceMappingURL=MeshBatchUvs.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/MeshGeometry.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/mesh/lib/MeshGeometry.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

class MeshGeometry extends core.Geometry {
  constructor(vertices, uvs, index) {
    super();
    const verticesBuffer = new core.Buffer(vertices);
    const uvsBuffer = new core.Buffer(uvs, true);
    const indexBuffer = new core.Buffer(index, true, true);
    this.addAttribute("aVertexPosition", verticesBuffer, 2, false, core.TYPES.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, core.TYPES.FLOAT).addIndex(indexBuffer);
    this._updateId = -1;
  }
  get vertexDirtyId() {
    return this.buffers[0]._updateID;
  }
}

exports.MeshGeometry = MeshGeometry;
//# sourceMappingURL=MeshGeometry.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/MeshMaterial.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/mesh/lib/MeshMaterial.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var mesh$1 = __webpack_require__(/*! ./shader/mesh.js */ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/shader/mesh.js");
var mesh = __webpack_require__(/*! ./shader/mesh2.js */ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/shader/mesh2.js");

class MeshMaterial extends core.Shader {
  constructor(uSampler, options) {
    const uniforms = {
      uSampler,
      alpha: 1,
      uTextureMatrix: core.Matrix.IDENTITY,
      uColor: new Float32Array([1, 1, 1, 1])
    };
    options = Object.assign({
      tint: 16777215,
      alpha: 1,
      pluginName: "batch"
    }, options);
    if (options.uniforms) {
      Object.assign(uniforms, options.uniforms);
    }
    super(options.program || core.Program.from(mesh["default"], mesh$1["default"]), uniforms);
    this._colorDirty = false;
    this.uvMatrix = new core.TextureMatrix(uSampler);
    this.batchable = options.program === void 0;
    this.pluginName = options.pluginName;
    this._tintColor = new core.Color(options.tint);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
    this._colorDirty = true;
    this.alpha = options.alpha;
  }
  get texture() {
    return this.uniforms.uSampler;
  }
  set texture(value) {
    if (this.uniforms.uSampler !== value) {
      if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value.baseTexture.alphaMode) {
        this._colorDirty = true;
      }
      this.uniforms.uSampler = value;
      this.uvMatrix.texture = value;
    }
  }
  set alpha(value) {
    if (value === this._alpha)
      return;
    this._alpha = value;
    this._colorDirty = true;
  }
  get alpha() {
    return this._alpha;
  }
  set tint(value) {
    if (value === this.tint)
      return;
    this._tintColor.setValue(value);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
    this._colorDirty = true;
  }
  get tint() {
    return this._tintColor.value;
  }
  get tintValue() {
    return this._tintColor.toNumber();
  }
  update() {
    if (this._colorDirty) {
      this._colorDirty = false;
      const baseTexture = this.texture.baseTexture;
      const applyToChannels = baseTexture.alphaMode;
      core.Color.shared.setValue(this._tintColor).premultiply(this._alpha, applyToChannels).toArray(this.uniforms.uColor);
    }
    if (this.uvMatrix.update()) {
      this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
    }
  }
}

exports.MeshMaterial = MeshMaterial;
//# sourceMappingURL=MeshMaterial.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/mesh/lib/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Mesh = __webpack_require__(/*! ./Mesh.js */ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/Mesh.js");
var MeshBatchUvs = __webpack_require__(/*! ./MeshBatchUvs.js */ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/MeshBatchUvs.js");
var MeshGeometry = __webpack_require__(/*! ./MeshGeometry.js */ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/MeshGeometry.js");
var MeshMaterial = __webpack_require__(/*! ./MeshMaterial.js */ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/MeshMaterial.js");



exports.Mesh = Mesh.Mesh;
exports.MeshBatchUvs = MeshBatchUvs.MeshBatchUvs;
exports.MeshGeometry = MeshGeometry.MeshGeometry;
exports.MeshMaterial = MeshMaterial.MeshMaterial;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/shader/mesh.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/mesh/lib/shader/mesh.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var fragment = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";

exports["default"] = fragment;
//# sourceMappingURL=mesh.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/shader/mesh2.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/mesh/lib/shader/mesh2.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";

exports["default"] = vertex;
//# sourceMappingURL=mesh2.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/mixin-cache-as-bitmap/lib/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/mixin-cache-as-bitmap/lib/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var display = __webpack_require__(/*! @pixi/display */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/index.js");
var sprite = __webpack_require__(/*! @pixi/sprite */ "./node_modules/pixi.js/node_modules/@pixi/sprite/lib/index.js");

const _tempMatrix = new core.Matrix();
display.DisplayObject.prototype._cacheAsBitmap = false;
display.DisplayObject.prototype._cacheData = null;
display.DisplayObject.prototype._cacheAsBitmapResolution = null;
display.DisplayObject.prototype._cacheAsBitmapMultisample = null;
class CacheData {
  constructor() {
    this.textureCacheId = null;
    this.originalRender = null;
    this.originalRenderCanvas = null;
    this.originalCalculateBounds = null;
    this.originalGetLocalBounds = null;
    this.originalUpdateTransform = null;
    this.originalDestroy = null;
    this.originalMask = null;
    this.originalFilterArea = null;
    this.originalContainsPoint = null;
    this.sprite = null;
  }
}
Object.defineProperties(display.DisplayObject.prototype, {
  cacheAsBitmapResolution: {
    get() {
      return this._cacheAsBitmapResolution;
    },
    set(resolution) {
      if (resolution === this._cacheAsBitmapResolution) {
        return;
      }
      this._cacheAsBitmapResolution = resolution;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  cacheAsBitmapMultisample: {
    get() {
      return this._cacheAsBitmapMultisample;
    },
    set(multisample) {
      if (multisample === this._cacheAsBitmapMultisample) {
        return;
      }
      this._cacheAsBitmapMultisample = multisample;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  cacheAsBitmap: {
    get() {
      return this._cacheAsBitmap;
    },
    set(value) {
      if (this._cacheAsBitmap === value) {
        return;
      }
      this._cacheAsBitmap = value;
      let data;
      if (value) {
        if (!this._cacheData) {
          this._cacheData = new CacheData();
        }
        data = this._cacheData;
        data.originalRender = this.render;
        data.originalRenderCanvas = this.renderCanvas;
        data.originalUpdateTransform = this.updateTransform;
        data.originalCalculateBounds = this.calculateBounds;
        data.originalGetLocalBounds = this.getLocalBounds;
        data.originalDestroy = this.destroy;
        data.originalContainsPoint = this.containsPoint;
        data.originalMask = this._mask;
        data.originalFilterArea = this.filterArea;
        this.render = this._renderCached;
        this.renderCanvas = this._renderCachedCanvas;
        this.destroy = this._cacheAsBitmapDestroy;
      } else {
        data = this._cacheData;
        if (data.sprite) {
          this._destroyCachedDisplayObject();
        }
        this.render = data.originalRender;
        this.renderCanvas = data.originalRenderCanvas;
        this.calculateBounds = data.originalCalculateBounds;
        this.getLocalBounds = data.originalGetLocalBounds;
        this.destroy = data.originalDestroy;
        this.updateTransform = data.originalUpdateTransform;
        this.containsPoint = data.originalContainsPoint;
        this._mask = data.originalMask;
        this.filterArea = data.originalFilterArea;
      }
    }
  }
});
display.DisplayObject.prototype._renderCached = function _renderCached(renderer) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObject(renderer);
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._render(renderer);
};
display.DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {
  if (this._cacheData?.sprite) {
    return;
  }
  const cacheAlpha = this.alpha;
  this.alpha = 1;
  renderer.batch.flush();
  const bounds = this.getLocalBounds(null, true).clone();
  if (this.filters?.length) {
    const padding = this.filters[0].padding;
    bounds.pad(padding);
  }
  bounds.ceil(core.settings.RESOLUTION);
  const cachedRenderTexture = renderer.renderTexture.current;
  const cachedSourceFrame = renderer.renderTexture.sourceFrame.clone();
  const cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone();
  const cachedProjectionTransform = renderer.projection.transform;
  const renderTexture = core.RenderTexture.create({
    width: bounds.width,
    height: bounds.height,
    resolution: this.cacheAsBitmapResolution || renderer.resolution,
    multisample: this.cacheAsBitmapMultisample ?? renderer.multisample
  });
  const textureCacheId = `cacheAsBitmap_${core.utils.uid()}`;
  this._cacheData.textureCacheId = textureCacheId;
  core.BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  core.Texture.addToCache(renderTexture, textureCacheId);
  const m = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
  this.render = this._cacheData.originalRender;
  renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });
  renderer.framebuffer.blit();
  renderer.projection.transform = cachedProjectionTransform;
  renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);
  this.render = this._renderCached;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  const cachedSprite = new sprite.Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.enableTempParent();
    this.updateTransform();
    this.disableTempParent(null);
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
display.DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObjectCanvas(renderer);
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._renderCanvas(renderer);
};
display.DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {
  if (this._cacheData?.sprite) {
    return;
  }
  const bounds = this.getLocalBounds(null, true);
  const cacheAlpha = this.alpha;
  this.alpha = 1;
  const cachedRenderTarget = renderer.canvasContext.activeContext;
  const cachedProjectionTransform = renderer._projTransform;
  bounds.ceil(core.settings.RESOLUTION);
  const renderTexture = core.RenderTexture.create({ width: bounds.width, height: bounds.height });
  const textureCacheId = `cacheAsBitmap_${core.utils.uid()}`;
  this._cacheData.textureCacheId = textureCacheId;
  core.BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  core.Texture.addToCache(renderTexture, textureCacheId);
  const m = _tempMatrix;
  this.transform.localTransform.copyTo(m);
  m.invert();
  m.tx -= bounds.x;
  m.ty -= bounds.y;
  this.renderCanvas = this._cacheData.originalRenderCanvas;
  renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });
  renderer.canvasContext.activeContext = cachedRenderTarget;
  renderer._projTransform = cachedProjectionTransform;
  this.renderCanvas = this._renderCachedCanvas;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  const cachedSprite = new sprite.Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.parent = renderer._tempDisplayObjectParent;
    this.updateTransform();
    this.parent = null;
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
display.DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {
  this._bounds.clear();
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite._calculateBounds();
  this._bounds.updateID = this._boundsID;
};
display.DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {
  return this._cacheData.sprite.getLocalBounds(null);
};
display.DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {
  this._cacheData.sprite._texture.destroy(true);
  this._cacheData.sprite = null;
  core.BaseTexture.removeFromCache(this._cacheData.textureCacheId);
  core.Texture.removeFromCache(this._cacheData.textureCacheId);
  this._cacheData.textureCacheId = null;
};
display.DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {
  this.cacheAsBitmap = false;
  this.destroy(options);
};

exports.CacheData = CacheData;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/mixin-get-child-by-name/lib/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/mixin-get-child-by-name/lib/index.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var display = __webpack_require__(/*! @pixi/display */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/index.js");

display.DisplayObject.prototype.name = null;
display.Container.prototype.getChildByName = function getChildByName(name, deep) {
  for (let i = 0, j = this.children.length; i < j; i++) {
    if (this.children[i].name === name) {
      return this.children[i];
    }
  }
  if (deep) {
    for (let i = 0, j = this.children.length; i < j; i++) {
      const child = this.children[i];
      if (!child.getChildByName) {
        continue;
      }
      const target = child.getChildByName(name, true);
      if (target) {
        return target;
      }
    }
  }
  return null;
};
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/mixin-get-global-position/lib/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/mixin-get-global-position/lib/index.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var display = __webpack_require__(/*! @pixi/display */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/index.js");

display.DisplayObject.prototype.getGlobalPosition = function getGlobalPosition(point = new core.Point(), skipUpdate = false) {
  if (this.parent) {
    this.parent.toGlobal(this.position, point, skipUpdate);
  } else {
    point.x = this.position.x;
    point.y = this.position.y;
  }
  return point;
};
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/particle-container/lib/ParticleBuffer.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/particle-container/lib/ParticleBuffer.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

class ParticleBuffer {
  constructor(properties, dynamicPropertyFlags, size) {
    this.geometry = new core.Geometry();
    this.indexBuffer = null;
    this.size = size;
    this.dynamicProperties = [];
    this.staticProperties = [];
    for (let i = 0; i < properties.length; ++i) {
      let property = properties[i];
      property = {
        attributeName: property.attributeName,
        size: property.size,
        uploadFunction: property.uploadFunction,
        type: property.type || core.TYPES.FLOAT,
        offset: property.offset
      };
      if (dynamicPropertyFlags[i]) {
        this.dynamicProperties.push(property);
      } else {
        this.staticProperties.push(property);
      }
    }
    this.staticStride = 0;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.dynamicStride = 0;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this._updateID = 0;
    this.initBuffers();
  }
  initBuffers() {
    const geometry = this.geometry;
    let dynamicOffset = 0;
    this.indexBuffer = new core.Buffer(core.utils.createIndicesForQuads(this.size), true, true);
    geometry.addIndex(this.indexBuffer);
    this.dynamicStride = 0;
    for (let i = 0; i < this.dynamicProperties.length; ++i) {
      const property = this.dynamicProperties[i];
      property.offset = dynamicOffset;
      dynamicOffset += property.size;
      this.dynamicStride += property.size;
    }
    const dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
    this.dynamicData = new Float32Array(dynBuffer);
    this.dynamicDataUint32 = new Uint32Array(dynBuffer);
    this.dynamicBuffer = new core.Buffer(this.dynamicData, false, false);
    let staticOffset = 0;
    this.staticStride = 0;
    for (let i = 0; i < this.staticProperties.length; ++i) {
      const property = this.staticProperties[i];
      property.offset = staticOffset;
      staticOffset += property.size;
      this.staticStride += property.size;
    }
    const statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
    this.staticData = new Float32Array(statBuffer);
    this.staticDataUint32 = new Uint32Array(statBuffer);
    this.staticBuffer = new core.Buffer(this.staticData, true, false);
    for (let i = 0; i < this.dynamicProperties.length; ++i) {
      const property = this.dynamicProperties[i];
      geometry.addAttribute(property.attributeName, this.dynamicBuffer, 0, property.type === core.TYPES.UNSIGNED_BYTE, property.type, this.dynamicStride * 4, property.offset * 4);
    }
    for (let i = 0; i < this.staticProperties.length; ++i) {
      const property = this.staticProperties[i];
      geometry.addAttribute(property.attributeName, this.staticBuffer, 0, property.type === core.TYPES.UNSIGNED_BYTE, property.type, this.staticStride * 4, property.offset * 4);
    }
  }
  uploadDynamic(children, startIndex, amount) {
    for (let i = 0; i < this.dynamicProperties.length; i++) {
      const property = this.dynamicProperties[i];
      property.uploadFunction(children, startIndex, amount, property.type === core.TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
    }
    this.dynamicBuffer._updateID++;
  }
  uploadStatic(children, startIndex, amount) {
    for (let i = 0; i < this.staticProperties.length; i++) {
      const property = this.staticProperties[i];
      property.uploadFunction(children, startIndex, amount, property.type === core.TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
    }
    this.staticBuffer._updateID++;
  }
  destroy() {
    this.indexBuffer = null;
    this.dynamicProperties = null;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this.staticProperties = null;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.geometry.destroy();
  }
}

exports.ParticleBuffer = ParticleBuffer;
//# sourceMappingURL=ParticleBuffer.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/particle-container/lib/ParticleContainer.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/particle-container/lib/ParticleContainer.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var display = __webpack_require__(/*! @pixi/display */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/index.js");

class ParticleContainer extends display.Container {
  constructor(maxSize = 1500, properties, batchSize = 16384, autoResize = false) {
    super();
    const maxBatchSize = 16384;
    if (batchSize > maxBatchSize) {
      batchSize = maxBatchSize;
    }
    this._properties = [false, true, false, false, false];
    this._maxSize = maxSize;
    this._batchSize = batchSize;
    this._buffers = null;
    this._bufferUpdateIDs = [];
    this._updateID = 0;
    this.interactiveChildren = false;
    this.blendMode = core.BLEND_MODES.NORMAL;
    this.autoResize = autoResize;
    this.roundPixels = true;
    this.baseTexture = null;
    this.setProperties(properties);
    this._tintColor = new core.Color(0);
    this.tintRgb = new Float32Array(3);
    this.tint = 16777215;
  }
  setProperties(properties) {
    if (properties) {
      this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];
      this._properties[1] = "position" in properties ? !!properties.position : this._properties[1];
      this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2];
      this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3];
      this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];
    }
  }
  updateTransform() {
    this.displayObjectUpdateTransform();
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value);
    this._tintColor.toRgbArray(this.tintRgb);
  }
  render(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
      return;
    }
    if (!this.baseTexture) {
      this.baseTexture = this.children[0]._texture.baseTexture;
      if (!this.baseTexture.valid) {
        this.baseTexture.once("update", () => this.onChildrenChange(0));
      }
    }
    renderer.batch.setObjectRenderer(renderer.plugins.particle);
    renderer.plugins.particle.render(this);
  }
  onChildrenChange(smallestChildIndex) {
    const bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
    while (this._bufferUpdateIDs.length < bufferIndex) {
      this._bufferUpdateIDs.push(0);
    }
    this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
  }
  dispose() {
    if (this._buffers) {
      for (let i = 0; i < this._buffers.length; ++i) {
        this._buffers[i].destroy();
      }
      this._buffers = null;
    }
  }
  destroy(options) {
    super.destroy(options);
    this.dispose();
    this._properties = null;
    this._buffers = null;
    this._bufferUpdateIDs = null;
  }
}

exports.ParticleContainer = ParticleContainer;
//# sourceMappingURL=ParticleContainer.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/particle-container/lib/ParticleRenderer.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/particle-container/lib/ParticleRenderer.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var ParticleBuffer = __webpack_require__(/*! ./ParticleBuffer.js */ "./node_modules/pixi.js/node_modules/@pixi/particle-container/lib/ParticleBuffer.js");
var particles$1 = __webpack_require__(/*! ./particles.js */ "./node_modules/pixi.js/node_modules/@pixi/particle-container/lib/particles.js");
var particles = __webpack_require__(/*! ./particles2.js */ "./node_modules/pixi.js/node_modules/@pixi/particle-container/lib/particles2.js");

class ParticleRenderer extends core.ObjectRenderer {
  constructor(renderer) {
    super(renderer);
    this.shader = null;
    this.properties = null;
    this.tempMatrix = new core.Matrix();
    this.properties = [
      {
        attributeName: "aVertexPosition",
        size: 2,
        uploadFunction: this.uploadVertices,
        offset: 0
      },
      {
        attributeName: "aPositionCoord",
        size: 2,
        uploadFunction: this.uploadPosition,
        offset: 0
      },
      {
        attributeName: "aRotation",
        size: 1,
        uploadFunction: this.uploadRotation,
        offset: 0
      },
      {
        attributeName: "aTextureCoord",
        size: 2,
        uploadFunction: this.uploadUvs,
        offset: 0
      },
      {
        attributeName: "aColor",
        size: 1,
        type: core.TYPES.UNSIGNED_BYTE,
        uploadFunction: this.uploadTint,
        offset: 0
      }
    ];
    this.shader = core.Shader.from(particles["default"], particles$1["default"], {});
    this.state = core.State.for2d();
  }
  render(container) {
    const children = container.children;
    const maxSize = container._maxSize;
    const batchSize = container._batchSize;
    const renderer = this.renderer;
    let totalChildren = children.length;
    if (totalChildren === 0) {
      return;
    } else if (totalChildren > maxSize && !container.autoResize) {
      totalChildren = maxSize;
    }
    let buffers = container._buffers;
    if (!buffers) {
      buffers = container._buffers = this.generateBuffers(container);
    }
    const baseTexture = children[0]._texture.baseTexture;
    const premultiplied = baseTexture.alphaMode > 0;
    this.state.blendMode = core.utils.correctBlendMode(container.blendMode, premultiplied);
    renderer.state.set(this.state);
    const gl = renderer.gl;
    const m = container.worldTransform.copyTo(this.tempMatrix);
    m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
    this.shader.uniforms.translationMatrix = m.toArray(true);
    this.shader.uniforms.uColor = core.Color.shared.setValue(container.tintRgb).premultiply(container.worldAlpha, premultiplied).toArray(this.shader.uniforms.uColor);
    this.shader.uniforms.uSampler = baseTexture;
    this.renderer.shader.bind(this.shader);
    let updateStatic = false;
    for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {
      let amount = totalChildren - i;
      if (amount > batchSize) {
        amount = batchSize;
      }
      if (j >= buffers.length) {
        buffers.push(this._generateOneMoreBuffer(container));
      }
      const buffer = buffers[j];
      buffer.uploadDynamic(children, i, amount);
      const bid = container._bufferUpdateIDs[j] || 0;
      updateStatic = updateStatic || buffer._updateID < bid;
      if (updateStatic) {
        buffer._updateID = container._updateID;
        buffer.uploadStatic(children, i, amount);
      }
      renderer.geometry.bind(buffer.geometry);
      gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
    }
  }
  generateBuffers(container) {
    const buffers = [];
    const size = container._maxSize;
    const batchSize = container._batchSize;
    const dynamicPropertyFlags = container._properties;
    for (let i = 0; i < size; i += batchSize) {
      buffers.push(new ParticleBuffer.ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
    }
    return buffers;
  }
  _generateOneMoreBuffer(container) {
    const batchSize = container._batchSize;
    const dynamicPropertyFlags = container._properties;
    return new ParticleBuffer.ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
  }
  uploadVertices(children, startIndex, amount, array, stride, offset) {
    let w0 = 0;
    let w1 = 0;
    let h0 = 0;
    let h1 = 0;
    for (let i = 0; i < amount; ++i) {
      const sprite = children[startIndex + i];
      const texture = sprite._texture;
      const sx = sprite.scale.x;
      const sy = sprite.scale.y;
      const trim = texture.trim;
      const orig = texture.orig;
      if (trim) {
        w1 = trim.x - sprite.anchor.x * orig.width;
        w0 = w1 + trim.width;
        h1 = trim.y - sprite.anchor.y * orig.height;
        h0 = h1 + trim.height;
      } else {
        w0 = orig.width * (1 - sprite.anchor.x);
        w1 = orig.width * -sprite.anchor.x;
        h0 = orig.height * (1 - sprite.anchor.y);
        h1 = orig.height * -sprite.anchor.y;
      }
      array[offset] = w1 * sx;
      array[offset + 1] = h1 * sy;
      array[offset + stride] = w0 * sx;
      array[offset + stride + 1] = h1 * sy;
      array[offset + stride * 2] = w0 * sx;
      array[offset + stride * 2 + 1] = h0 * sy;
      array[offset + stride * 3] = w1 * sx;
      array[offset + stride * 3 + 1] = h0 * sy;
      offset += stride * 4;
    }
  }
  uploadPosition(children, startIndex, amount, array, stride, offset) {
    for (let i = 0; i < amount; i++) {
      const spritePosition = children[startIndex + i].position;
      array[offset] = spritePosition.x;
      array[offset + 1] = spritePosition.y;
      array[offset + stride] = spritePosition.x;
      array[offset + stride + 1] = spritePosition.y;
      array[offset + stride * 2] = spritePosition.x;
      array[offset + stride * 2 + 1] = spritePosition.y;
      array[offset + stride * 3] = spritePosition.x;
      array[offset + stride * 3 + 1] = spritePosition.y;
      offset += stride * 4;
    }
  }
  uploadRotation(children, startIndex, amount, array, stride, offset) {
    for (let i = 0; i < amount; i++) {
      const spriteRotation = children[startIndex + i].rotation;
      array[offset] = spriteRotation;
      array[offset + stride] = spriteRotation;
      array[offset + stride * 2] = spriteRotation;
      array[offset + stride * 3] = spriteRotation;
      offset += stride * 4;
    }
  }
  uploadUvs(children, startIndex, amount, array, stride, offset) {
    for (let i = 0; i < amount; ++i) {
      const textureUvs = children[startIndex + i]._texture._uvs;
      if (textureUvs) {
        array[offset] = textureUvs.x0;
        array[offset + 1] = textureUvs.y0;
        array[offset + stride] = textureUvs.x1;
        array[offset + stride + 1] = textureUvs.y1;
        array[offset + stride * 2] = textureUvs.x2;
        array[offset + stride * 2 + 1] = textureUvs.y2;
        array[offset + stride * 3] = textureUvs.x3;
        array[offset + stride * 3 + 1] = textureUvs.y3;
        offset += stride * 4;
      } else {
        array[offset] = 0;
        array[offset + 1] = 0;
        array[offset + stride] = 0;
        array[offset + stride + 1] = 0;
        array[offset + stride * 2] = 0;
        array[offset + stride * 2 + 1] = 0;
        array[offset + stride * 3] = 0;
        array[offset + stride * 3 + 1] = 0;
        offset += stride * 4;
      }
    }
  }
  uploadTint(children, startIndex, amount, array, stride, offset) {
    for (let i = 0; i < amount; ++i) {
      const sprite = children[startIndex + i];
      const result = core.Color.shared.setValue(sprite._tintRGB).toPremultiplied(sprite.alpha, sprite.texture.baseTexture.alphaMode > 0);
      array[offset] = result;
      array[offset + stride] = result;
      array[offset + stride * 2] = result;
      array[offset + stride * 3] = result;
      offset += stride * 4;
    }
  }
  destroy() {
    super.destroy();
    if (this.shader) {
      this.shader.destroy();
      this.shader = null;
    }
    this.tempMatrix = null;
  }
}
ParticleRenderer.extension = {
  name: "particle",
  type: core.ExtensionType.RendererPlugin
};
core.extensions.add(ParticleRenderer);

exports.ParticleRenderer = ParticleRenderer;
//# sourceMappingURL=ParticleRenderer.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/particle-container/lib/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/particle-container/lib/index.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var ParticleContainer = __webpack_require__(/*! ./ParticleContainer.js */ "./node_modules/pixi.js/node_modules/@pixi/particle-container/lib/ParticleContainer.js");
var ParticleRenderer = __webpack_require__(/*! ./ParticleRenderer.js */ "./node_modules/pixi.js/node_modules/@pixi/particle-container/lib/ParticleRenderer.js");



exports.ParticleContainer = ParticleContainer.ParticleContainer;
exports.ParticleRenderer = ParticleRenderer.ParticleRenderer;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/particle-container/lib/particles.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/particle-container/lib/particles.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var fragment = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}";

exports["default"] = fragment;
//# sourceMappingURL=particles.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/particle-container/lib/particles2.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/particle-container/lib/particles2.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n";

exports["default"] = vertex;
//# sourceMappingURL=particles2.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/prepare/lib/BasePrepare.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/prepare/lib/BasePrepare.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var display = __webpack_require__(/*! @pixi/display */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/index.js");
var text = __webpack_require__(/*! @pixi/text */ "./node_modules/pixi.js/node_modules/@pixi/text/lib/index.js");
var CountLimiter = __webpack_require__(/*! ./CountLimiter.js */ "./node_modules/pixi.js/node_modules/@pixi/prepare/lib/CountLimiter.js");

function findMultipleBaseTextures(item, queue) {
  let result = false;
  if (item?._textures?.length) {
    for (let i = 0; i < item._textures.length; i++) {
      if (item._textures[i] instanceof core.Texture) {
        const baseTexture = item._textures[i].baseTexture;
        if (!queue.includes(baseTexture)) {
          queue.push(baseTexture);
          result = true;
        }
      }
    }
  }
  return result;
}
function findBaseTexture(item, queue) {
  if (item.baseTexture instanceof core.BaseTexture) {
    const texture = item.baseTexture;
    if (!queue.includes(texture)) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function findTexture(item, queue) {
  if (item._texture && item._texture instanceof core.Texture) {
    const texture = item._texture.baseTexture;
    if (!queue.includes(texture)) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function drawText(_helper, item) {
  if (item instanceof text.Text) {
    item.updateText(true);
    return true;
  }
  return false;
}
function calculateTextStyle(_helper, item) {
  if (item instanceof text.TextStyle) {
    const font = item.toFontString();
    text.TextMetrics.measureFont(font);
    return true;
  }
  return false;
}
function findText(item, queue) {
  if (item instanceof text.Text) {
    if (!queue.includes(item.style)) {
      queue.push(item.style);
    }
    if (!queue.includes(item)) {
      queue.push(item);
    }
    const texture = item._texture.baseTexture;
    if (!queue.includes(texture)) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function findTextStyle(item, queue) {
  if (item instanceof text.TextStyle) {
    if (!queue.includes(item)) {
      queue.push(item);
    }
    return true;
  }
  return false;
}
const _BasePrepare = class {
  constructor(renderer) {
    this.limiter = new CountLimiter.CountLimiter(_BasePrepare.uploadsPerFrame);
    this.renderer = renderer;
    this.uploadHookHelper = null;
    this.queue = [];
    this.addHooks = [];
    this.uploadHooks = [];
    this.completes = [];
    this.ticking = false;
    this.delayedTick = () => {
      if (!this.queue) {
        return;
      }
      this.prepareItems();
    };
    this.registerFindHook(findText);
    this.registerFindHook(findTextStyle);
    this.registerFindHook(findMultipleBaseTextures);
    this.registerFindHook(findBaseTexture);
    this.registerFindHook(findTexture);
    this.registerUploadHook(drawText);
    this.registerUploadHook(calculateTextStyle);
  }
  upload(item) {
    return new Promise((resolve) => {
      if (item) {
        this.add(item);
      }
      if (this.queue.length) {
        this.completes.push(resolve);
        if (!this.ticking) {
          this.ticking = true;
          core.Ticker.system.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);
        }
      } else {
        resolve();
      }
    });
  }
  tick() {
    setTimeout(this.delayedTick, 0);
  }
  prepareItems() {
    this.limiter.beginFrame();
    while (this.queue.length && this.limiter.allowedToUpload()) {
      const item = this.queue[0];
      let uploaded = false;
      if (item && !item._destroyed) {
        for (let i = 0, len = this.uploadHooks.length; i < len; i++) {
          if (this.uploadHooks[i](this.uploadHookHelper, item)) {
            this.queue.shift();
            uploaded = true;
            break;
          }
        }
      }
      if (!uploaded) {
        this.queue.shift();
      }
    }
    if (!this.queue.length) {
      this.ticking = false;
      const completes = this.completes.slice(0);
      this.completes.length = 0;
      for (let i = 0, len = completes.length; i < len; i++) {
        completes[i]();
      }
    } else {
      core.Ticker.system.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);
    }
  }
  registerFindHook(addHook) {
    if (addHook) {
      this.addHooks.push(addHook);
    }
    return this;
  }
  registerUploadHook(uploadHook) {
    if (uploadHook) {
      this.uploadHooks.push(uploadHook);
    }
    return this;
  }
  add(item) {
    for (let i = 0, len = this.addHooks.length; i < len; i++) {
      if (this.addHooks[i](item, this.queue)) {
        break;
      }
    }
    if (item instanceof display.Container) {
      for (let i = item.children.length - 1; i >= 0; i--) {
        this.add(item.children[i]);
      }
    }
    return this;
  }
  destroy() {
    if (this.ticking) {
      core.Ticker.system.remove(this.tick, this);
    }
    this.ticking = false;
    this.addHooks = null;
    this.uploadHooks = null;
    this.renderer = null;
    this.completes = null;
    this.queue = null;
    this.limiter = null;
    this.uploadHookHelper = null;
  }
};
let BasePrepare = _BasePrepare;
BasePrepare.uploadsPerFrame = 4;

exports.BasePrepare = BasePrepare;
//# sourceMappingURL=BasePrepare.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/prepare/lib/CountLimiter.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/prepare/lib/CountLimiter.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class CountLimiter {
  constructor(maxItemsPerFrame) {
    this.maxItemsPerFrame = maxItemsPerFrame;
    this.itemsLeft = 0;
  }
  beginFrame() {
    this.itemsLeft = this.maxItemsPerFrame;
  }
  allowedToUpload() {
    return this.itemsLeft-- > 0;
  }
}

exports.CountLimiter = CountLimiter;
//# sourceMappingURL=CountLimiter.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/prepare/lib/Prepare.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/prepare/lib/Prepare.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var graphics = __webpack_require__(/*! @pixi/graphics */ "./node_modules/pixi.js/node_modules/@pixi/graphics/lib/index.js");
var BasePrepare = __webpack_require__(/*! ./BasePrepare.js */ "./node_modules/pixi.js/node_modules/@pixi/prepare/lib/BasePrepare.js");

function uploadBaseTextures(renderer, item) {
  if (item instanceof core.BaseTexture) {
    if (!item._glTextures[renderer.CONTEXT_UID]) {
      renderer.texture.bind(item);
    }
    return true;
  }
  return false;
}
function uploadGraphics(renderer, item) {
  if (!(item instanceof graphics.Graphics)) {
    return false;
  }
  const { geometry } = item;
  item.finishPoly();
  geometry.updateBatches();
  const { batches } = geometry;
  for (let i = 0; i < batches.length; i++) {
    const { texture } = batches[i].style;
    if (texture) {
      uploadBaseTextures(renderer, texture.baseTexture);
    }
  }
  if (!geometry.batchable) {
    renderer.geometry.bind(geometry, item._resolveDirectShader(renderer));
  }
  return true;
}
function findGraphics(item, queue) {
  if (item instanceof graphics.Graphics) {
    queue.push(item);
    return true;
  }
  return false;
}
class Prepare extends BasePrepare.BasePrepare {
  constructor(renderer) {
    super(renderer);
    this.uploadHookHelper = this.renderer;
    this.registerFindHook(findGraphics);
    this.registerUploadHook(uploadBaseTextures);
    this.registerUploadHook(uploadGraphics);
  }
}
Prepare.extension = {
  name: "prepare",
  type: core.ExtensionType.RendererSystem
};
core.extensions.add(Prepare);

exports.Prepare = Prepare;
//# sourceMappingURL=Prepare.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/prepare/lib/TimeLimiter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/prepare/lib/TimeLimiter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class TimeLimiter {
  constructor(maxMilliseconds) {
    this.maxMilliseconds = maxMilliseconds;
    this.frameStart = 0;
  }
  beginFrame() {
    this.frameStart = Date.now();
  }
  allowedToUpload() {
    return Date.now() - this.frameStart < this.maxMilliseconds;
  }
}

exports.TimeLimiter = TimeLimiter;
//# sourceMappingURL=TimeLimiter.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/prepare/lib/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/prepare/lib/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(/*! ./settings.js */ "./node_modules/pixi.js/node_modules/@pixi/prepare/lib/settings.js");
var BasePrepare = __webpack_require__(/*! ./BasePrepare.js */ "./node_modules/pixi.js/node_modules/@pixi/prepare/lib/BasePrepare.js");
var CountLimiter = __webpack_require__(/*! ./CountLimiter.js */ "./node_modules/pixi.js/node_modules/@pixi/prepare/lib/CountLimiter.js");
var Prepare = __webpack_require__(/*! ./Prepare.js */ "./node_modules/pixi.js/node_modules/@pixi/prepare/lib/Prepare.js");
var TimeLimiter = __webpack_require__(/*! ./TimeLimiter.js */ "./node_modules/pixi.js/node_modules/@pixi/prepare/lib/TimeLimiter.js");



exports.BasePrepare = BasePrepare.BasePrepare;
exports.CountLimiter = CountLimiter.CountLimiter;
exports.Prepare = Prepare.Prepare;
exports.TimeLimiter = TimeLimiter.TimeLimiter;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/prepare/lib/settings.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/prepare/lib/settings.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var BasePrepare = __webpack_require__(/*! ./BasePrepare.js */ "./node_modules/pixi.js/node_modules/@pixi/prepare/lib/BasePrepare.js");

Object.defineProperties(core.settings, {
  UPLOADS_PER_FRAME: {
    get() {
      return BasePrepare.BasePrepare.uploadsPerFrame;
    },
    set(value) {
      core.utils.deprecation("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame");
      BasePrepare.BasePrepare.uploadsPerFrame = value;
    }
  }
});

Object.defineProperty(exports, "settings", ({
    enumerable: true,
    get: function () { return core.settings; }
}));
//# sourceMappingURL=settings.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/runner/lib/Runner.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/runner/lib/Runner.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class Runner {
  constructor(name) {
    this.items = [];
    this._name = name;
    this._aliasCount = 0;
  }
  emit(a0, a1, a2, a3, a4, a5, a6, a7) {
    if (arguments.length > 8) {
      throw new Error("max arguments reached");
    }
    const { name, items } = this;
    this._aliasCount++;
    for (let i = 0, len = items.length; i < len; i++) {
      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
    }
    if (items === this.items) {
      this._aliasCount--;
    }
    return this;
  }
  ensureNonAliasedItems() {
    if (this._aliasCount > 0 && this.items.length > 1) {
      this._aliasCount = 0;
      this.items = this.items.slice(0);
    }
  }
  add(item) {
    if (item[this._name]) {
      this.ensureNonAliasedItems();
      this.remove(item);
      this.items.push(item);
    }
    return this;
  }
  remove(item) {
    const index = this.items.indexOf(item);
    if (index !== -1) {
      this.ensureNonAliasedItems();
      this.items.splice(index, 1);
    }
    return this;
  }
  contains(item) {
    return this.items.includes(item);
  }
  removeAll() {
    this.ensureNonAliasedItems();
    this.items.length = 0;
    return this;
  }
  destroy() {
    this.removeAll();
    this.items = null;
    this._name = null;
  }
  get empty() {
    return this.items.length === 0;
  }
  get name() {
    return this._name;
  }
}
Object.defineProperties(Runner.prototype, {
  dispatch: { value: Runner.prototype.emit },
  run: { value: Runner.prototype.emit }
});

exports.Runner = Runner;
//# sourceMappingURL=Runner.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/runner/lib/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/runner/lib/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Runner = __webpack_require__(/*! ./Runner.js */ "./node_modules/pixi.js/node_modules/@pixi/runner/lib/Runner.js");



exports.Runner = Runner.Runner;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/ICanvas.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/settings/lib/ICanvas.js ***!
  \*************************************************************************/
/***/ (() => {

"use strict";


//# sourceMappingURL=ICanvas.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/ICanvasRenderingContext2D.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/settings/lib/ICanvasRenderingContext2D.js ***!
  \*******************************************************************************************/
/***/ (() => {

"use strict";


//# sourceMappingURL=ICanvasRenderingContext2D.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/adapter.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/settings/lib/adapter.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const BrowserAdapter = {
  createCanvas: (width, height) => {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  },
  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
  getWebGLRenderingContext: () => WebGLRenderingContext,
  getNavigator: () => navigator,
  getBaseUrl: () => document.baseURI ?? window.location.href,
  getFontFaceSet: () => document.fonts,
  fetch: (url, options) => fetch(url, options),
  parseXML: (xml) => {
    const parser = new DOMParser();
    return parser.parseFromString(xml, "text/xml");
  }
};

exports.BrowserAdapter = BrowserAdapter;
//# sourceMappingURL=adapter.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var adapter = __webpack_require__(/*! ./adapter.js */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/adapter.js");
__webpack_require__(/*! ./ICanvas.js */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/ICanvas.js");
__webpack_require__(/*! ./ICanvasRenderingContext2D.js */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/ICanvasRenderingContext2D.js");
var settings = __webpack_require__(/*! ./settings.js */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/settings.js");
var isMobile = __webpack_require__(/*! ./utils/isMobile.js */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/utils/isMobile.js");



exports.BrowserAdapter = adapter.BrowserAdapter;
exports.settings = settings.settings;
exports.isMobile = isMobile.isMobile;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/settings.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/settings/lib/settings.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var adapter = __webpack_require__(/*! ./adapter.js */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/adapter.js");

const settings = {
  ADAPTER: adapter.BrowserAdapter,
  RESOLUTION: 1,
  CREATE_IMAGE_BITMAP: false,
  ROUND_PIXELS: false
};

exports.settings = settings;
//# sourceMappingURL=settings.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/utils/isMobile.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/settings/lib/utils/isMobile.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var isMobileJs = __webpack_require__(/*! ismobilejs */ "./node_modules/ismobilejs/esm/index.js");

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var isMobileJs__default = /*#__PURE__*/_interopDefaultLegacy(isMobileJs);

const isMobileCall = isMobileJs__default["default"].default ?? isMobileJs__default["default"];
const isMobile = isMobileCall(globalThis.navigator);

exports.isMobile = isMobile;
//# sourceMappingURL=isMobile.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/sprite-animated/lib/AnimatedSprite.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/sprite-animated/lib/AnimatedSprite.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var sprite = __webpack_require__(/*! @pixi/sprite */ "./node_modules/pixi.js/node_modules/@pixi/sprite/lib/index.js");

class AnimatedSprite extends sprite.Sprite {
  constructor(textures, autoUpdate = true) {
    super(textures[0] instanceof core.Texture ? textures[0] : textures[0].texture);
    this._textures = null;
    this._durations = null;
    this._autoUpdate = autoUpdate;
    this._isConnectedToTicker = false;
    this.animationSpeed = 1;
    this.loop = true;
    this.updateAnchor = false;
    this.onComplete = null;
    this.onFrameChange = null;
    this.onLoop = null;
    this._currentTime = 0;
    this._playing = false;
    this._previousFrame = null;
    this.textures = textures;
  }
  stop() {
    if (!this._playing) {
      return;
    }
    this._playing = false;
    if (this._autoUpdate && this._isConnectedToTicker) {
      core.Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  }
  play() {
    if (this._playing) {
      return;
    }
    this._playing = true;
    if (this._autoUpdate && !this._isConnectedToTicker) {
      core.Ticker.shared.add(this.update, this, core.UPDATE_PRIORITY.HIGH);
      this._isConnectedToTicker = true;
    }
  }
  gotoAndStop(frameNumber) {
    this.stop();
    this.currentFrame = frameNumber;
  }
  gotoAndPlay(frameNumber) {
    this.currentFrame = frameNumber;
    this.play();
  }
  update(deltaTime) {
    if (!this._playing) {
      return;
    }
    const elapsed = this.animationSpeed * deltaTime;
    const previousFrame = this.currentFrame;
    if (this._durations !== null) {
      let lag = this._currentTime % 1 * this._durations[this.currentFrame];
      lag += elapsed / 60 * 1e3;
      while (lag < 0) {
        this._currentTime--;
        lag += this._durations[this.currentFrame];
      }
      const sign = Math.sign(this.animationSpeed * deltaTime);
      this._currentTime = Math.floor(this._currentTime);
      while (lag >= this._durations[this.currentFrame]) {
        lag -= this._durations[this.currentFrame] * sign;
        this._currentTime += sign;
      }
      this._currentTime += lag / this._durations[this.currentFrame];
    } else {
      this._currentTime += elapsed;
    }
    if (this._currentTime < 0 && !this.loop) {
      this.gotoAndStop(0);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (this._currentTime >= this._textures.length && !this.loop) {
      this.gotoAndStop(this._textures.length - 1);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (previousFrame !== this.currentFrame) {
      if (this.loop && this.onLoop) {
        if (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) {
          this.onLoop();
        }
      }
      this.updateTexture();
    }
  }
  updateTexture() {
    const currentFrame = this.currentFrame;
    if (this._previousFrame === currentFrame) {
      return;
    }
    this._previousFrame = currentFrame;
    this._texture = this._textures[currentFrame];
    this._textureID = -1;
    this._textureTrimmedID = -1;
    this._cachedTint = 16777215;
    this.uvs = this._texture._uvs.uvsFloat32;
    if (this.updateAnchor) {
      this._anchor.copyFrom(this._texture.defaultAnchor);
    }
    if (this.onFrameChange) {
      this.onFrameChange(this.currentFrame);
    }
  }
  destroy(options) {
    this.stop();
    super.destroy(options);
    this.onComplete = null;
    this.onFrameChange = null;
    this.onLoop = null;
  }
  static fromFrames(frames) {
    const textures = [];
    for (let i = 0; i < frames.length; ++i) {
      textures.push(core.Texture.from(frames[i]));
    }
    return new AnimatedSprite(textures);
  }
  static fromImages(images) {
    const textures = [];
    for (let i = 0; i < images.length; ++i) {
      textures.push(core.Texture.from(images[i]));
    }
    return new AnimatedSprite(textures);
  }
  get totalFrames() {
    return this._textures.length;
  }
  get textures() {
    return this._textures;
  }
  set textures(value) {
    if (value[0] instanceof core.Texture) {
      this._textures = value;
      this._durations = null;
    } else {
      this._textures = [];
      this._durations = [];
      for (let i = 0; i < value.length; i++) {
        this._textures.push(value[i].texture);
        this._durations.push(value[i].time);
      }
    }
    this._previousFrame = null;
    this.gotoAndStop(0);
    this.updateTexture();
  }
  get currentFrame() {
    let currentFrame = Math.floor(this._currentTime) % this._textures.length;
    if (currentFrame < 0) {
      currentFrame += this._textures.length;
    }
    return currentFrame;
  }
  set currentFrame(value) {
    if (value < 0 || value > this.totalFrames - 1) {
      throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
    }
    const previousFrame = this.currentFrame;
    this._currentTime = value;
    if (previousFrame !== this.currentFrame) {
      this.updateTexture();
    }
  }
  get playing() {
    return this._playing;
  }
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      if (!this._autoUpdate && this._isConnectedToTicker) {
        core.Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
        core.Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    }
  }
}

exports.AnimatedSprite = AnimatedSprite;
//# sourceMappingURL=AnimatedSprite.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/sprite-animated/lib/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/sprite-animated/lib/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var AnimatedSprite = __webpack_require__(/*! ./AnimatedSprite.js */ "./node_modules/pixi.js/node_modules/@pixi/sprite-animated/lib/AnimatedSprite.js");



exports.AnimatedSprite = AnimatedSprite.AnimatedSprite;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/TilingSprite.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/TilingSprite.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var sprite = __webpack_require__(/*! @pixi/sprite */ "./node_modules/pixi.js/node_modules/@pixi/sprite/lib/index.js");

const tempPoint = new core.Point();
class TilingSprite extends sprite.Sprite {
  constructor(texture, width = 100, height = 100) {
    super(texture);
    this.tileTransform = new core.Transform();
    this._width = width;
    this._height = height;
    this.uvMatrix = this.texture.uvMatrix || new core.TextureMatrix(texture);
    this.pluginName = "tilingSprite";
    this.uvRespectAnchor = false;
  }
  get clampMargin() {
    return this.uvMatrix.clampMargin;
  }
  set clampMargin(value) {
    this.uvMatrix.clampMargin = value;
    this.uvMatrix.update(true);
  }
  get tileScale() {
    return this.tileTransform.scale;
  }
  set tileScale(value) {
    this.tileTransform.scale.copyFrom(value);
  }
  get tilePosition() {
    return this.tileTransform.position;
  }
  set tilePosition(value) {
    this.tileTransform.position.copyFrom(value);
  }
  _onTextureUpdate() {
    if (this.uvMatrix) {
      this.uvMatrix.texture = this._texture;
    }
    this._cachedTint = 16777215;
  }
  _render(renderer) {
    const texture = this._texture;
    if (!texture || !texture.valid) {
      return;
    }
    this.tileTransform.updateLocalTransform();
    this.uvMatrix.update();
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    renderer.plugins[this.pluginName].render(this);
  }
  _calculateBounds() {
    const minX = this._width * -this._anchor._x;
    const minY = this._height * -this._anchor._y;
    const maxX = this._width * (1 - this._anchor._x);
    const maxY = this._height * (1 - this._anchor._y);
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  }
  getLocalBounds(rect) {
    if (this.children.length === 0) {
      this._bounds.minX = this._width * -this._anchor._x;
      this._bounds.minY = this._height * -this._anchor._y;
      this._bounds.maxX = this._width * (1 - this._anchor._x);
      this._bounds.maxY = this._height * (1 - this._anchor._y);
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new core.Rectangle();
        }
        rect = this._localBoundsRect;
      }
      return this._bounds.getRectangle(rect);
    }
    return super.getLocalBounds.call(this, rect);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, tempPoint);
    const width = this._width;
    const height = this._height;
    const x1 = -width * this.anchor._x;
    if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
      const y1 = -height * this.anchor._y;
      if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {
        return true;
      }
    }
    return false;
  }
  destroy(options) {
    super.destroy(options);
    this.tileTransform = null;
    this.uvMatrix = null;
  }
  static from(source, options) {
    const texture = source instanceof core.Texture ? source : core.Texture.from(source, options);
    return new TilingSprite(texture, options.width, options.height);
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
  }
}

exports.TilingSprite = TilingSprite;
//# sourceMappingURL=TilingSprite.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/TilingSpriteRenderer.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/TilingSpriteRenderer.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var spriteTiling$1 = __webpack_require__(/*! ./sprite-tiling.js */ "./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/sprite-tiling.js");
var spriteTiling = __webpack_require__(/*! ./sprite-tiling2.js */ "./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/sprite-tiling2.js");
var spriteTilingFallback$1 = __webpack_require__(/*! ./sprite-tiling-fallback.js */ "./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.js");
var spriteTilingFallback = __webpack_require__(/*! ./sprite-tiling-fallback2.js */ "./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback2.js");
var spriteTilingSimple = __webpack_require__(/*! ./sprite-tiling-simple.js */ "./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/sprite-tiling-simple.js");

const tempMat = new core.Matrix();
class TilingSpriteRenderer extends core.ObjectRenderer {
  constructor(renderer) {
    super(renderer);
    renderer.runners.contextChange.add(this);
    this.quad = new core.QuadUv();
    this.state = core.State.for2d();
  }
  contextChange() {
    const renderer = this.renderer;
    const uniforms = { globals: renderer.globalUniforms };
    this.simpleShader = core.Shader.from(spriteTilingFallback["default"], spriteTilingSimple["default"], uniforms);
    this.shader = renderer.context.webGLVersion > 1 ? core.Shader.from(spriteTiling["default"], spriteTiling$1["default"], uniforms) : core.Shader.from(spriteTilingFallback["default"], spriteTilingFallback$1["default"], uniforms);
  }
  render(ts) {
    const renderer = this.renderer;
    const quad = this.quad;
    let vertices = quad.vertices;
    vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
    vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
    vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);
    vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
    const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;
    const anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
    vertices = quad.uvs;
    vertices[0] = vertices[6] = -anchorX;
    vertices[1] = vertices[3] = -anchorY;
    vertices[2] = vertices[4] = 1 - anchorX;
    vertices[5] = vertices[7] = 1 - anchorY;
    quad.invalidate();
    const tex = ts._texture;
    const baseTex = tex.baseTexture;
    const premultiplied = baseTex.alphaMode > 0;
    const lt = ts.tileTransform.localTransform;
    const uv = ts.uvMatrix;
    let isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
    if (isSimple) {
      if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
        if (baseTex.wrapMode === core.WRAP_MODES.CLAMP) {
          baseTex.wrapMode = core.WRAP_MODES.REPEAT;
        }
      } else {
        isSimple = baseTex.wrapMode !== core.WRAP_MODES.CLAMP;
      }
    }
    const shader = isSimple ? this.simpleShader : this.shader;
    const w = tex.width;
    const h = tex.height;
    const W = ts._width;
    const H = ts._height;
    tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);
    tempMat.invert();
    if (isSimple) {
      tempMat.prepend(uv.mapCoord);
    } else {
      shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
      shader.uniforms.uClampFrame = uv.uClampFrame;
      shader.uniforms.uClampOffset = uv.uClampOffset;
    }
    shader.uniforms.uTransform = tempMat.toArray(true);
    shader.uniforms.uColor = core.Color.shared.setValue(ts.tint).premultiply(ts.worldAlpha, premultiplied).toArray(shader.uniforms.uColor);
    shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
    shader.uniforms.uSampler = tex;
    renderer.shader.bind(shader);
    renderer.geometry.bind(quad);
    this.state.blendMode = core.utils.correctBlendMode(ts.blendMode, premultiplied);
    renderer.state.set(this.state);
    renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
  }
}
TilingSpriteRenderer.extension = {
  name: "tilingSprite",
  type: core.ExtensionType.RendererPlugin
};
core.extensions.add(TilingSpriteRenderer);

exports.TilingSpriteRenderer = TilingSpriteRenderer;
//# sourceMappingURL=TilingSpriteRenderer.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var TilingSprite = __webpack_require__(/*! ./TilingSprite.js */ "./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/TilingSprite.js");
var TilingSpriteRenderer = __webpack_require__(/*! ./TilingSpriteRenderer.js */ "./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/TilingSpriteRenderer.js");



exports.TilingSprite = TilingSprite.TilingSprite;
exports.TilingSpriteRenderer = TilingSpriteRenderer.TilingSpriteRenderer;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var gl1FragmentSrc = "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n";

exports["default"] = gl1FragmentSrc;
//# sourceMappingURL=sprite-tiling-fallback.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback2.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback2.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var gl1VertexSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";

exports["default"] = gl1VertexSrc;
//# sourceMappingURL=sprite-tiling-fallback2.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/sprite-tiling-simple.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/sprite-tiling-simple.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var fragmentSimpleSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n";

exports["default"] = fragmentSimpleSrc;
//# sourceMappingURL=sprite-tiling-simple.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/sprite-tiling.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/sprite-tiling.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var gl2FragmentSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n";

exports["default"] = gl2FragmentSrc;
//# sourceMappingURL=sprite-tiling.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/sprite-tiling2.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/sprite-tiling/lib/sprite-tiling2.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var gl2VertexSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";

exports["default"] = gl2VertexSrc;
//# sourceMappingURL=sprite-tiling2.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/sprite/lib/Sprite.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/sprite/lib/Sprite.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var display = __webpack_require__(/*! @pixi/display */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/index.js");

const tempPoint = new core.Point();
const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
class Sprite extends display.Container {
  constructor(texture) {
    super();
    this._anchor = new core.ObservablePoint(this._onAnchorUpdate, this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);
    this._texture = null;
    this._width = 0;
    this._height = 0;
    this._tintColor = new core.Color(16777215);
    this._tintRGB = null;
    this.tint = 16777215;
    this.blendMode = core.BLEND_MODES.NORMAL;
    this._cachedTint = 16777215;
    this.uvs = null;
    this.texture = texture || core.Texture.EMPTY;
    this.vertexData = new Float32Array(8);
    this.vertexTrimmedData = null;
    this._transformID = -1;
    this._textureID = -1;
    this._transformTrimmedID = -1;
    this._textureTrimmedID = -1;
    this.indices = indices;
    this.pluginName = "batch";
    this.isSprite = true;
    this._roundPixels = core.settings.ROUND_PIXELS;
  }
  _onTextureUpdate() {
    this._textureID = -1;
    this._textureTrimmedID = -1;
    this._cachedTint = 16777215;
    if (this._width) {
      this.scale.x = core.utils.sign(this.scale.x) * this._width / this._texture.orig.width;
    }
    if (this._height) {
      this.scale.y = core.utils.sign(this.scale.y) * this._height / this._texture.orig.height;
    }
  }
  _onAnchorUpdate() {
    this._transformID = -1;
    this._transformTrimmedID = -1;
  }
  calculateVertices() {
    const texture = this._texture;
    if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
      return;
    }
    if (this._textureID !== texture._updateID) {
      this.uvs = this._texture._uvs.uvsFloat32;
    }
    this._transformID = this.transform._worldID;
    this._textureID = texture._updateID;
    const wt = this.transform.worldTransform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const vertexData = this.vertexData;
    const trim = texture.trim;
    const orig = texture.orig;
    const anchor = this._anchor;
    let w0 = 0;
    let w1 = 0;
    let h0 = 0;
    let h1 = 0;
    if (trim) {
      w1 = trim.x - anchor._x * orig.width;
      w0 = w1 + trim.width;
      h1 = trim.y - anchor._y * orig.height;
      h0 = h1 + trim.height;
    } else {
      w1 = -anchor._x * orig.width;
      w0 = w1 + orig.width;
      h1 = -anchor._y * orig.height;
      h0 = h1 + orig.height;
    }
    vertexData[0] = a * w1 + c * h1 + tx;
    vertexData[1] = d * h1 + b * w1 + ty;
    vertexData[2] = a * w0 + c * h1 + tx;
    vertexData[3] = d * h1 + b * w0 + ty;
    vertexData[4] = a * w0 + c * h0 + tx;
    vertexData[5] = d * h0 + b * w0 + ty;
    vertexData[6] = a * w1 + c * h0 + tx;
    vertexData[7] = d * h0 + b * w1 + ty;
    if (this._roundPixels) {
      const resolution = core.settings.RESOLUTION;
      for (let i = 0; i < vertexData.length; ++i) {
        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;
      }
    }
  }
  calculateTrimmedVertices() {
    if (!this.vertexTrimmedData) {
      this.vertexTrimmedData = new Float32Array(8);
    } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
      return;
    }
    this._transformTrimmedID = this.transform._worldID;
    this._textureTrimmedID = this._texture._updateID;
    const texture = this._texture;
    const vertexData = this.vertexTrimmedData;
    const orig = texture.orig;
    const anchor = this._anchor;
    const wt = this.transform.worldTransform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const w1 = -anchor._x * orig.width;
    const w0 = w1 + orig.width;
    const h1 = -anchor._y * orig.height;
    const h0 = h1 + orig.height;
    vertexData[0] = a * w1 + c * h1 + tx;
    vertexData[1] = d * h1 + b * w1 + ty;
    vertexData[2] = a * w0 + c * h1 + tx;
    vertexData[3] = d * h1 + b * w0 + ty;
    vertexData[4] = a * w0 + c * h0 + tx;
    vertexData[5] = d * h0 + b * w0 + ty;
    vertexData[6] = a * w1 + c * h0 + tx;
    vertexData[7] = d * h0 + b * w1 + ty;
  }
  _render(renderer) {
    this.calculateVertices();
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    renderer.plugins[this.pluginName].render(this);
  }
  _calculateBounds() {
    const trim = this._texture.trim;
    const orig = this._texture.orig;
    if (!trim || trim.width === orig.width && trim.height === orig.height) {
      this.calculateVertices();
      this._bounds.addQuad(this.vertexData);
    } else {
      this.calculateTrimmedVertices();
      this._bounds.addQuad(this.vertexTrimmedData);
    }
  }
  getLocalBounds(rect) {
    if (this.children.length === 0) {
      if (!this._localBounds) {
        this._localBounds = new display.Bounds();
      }
      this._localBounds.minX = this._texture.orig.width * -this._anchor._x;
      this._localBounds.minY = this._texture.orig.height * -this._anchor._y;
      this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
      this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new core.Rectangle();
        }
        rect = this._localBoundsRect;
      }
      return this._localBounds.getRectangle(rect);
    }
    return super.getLocalBounds.call(this, rect);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, tempPoint);
    const width = this._texture.orig.width;
    const height = this._texture.orig.height;
    const x1 = -width * this.anchor.x;
    let y1 = 0;
    if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
      y1 = -height * this.anchor.y;
      if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {
        return true;
      }
    }
    return false;
  }
  destroy(options) {
    super.destroy(options);
    this._texture.off("update", this._onTextureUpdate, this);
    this._anchor = null;
    const destroyTexture = typeof options === "boolean" ? options : options?.texture;
    if (destroyTexture) {
      const destroyBaseTexture = typeof options === "boolean" ? options : options?.baseTexture;
      this._texture.destroy(!!destroyBaseTexture);
    }
    this._texture = null;
  }
  static from(source, options) {
    const texture = source instanceof core.Texture ? source : core.Texture.from(source, options);
    return new Sprite(texture);
  }
  set roundPixels(value) {
    if (this._roundPixels !== value) {
      this._transformID = -1;
    }
    this._roundPixels = value;
  }
  get roundPixels() {
    return this._roundPixels;
  }
  get width() {
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value) {
    const s = core.utils.sign(this.scale.x) || 1;
    this.scale.x = s * value / this._texture.orig.width;
    this._width = value;
  }
  get height() {
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value) {
    const s = core.utils.sign(this.scale.y) || 1;
    this.scale.y = s * value / this._texture.orig.height;
    this._height = value;
  }
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    this._anchor.copyFrom(value);
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
  }
  get tintValue() {
    return this._tintColor.toNumber();
  }
  get texture() {
    return this._texture;
  }
  set texture(value) {
    if (this._texture === value) {
      return;
    }
    if (this._texture) {
      this._texture.off("update", this._onTextureUpdate, this);
    }
    this._texture = value || core.Texture.EMPTY;
    this._cachedTint = 16777215;
    this._textureID = -1;
    this._textureTrimmedID = -1;
    if (value) {
      if (value.baseTexture.valid) {
        this._onTextureUpdate();
      } else {
        value.once("update", this._onTextureUpdate, this);
      }
    }
  }
}

exports.Sprite = Sprite;
//# sourceMappingURL=Sprite.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/sprite/lib/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/sprite/lib/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Sprite = __webpack_require__(/*! ./Sprite.js */ "./node_modules/pixi.js/node_modules/@pixi/sprite/lib/Sprite.js");



exports.Sprite = Sprite.Sprite;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/spritesheet/lib/Spritesheet.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/spritesheet/lib/Spritesheet.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

const _Spritesheet = class {
  constructor(texture, data, resolutionFilename = null) {
    this.linkedSheets = [];
    this._texture = texture instanceof core.Texture ? texture : null;
    this.baseTexture = texture instanceof core.BaseTexture ? texture : this._texture.baseTexture;
    this.textures = {};
    this.animations = {};
    this.data = data;
    const resource = this.baseTexture.resource;
    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));
    this._frames = this.data.frames;
    this._frameKeys = Object.keys(this._frames);
    this._batchIndex = 0;
    this._callback = null;
  }
  _updateResolution(resolutionFilename = null) {
    const { scale } = this.data.meta;
    let resolution = core.utils.getResolutionOfUrl(resolutionFilename, null);
    if (resolution === null) {
      resolution = parseFloat(scale ?? "1");
    }
    if (resolution !== 1) {
      this.baseTexture.setResolution(resolution);
    }
    return resolution;
  }
  parse() {
    return new Promise((resolve) => {
      this._callback = resolve;
      this._batchIndex = 0;
      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {
        this._processFrames(0);
        this._processAnimations();
        this._parseComplete();
      } else {
        this._nextBatch();
      }
    });
  }
  _processFrames(initialFrameIndex) {
    let frameIndex = initialFrameIndex;
    const maxFrames = _Spritesheet.BATCH_SIZE;
    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
      const i = this._frameKeys[frameIndex];
      const data = this._frames[i];
      const rect = data.frame;
      if (rect) {
        let frame = null;
        let trim = null;
        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
        const orig = new core.Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
        if (data.rotated) {
          frame = new core.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
        } else {
          frame = new core.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        if (data.trimmed !== false && data.spriteSourceSize) {
          trim = new core.Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        this.textures[i] = new core.Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor, data.borders);
        core.Texture.addToCache(this.textures[i], i);
      }
      frameIndex++;
    }
  }
  _processAnimations() {
    const animations = this.data.animations || {};
    for (const animName in animations) {
      this.animations[animName] = [];
      for (let i = 0; i < animations[animName].length; i++) {
        const frameName = animations[animName][i];
        this.animations[animName].push(this.textures[frameName]);
      }
    }
  }
  _parseComplete() {
    const callback = this._callback;
    this._callback = null;
    this._batchIndex = 0;
    callback.call(this, this.textures);
  }
  _nextBatch() {
    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);
    this._batchIndex++;
    setTimeout(() => {
      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {
        this._nextBatch();
      } else {
        this._processAnimations();
        this._parseComplete();
      }
    }, 0);
  }
  destroy(destroyBase = false) {
    for (const i in this.textures) {
      this.textures[i].destroy();
    }
    this._frames = null;
    this._frameKeys = null;
    this.data = null;
    this.textures = null;
    if (destroyBase) {
      this._texture?.destroy();
      this.baseTexture.destroy();
    }
    this._texture = null;
    this.baseTexture = null;
    this.linkedSheets = [];
  }
};
let Spritesheet = _Spritesheet;
Spritesheet.BATCH_SIZE = 1e3;

exports.Spritesheet = Spritesheet;
//# sourceMappingURL=Spritesheet.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/spritesheet/lib/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/spritesheet/lib/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Spritesheet = __webpack_require__(/*! ./Spritesheet.js */ "./node_modules/pixi.js/node_modules/@pixi/spritesheet/lib/Spritesheet.js");
var spritesheetAsset = __webpack_require__(/*! ./spritesheetAsset.js */ "./node_modules/pixi.js/node_modules/@pixi/spritesheet/lib/spritesheetAsset.js");



exports.Spritesheet = Spritesheet.Spritesheet;
exports.spritesheetAsset = spritesheetAsset.spritesheetAsset;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/spritesheet/lib/spritesheetAsset.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/spritesheet/lib/spritesheetAsset.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var assets = __webpack_require__(/*! @pixi/assets */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/index.js");
var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var Spritesheet = __webpack_require__(/*! ./Spritesheet.js */ "./node_modules/pixi.js/node_modules/@pixi/spritesheet/lib/Spritesheet.js");

const validImages = ["jpg", "png", "jpeg", "avif", "webp"];
function getCacheableAssets(keys, asset, ignoreMultiPack) {
  const out = {};
  keys.forEach((key) => {
    out[key] = asset;
  });
  Object.keys(asset.textures).forEach((key) => {
    out[key] = asset.textures[key];
  });
  if (!ignoreMultiPack) {
    const basePath = core.utils.path.dirname(keys[0]);
    asset.linkedSheets.forEach((item, i) => {
      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);
      Object.assign(out, out2);
    });
  }
  return out;
}
const spritesheetAsset = {
  extension: core.ExtensionType.Asset,
  cache: {
    test: (asset) => asset instanceof Spritesheet.Spritesheet,
    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
  },
  resolver: {
    test: (value) => {
      const tempURL = value.split("?")[0];
      const split = tempURL.split(".");
      const extension = split.pop();
      const format = split.pop();
      return extension === "json" && validImages.includes(format);
    },
    parse: (value) => {
      const split = value.split(".");
      return {
        resolution: parseFloat(core.settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
        format: split[split.length - 2],
        src: value
      };
    }
  },
  loader: {
    name: "spritesheetLoader",
    extension: {
      type: core.ExtensionType.LoadParser,
      priority: assets.LoaderParserPriority.Normal
    },
    async testParse(asset, options) {
      return core.utils.path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
    },
    async parse(asset, options, loader) {
      let basePath = core.utils.path.dirname(options.src);
      if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
        basePath += "/";
      }
      let imagePath = basePath + asset.meta.image;
      imagePath = assets.copySearchParams(imagePath, options.src);
      const assets$1 = await loader.load([imagePath]);
      const texture = assets$1[imagePath];
      const spritesheet = new Spritesheet.Spritesheet(texture.baseTexture, asset, options.src);
      await spritesheet.parse();
      const multiPacks = asset?.meta?.related_multi_packs;
      if (Array.isArray(multiPacks)) {
        const promises = [];
        for (const item of multiPacks) {
          if (typeof item !== "string") {
            continue;
          }
          let itemUrl = basePath + item;
          if (options.data?.ignoreMultiPack) {
            continue;
          }
          itemUrl = assets.copySearchParams(itemUrl, options.src);
          promises.push(loader.load({
            src: itemUrl,
            data: {
              ignoreMultiPack: true
            }
          }));
        }
        const res = await Promise.all(promises);
        spritesheet.linkedSheets = res;
        res.forEach((item) => {
          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
        });
      }
      return spritesheet;
    },
    unload(spritesheet) {
      spritesheet.destroy(true);
    }
  }
};
core.extensions.add(spritesheetAsset);

exports.spritesheetAsset = spritesheetAsset;
//# sourceMappingURL=spritesheetAsset.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/BitmapFont.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/BitmapFont.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var text = __webpack_require__(/*! @pixi/text */ "./node_modules/pixi.js/node_modules/@pixi/text/lib/index.js");
var BitmapFontData = __webpack_require__(/*! ./BitmapFontData.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/BitmapFontData.js");
var index = __webpack_require__(/*! ./formats/index.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/formats/index.js");
__webpack_require__(/*! ./utils/index.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/index.js");
var resolveCharacters = __webpack_require__(/*! ./utils/resolveCharacters.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/resolveCharacters.js");
var drawGlyph = __webpack_require__(/*! ./utils/drawGlyph.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/drawGlyph.js");
var extractCharCode = __webpack_require__(/*! ./utils/extractCharCode.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.js");

const _BitmapFont = class {
  constructor(data, textures, ownsTextures) {
    const [info] = data.info;
    const [common] = data.common;
    const [page] = data.page;
    const [distanceField] = data.distanceField;
    const res = core.utils.getResolutionOfUrl(page.file);
    const pageTextures = {};
    this._ownsTextures = ownsTextures;
    this.font = info.face;
    this.size = info.size;
    this.lineHeight = common.lineHeight / res;
    this.chars = {};
    this.pageTextures = pageTextures;
    for (let i = 0; i < data.page.length; i++) {
      const { id, file } = data.page[i];
      pageTextures[id] = textures instanceof Array ? textures[i] : textures[file];
      if (distanceField?.fieldType && distanceField.fieldType !== "none") {
        pageTextures[id].baseTexture.alphaMode = core.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA;
        pageTextures[id].baseTexture.mipmap = core.MIPMAP_MODES.OFF;
      }
    }
    for (let i = 0; i < data.char.length; i++) {
      const { id, page: page2 } = data.char[i];
      let { x, y, width, height, xoffset, yoffset, xadvance } = data.char[i];
      x /= res;
      y /= res;
      width /= res;
      height /= res;
      xoffset /= res;
      yoffset /= res;
      xadvance /= res;
      const rect = new core.Rectangle(x + pageTextures[page2].frame.x / res, y + pageTextures[page2].frame.y / res, width, height);
      this.chars[id] = {
        xOffset: xoffset,
        yOffset: yoffset,
        xAdvance: xadvance,
        kerning: {},
        texture: new core.Texture(pageTextures[page2].baseTexture, rect),
        page: page2
      };
    }
    for (let i = 0; i < data.kerning.length; i++) {
      let { first, second, amount } = data.kerning[i];
      first /= res;
      second /= res;
      amount /= res;
      if (this.chars[second]) {
        this.chars[second].kerning[first] = amount;
      }
    }
    this.distanceFieldRange = distanceField?.distanceRange;
    this.distanceFieldType = distanceField?.fieldType?.toLowerCase() ?? "none";
  }
  destroy() {
    for (const id in this.chars) {
      this.chars[id].texture.destroy();
      this.chars[id].texture = null;
    }
    for (const id in this.pageTextures) {
      if (this._ownsTextures) {
        this.pageTextures[id].destroy(true);
      }
      this.pageTextures[id] = null;
    }
    this.chars = null;
    this.pageTextures = null;
  }
  static install(data, textures, ownsTextures) {
    let fontData;
    if (data instanceof BitmapFontData.BitmapFontData) {
      fontData = data;
    } else {
      const format = index.autoDetectFormat(data);
      if (!format) {
        throw new Error("Unrecognized data format for font.");
      }
      fontData = format.parse(data);
    }
    if (textures instanceof core.Texture) {
      textures = [textures];
    }
    const font = new _BitmapFont(fontData, textures, ownsTextures);
    _BitmapFont.available[font.font] = font;
    return font;
  }
  static uninstall(name) {
    const font = _BitmapFont.available[name];
    if (!font) {
      throw new Error(`No font found named '${name}'`);
    }
    font.destroy();
    delete _BitmapFont.available[name];
  }
  static from(name, textStyle, options) {
    if (!name) {
      throw new Error("[BitmapFont] Property `name` is required.");
    }
    const {
      chars,
      padding,
      resolution,
      textureWidth,
      textureHeight,
      ...baseOptions
    } = Object.assign({}, _BitmapFont.defaultOptions, options);
    const charsList = resolveCharacters.resolveCharacters(chars);
    const style = textStyle instanceof text.TextStyle ? textStyle : new text.TextStyle(textStyle);
    const lineWidth = textureWidth;
    const fontData = new BitmapFontData.BitmapFontData();
    fontData.info[0] = {
      face: style.fontFamily,
      size: style.fontSize
    };
    fontData.common[0] = {
      lineHeight: style.fontSize
    };
    let positionX = 0;
    let positionY = 0;
    let canvas;
    let context;
    let baseTexture;
    let maxCharHeight = 0;
    const baseTextures = [];
    const textures = [];
    for (let i = 0; i < charsList.length; i++) {
      if (!canvas) {
        canvas = core.settings.ADAPTER.createCanvas();
        canvas.width = textureWidth;
        canvas.height = textureHeight;
        context = canvas.getContext("2d");
        baseTexture = new core.BaseTexture(canvas, { resolution, ...baseOptions });
        baseTextures.push(baseTexture);
        textures.push(new core.Texture(baseTexture));
        fontData.page.push({
          id: textures.length - 1,
          file: ""
        });
      }
      const character = charsList[i];
      const metrics = text.TextMetrics.measureText(character, style, false, canvas);
      const width = metrics.width;
      const height = Math.ceil(metrics.height);
      const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
      if (positionY >= textureHeight - height * resolution) {
        if (positionY === 0) {
          throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
        }
        --i;
        canvas = null;
        context = null;
        baseTexture = null;
        positionY = 0;
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);
      if (textureGlyphWidth * resolution + positionX >= lineWidth) {
        if (positionX === 0) {
          throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
        }
        --i;
        positionY += maxCharHeight * resolution;
        positionY = Math.ceil(positionY);
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      drawGlyph.drawGlyph(canvas, context, metrics, positionX, positionY, resolution, style);
      const id = extractCharCode.extractCharCode(metrics.text);
      fontData.char.push({
        id,
        page: textures.length - 1,
        x: positionX / resolution,
        y: positionY / resolution,
        width: textureGlyphWidth,
        height,
        xoffset: 0,
        yoffset: 0,
        xadvance: width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0)
      });
      positionX += (textureGlyphWidth + 2 * padding) * resolution;
      positionX = Math.ceil(positionX);
    }
    for (let i = 0, len = charsList.length; i < len; i++) {
      const first = charsList[i];
      for (let j = 0; j < len; j++) {
        const second = charsList[j];
        const c1 = context.measureText(first).width;
        const c2 = context.measureText(second).width;
        const total = context.measureText(first + second).width;
        const amount = total - (c1 + c2);
        if (amount) {
          fontData.kerning.push({
            first: extractCharCode.extractCharCode(first),
            second: extractCharCode.extractCharCode(second),
            amount
          });
        }
      }
    }
    const font = new _BitmapFont(fontData, textures, true);
    if (_BitmapFont.available[name] !== void 0) {
      _BitmapFont.uninstall(name);
    }
    _BitmapFont.available[name] = font;
    return font;
  }
};
let BitmapFont = _BitmapFont;
BitmapFont.ALPHA = [["a", "z"], ["A", "Z"], " "];
BitmapFont.NUMERIC = [["0", "9"]];
BitmapFont.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
BitmapFont.ASCII = [[" ", "~"]];
BitmapFont.defaultOptions = {
  resolution: 1,
  textureWidth: 512,
  textureHeight: 512,
  padding: 4,
  chars: _BitmapFont.ALPHANUMERIC
};
BitmapFont.available = {};

exports.BitmapFont = BitmapFont;
//# sourceMappingURL=BitmapFont.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/BitmapFontData.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/BitmapFontData.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class BitmapFontData {
  constructor() {
    this.info = [];
    this.common = [];
    this.page = [];
    this.char = [];
    this.kerning = [];
    this.distanceField = [];
  }
}

exports.BitmapFontData = BitmapFontData;
//# sourceMappingURL=BitmapFontData.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/BitmapText.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/BitmapText.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var display = __webpack_require__(/*! @pixi/display */ "./node_modules/pixi.js/node_modules/@pixi/display/lib/index.js");
var mesh = __webpack_require__(/*! @pixi/mesh */ "./node_modules/pixi.js/node_modules/@pixi/mesh/lib/index.js");
var BitmapFont = __webpack_require__(/*! ./BitmapFont.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/BitmapFont.js");
var msdf$1 = __webpack_require__(/*! ./shader/msdf.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/shader/msdf.js");
var msdf = __webpack_require__(/*! ./shader/msdf2.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/shader/msdf2.js");
__webpack_require__(/*! ./utils/index.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/index.js");
var splitTextToCharacters = __webpack_require__(/*! ./utils/splitTextToCharacters.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.js");
var extractCharCode = __webpack_require__(/*! ./utils/extractCharCode.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.js");

const pageMeshDataDefaultPageMeshData = [];
const pageMeshDataMSDFPageMeshData = [];
const charRenderDataPool = [];
const _BitmapText = class extends display.Container {
  constructor(text, style = {}) {
    super();
    const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign({}, _BitmapText.styleDefaults, style);
    if (!BitmapFont.BitmapFont.available[fontName]) {
      throw new Error(`Missing BitmapFont "${fontName}"`);
    }
    this._activePagesMeshData = [];
    this._textWidth = 0;
    this._textHeight = 0;
    this._align = align;
    this._tintColor = new core.Color(tint);
    this._font = void 0;
    this._fontName = fontName;
    this._fontSize = fontSize;
    this.text = text;
    this._maxWidth = maxWidth;
    this._maxLineHeight = 0;
    this._letterSpacing = letterSpacing;
    this._anchor = new core.ObservablePoint(() => {
      this.dirty = true;
    }, this, 0, 0);
    this._roundPixels = core.settings.ROUND_PIXELS;
    this.dirty = true;
    this._resolution = core.settings.RESOLUTION;
    this._autoResolution = true;
    this._textureCache = {};
  }
  updateText() {
    const data = BitmapFont.BitmapFont.available[this._fontName];
    const fontSize = this.fontSize;
    const scale = fontSize / data.size;
    const pos = new core.Point();
    const chars = [];
    const lineWidths = [];
    const lineSpaces = [];
    const text = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ";
    const charsInput = splitTextToCharacters.splitTextToCharacters(text);
    const maxWidth = this._maxWidth * data.size / fontSize;
    const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    let prevCharCode = null;
    let lastLineWidth = 0;
    let maxLineWidth = 0;
    let line = 0;
    let lastBreakPos = -1;
    let lastBreakWidth = 0;
    let spacesRemoved = 0;
    let maxLineHeight = 0;
    let spaceCount = 0;
    for (let i = 0; i < charsInput.length; i++) {
      const char = charsInput[i];
      const charCode = extractCharCode.extractCharCode(char);
      if (/(?:\s)/.test(char)) {
        lastBreakPos = i;
        lastBreakWidth = lastLineWidth;
        spaceCount++;
      }
      if (char === "\r" || char === "\n") {
        lineWidths.push(lastLineWidth);
        lineSpaces.push(-1);
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        ++line;
        ++spacesRemoved;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
        continue;
      }
      const charData = data.chars[charCode];
      if (!charData) {
        continue;
      }
      if (prevCharCode && charData.kerning[prevCharCode]) {
        pos.x += charData.kerning[prevCharCode];
      }
      const charRenderData = charRenderDataPool.pop() || {
        texture: core.Texture.EMPTY,
        line: 0,
        charCode: 0,
        prevSpaces: 0,
        position: new core.Point()
      };
      charRenderData.texture = charData.texture;
      charRenderData.line = line;
      charRenderData.charCode = charCode;
      charRenderData.position.x = Math.round(pos.x + charData.xOffset + this._letterSpacing / 2);
      charRenderData.position.y = Math.round(pos.y + charData.yOffset);
      charRenderData.prevSpaces = spaceCount;
      chars.push(charRenderData);
      lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);
      pos.x += charData.xAdvance + this._letterSpacing;
      maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
      prevCharCode = charCode;
      if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
        ++spacesRemoved;
        core.utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);
        i = lastBreakPos;
        lastBreakPos = -1;
        lineWidths.push(lastBreakWidth);
        lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);
        maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
        line++;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
      }
    }
    const lastChar = charsInput[charsInput.length - 1];
    if (lastChar !== "\r" && lastChar !== "\n") {
      if (/(?:\s)/.test(lastChar)) {
        lastLineWidth = lastBreakWidth;
      }
      lineWidths.push(lastLineWidth);
      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
      lineSpaces.push(-1);
    }
    const lineAlignOffsets = [];
    for (let i = 0; i <= line; i++) {
      let alignOffset = 0;
      if (this._align === "right") {
        alignOffset = maxLineWidth - lineWidths[i];
      } else if (this._align === "center") {
        alignOffset = (maxLineWidth - lineWidths[i]) / 2;
      } else if (this._align === "justify") {
        alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];
      }
      lineAlignOffsets.push(alignOffset);
    }
    const lenChars = chars.length;
    const pagesMeshData = {};
    const newPagesMeshData = [];
    const activePagesMeshData = this._activePagesMeshData;
    pageMeshDataPool.push(...activePagesMeshData);
    for (let i = 0; i < lenChars; i++) {
      const texture = chars[i].texture;
      const baseTextureUid = texture.baseTexture.uid;
      if (!pagesMeshData[baseTextureUid]) {
        let pageMeshData = pageMeshDataPool.pop();
        if (!pageMeshData) {
          const geometry = new mesh.MeshGeometry();
          let material;
          let meshBlendMode;
          if (data.distanceFieldType === "none") {
            material = new mesh.MeshMaterial(core.Texture.EMPTY);
            meshBlendMode = core.BLEND_MODES.NORMAL;
          } else {
            material = new mesh.MeshMaterial(core.Texture.EMPTY, { program: core.Program.from(msdf["default"], msdf$1["default"]), uniforms: { uFWidth: 0 } });
            meshBlendMode = core.BLEND_MODES.NORMAL_NPM;
          }
          const mesh$1 = new mesh.Mesh(geometry, material);
          mesh$1.blendMode = meshBlendMode;
          pageMeshData = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh: mesh$1,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        pageMeshData.index = 0;
        pageMeshData.indexCount = 0;
        pageMeshData.vertexCount = 0;
        pageMeshData.uvsCount = 0;
        pageMeshData.total = 0;
        const { _textureCache } = this;
        _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new core.Texture(texture.baseTexture);
        pageMeshData.mesh.texture = _textureCache[baseTextureUid];
        pageMeshData.mesh.tint = this._tintColor.value;
        newPagesMeshData.push(pageMeshData);
        pagesMeshData[baseTextureUid] = pageMeshData;
      }
      pagesMeshData[baseTextureUid].total++;
    }
    for (let i = 0; i < activePagesMeshData.length; i++) {
      if (!newPagesMeshData.includes(activePagesMeshData[i])) {
        this.removeChild(activePagesMeshData[i].mesh);
      }
    }
    for (let i = 0; i < newPagesMeshData.length; i++) {
      if (newPagesMeshData[i].mesh.parent !== this) {
        this.addChild(newPagesMeshData[i].mesh);
      }
    }
    this._activePagesMeshData = newPagesMeshData;
    for (const i in pagesMeshData) {
      const pageMeshData = pagesMeshData[i];
      const total = pageMeshData.total;
      if (!(pageMeshData.indices?.length > 6 * total) || pageMeshData.vertices.length < mesh.Mesh.BATCHABLE_SIZE * 2) {
        pageMeshData.vertices = new Float32Array(4 * 2 * total);
        pageMeshData.uvs = new Float32Array(4 * 2 * total);
        pageMeshData.indices = new Uint16Array(6 * total);
      } else {
        const total2 = pageMeshData.total;
        const vertices = pageMeshData.vertices;
        for (let i2 = total2 * 4 * 2; i2 < vertices.length; i2++) {
          vertices[i2] = 0;
        }
      }
      pageMeshData.mesh.size = 6 * total;
    }
    for (let i = 0; i < lenChars; i++) {
      const char = chars[i];
      let offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);
      if (this._roundPixels) {
        offset = Math.round(offset);
      }
      const xPos = offset * scale;
      const yPos = char.position.y * scale;
      const texture = char.texture;
      const pageMesh = pagesMeshData[texture.baseTexture.uid];
      const textureFrame = texture.frame;
      const textureUvs = texture._uvs;
      const index = pageMesh.index++;
      pageMesh.indices[index * 6 + 0] = 0 + index * 4;
      pageMesh.indices[index * 6 + 1] = 1 + index * 4;
      pageMesh.indices[index * 6 + 2] = 2 + index * 4;
      pageMesh.indices[index * 6 + 3] = 0 + index * 4;
      pageMesh.indices[index * 6 + 4] = 2 + index * 4;
      pageMesh.indices[index * 6 + 5] = 3 + index * 4;
      pageMesh.vertices[index * 8 + 0] = xPos;
      pageMesh.vertices[index * 8 + 1] = yPos;
      pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index * 8 + 3] = yPos;
      pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale;
      pageMesh.vertices[index * 8 + 6] = xPos;
      pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale;
      pageMesh.uvs[index * 8 + 0] = textureUvs.x0;
      pageMesh.uvs[index * 8 + 1] = textureUvs.y0;
      pageMesh.uvs[index * 8 + 2] = textureUvs.x1;
      pageMesh.uvs[index * 8 + 3] = textureUvs.y1;
      pageMesh.uvs[index * 8 + 4] = textureUvs.x2;
      pageMesh.uvs[index * 8 + 5] = textureUvs.y2;
      pageMesh.uvs[index * 8 + 6] = textureUvs.x3;
      pageMesh.uvs[index * 8 + 7] = textureUvs.y3;
    }
    this._textWidth = maxLineWidth * scale;
    this._textHeight = (pos.y + data.lineHeight) * scale;
    for (const i in pagesMeshData) {
      const pageMeshData = pagesMeshData[i];
      if (this.anchor.x !== 0 || this.anchor.y !== 0) {
        let vertexCount = 0;
        const anchorOffsetX = this._textWidth * this.anchor.x;
        const anchorOffsetY = this._textHeight * this.anchor.y;
        for (let i2 = 0; i2 < pageMeshData.total; i2++) {
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
        }
      }
      this._maxLineHeight = maxLineHeight * scale;
      const vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");
      const textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");
      const indexBuffer = pageMeshData.mesh.geometry.getIndex();
      vertexBuffer.data = pageMeshData.vertices;
      textureBuffer.data = pageMeshData.uvs;
      indexBuffer.data = pageMeshData.indices;
      vertexBuffer.update();
      textureBuffer.update();
      indexBuffer.update();
    }
    for (let i = 0; i < chars.length; i++) {
      charRenderDataPool.push(chars[i]);
    }
    this._font = data;
    this.dirty = false;
  }
  updateTransform() {
    this.validate();
    this.containerUpdateTransform();
  }
  _render(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    const { distanceFieldRange, distanceFieldType, size } = BitmapFont.BitmapFont.available[this._fontName];
    if (distanceFieldType !== "none") {
      const { a, b, c, d } = this.worldTransform;
      const dx = Math.sqrt(a * a + b * b);
      const dy = Math.sqrt(c * c + d * d);
      const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
      const fontScale = this.fontSize / size;
      const resolution = renderer._view.resolution;
      for (const mesh of this._activePagesMeshData) {
        mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;
      }
    }
    super._render(renderer);
  }
  getLocalBounds() {
    this.validate();
    return super.getLocalBounds();
  }
  validate() {
    const font = BitmapFont.BitmapFont.available[this._fontName];
    if (!font) {
      throw new Error(`Missing BitmapFont "${this._fontName}"`);
    }
    if (this._font !== font) {
      this.dirty = true;
    }
    if (this.dirty) {
      this.updateText();
    }
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    if (this.tint === value)
      return;
    this._tintColor.setValue(value);
    for (let i = 0; i < this._activePagesMeshData.length; i++) {
      this._activePagesMeshData[i].mesh.tint = value;
    }
  }
  get align() {
    return this._align;
  }
  set align(value) {
    if (this._align !== value) {
      this._align = value;
      this.dirty = true;
    }
  }
  get fontName() {
    return this._fontName;
  }
  set fontName(value) {
    if (!BitmapFont.BitmapFont.available[value]) {
      throw new Error(`Missing BitmapFont "${value}"`);
    }
    if (this._fontName !== value) {
      this._fontName = value;
      this.dirty = true;
    }
  }
  get fontSize() {
    return this._fontSize ?? BitmapFont.BitmapFont.available[this._fontName].size;
  }
  set fontSize(value) {
    if (this._fontSize !== value) {
      this._fontSize = value;
      this.dirty = true;
    }
  }
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    if (typeof value === "number") {
      this._anchor.set(value);
    } else {
      this._anchor.copyFrom(value);
    }
  }
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text === null || text === void 0 ? "" : text);
    if (this._text === text) {
      return;
    }
    this._text = text;
    this.dirty = true;
  }
  get maxWidth() {
    return this._maxWidth;
  }
  set maxWidth(value) {
    if (this._maxWidth === value) {
      return;
    }
    this._maxWidth = value;
    this.dirty = true;
  }
  get maxLineHeight() {
    this.validate();
    return this._maxLineHeight;
  }
  get textWidth() {
    this.validate();
    return this._textWidth;
  }
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(value) {
    if (this._letterSpacing !== value) {
      this._letterSpacing = value;
      this.dirty = true;
    }
  }
  get roundPixels() {
    return this._roundPixels;
  }
  set roundPixels(value) {
    if (value !== this._roundPixels) {
      this._roundPixels = value;
      this.dirty = true;
    }
  }
  get textHeight() {
    this.validate();
    return this._textHeight;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false;
    if (this._resolution === value) {
      return;
    }
    this._resolution = value;
    this.dirty = true;
  }
  destroy(options) {
    const { _textureCache } = this;
    const data = BitmapFont.BitmapFont.available[this._fontName];
    const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    pageMeshDataPool.push(...this._activePagesMeshData);
    for (const pageMeshData of this._activePagesMeshData) {
      this.removeChild(pageMeshData.mesh);
    }
    this._activePagesMeshData = [];
    pageMeshDataPool.filter((page) => _textureCache[page.mesh.texture.baseTexture.uid]).forEach((page) => {
      page.mesh.texture = core.Texture.EMPTY;
    });
    for (const id in _textureCache) {
      const texture = _textureCache[id];
      texture.destroy();
      delete _textureCache[id];
    }
    this._font = null;
    this._tintColor = null;
    this._textureCache = null;
    super.destroy(options);
  }
};
let BitmapText = _BitmapText;
BitmapText.styleDefaults = {
  align: "left",
  tint: 16777215,
  maxWidth: 0,
  letterSpacing: 0
};

exports.BitmapText = BitmapText;
//# sourceMappingURL=BitmapText.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/BitmapTextStyle.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/BitmapTextStyle.js ***!
  \************************************************************************************/
/***/ (() => {

"use strict";


//# sourceMappingURL=BitmapTextStyle.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/formats/TextFormat.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/formats/TextFormat.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var BitmapFontData = __webpack_require__(/*! ../BitmapFontData.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/BitmapFontData.js");

class TextFormat {
  static test(data) {
    return typeof data === "string" && data.startsWith("info face=");
  }
  static parse(txt) {
    const items = txt.match(/^[a-z]+\s+.+$/gm);
    const rawData = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (const i in items) {
      const name = items[i].match(/^[a-z]+/gm)[0];
      const attributeList = items[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
      const itemData = {};
      for (const i2 in attributeList) {
        const split = attributeList[i2].split("=");
        const key = split[0];
        const strValue = split[1].replace(/"/gm, "");
        const floatValue = parseFloat(strValue);
        const value = isNaN(floatValue) ? strValue : floatValue;
        itemData[key] = value;
      }
      rawData[name].push(itemData);
    }
    const font = new BitmapFontData.BitmapFontData();
    rawData.info.forEach((info) => font.info.push({
      face: info.face,
      size: parseInt(info.size, 10)
    }));
    rawData.common.forEach((common) => font.common.push({
      lineHeight: parseInt(common.lineHeight, 10)
    }));
    rawData.page.forEach((page) => font.page.push({
      id: parseInt(page.id, 10),
      file: page.file
    }));
    rawData.char.forEach((char) => font.char.push({
      id: parseInt(char.id, 10),
      page: parseInt(char.page, 10),
      x: parseInt(char.x, 10),
      y: parseInt(char.y, 10),
      width: parseInt(char.width, 10),
      height: parseInt(char.height, 10),
      xoffset: parseInt(char.xoffset, 10),
      yoffset: parseInt(char.yoffset, 10),
      xadvance: parseInt(char.xadvance, 10)
    }));
    rawData.kerning.forEach((kerning) => font.kerning.push({
      first: parseInt(kerning.first, 10),
      second: parseInt(kerning.second, 10),
      amount: parseInt(kerning.amount, 10)
    }));
    rawData.distanceField.forEach((df) => font.distanceField.push({
      distanceRange: parseInt(df.distanceRange, 10),
      fieldType: df.fieldType
    }));
    return font;
  }
}

exports.TextFormat = TextFormat;
//# sourceMappingURL=TextFormat.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var BitmapFontData = __webpack_require__(/*! ../BitmapFontData.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/BitmapFontData.js");

class XMLFormat {
  static test(data) {
    const xml = data;
    return "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
  }
  static parse(xml) {
    const data = new BitmapFontData.BitmapFontData();
    const info = xml.getElementsByTagName("info");
    const common = xml.getElementsByTagName("common");
    const page = xml.getElementsByTagName("page");
    const char = xml.getElementsByTagName("char");
    const kerning = xml.getElementsByTagName("kerning");
    const distanceField = xml.getElementsByTagName("distanceField");
    for (let i = 0; i < info.length; i++) {
      data.info.push({
        face: info[i].getAttribute("face"),
        size: parseInt(info[i].getAttribute("size"), 10)
      });
    }
    for (let i = 0; i < common.length; i++) {
      data.common.push({
        lineHeight: parseInt(common[i].getAttribute("lineHeight"), 10)
      });
    }
    for (let i = 0; i < page.length; i++) {
      data.page.push({
        id: parseInt(page[i].getAttribute("id"), 10) || 0,
        file: page[i].getAttribute("file")
      });
    }
    for (let i = 0; i < char.length; i++) {
      const letter = char[i];
      data.char.push({
        id: parseInt(letter.getAttribute("id"), 10),
        page: parseInt(letter.getAttribute("page"), 10) || 0,
        x: parseInt(letter.getAttribute("x"), 10),
        y: parseInt(letter.getAttribute("y"), 10),
        width: parseInt(letter.getAttribute("width"), 10),
        height: parseInt(letter.getAttribute("height"), 10),
        xoffset: parseInt(letter.getAttribute("xoffset"), 10),
        yoffset: parseInt(letter.getAttribute("yoffset"), 10),
        xadvance: parseInt(letter.getAttribute("xadvance"), 10)
      });
    }
    for (let i = 0; i < kerning.length; i++) {
      data.kerning.push({
        first: parseInt(kerning[i].getAttribute("first"), 10),
        second: parseInt(kerning[i].getAttribute("second"), 10),
        amount: parseInt(kerning[i].getAttribute("amount"), 10)
      });
    }
    for (let i = 0; i < distanceField.length; i++) {
      data.distanceField.push({
        fieldType: distanceField[i].getAttribute("fieldType"),
        distanceRange: parseInt(distanceField[i].getAttribute("distanceRange"), 10)
      });
    }
    return data;
  }
}

exports.XMLFormat = XMLFormat;
//# sourceMappingURL=XMLFormat.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var XMLFormat = __webpack_require__(/*! ./XMLFormat.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.js");

class XMLStringFormat {
  static test(data) {
    if (typeof data === "string" && data.includes("<font>")) {
      return XMLFormat.XMLFormat.test(core.settings.ADAPTER.parseXML(data));
    }
    return false;
  }
  static parse(xmlTxt) {
    return XMLFormat.XMLFormat.parse(core.settings.ADAPTER.parseXML(xmlTxt));
  }
}

exports.XMLStringFormat = XMLStringFormat;
//# sourceMappingURL=XMLStringFormat.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/formats/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/formats/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var TextFormat = __webpack_require__(/*! ./TextFormat.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/formats/TextFormat.js");
var XMLFormat = __webpack_require__(/*! ./XMLFormat.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.js");
var XMLStringFormat = __webpack_require__(/*! ./XMLStringFormat.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.js");

const formats = [
  TextFormat.TextFormat,
  XMLFormat.XMLFormat,
  XMLStringFormat.XMLStringFormat
];
function autoDetectFormat(data) {
  for (let i = 0; i < formats.length; i++) {
    if (formats[i].test(data)) {
      return formats[i];
    }
  }
  return null;
}

exports.TextFormat = TextFormat.TextFormat;
exports.XMLFormat = XMLFormat.XMLFormat;
exports.XMLStringFormat = XMLStringFormat.XMLStringFormat;
exports.autoDetectFormat = autoDetectFormat;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var BitmapFont = __webpack_require__(/*! ./BitmapFont.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/BitmapFont.js");
var BitmapFontData = __webpack_require__(/*! ./BitmapFontData.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/BitmapFontData.js");
var BitmapText = __webpack_require__(/*! ./BitmapText.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/BitmapText.js");
__webpack_require__(/*! ./BitmapTextStyle.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/BitmapTextStyle.js");
var index = __webpack_require__(/*! ./formats/index.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/formats/index.js");
var loadBitmapFont = __webpack_require__(/*! ./loadBitmapFont.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/loadBitmapFont.js");
var TextFormat = __webpack_require__(/*! ./formats/TextFormat.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/formats/TextFormat.js");
var XMLFormat = __webpack_require__(/*! ./formats/XMLFormat.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.js");
var XMLStringFormat = __webpack_require__(/*! ./formats/XMLStringFormat.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.js");



exports.BitmapFont = BitmapFont.BitmapFont;
exports.BitmapFontData = BitmapFontData.BitmapFontData;
exports.BitmapText = BitmapText.BitmapText;
exports.autoDetectFormat = index.autoDetectFormat;
exports.loadBitmapFont = loadBitmapFont.loadBitmapFont;
exports.TextFormat = TextFormat.TextFormat;
exports.XMLFormat = XMLFormat.XMLFormat;
exports.XMLStringFormat = XMLStringFormat.XMLStringFormat;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/loadBitmapFont.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/loadBitmapFont.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var assets = __webpack_require__(/*! @pixi/assets */ "./node_modules/pixi.js/node_modules/@pixi/assets/lib/index.js");
var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var BitmapFont = __webpack_require__(/*! ./BitmapFont.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/BitmapFont.js");
__webpack_require__(/*! ./formats/index.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/formats/index.js");
var TextFormat = __webpack_require__(/*! ./formats/TextFormat.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/formats/TextFormat.js");
var XMLStringFormat = __webpack_require__(/*! ./formats/XMLStringFormat.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.js");

const validExtensions = [".xml", ".fnt"];
const loadBitmapFont = {
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: assets.LoaderParserPriority.Normal
  },
  name: "loadBitmapFont",
  test(url) {
    return validExtensions.includes(core.utils.path.extname(url).toLowerCase());
  },
  async testParse(data) {
    return TextFormat.TextFormat.test(data) || XMLStringFormat.XMLStringFormat.test(data);
  },
  async parse(asset, data, loader) {
    const fontData = TextFormat.TextFormat.test(asset) ? TextFormat.TextFormat.parse(asset) : XMLStringFormat.XMLStringFormat.parse(asset);
    const { src } = data;
    const { page: pages } = fontData;
    const textureUrls = [];
    for (let i = 0; i < pages.length; ++i) {
      const pageFile = pages[i].file;
      let imagePath = core.utils.path.join(core.utils.path.dirname(src), pageFile);
      imagePath = assets.copySearchParams(imagePath, src);
      textureUrls.push(imagePath);
    }
    const loadedTextures = await loader.load(textureUrls);
    const textures = textureUrls.map((url) => loadedTextures[url]);
    return BitmapFont.BitmapFont.install(fontData, textures, true);
  },
  async load(url, _options) {
    const response = await core.settings.ADAPTER.fetch(url);
    return response.text();
  },
  unload(bitmapFont) {
    bitmapFont.destroy();
  }
};
core.extensions.add(loadBitmapFont);

exports.loadBitmapFont = loadBitmapFont;
//# sourceMappingURL=loadBitmapFont.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/shader/msdf.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/shader/msdf.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var msdfFrag = "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n  if (median < 0.01) {\r\n    alpha = 0.0;\r\n  } else if (median > 0.99) {\r\n    alpha = 1.0;\r\n  }\r\n\r\n  // Gamma correction for coverage-like alpha\r\n  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r\n  float gamma = mix(1.0, 1.0 / 2.2, luma);\r\n  float coverage = pow(uColor.a * alpha, gamma);  \r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, coverage);\r\n}\r\n";

exports["default"] = msdfFrag;
//# sourceMappingURL=msdf.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/shader/msdf2.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/shader/msdf2.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var msdfVert = "// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";

exports["default"] = msdfVert;
//# sourceMappingURL=msdf2.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/drawGlyph.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/drawGlyph.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var generateFillStyle = __webpack_require__(/*! ./generateFillStyle.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/generateFillStyle.js");

function drawGlyph(canvas, context, metrics, x, y, resolution, style) {
  const char = metrics.text;
  const fontProperties = metrics.fontProperties;
  context.translate(x, y);
  context.scale(resolution, resolution);
  const tx = style.strokeThickness / 2;
  const ty = -(style.strokeThickness / 2);
  context.font = style.toFontString();
  context.lineWidth = style.strokeThickness;
  context.textBaseline = style.textBaseline;
  context.lineJoin = style.lineJoin;
  context.miterLimit = style.miterLimit;
  context.fillStyle = generateFillStyle.generateFillStyle(canvas, context, style, resolution, [char], metrics);
  context.strokeStyle = style.stroke;
  if (style.dropShadow) {
    const dropShadowColor = style.dropShadowColor;
    const dropShadowBlur = style.dropShadowBlur * resolution;
    const dropShadowDistance = style.dropShadowDistance * resolution;
    context.shadowColor = core.Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();
    context.shadowBlur = dropShadowBlur;
    context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
    context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;
  } else {
    context.shadowColor = "black";
    context.shadowBlur = 0;
    context.shadowOffsetX = 0;
    context.shadowOffsetY = 0;
  }
  if (style.stroke && style.strokeThickness) {
    context.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  if (style.fill) {
    context.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  context.setTransform(1, 0, 0, 1, 0, 0);
  context.fillStyle = "rgba(0, 0, 0, 0)";
}

exports.drawGlyph = drawGlyph;
//# sourceMappingURL=drawGlyph.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function extractCharCode(str) {
  return str.codePointAt ? str.codePointAt(0) : str.charCodeAt(0);
}

exports.extractCharCode = extractCharCode;
//# sourceMappingURL=extractCharCode.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/generateFillStyle.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/generateFillStyle.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var text = __webpack_require__(/*! @pixi/text */ "./node_modules/pixi.js/node_modules/@pixi/text/lib/index.js");

function generateFillStyle(canvas, context, style, resolution, lines, metrics) {
  const fillStyle = style.fill;
  if (!Array.isArray(fillStyle)) {
    return fillStyle;
  } else if (fillStyle.length === 1) {
    return fillStyle[0];
  }
  let gradient;
  const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
  const padding = style.padding || 0;
  const width = canvas.width / resolution - dropShadowCorrection - padding * 2;
  const height = canvas.height / resolution - dropShadowCorrection - padding * 2;
  const fill = fillStyle.slice();
  const fillGradientStops = style.fillGradientStops.slice();
  if (!fillGradientStops.length) {
    const lengthPlus1 = fill.length + 1;
    for (let i = 1; i < lengthPlus1; ++i) {
      fillGradientStops.push(i / lengthPlus1);
    }
  }
  fill.unshift(fillStyle[0]);
  fillGradientStops.unshift(0);
  fill.push(fillStyle[fillStyle.length - 1]);
  fillGradientStops.push(1);
  if (style.fillGradientType === text.TEXT_GRADIENT.LINEAR_VERTICAL) {
    gradient = context.createLinearGradient(width / 2, padding, width / 2, height + padding);
    let lastIterationStop = 0;
    const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
    const gradStopLineHeight = textHeight / height;
    for (let i = 0; i < lines.length; i++) {
      const thisLineTop = metrics.lineHeight * i;
      for (let j = 0; j < fill.length; j++) {
        let lineStop = 0;
        if (typeof fillGradientStops[j] === "number") {
          lineStop = fillGradientStops[j];
        } else {
          lineStop = j / fill.length;
        }
        const globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
        let clampedStop = Math.max(lastIterationStop, globalStop);
        clampedStop = Math.min(clampedStop, 1);
        gradient.addColorStop(clampedStop, fill[j]);
        lastIterationStop = clampedStop;
      }
    }
  } else {
    gradient = context.createLinearGradient(padding, height / 2, width + padding, height / 2);
    const totalIterations = fill.length + 1;
    let currentIteration = 1;
    for (let i = 0; i < fill.length; i++) {
      let stop;
      if (typeof fillGradientStops[i] === "number") {
        stop = fillGradientStops[i];
      } else {
        stop = currentIteration / totalIterations;
      }
      gradient.addColorStop(stop, fill[i]);
      currentIteration++;
    }
  }
  return gradient;
}

exports.generateFillStyle = generateFillStyle;
//# sourceMappingURL=generateFillStyle.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/index.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var drawGlyph = __webpack_require__(/*! ./drawGlyph.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/drawGlyph.js");
var extractCharCode = __webpack_require__(/*! ./extractCharCode.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.js");
var generateFillStyle = __webpack_require__(/*! ./generateFillStyle.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/generateFillStyle.js");
var resolveCharacters = __webpack_require__(/*! ./resolveCharacters.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/resolveCharacters.js");
var splitTextToCharacters = __webpack_require__(/*! ./splitTextToCharacters.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.js");



exports.drawGlyph = drawGlyph.drawGlyph;
exports.extractCharCode = extractCharCode.extractCharCode;
exports.generateFillStyle = generateFillStyle.generateFillStyle;
exports.resolveCharacters = resolveCharacters.resolveCharacters;
exports.splitTextToCharacters = splitTextToCharacters.splitTextToCharacters;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/resolveCharacters.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/resolveCharacters.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var splitTextToCharacters = __webpack_require__(/*! ./splitTextToCharacters.js */ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.js");

function resolveCharacters(chars) {
  if (typeof chars === "string") {
    chars = [chars];
  }
  const result = [];
  for (let i = 0, j = chars.length; i < j; i++) {
    const item = chars[i];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
      }
      const startCode = item[0].charCodeAt(0);
      const endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {
        result.push(String.fromCharCode(i2));
      }
    } else {
      result.push(...splitTextToCharacters.splitTextToCharacters(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}

exports.resolveCharacters = resolveCharacters;
//# sourceMappingURL=resolveCharacters.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function splitTextToCharacters(text) {
  return Array.from ? Array.from(text) : text.split("");
}

exports.splitTextToCharacters = splitTextToCharacters;
//# sourceMappingURL=splitTextToCharacters.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-html/lib/HTMLText.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-html/lib/HTMLText.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var sprite = __webpack_require__(/*! @pixi/sprite */ "./node_modules/pixi.js/node_modules/@pixi/sprite/lib/index.js");
var text = __webpack_require__(/*! @pixi/text */ "./node_modules/pixi.js/node_modules/@pixi/text/lib/index.js");
var HTMLTextStyle = __webpack_require__(/*! ./HTMLTextStyle.js */ "./node_modules/pixi.js/node_modules/@pixi/text-html/lib/HTMLTextStyle.js");

const _HTMLText = class extends sprite.Sprite {
  constructor(text = "", style = {}) {
    super(core.Texture.EMPTY);
    this._text = null;
    this._style = null;
    this._autoResolution = true;
    this._loading = false;
    this.localStyleID = -1;
    this.dirty = false;
    this.ownsStyle = false;
    const image = new Image();
    const texture = core.Texture.from(image, {
      scaleMode: core.settings.SCALE_MODE,
      resourceOptions: {
        autoLoad: false
      }
    });
    texture.orig = new core.Rectangle();
    texture.trim = new core.Rectangle();
    this.texture = texture;
    const nssvg = "http://www.w3.org/2000/svg";
    const nsxhtml = "http://www.w3.org/1999/xhtml";
    const svgRoot = document.createElementNS(nssvg, "svg");
    const foreignObject = document.createElementNS(nssvg, "foreignObject");
    const domElement = document.createElementNS(nsxhtml, "div");
    const styleElement = document.createElementNS(nsxhtml, "style");
    foreignObject.setAttribute("width", "10000");
    foreignObject.setAttribute("height", "10000");
    foreignObject.style.overflow = "hidden";
    svgRoot.appendChild(foreignObject);
    this.maxWidth = _HTMLText.defaultMaxWidth;
    this.maxHeight = _HTMLText.defaultMaxHeight;
    this._domElement = domElement;
    this._styleElement = styleElement;
    this._svgRoot = svgRoot;
    this._foreignObject = foreignObject;
    this._foreignObject.appendChild(styleElement);
    this._foreignObject.appendChild(domElement);
    this._image = image;
    this._loadImage = new Image();
    this._autoResolution = _HTMLText.defaultAutoResolution;
    this._resolution = _HTMLText.defaultResolution ?? core.settings.RESOLUTION;
    this.text = text;
    this.style = style;
  }
  measureText(overrides) {
    const { text, style, resolution } = Object.assign({
      text: this._text,
      style: this._style,
      resolution: this._resolution
    }, overrides);
    Object.assign(this._domElement, {
      innerHTML: text,
      style: style.toCSS(resolution)
    });
    this._styleElement.textContent = style.toGlobalCSS();
    document.body.appendChild(this._svgRoot);
    const contentBounds = this._domElement.getBoundingClientRect();
    this._svgRoot.remove();
    const contentWidth = Math.min(this.maxWidth, Math.ceil(contentBounds.width));
    const contentHeight = Math.min(this.maxHeight, Math.ceil(contentBounds.height));
    this._svgRoot.setAttribute("width", contentWidth.toString());
    this._svgRoot.setAttribute("height", contentHeight.toString());
    if (text !== this._text) {
      this._domElement.innerHTML = this._text;
    }
    if (style !== this._style) {
      Object.assign(this._domElement, { style: this._style?.toCSS(resolution) });
      this._styleElement.textContent = this._style?.toGlobalCSS();
    }
    return {
      width: contentWidth + style.padding * 2,
      height: contentHeight + style.padding * 2
    };
  }
  async updateText(respectDirty = true) {
    const { style, _image: image, _loadImage: loadImage } = this;
    if (this.localStyleID !== style.styleID) {
      this.dirty = true;
      this.localStyleID = style.styleID;
    }
    if (!this.dirty && respectDirty) {
      return;
    }
    const { width, height } = this.measureText();
    image.width = loadImage.width = Math.ceil(Math.max(1, width));
    image.height = loadImage.height = Math.ceil(Math.max(1, height));
    if (!this._loading) {
      this._loading = true;
      await new Promise((resolve) => {
        loadImage.onload = async () => {
          await style.onBeforeDraw();
          this._loading = false;
          image.src = loadImage.src;
          loadImage.onload = null;
          loadImage.src = "";
          this.updateTexture();
          resolve();
        };
        const svgURL = new XMLSerializer().serializeToString(this._svgRoot);
        loadImage.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(svgURL)}`;
      });
    }
  }
  get source() {
    return this._image;
  }
  updateTexture() {
    const { style, texture, _image: image, resolution } = this;
    const { padding } = style;
    const { baseTexture } = texture;
    texture.trim.width = texture._frame.width = image.width / resolution;
    texture.trim.height = texture._frame.height = image.height / resolution;
    texture.trim.x = -padding;
    texture.trim.y = -padding;
    texture.orig.width = texture._frame.width - padding * 2;
    texture.orig.height = texture._frame.height - padding * 2;
    this._onTextureUpdate();
    baseTexture.setRealSize(image.width, image.height, resolution);
    this.dirty = false;
  }
  _render(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._render(renderer);
  }
  _renderCanvas(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._renderCanvas(renderer);
  }
  getLocalBounds(rect) {
    this.updateText(true);
    return super.getLocalBounds(rect);
  }
  _calculateBounds() {
    this.updateText(true);
    this.calculateVertices();
    this._bounds.addQuad(this.vertexData);
  }
  _onStyleChange() {
    this.dirty = true;
  }
  destroy(options) {
    if (typeof options === "boolean") {
      options = { children: options };
    }
    options = Object.assign({}, _HTMLText.defaultDestroyOptions, options);
    super.destroy(options);
    const forceClear = null;
    if (this.ownsStyle) {
      this._style?.cleanFonts();
    }
    this._style = forceClear;
    this._svgRoot?.remove();
    this._svgRoot = forceClear;
    this._domElement?.remove();
    this._domElement = forceClear;
    this._foreignObject?.remove();
    this._foreignObject = forceClear;
    this._styleElement?.remove();
    this._styleElement = forceClear;
    this._loadImage.src = "";
    this._loadImage.onload = null;
    this._loadImage = forceClear;
    this._image.src = "";
    this._image = forceClear;
  }
  get width() {
    this.updateText(true);
    return Math.abs(this.scale.x) * this._image.width / this.resolution;
  }
  set width(value) {
    this.updateText(true);
    const s = core.utils.sign(this.scale.x) || 1;
    this.scale.x = s * value / this._image.width / this.resolution;
    this._width = value;
  }
  get height() {
    this.updateText(true);
    return Math.abs(this.scale.y) * this._image.height / this.resolution;
  }
  set height(value) {
    this.updateText(true);
    const s = core.utils.sign(this.scale.y) || 1;
    this.scale.y = s * value / this._image.height / this.resolution;
    this._height = value;
  }
  get style() {
    return this._style;
  }
  set style(style) {
    if (this._style === style) {
      return;
    }
    style = style || {};
    if (style instanceof HTMLTextStyle.HTMLTextStyle) {
      this.ownsStyle = false;
      this._style = style;
    } else if (style instanceof text.TextStyle) {
      console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle");
      this.ownsStyle = true;
      this._style = HTMLTextStyle.HTMLTextStyle.from(style);
    } else {
      this.ownsStyle = true;
      this._style = new HTMLTextStyle.HTMLTextStyle(style);
    }
    this.localStyleID = -1;
    this.dirty = true;
  }
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text === "" || text === null || text === void 0 ? " " : text);
    text = this.sanitiseText(text);
    if (this._text === text) {
      return;
    }
    this._text = text;
    this.dirty = true;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false;
    if (this._resolution === value) {
      return;
    }
    this._resolution = value;
    this.dirty = true;
  }
  sanitiseText(text) {
    return text.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;");
  }
};
let HTMLText = _HTMLText;
HTMLText.defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
};
HTMLText.defaultMaxWidth = 2024;
HTMLText.defaultMaxHeight = 2024;
HTMLText.defaultAutoResolution = true;

exports.HTMLText = HTMLText;
//# sourceMappingURL=HTMLText.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-html/lib/HTMLTextStyle.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-html/lib/HTMLTextStyle.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var text = __webpack_require__(/*! @pixi/text */ "./node_modules/pixi.js/node_modules/@pixi/text/lib/index.js");

const _HTMLTextStyle = class extends text.TextStyle {
  constructor() {
    super(...arguments);
    this._fonts = [];
    this._overrides = [];
    this._stylesheet = "";
    this.fontsDirty = false;
  }
  static from(originalStyle) {
    return new _HTMLTextStyle(Object.keys(_HTMLTextStyle.defaultOptions).reduce((obj, prop) => ({ ...obj, [prop]: originalStyle[prop] }), {}));
  }
  cleanFonts() {
    if (this._fonts.length > 0) {
      this._fonts.forEach((font) => {
        URL.revokeObjectURL(font.src);
        font.refs--;
        if (font.refs === 0) {
          if (font.fontFace) {
            document.fonts.delete(font.fontFace);
          }
          delete _HTMLTextStyle.availableFonts[font.originalUrl];
        }
      });
      this.fontFamily = "Arial";
      this._fonts.length = 0;
      this.styleID++;
      this.fontsDirty = true;
    }
  }
  loadFont(url, options = {}) {
    const { availableFonts } = _HTMLTextStyle;
    if (availableFonts[url]) {
      const font = availableFonts[url];
      this._fonts.push(font);
      font.refs++;
      this.styleID++;
      this.fontsDirty = true;
      return Promise.resolve();
    }
    return core.settings.ADAPTER.fetch(url).then((response) => response.blob()).then(async (blob) => new Promise((resolve, reject) => {
      const src = URL.createObjectURL(blob);
      const reader = new FileReader();
      reader.onload = () => resolve([src, reader.result]);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    })).then(async ([src, dataSrc]) => {
      const font = Object.assign({
        family: core.utils.path.basename(url, core.utils.path.extname(url)),
        weight: "normal",
        style: "normal",
        src,
        dataSrc,
        refs: 1,
        originalUrl: url,
        fontFace: null
      }, options);
      availableFonts[url] = font;
      this._fonts.push(font);
      this.styleID++;
      const fontFace = new FontFace(font.family, `url(${font.src})`, {
        weight: font.weight,
        style: font.style
      });
      font.fontFace = fontFace;
      await fontFace.load();
      document.fonts.add(fontFace);
      await document.fonts.ready;
      this.styleID++;
      this.fontsDirty = true;
    });
  }
  addOverride(...value) {
    const toAdd = value.filter((v) => !this._overrides.includes(v));
    if (toAdd.length > 0) {
      this._overrides.push(...toAdd);
      this.styleID++;
    }
  }
  removeOverride(...value) {
    const toRemove = value.filter((v) => this._overrides.includes(v));
    if (toRemove.length > 0) {
      this._overrides = this._overrides.filter((v) => !toRemove.includes(v));
      this.styleID++;
    }
  }
  toCSS(scale) {
    return [
      `transform: scale(${scale})`,
      `transform-origin: top left`,
      "display: inline-block",
      `color: ${this.normalizeColor(this.fill)}`,
      `font-size: ${this.fontSize}px`,
      `font-family: ${this.fontFamily}`,
      `font-weight: ${this.fontWeight}`,
      `font-style: ${this.fontStyle}`,
      `font-variant: ${this.fontVariant}`,
      `letter-spacing: ${this.letterSpacing}px`,
      `text-align: ${this.align}`,
      `padding: ${this.padding}px`,
      `white-space: ${this.whiteSpace}`,
      ...this.lineHeight ? [`line-height: ${this.lineHeight}px`] : [],
      ...this.wordWrap ? [
        `word-wrap: ${this.breakWords ? "break-all" : "break-word"}`,
        `max-width: ${this.wordWrapWidth}px`
      ] : [],
      ...this.strokeThickness ? [
        `-webkit-text-stroke-width: ${this.strokeThickness}px`,
        `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`,
        `text-stroke-width: ${this.strokeThickness}px`,
        `text-stroke-color: ${this.normalizeColor(this.stroke)}`,
        "paint-order: stroke"
      ] : [],
      ...this.dropShadow ? [this.dropShadowToCSS()] : [],
      ...this._overrides
    ].join(";");
  }
  toGlobalCSS() {
    return this._fonts.reduce((result, font) => `${result}
            @font-face {
                font-family: "${font.family}";
                src: url('${font.dataSrc}');
                font-weight: ${font.weight};
                font-style: ${font.style}; 
            }`, this._stylesheet);
  }
  get stylesheet() {
    return this._stylesheet;
  }
  set stylesheet(value) {
    if (this._stylesheet !== value) {
      this._stylesheet = value;
      this.styleID++;
    }
  }
  normalizeColor(color) {
    if (Array.isArray(color)) {
      color = core.utils.rgb2hex(color);
    }
    if (typeof color === "number") {
      return core.utils.hex2string(color);
    }
    return color;
  }
  dropShadowToCSS() {
    let color = this.normalizeColor(this.dropShadowColor);
    const alpha = this.dropShadowAlpha;
    const x = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance);
    const y = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);
    if (color.startsWith("#") && alpha < 1) {
      color += (alpha * 255 | 0).toString(16).padStart(2, "0");
    }
    const position = `${x}px ${y}px`;
    if (this.dropShadowBlur > 0) {
      return `text-shadow: ${position} ${this.dropShadowBlur}px ${color}`;
    }
    return `text-shadow: ${position} ${color}`;
  }
  reset() {
    Object.assign(this, _HTMLTextStyle.defaultOptions);
  }
  onBeforeDraw() {
    const { fontsDirty: prevFontsDirty } = this;
    this.fontsDirty = false;
    if (this.isSafari && this._fonts.length > 0 && prevFontsDirty) {
      return new Promise((resolve) => setTimeout(resolve, 100));
    }
    return Promise.resolve();
  }
  get isSafari() {
    const { userAgent } = core.settings.ADAPTER.getNavigator();
    return /^((?!chrome|android).)*safari/i.test(userAgent);
  }
  set fillGradientStops(_value) {
    console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText");
  }
  get fillGradientStops() {
    return super.fillGradientStops;
  }
  set fillGradientType(_value) {
    console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText");
  }
  get fillGradientType() {
    return super.fillGradientType;
  }
  set miterLimit(_value) {
    console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText");
  }
  get miterLimit() {
    return super.miterLimit;
  }
  set trim(_value) {
    console.warn("[HTMLTextStyle] trim is not supported by HTMLText");
  }
  get trim() {
    return super.trim;
  }
  set textBaseline(_value) {
    console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText");
  }
  get textBaseline() {
    return super.textBaseline;
  }
  set leading(_value) {
    console.warn("[HTMLTextStyle] leading is not supported by HTMLText");
  }
  get leading() {
    return super.leading;
  }
  set lineJoin(_value) {
    console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText");
  }
  get lineJoin() {
    return super.lineJoin;
  }
};
let HTMLTextStyle = _HTMLTextStyle;
HTMLTextStyle.availableFonts = {};
HTMLTextStyle.defaultOptions = {
  align: "left",
  breakWords: false,
  dropShadow: false,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  whiteSpace: "normal",
  wordWrap: false,
  wordWrapWidth: 100
};

exports.HTMLTextStyle = HTMLTextStyle;
//# sourceMappingURL=HTMLTextStyle.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text-html/lib/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text-html/lib/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var HTMLText = __webpack_require__(/*! ./HTMLText.js */ "./node_modules/pixi.js/node_modules/@pixi/text-html/lib/HTMLText.js");
var HTMLTextStyle = __webpack_require__(/*! ./HTMLTextStyle.js */ "./node_modules/pixi.js/node_modules/@pixi/text-html/lib/HTMLTextStyle.js");



exports.HTMLText = HTMLText.HTMLText;
exports.HTMLTextStyle = HTMLTextStyle.HTMLTextStyle;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text/lib/Text.js":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text/lib/Text.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");
var sprite = __webpack_require__(/*! @pixi/sprite */ "./node_modules/pixi.js/node_modules/@pixi/sprite/lib/index.js");
var _const = __webpack_require__(/*! ./const.js */ "./node_modules/pixi.js/node_modules/@pixi/text/lib/const.js");
var TextMetrics = __webpack_require__(/*! ./TextMetrics.js */ "./node_modules/pixi.js/node_modules/@pixi/text/lib/TextMetrics.js");
var TextStyle = __webpack_require__(/*! ./TextStyle.js */ "./node_modules/pixi.js/node_modules/@pixi/text/lib/TextStyle.js");

const defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
};
const _Text = class extends sprite.Sprite {
  constructor(text, style, canvas) {
    let ownCanvas = false;
    if (!canvas) {
      canvas = core.settings.ADAPTER.createCanvas();
      ownCanvas = true;
    }
    canvas.width = 3;
    canvas.height = 3;
    const texture = core.Texture.from(canvas);
    texture.orig = new core.Rectangle();
    texture.trim = new core.Rectangle();
    super(texture);
    this._ownCanvas = ownCanvas;
    this.canvas = canvas;
    this.context = canvas.getContext("2d", {
      willReadFrequently: true
    });
    this._resolution = _Text.defaultResolution ?? core.settings.RESOLUTION;
    this._autoResolution = _Text.defaultAutoResolution;
    this._text = null;
    this._style = null;
    this._styleListener = null;
    this._font = "";
    this.text = text;
    this.style = style;
    this.localStyleID = -1;
  }
  static get experimentalLetterSpacing() {
    return TextMetrics.TextMetrics.experimentalLetterSpacing;
  }
  static set experimentalLetterSpacing(value) {
    core.utils.deprecation("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing");
    TextMetrics.TextMetrics.experimentalLetterSpacing = value;
  }
  updateText(respectDirty) {
    const style = this._style;
    if (this.localStyleID !== style.styleID) {
      this.dirty = true;
      this.localStyleID = style.styleID;
    }
    if (!this.dirty && respectDirty) {
      return;
    }
    this._font = this._style.toFontString();
    const context = this.context;
    const measured = TextMetrics.TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);
    const width = measured.width;
    const height = measured.height;
    const lines = measured.lines;
    const lineHeight = measured.lineHeight;
    const lineWidths = measured.lineWidths;
    const maxLineWidth = measured.maxLineWidth;
    const fontProperties = measured.fontProperties;
    this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);
    this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);
    context.scale(this._resolution, this._resolution);
    context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    context.font = this._font;
    context.lineWidth = style.strokeThickness;
    context.textBaseline = style.textBaseline;
    context.lineJoin = style.lineJoin;
    context.miterLimit = style.miterLimit;
    let linePositionX;
    let linePositionY;
    const passesCount = style.dropShadow ? 2 : 1;
    for (let i = 0; i < passesCount; ++i) {
      const isShadowPass = style.dropShadow && i === 0;
      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
      const dsOffsetShadow = dsOffsetText * this._resolution;
      if (isShadowPass) {
        context.fillStyle = "black";
        context.strokeStyle = "black";
        const dropShadowColor = style.dropShadowColor;
        const dropShadowBlur = style.dropShadowBlur * this._resolution;
        const dropShadowDistance = style.dropShadowDistance * this._resolution;
        context.shadowColor = core.Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();
        context.shadowBlur = dropShadowBlur;
        context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
        context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
      } else {
        context.fillStyle = this._generateFillStyle(style, lines, measured);
        context.strokeStyle = style.stroke;
        context.shadowColor = "black";
        context.shadowBlur = 0;
        context.shadowOffsetX = 0;
        context.shadowOffsetY = 0;
      }
      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
      if (lineHeight - fontProperties.fontSize < 0) {
        linePositionYShift = 0;
      }
      for (let i2 = 0; i2 < lines.length; i2++) {
        linePositionX = style.strokeThickness / 2;
        linePositionY = style.strokeThickness / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;
        if (style.align === "right") {
          linePositionX += maxLineWidth - lineWidths[i2];
        } else if (style.align === "center") {
          linePositionX += (maxLineWidth - lineWidths[i2]) / 2;
        }
        if (style.stroke && style.strokeThickness) {
          this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);
        }
        if (style.fill) {
          this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
        }
      }
    }
    this.updateTexture();
  }
  drawLetterSpacing(text, x, y, isStroke = false) {
    const style = this._style;
    const letterSpacing = style.letterSpacing;
    let useExperimentalLetterSpacing = false;
    if (TextMetrics.TextMetrics.experimentalLetterSpacingSupported) {
      if (TextMetrics.TextMetrics.experimentalLetterSpacing) {
        this.context.letterSpacing = `${letterSpacing}px`;
        this.context.textLetterSpacing = `${letterSpacing}px`;
        useExperimentalLetterSpacing = true;
      } else {
        this.context.letterSpacing = "0px";
        this.context.textLetterSpacing = "0px";
      }
    }
    if (letterSpacing === 0 || useExperimentalLetterSpacing) {
      if (isStroke) {
        this.context.strokeText(text, x, y);
      } else {
        this.context.fillText(text, x, y);
      }
      return;
    }
    let currentPosition = x;
    const stringArray = TextMetrics.TextMetrics.graphemeSegmenter(text);
    let previousWidth = this.context.measureText(text).width;
    let currentWidth = 0;
    for (let i = 0; i < stringArray.length; ++i) {
      const currentChar = stringArray[i];
      if (isStroke) {
        this.context.strokeText(currentChar, currentPosition, y);
      } else {
        this.context.fillText(currentChar, currentPosition, y);
      }
      let textStr = "";
      for (let j = i + 1; j < stringArray.length; ++j) {
        textStr += stringArray[j];
      }
      currentWidth = this.context.measureText(textStr).width;
      currentPosition += previousWidth - currentWidth + letterSpacing;
      previousWidth = currentWidth;
    }
  }
  updateTexture() {
    const canvas = this.canvas;
    if (this._style.trim) {
      const trimmed = core.utils.trimCanvas(canvas);
      if (trimmed.data) {
        canvas.width = trimmed.width;
        canvas.height = trimmed.height;
        this.context.putImageData(trimmed.data, 0, 0);
      }
    }
    const texture = this._texture;
    const style = this._style;
    const padding = style.trim ? 0 : style.padding;
    const baseTexture = texture.baseTexture;
    texture.trim.width = texture._frame.width = canvas.width / this._resolution;
    texture.trim.height = texture._frame.height = canvas.height / this._resolution;
    texture.trim.x = -padding;
    texture.trim.y = -padding;
    texture.orig.width = texture._frame.width - padding * 2;
    texture.orig.height = texture._frame.height - padding * 2;
    this._onTextureUpdate();
    baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);
    texture.updateUvs();
    this.dirty = false;
  }
  _render(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._render(renderer);
  }
  updateTransform() {
    this.updateText(true);
    super.updateTransform();
  }
  getBounds(skipUpdate, rect) {
    this.updateText(true);
    if (this._textureID === -1) {
      skipUpdate = false;
    }
    return super.getBounds(skipUpdate, rect);
  }
  getLocalBounds(rect) {
    this.updateText(true);
    return super.getLocalBounds.call(this, rect);
  }
  _calculateBounds() {
    this.calculateVertices();
    this._bounds.addQuad(this.vertexData);
  }
  _generateFillStyle(style, lines, metrics) {
    const fillStyle = style.fill;
    if (!Array.isArray(fillStyle)) {
      return fillStyle;
    } else if (fillStyle.length === 1) {
      return fillStyle[0];
    }
    let gradient;
    const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
    const padding = style.padding || 0;
    const width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;
    const height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;
    const fill = fillStyle.slice();
    const fillGradientStops = style.fillGradientStops.slice();
    if (!fillGradientStops.length) {
      const lengthPlus1 = fill.length + 1;
      for (let i = 1; i < lengthPlus1; ++i) {
        fillGradientStops.push(i / lengthPlus1);
      }
    }
    fill.unshift(fillStyle[0]);
    fillGradientStops.unshift(0);
    fill.push(fillStyle[fillStyle.length - 1]);
    fillGradientStops.push(1);
    if (style.fillGradientType === _const.TEXT_GRADIENT.LINEAR_VERTICAL) {
      gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
      const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
      for (let i = 0; i < lines.length; i++) {
        const lastLineBottom = metrics.lineHeight * (i - 1) + textHeight;
        const thisLineTop = metrics.lineHeight * i;
        let thisLineGradientStart = thisLineTop;
        if (i > 0 && lastLineBottom > thisLineTop) {
          thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;
        }
        const thisLineBottom = thisLineTop + textHeight;
        const nextLineTop = metrics.lineHeight * (i + 1);
        let thisLineGradientEnd = thisLineBottom;
        if (i + 1 < lines.length && nextLineTop < thisLineBottom) {
          thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;
        }
        const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;
        for (let j = 0; j < fill.length; j++) {
          let lineStop = 0;
          if (typeof fillGradientStops[j] === "number") {
            lineStop = fillGradientStops[j];
          } else {
            lineStop = j / fill.length;
          }
          let globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));
          globalStop = Number(globalStop.toFixed(5));
          gradient.addColorStop(globalStop, fill[j]);
        }
      }
    } else {
      gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
      const totalIterations = fill.length + 1;
      let currentIteration = 1;
      for (let i = 0; i < fill.length; i++) {
        let stop;
        if (typeof fillGradientStops[i] === "number") {
          stop = fillGradientStops[i];
        } else {
          stop = currentIteration / totalIterations;
        }
        gradient.addColorStop(stop, fill[i]);
        currentIteration++;
      }
    }
    return gradient;
  }
  destroy(options) {
    if (typeof options === "boolean") {
      options = { children: options };
    }
    options = Object.assign({}, defaultDestroyOptions, options);
    super.destroy(options);
    if (this._ownCanvas) {
      this.canvas.height = this.canvas.width = 0;
    }
    this.context = null;
    this.canvas = null;
    this._style = null;
  }
  get width() {
    this.updateText(true);
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value) {
    this.updateText(true);
    const s = core.utils.sign(this.scale.x) || 1;
    this.scale.x = s * value / this._texture.orig.width;
    this._width = value;
  }
  get height() {
    this.updateText(true);
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value) {
    this.updateText(true);
    const s = core.utils.sign(this.scale.y) || 1;
    this.scale.y = s * value / this._texture.orig.height;
    this._height = value;
  }
  get style() {
    return this._style;
  }
  set style(style) {
    style = style || {};
    if (style instanceof TextStyle.TextStyle) {
      this._style = style;
    } else {
      this._style = new TextStyle.TextStyle(style);
    }
    this.localStyleID = -1;
    this.dirty = true;
  }
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text === null || text === void 0 ? "" : text);
    if (this._text === text) {
      return;
    }
    this._text = text;
    this.dirty = true;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false;
    if (this._resolution === value) {
      return;
    }
    this._resolution = value;
    this.dirty = true;
  }
};
let Text = _Text;
Text.defaultAutoResolution = true;

exports.Text = Text;
//# sourceMappingURL=Text.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text/lib/TextMetrics.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text/lib/TextMetrics.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

const contextSettings = {
  willReadFrequently: true
};
const _TextMetrics = class {
  static get experimentalLetterSpacingSupported() {
    let result = _TextMetrics._experimentalLetterSpacingSupported;
    if (result !== void 0) {
      const proto = core.settings.ADAPTER.getCanvasRenderingContext2D().prototype;
      result = _TextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
    }
    return result;
  }
  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
    this.text = text;
    this.style = style;
    this.width = width;
    this.height = height;
    this.lines = lines;
    this.lineWidths = lineWidths;
    this.lineHeight = lineHeight;
    this.maxLineWidth = maxLineWidth;
    this.fontProperties = fontProperties;
  }
  static measureText(text, style, wordWrap, canvas = _TextMetrics._canvas) {
    wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;
    const font = style.toFontString();
    const fontProperties = _TextMetrics.measureFont(font);
    if (fontProperties.fontSize === 0) {
      fontProperties.fontSize = style.fontSize;
      fontProperties.ascent = style.fontSize;
    }
    const context = canvas.getContext("2d", contextSettings);
    context.font = font;
    const outputText = wordWrap ? _TextMetrics.wordWrap(text, style, canvas) : text;
    const lines = outputText.split(/(?:\r\n|\r|\n)/);
    const lineWidths = new Array(lines.length);
    let maxLineWidth = 0;
    for (let i = 0; i < lines.length; i++) {
      const lineWidth = _TextMetrics._measureText(lines[i], style.letterSpacing, context);
      lineWidths[i] = lineWidth;
      maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }
    let width = maxLineWidth + style.strokeThickness;
    if (style.dropShadow) {
      width += style.dropShadowDistance;
    }
    const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
    let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness * 2) + (lines.length - 1) * (lineHeight + style.leading);
    if (style.dropShadow) {
      height += style.dropShadowDistance;
    }
    return new _TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
  }
  static _measureText(text, letterSpacing, context) {
    let useExperimentalLetterSpacing = false;
    if (_TextMetrics.experimentalLetterSpacingSupported) {
      if (_TextMetrics.experimentalLetterSpacing) {
        context.letterSpacing = `${letterSpacing}px`;
        context.textLetterSpacing = `${letterSpacing}px`;
        useExperimentalLetterSpacing = true;
      } else {
        context.letterSpacing = "0px";
        context.textLetterSpacing = "0px";
      }
    }
    let width = context.measureText(text).width;
    if (width > 0) {
      if (useExperimentalLetterSpacing) {
        width -= letterSpacing;
      } else {
        width += (_TextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;
      }
    }
    return width;
  }
  static wordWrap(text, style, canvas = _TextMetrics._canvas) {
    const context = canvas.getContext("2d", contextSettings);
    let width = 0;
    let line = "";
    let lines = "";
    const cache = /* @__PURE__ */ Object.create(null);
    const { letterSpacing, whiteSpace } = style;
    const collapseSpaces = _TextMetrics.collapseSpaces(whiteSpace);
    const collapseNewlines = _TextMetrics.collapseNewlines(whiteSpace);
    let canPrependSpaces = !collapseSpaces;
    const wordWrapWidth = style.wordWrapWidth + letterSpacing;
    const tokens = _TextMetrics.tokenize(text);
    for (let i = 0; i < tokens.length; i++) {
      let token = tokens[i];
      if (_TextMetrics.isNewline(token)) {
        if (!collapseNewlines) {
          lines += _TextMetrics.addLine(line);
          canPrependSpaces = !collapseSpaces;
          line = "";
          width = 0;
          continue;
        }
        token = " ";
      }
      if (collapseSpaces) {
        const currIsBreakingSpace = _TextMetrics.isBreakingSpace(token);
        const lastIsBreakingSpace = _TextMetrics.isBreakingSpace(line[line.length - 1]);
        if (currIsBreakingSpace && lastIsBreakingSpace) {
          continue;
        }
      }
      const tokenWidth = _TextMetrics.getFromCache(token, letterSpacing, cache, context);
      if (tokenWidth > wordWrapWidth) {
        if (line !== "") {
          lines += _TextMetrics.addLine(line);
          line = "";
          width = 0;
        }
        if (_TextMetrics.canBreakWords(token, style.breakWords)) {
          const characters = _TextMetrics.wordWrapSplit(token);
          for (let j = 0; j < characters.length; j++) {
            let char = characters[j];
            let lastChar = char;
            let k = 1;
            while (characters[j + k]) {
              const nextChar = characters[j + k];
              if (!_TextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {
                char += nextChar;
              } else {
                break;
              }
              lastChar = nextChar;
              k++;
            }
            j += k - 1;
            const characterWidth = _TextMetrics.getFromCache(char, letterSpacing, cache, context);
            if (characterWidth + width > wordWrapWidth) {
              lines += _TextMetrics.addLine(line);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
            line += char;
            width += characterWidth;
          }
        } else {
          if (line.length > 0) {
            lines += _TextMetrics.addLine(line);
            line = "";
            width = 0;
          }
          const isLastToken = i === tokens.length - 1;
          lines += _TextMetrics.addLine(token, !isLastToken);
          canPrependSpaces = false;
          line = "";
          width = 0;
        }
      } else {
        if (tokenWidth + width > wordWrapWidth) {
          canPrependSpaces = false;
          lines += _TextMetrics.addLine(line);
          line = "";
          width = 0;
        }
        if (line.length > 0 || !_TextMetrics.isBreakingSpace(token) || canPrependSpaces) {
          line += token;
          width += tokenWidth;
        }
      }
    }
    lines += _TextMetrics.addLine(line, false);
    return lines;
  }
  static addLine(line, newLine = true) {
    line = _TextMetrics.trimRight(line);
    line = newLine ? `${line}
` : line;
    return line;
  }
  static getFromCache(key, letterSpacing, cache, context) {
    let width = cache[key];
    if (typeof width !== "number") {
      width = _TextMetrics._measureText(key, letterSpacing, context) + letterSpacing;
      cache[key] = width;
    }
    return width;
  }
  static collapseSpaces(whiteSpace) {
    return whiteSpace === "normal" || whiteSpace === "pre-line";
  }
  static collapseNewlines(whiteSpace) {
    return whiteSpace === "normal";
  }
  static trimRight(text) {
    if (typeof text !== "string") {
      return "";
    }
    for (let i = text.length - 1; i >= 0; i--) {
      const char = text[i];
      if (!_TextMetrics.isBreakingSpace(char)) {
        break;
      }
      text = text.slice(0, -1);
    }
    return text;
  }
  static isNewline(char) {
    if (typeof char !== "string") {
      return false;
    }
    return _TextMetrics._newlines.includes(char.charCodeAt(0));
  }
  static isBreakingSpace(char, _nextChar) {
    if (typeof char !== "string") {
      return false;
    }
    return _TextMetrics._breakingSpaces.includes(char.charCodeAt(0));
  }
  static tokenize(text) {
    const tokens = [];
    let token = "";
    if (typeof text !== "string") {
      return tokens;
    }
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      const nextChar = text[i + 1];
      if (_TextMetrics.isBreakingSpace(char, nextChar) || _TextMetrics.isNewline(char)) {
        if (token !== "") {
          tokens.push(token);
          token = "";
        }
        tokens.push(char);
        continue;
      }
      token += char;
    }
    if (token !== "") {
      tokens.push(token);
    }
    return tokens;
  }
  static canBreakWords(_token, breakWords) {
    return breakWords;
  }
  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
    return true;
  }
  static wordWrapSplit(token) {
    return _TextMetrics.graphemeSegmenter(token);
  }
  static measureFont(font) {
    if (_TextMetrics._fonts[font]) {
      return _TextMetrics._fonts[font];
    }
    const properties = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    };
    const canvas = _TextMetrics._canvas;
    const context = _TextMetrics._context;
    context.font = font;
    const metricsString = _TextMetrics.METRICS_STRING + _TextMetrics.BASELINE_SYMBOL;
    const width = Math.ceil(context.measureText(metricsString).width);
    let baseline = Math.ceil(context.measureText(_TextMetrics.BASELINE_SYMBOL).width);
    const height = Math.ceil(_TextMetrics.HEIGHT_MULTIPLIER * baseline);
    baseline = baseline * _TextMetrics.BASELINE_MULTIPLIER | 0;
    if (width === 0 || height === 0) {
      _TextMetrics._fonts[font] = properties;
      return properties;
    }
    canvas.width = width;
    canvas.height = height;
    context.fillStyle = "#f00";
    context.fillRect(0, 0, width, height);
    context.font = font;
    context.textBaseline = "alphabetic";
    context.fillStyle = "#000";
    context.fillText(metricsString, 0, baseline);
    const imagedata = context.getImageData(0, 0, width, height).data;
    const pixels = imagedata.length;
    const line = width * 4;
    let i = 0;
    let idx = 0;
    let stop = false;
    for (i = 0; i < baseline; ++i) {
      for (let j = 0; j < line; j += 4) {
        if (imagedata[idx + j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx += line;
      } else {
        break;
      }
    }
    properties.ascent = baseline - i;
    idx = pixels - line;
    stop = false;
    for (i = height; i > baseline; --i) {
      for (let j = 0; j < line; j += 4) {
        if (imagedata[idx + j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx -= line;
      } else {
        break;
      }
    }
    properties.descent = i - baseline;
    properties.fontSize = properties.ascent + properties.descent;
    _TextMetrics._fonts[font] = properties;
    return properties;
  }
  static clearMetrics(font = "") {
    if (font) {
      delete _TextMetrics._fonts[font];
    } else {
      _TextMetrics._fonts = {};
    }
  }
  static get _canvas() {
    if (!_TextMetrics.__canvas) {
      let canvas;
      try {
        const c = new OffscreenCanvas(0, 0);
        const context = c.getContext("2d", contextSettings);
        if (context?.measureText) {
          _TextMetrics.__canvas = c;
          return c;
        }
        canvas = core.settings.ADAPTER.createCanvas();
      } catch (ex) {
        canvas = core.settings.ADAPTER.createCanvas();
      }
      canvas.width = canvas.height = 10;
      _TextMetrics.__canvas = canvas;
    }
    return _TextMetrics.__canvas;
  }
  static get _context() {
    if (!_TextMetrics.__context) {
      _TextMetrics.__context = _TextMetrics._canvas.getContext("2d", contextSettings);
    }
    return _TextMetrics.__context;
  }
};
let TextMetrics = _TextMetrics;
TextMetrics.METRICS_STRING = "|\xC9q\xC5";
TextMetrics.BASELINE_SYMBOL = "M";
TextMetrics.BASELINE_MULTIPLIER = 1.4;
TextMetrics.HEIGHT_MULTIPLIER = 2;
TextMetrics.graphemeSegmenter = (() => {
  if (typeof Intl?.Segmenter === "function") {
    const segmenter = new Intl.Segmenter();
    return (s) => [...segmenter.segment(s)].map((x) => x.segment);
  }
  return (s) => [...s];
})();
TextMetrics.experimentalLetterSpacing = false;
TextMetrics._fonts = {};
TextMetrics._newlines = [
  10,
  13
];
TextMetrics._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];

exports.TextMetrics = TextMetrics;
//# sourceMappingURL=TextMetrics.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text/lib/TextStyle.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text/lib/TextStyle.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(/*! ./const.js */ "./node_modules/pixi.js/node_modules/@pixi/text/lib/const.js");
var core = __webpack_require__(/*! @pixi/core */ "./node_modules/pixi.js/node_modules/@pixi/core/lib/index.js");

const genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
const _TextStyle = class {
  constructor(style) {
    this.styleID = 0;
    this.reset();
    deepCopyProperties(this, style, style);
  }
  clone() {
    const clonedProperties = {};
    deepCopyProperties(clonedProperties, this, _TextStyle.defaultStyle);
    return new _TextStyle(clonedProperties);
  }
  reset() {
    deepCopyProperties(this, _TextStyle.defaultStyle, _TextStyle.defaultStyle);
  }
  get align() {
    return this._align;
  }
  set align(align) {
    if (this._align !== align) {
      this._align = align;
      this.styleID++;
    }
  }
  get breakWords() {
    return this._breakWords;
  }
  set breakWords(breakWords) {
    if (this._breakWords !== breakWords) {
      this._breakWords = breakWords;
      this.styleID++;
    }
  }
  get dropShadow() {
    return this._dropShadow;
  }
  set dropShadow(dropShadow) {
    if (this._dropShadow !== dropShadow) {
      this._dropShadow = dropShadow;
      this.styleID++;
    }
  }
  get dropShadowAlpha() {
    return this._dropShadowAlpha;
  }
  set dropShadowAlpha(dropShadowAlpha) {
    if (this._dropShadowAlpha !== dropShadowAlpha) {
      this._dropShadowAlpha = dropShadowAlpha;
      this.styleID++;
    }
  }
  get dropShadowAngle() {
    return this._dropShadowAngle;
  }
  set dropShadowAngle(dropShadowAngle) {
    if (this._dropShadowAngle !== dropShadowAngle) {
      this._dropShadowAngle = dropShadowAngle;
      this.styleID++;
    }
  }
  get dropShadowBlur() {
    return this._dropShadowBlur;
  }
  set dropShadowBlur(dropShadowBlur) {
    if (this._dropShadowBlur !== dropShadowBlur) {
      this._dropShadowBlur = dropShadowBlur;
      this.styleID++;
    }
  }
  get dropShadowColor() {
    return this._dropShadowColor;
  }
  set dropShadowColor(dropShadowColor) {
    const outputColor = getColor(dropShadowColor);
    if (this._dropShadowColor !== outputColor) {
      this._dropShadowColor = outputColor;
      this.styleID++;
    }
  }
  get dropShadowDistance() {
    return this._dropShadowDistance;
  }
  set dropShadowDistance(dropShadowDistance) {
    if (this._dropShadowDistance !== dropShadowDistance) {
      this._dropShadowDistance = dropShadowDistance;
      this.styleID++;
    }
  }
  get fill() {
    return this._fill;
  }
  set fill(fill) {
    const outputColor = getColor(fill);
    if (this._fill !== outputColor) {
      this._fill = outputColor;
      this.styleID++;
    }
  }
  get fillGradientType() {
    return this._fillGradientType;
  }
  set fillGradientType(fillGradientType) {
    if (this._fillGradientType !== fillGradientType) {
      this._fillGradientType = fillGradientType;
      this.styleID++;
    }
  }
  get fillGradientStops() {
    return this._fillGradientStops;
  }
  set fillGradientStops(fillGradientStops) {
    if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
      this._fillGradientStops = fillGradientStops;
      this.styleID++;
    }
  }
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(fontFamily) {
    if (this.fontFamily !== fontFamily) {
      this._fontFamily = fontFamily;
      this.styleID++;
    }
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(fontSize) {
    if (this._fontSize !== fontSize) {
      this._fontSize = fontSize;
      this.styleID++;
    }
  }
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(fontStyle) {
    if (this._fontStyle !== fontStyle) {
      this._fontStyle = fontStyle;
      this.styleID++;
    }
  }
  get fontVariant() {
    return this._fontVariant;
  }
  set fontVariant(fontVariant) {
    if (this._fontVariant !== fontVariant) {
      this._fontVariant = fontVariant;
      this.styleID++;
    }
  }
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(fontWeight) {
    if (this._fontWeight !== fontWeight) {
      this._fontWeight = fontWeight;
      this.styleID++;
    }
  }
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(letterSpacing) {
    if (this._letterSpacing !== letterSpacing) {
      this._letterSpacing = letterSpacing;
      this.styleID++;
    }
  }
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(lineHeight) {
    if (this._lineHeight !== lineHeight) {
      this._lineHeight = lineHeight;
      this.styleID++;
    }
  }
  get leading() {
    return this._leading;
  }
  set leading(leading) {
    if (this._leading !== leading) {
      this._leading = leading;
      this.styleID++;
    }
  }
  get lineJoin() {
    return this._lineJoin;
  }
  set lineJoin(lineJoin) {
    if (this._lineJoin !== lineJoin) {
      this._lineJoin = lineJoin;
      this.styleID++;
    }
  }
  get miterLimit() {
    return this._miterLimit;
  }
  set miterLimit(miterLimit) {
    if (this._miterLimit !== miterLimit) {
      this._miterLimit = miterLimit;
      this.styleID++;
    }
  }
  get padding() {
    return this._padding;
  }
  set padding(padding) {
    if (this._padding !== padding) {
      this._padding = padding;
      this.styleID++;
    }
  }
  get stroke() {
    return this._stroke;
  }
  set stroke(stroke) {
    const outputColor = getColor(stroke);
    if (this._stroke !== outputColor) {
      this._stroke = outputColor;
      this.styleID++;
    }
  }
  get strokeThickness() {
    return this._strokeThickness;
  }
  set strokeThickness(strokeThickness) {
    if (this._strokeThickness !== strokeThickness) {
      this._strokeThickness = strokeThickness;
      this.styleID++;
    }
  }
  get textBaseline() {
    return this._textBaseline;
  }
  set textBaseline(textBaseline) {
    if (this._textBaseline !== textBaseline) {
      this._textBaseline = textBaseline;
      this.styleID++;
    }
  }
  get trim() {
    return this._trim;
  }
  set trim(trim) {
    if (this._trim !== trim) {
      this._trim = trim;
      this.styleID++;
    }
  }
  get whiteSpace() {
    return this._whiteSpace;
  }
  set whiteSpace(whiteSpace) {
    if (this._whiteSpace !== whiteSpace) {
      this._whiteSpace = whiteSpace;
      this.styleID++;
    }
  }
  get wordWrap() {
    return this._wordWrap;
  }
  set wordWrap(wordWrap) {
    if (this._wordWrap !== wordWrap) {
      this._wordWrap = wordWrap;
      this.styleID++;
    }
  }
  get wordWrapWidth() {
    return this._wordWrapWidth;
  }
  set wordWrapWidth(wordWrapWidth) {
    if (this._wordWrapWidth !== wordWrapWidth) {
      this._wordWrapWidth = wordWrapWidth;
      this.styleID++;
    }
  }
  toFontString() {
    const fontSizeString = typeof this.fontSize === "number" ? `${this.fontSize}px` : this.fontSize;
    let fontFamilies = this.fontFamily;
    if (!Array.isArray(this.fontFamily)) {
      fontFamilies = this.fontFamily.split(",");
    }
    for (let i = fontFamilies.length - 1; i >= 0; i--) {
      let fontFamily = fontFamilies[i].trim();
      if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
        fontFamily = `"${fontFamily}"`;
      }
      fontFamilies[i] = fontFamily;
    }
    return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
  }
};
let TextStyle = _TextStyle;
TextStyle.defaultStyle = {
  align: "left",
  breakWords: false,
  dropShadow: false,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: _const.TEXT_GRADIENT.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  leading: 0,
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: false,
  whiteSpace: "pre",
  wordWrap: false,
  wordWrapWidth: 100
};
function getColor(color) {
  const temp = core.Color.shared;
  if (!Array.isArray(color)) {
    return temp.setValue(color).toHex();
  } else {
    return color.map((c) => temp.setValue(c).toHex());
  }
}
function areArraysEqual(array1, array2) {
  if (!Array.isArray(array1) || !Array.isArray(array2)) {
    return false;
  }
  if (array1.length !== array2.length) {
    return false;
  }
  for (let i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function deepCopyProperties(target, source, propertyObj) {
  for (const prop in propertyObj) {
    if (Array.isArray(source[prop])) {
      target[prop] = source[prop].slice();
    } else {
      target[prop] = source[prop];
    }
  }
}

exports.TextStyle = TextStyle;
//# sourceMappingURL=TextStyle.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text/lib/const.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text/lib/const.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var TEXT_GRADIENT = /* @__PURE__ */ ((TEXT_GRADIENT2) => {
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
  return TEXT_GRADIENT2;
})(TEXT_GRADIENT || {});

exports.TEXT_GRADIENT = TEXT_GRADIENT;
//# sourceMappingURL=const.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/text/lib/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/text/lib/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(/*! ./const.js */ "./node_modules/pixi.js/node_modules/@pixi/text/lib/const.js");
var Text = __webpack_require__(/*! ./Text.js */ "./node_modules/pixi.js/node_modules/@pixi/text/lib/Text.js");
var TextMetrics = __webpack_require__(/*! ./TextMetrics.js */ "./node_modules/pixi.js/node_modules/@pixi/text/lib/TextMetrics.js");
var TextStyle = __webpack_require__(/*! ./TextStyle.js */ "./node_modules/pixi.js/node_modules/@pixi/text/lib/TextStyle.js");



exports.TEXT_GRADIENT = _const.TEXT_GRADIENT;
exports.Text = Text.Text;
exports.TextMetrics = TextMetrics.TextMetrics;
exports.TextStyle = TextStyle.TextStyle;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/ticker/lib/Ticker.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/ticker/lib/Ticker.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(/*! ./const.js */ "./node_modules/pixi.js/node_modules/@pixi/ticker/lib/const.js");
var TickerListener = __webpack_require__(/*! ./TickerListener.js */ "./node_modules/pixi.js/node_modules/@pixi/ticker/lib/TickerListener.js");

const _Ticker = class {
  constructor() {
    this.autoStart = false;
    this.deltaTime = 1;
    this.lastTime = -1;
    this.speed = 1;
    this.started = false;
    this._requestId = null;
    this._maxElapsedMS = 100;
    this._minElapsedMS = 0;
    this._protected = false;
    this._lastFrame = -1;
    this._head = new TickerListener.TickerListener(null, null, Infinity);
    this.deltaMS = 1 / _Ticker.targetFPMS;
    this.elapsedMS = 1 / _Ticker.targetFPMS;
    this._tick = (time) => {
      this._requestId = null;
      if (this.started) {
        this.update(time);
        if (this.started && this._requestId === null && this._head.next) {
          this._requestId = requestAnimationFrame(this._tick);
        }
      }
    };
  }
  _requestIfNeeded() {
    if (this._requestId === null && this._head.next) {
      this.lastTime = performance.now();
      this._lastFrame = this.lastTime;
      this._requestId = requestAnimationFrame(this._tick);
    }
  }
  _cancelIfNeeded() {
    if (this._requestId !== null) {
      cancelAnimationFrame(this._requestId);
      this._requestId = null;
    }
  }
  _startIfPossible() {
    if (this.started) {
      this._requestIfNeeded();
    } else if (this.autoStart) {
      this.start();
    }
  }
  add(fn, context, priority = _const.UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener.TickerListener(fn, context, priority));
  }
  addOnce(fn, context, priority = _const.UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener.TickerListener(fn, context, priority, true));
  }
  _addListener(listener) {
    let current = this._head.next;
    let previous = this._head;
    if (!current) {
      listener.connect(previous);
    } else {
      while (current) {
        if (listener.priority > current.priority) {
          listener.connect(previous);
          break;
        }
        previous = current;
        current = current.next;
      }
      if (!listener.previous) {
        listener.connect(previous);
      }
    }
    this._startIfPossible();
    return this;
  }
  remove(fn, context) {
    let listener = this._head.next;
    while (listener) {
      if (listener.match(fn, context)) {
        listener = listener.destroy();
      } else {
        listener = listener.next;
      }
    }
    if (!this._head.next) {
      this._cancelIfNeeded();
    }
    return this;
  }
  get count() {
    if (!this._head) {
      return 0;
    }
    let count = 0;
    let current = this._head;
    while (current = current.next) {
      count++;
    }
    return count;
  }
  start() {
    if (!this.started) {
      this.started = true;
      this._requestIfNeeded();
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this._cancelIfNeeded();
    }
  }
  destroy() {
    if (!this._protected) {
      this.stop();
      let listener = this._head.next;
      while (listener) {
        listener = listener.destroy(true);
      }
      this._head.destroy();
      this._head = null;
    }
  }
  update(currentTime = performance.now()) {
    let elapsedMS;
    if (currentTime > this.lastTime) {
      elapsedMS = this.elapsedMS = currentTime - this.lastTime;
      if (elapsedMS > this._maxElapsedMS) {
        elapsedMS = this._maxElapsedMS;
      }
      elapsedMS *= this.speed;
      if (this._minElapsedMS) {
        const delta = currentTime - this._lastFrame | 0;
        if (delta < this._minElapsedMS) {
          return;
        }
        this._lastFrame = currentTime - delta % this._minElapsedMS;
      }
      this.deltaMS = elapsedMS;
      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;
      const head = this._head;
      let listener = head.next;
      while (listener) {
        listener = listener.emit(this.deltaTime);
      }
      if (!head.next) {
        this._cancelIfNeeded();
      }
    } else {
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    }
    this.lastTime = currentTime;
  }
  get FPS() {
    return 1e3 / this.elapsedMS;
  }
  get minFPS() {
    return 1e3 / this._maxElapsedMS;
  }
  set minFPS(fps) {
    const minFPS = Math.min(this.maxFPS, fps);
    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);
    this._maxElapsedMS = 1 / minFPMS;
  }
  get maxFPS() {
    if (this._minElapsedMS) {
      return Math.round(1e3 / this._minElapsedMS);
    }
    return 0;
  }
  set maxFPS(fps) {
    if (fps === 0) {
      this._minElapsedMS = 0;
    } else {
      const maxFPS = Math.max(this.minFPS, fps);
      this._minElapsedMS = 1 / (maxFPS / 1e3);
    }
  }
  static get shared() {
    if (!_Ticker._shared) {
      const shared = _Ticker._shared = new _Ticker();
      shared.autoStart = true;
      shared._protected = true;
    }
    return _Ticker._shared;
  }
  static get system() {
    if (!_Ticker._system) {
      const system = _Ticker._system = new _Ticker();
      system.autoStart = true;
      system._protected = true;
    }
    return _Ticker._system;
  }
};
let Ticker = _Ticker;
Ticker.targetFPMS = 0.06;

exports.Ticker = Ticker;
//# sourceMappingURL=Ticker.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/ticker/lib/TickerListener.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/ticker/lib/TickerListener.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class TickerListener {
  constructor(fn, context = null, priority = 0, once = false) {
    this.next = null;
    this.previous = null;
    this._destroyed = false;
    this.fn = fn;
    this.context = context;
    this.priority = priority;
    this.once = once;
  }
  match(fn, context = null) {
    return this.fn === fn && this.context === context;
  }
  emit(deltaTime) {
    if (this.fn) {
      if (this.context) {
        this.fn.call(this.context, deltaTime);
      } else {
        this.fn(deltaTime);
      }
    }
    const redirect = this.next;
    if (this.once) {
      this.destroy(true);
    }
    if (this._destroyed) {
      this.next = null;
    }
    return redirect;
  }
  connect(previous) {
    this.previous = previous;
    if (previous.next) {
      previous.next.previous = this;
    }
    this.next = previous.next;
    previous.next = this;
  }
  destroy(hard = false) {
    this._destroyed = true;
    this.fn = null;
    this.context = null;
    if (this.previous) {
      this.previous.next = this.next;
    }
    if (this.next) {
      this.next.previous = this.previous;
    }
    const redirect = this.next;
    this.next = hard ? null : redirect;
    this.previous = null;
    return redirect;
  }
}

exports.TickerListener = TickerListener;
//# sourceMappingURL=TickerListener.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/ticker/lib/TickerPlugin.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/ticker/lib/TickerPlugin.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/pixi.js/node_modules/@pixi/extensions/lib/index.js");
var _const = __webpack_require__(/*! ./const.js */ "./node_modules/pixi.js/node_modules/@pixi/ticker/lib/const.js");
var Ticker = __webpack_require__(/*! ./Ticker.js */ "./node_modules/pixi.js/node_modules/@pixi/ticker/lib/Ticker.js");

class TickerPlugin {
  static init(options) {
    options = Object.assign({
      autoStart: true,
      sharedTicker: false
    }, options);
    Object.defineProperty(this, "ticker", {
      set(ticker) {
        if (this._ticker) {
          this._ticker.remove(this.render, this);
        }
        this._ticker = ticker;
        if (ticker) {
          ticker.add(this.render, this, _const.UPDATE_PRIORITY.LOW);
        }
      },
      get() {
        return this._ticker;
      }
    });
    this.stop = () => {
      this._ticker.stop();
    };
    this.start = () => {
      this._ticker.start();
    };
    this._ticker = null;
    this.ticker = options.sharedTicker ? Ticker.Ticker.shared : new Ticker.Ticker();
    if (options.autoStart) {
      this.start();
    }
  }
  static destroy() {
    if (this._ticker) {
      const oldTicker = this._ticker;
      this.ticker = null;
      oldTicker.destroy();
    }
  }
}
TickerPlugin.extension = extensions.ExtensionType.Application;
extensions.extensions.add(TickerPlugin);

exports.TickerPlugin = TickerPlugin;
//# sourceMappingURL=TickerPlugin.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/ticker/lib/const.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/ticker/lib/const.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
  return UPDATE_PRIORITY2;
})(UPDATE_PRIORITY || {});

exports.UPDATE_PRIORITY = UPDATE_PRIORITY;
//# sourceMappingURL=const.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/ticker/lib/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/ticker/lib/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(/*! ./settings.js */ "./node_modules/pixi.js/node_modules/@pixi/ticker/lib/settings.js");
var _const = __webpack_require__(/*! ./const.js */ "./node_modules/pixi.js/node_modules/@pixi/ticker/lib/const.js");
var Ticker = __webpack_require__(/*! ./Ticker.js */ "./node_modules/pixi.js/node_modules/@pixi/ticker/lib/Ticker.js");
var TickerPlugin = __webpack_require__(/*! ./TickerPlugin.js */ "./node_modules/pixi.js/node_modules/@pixi/ticker/lib/TickerPlugin.js");



exports.UPDATE_PRIORITY = _const.UPDATE_PRIORITY;
exports.Ticker = Ticker.Ticker;
exports.TickerPlugin = TickerPlugin.TickerPlugin;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/ticker/lib/settings.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/ticker/lib/settings.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");
var utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/index.js");
var Ticker = __webpack_require__(/*! ./Ticker.js */ "./node_modules/pixi.js/node_modules/@pixi/ticker/lib/Ticker.js");

Object.defineProperties(settings.settings, {
  TARGET_FPMS: {
    get() {
      return Ticker.Ticker.targetFPMS;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS");
      Ticker.Ticker.targetFPMS = value;
    }
  }
});

Object.defineProperty(exports, "settings", ({
    enumerable: true,
    get: function () { return settings.settings; }
}));
//# sourceMappingURL=settings.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/browser/hello.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/browser/hello.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var deprecation = __webpack_require__(/*! ../logging/deprecation.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/logging/deprecation.js");

function skipHello() {
  deprecation.deprecation("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello");
}
function sayHello() {
  deprecation.deprecation("7.0.0", `sayHello is deprecated, please use Renderer's "hello" option`);
}

exports.sayHello = sayHello;
exports.skipHello = skipHello;
//# sourceMappingURL=hello.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/browser/isWebGLSupported.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/browser/isWebGLSupported.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(/*! ../settings.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/settings.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");

let supported;
function isWebGLSupported() {
  if (typeof supported === "undefined") {
    supported = function supported2() {
      const contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: settings.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
      };
      try {
        if (!settings.settings.ADAPTER.getWebGLRenderingContext()) {
          return false;
        }
        const canvas = settings.settings.ADAPTER.createCanvas();
        let gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);
        const success = !!gl?.getContextAttributes()?.stencil;
        if (gl) {
          const loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (e) {
        return false;
      }
    }();
  }
  return supported;
}

exports.isWebGLSupported = isWebGLSupported;
//# sourceMappingURL=isWebGLSupported.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/color/hex.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/color/hex.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var color = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.js");
var deprecation = __webpack_require__(/*! ../logging/deprecation.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/logging/deprecation.js");

function hex2rgb(hex, out = []) {
  deprecation.deprecation("7.2.0", "utils.hex2rgb is deprecated, use Color#toRgbArray instead");
  return color.Color.shared.setValue(hex).toRgbArray(out);
}
function hex2string(hex) {
  deprecation.deprecation("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead");
  return color.Color.shared.setValue(hex).toHex();
}
function string2hex(string) {
  deprecation.deprecation("7.2.0", "utils.string2hex is deprecated, use Color#toNumber instead");
  return color.Color.shared.setValue(string).toNumber();
}
function rgb2hex(rgb) {
  deprecation.deprecation("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead");
  return color.Color.shared.setValue(rgb).toNumber();
}

exports.hex2rgb = hex2rgb;
exports.hex2string = hex2string;
exports.rgb2hex = rgb2hex;
exports.string2hex = string2hex;
//# sourceMappingURL=hex.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/color/premultiply.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/color/premultiply.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var color = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.js");
var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/pixi.js/node_modules/@pixi/constants/lib/index.js");
var deprecation = __webpack_require__(/*! ../logging/deprecation.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/logging/deprecation.js");

function mapPremultipliedBlendModes() {
  const pm = [];
  const npm = [];
  for (let i = 0; i < 32; i++) {
    pm[i] = i;
    npm[i] = i;
  }
  pm[constants.BLEND_MODES.NORMAL_NPM] = constants.BLEND_MODES.NORMAL;
  pm[constants.BLEND_MODES.ADD_NPM] = constants.BLEND_MODES.ADD;
  pm[constants.BLEND_MODES.SCREEN_NPM] = constants.BLEND_MODES.SCREEN;
  npm[constants.BLEND_MODES.NORMAL] = constants.BLEND_MODES.NORMAL_NPM;
  npm[constants.BLEND_MODES.ADD] = constants.BLEND_MODES.ADD_NPM;
  npm[constants.BLEND_MODES.SCREEN] = constants.BLEND_MODES.SCREEN_NPM;
  const array = [];
  array.push(npm);
  array.push(pm);
  return array;
}
const premultiplyBlendMode = mapPremultipliedBlendModes();
function correctBlendMode(blendMode, premultiplied) {
  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
}
function premultiplyRgba(rgb, alpha, out, premultiply = true) {
  deprecation.deprecation("7.2.0", `utils.premultiplyRgba has moved to Color.premultiply`);
  return color.Color.shared.setValue(rgb).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));
}
function premultiplyTint(tint, alpha) {
  deprecation.deprecation("7.2.0", `utils.premultiplyTint has moved to Color.toPremultiplied`);
  return color.Color.shared.setValue(tint).toPremultiplied(alpha);
}
function premultiplyTintToRgba(tint, alpha, out, premultiply = true) {
  deprecation.deprecation("7.2.0", `utils.premultiplyTintToRgba has moved to Color.premultiply`);
  return color.Color.shared.setValue(tint).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));
}

exports.correctBlendMode = correctBlendMode;
exports.premultiplyBlendMode = premultiplyBlendMode;
exports.premultiplyRgba = premultiplyRgba;
exports.premultiplyTint = premultiplyTint;
exports.premultiplyTintToRgba = premultiplyTintToRgba;
//# sourceMappingURL=premultiply.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/const.js":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/const.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;

exports.DATA_URI = DATA_URI;
//# sourceMappingURL=const.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/createIndicesForQuads.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/createIndicesForQuads.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function createIndicesForQuads(size, outBuffer = null) {
  const totalIndices = size * 6;
  outBuffer = outBuffer || new Uint16Array(totalIndices);
  if (outBuffer.length !== totalIndices) {
    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
  }
  for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
    outBuffer[i + 0] = j + 0;
    outBuffer[i + 1] = j + 1;
    outBuffer[i + 2] = j + 2;
    outBuffer[i + 3] = j + 0;
    outBuffer[i + 4] = j + 2;
    outBuffer[i + 5] = j + 3;
  }
  return outBuffer;
}

exports.createIndicesForQuads = createIndicesForQuads;
//# sourceMappingURL=createIndicesForQuads.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/getBufferType.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/getBufferType.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function getBufferType(array) {
  if (array.BYTES_PER_ELEMENT === 4) {
    if (array instanceof Float32Array) {
      return "Float32Array";
    } else if (array instanceof Uint32Array) {
      return "Uint32Array";
    }
    return "Int32Array";
  } else if (array.BYTES_PER_ELEMENT === 2) {
    if (array instanceof Uint16Array) {
      return "Uint16Array";
    }
  } else if (array.BYTES_PER_ELEMENT === 1) {
    if (array instanceof Uint8Array) {
      return "Uint8Array";
    }
  }
  return null;
}

exports.getBufferType = getBufferType;
//# sourceMappingURL=getBufferType.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/interleaveTypedArrays.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/interleaveTypedArrays.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var getBufferType = __webpack_require__(/*! ./getBufferType.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/getBufferType.js");

const map = { Float32Array, Uint32Array, Int32Array, Uint8Array };
function interleaveTypedArrays(arrays, sizes) {
  let outSize = 0;
  let stride = 0;
  const views = {};
  for (let i = 0; i < arrays.length; i++) {
    stride += sizes[i];
    outSize += arrays[i].length;
  }
  const buffer = new ArrayBuffer(outSize * 4);
  let out = null;
  let littleOffset = 0;
  for (let i = 0; i < arrays.length; i++) {
    const size = sizes[i];
    const array = arrays[i];
    const type = getBufferType.getBufferType(array);
    if (!views[type]) {
      views[type] = new map[type](buffer);
    }
    out = views[type];
    for (let j = 0; j < array.length; j++) {
      const indexStart = (j / size | 0) * stride + littleOffset;
      const index = j % size;
      out[indexStart + index] = array[j];
    }
    littleOffset += size;
  }
  return new Float32Array(buffer);
}

exports.interleaveTypedArrays = interleaveTypedArrays;
//# sourceMappingURL=interleaveTypedArrays.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/pow2.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/pow2.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function nextPow2(v) {
  v += v === 0 ? 1 : 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}
function isPow2(v) {
  return !(v & v - 1) && !!v;
}
function log2(v) {
  let r = (v > 65535 ? 1 : 0) << 4;
  v >>>= r;
  let shift = (v > 255 ? 1 : 0) << 3;
  v >>>= shift;
  r |= shift;
  shift = (v > 15 ? 1 : 0) << 2;
  v >>>= shift;
  r |= shift;
  shift = (v > 3 ? 1 : 0) << 1;
  v >>>= shift;
  r |= shift;
  return r | v >> 1;
}

exports.isPow2 = isPow2;
exports.log2 = log2;
exports.nextPow2 = nextPow2;
//# sourceMappingURL=pow2.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/removeItems.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/removeItems.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function removeItems(arr, startIdx, removeCount) {
  const length = arr.length;
  let i;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  const len = length - removeCount;
  for (i = startIdx; i < len; ++i) {
    arr[i] = arr[i + removeCount];
  }
  arr.length = len;
}

exports.removeItems = removeItems;
//# sourceMappingURL=removeItems.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/sign.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/sign.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function sign(n) {
  if (n === 0)
    return 0;
  return n < 0 ? -1 : 1;
}

exports.sign = sign;
//# sourceMappingURL=sign.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/uid.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/uid.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

let nextUid = 0;
function uid() {
  return ++nextUid;
}

exports.uid = uid;
//# sourceMappingURL=uid.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(/*! ./settings.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/settings.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");
var eventemitter3 = __webpack_require__(/*! eventemitter3 */ "./node_modules/pixi.js/node_modules/eventemitter3/index.js");
var earcut = __webpack_require__(/*! earcut */ "./node_modules/earcut/src/earcut.js");
var url = __webpack_require__(/*! ./url.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/url.js");
var path = __webpack_require__(/*! ./path.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/path.js");
var hello = __webpack_require__(/*! ./browser/hello.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/browser/hello.js");
var isWebGLSupported = __webpack_require__(/*! ./browser/isWebGLSupported.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/browser/isWebGLSupported.js");
var hex = __webpack_require__(/*! ./color/hex.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/color/hex.js");
var premultiply = __webpack_require__(/*! ./color/premultiply.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/color/premultiply.js");
var _const = __webpack_require__(/*! ./const.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/const.js");
var createIndicesForQuads = __webpack_require__(/*! ./data/createIndicesForQuads.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/createIndicesForQuads.js");
var getBufferType = __webpack_require__(/*! ./data/getBufferType.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/getBufferType.js");
var interleaveTypedArrays = __webpack_require__(/*! ./data/interleaveTypedArrays.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/interleaveTypedArrays.js");
var pow2 = __webpack_require__(/*! ./data/pow2.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/pow2.js");
var removeItems = __webpack_require__(/*! ./data/removeItems.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/removeItems.js");
var sign = __webpack_require__(/*! ./data/sign.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/sign.js");
var uid = __webpack_require__(/*! ./data/uid.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/data/uid.js");
var deprecation = __webpack_require__(/*! ./logging/deprecation.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/logging/deprecation.js");
var BoundingBox = __webpack_require__(/*! ./media/BoundingBox.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/media/BoundingBox.js");
var caches = __webpack_require__(/*! ./media/caches.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/media/caches.js");
var CanvasRenderTarget = __webpack_require__(/*! ./media/CanvasRenderTarget.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/media/CanvasRenderTarget.js");
var getCanvasBoundingBox = __webpack_require__(/*! ./media/getCanvasBoundingBox.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.js");
var trimCanvas = __webpack_require__(/*! ./media/trimCanvas.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/media/trimCanvas.js");
var decomposeDataUri = __webpack_require__(/*! ./network/decomposeDataUri.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/network/decomposeDataUri.js");
var determineCrossOrigin = __webpack_require__(/*! ./network/determineCrossOrigin.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/network/determineCrossOrigin.js");
var getResolutionOfUrl = __webpack_require__(/*! ./network/getResolutionOfUrl.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/network/getResolutionOfUrl.js");
__webpack_require__(/*! ./types/index.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/types/index.js");

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var eventemitter3__default = /*#__PURE__*/_interopDefaultLegacy(eventemitter3);
var earcut__default = /*#__PURE__*/_interopDefaultLegacy(earcut);



Object.defineProperty(exports, "isMobile", ({
	enumerable: true,
	get: function () { return settings.isMobile; }
}));
Object.defineProperty(exports, "EventEmitter", ({
	enumerable: true,
	get: function () { return eventemitter3__default["default"]; }
}));
Object.defineProperty(exports, "earcut", ({
	enumerable: true,
	get: function () { return earcut__default["default"]; }
}));
exports.url = url.url;
exports.path = path.path;
exports.sayHello = hello.sayHello;
exports.skipHello = hello.skipHello;
exports.isWebGLSupported = isWebGLSupported.isWebGLSupported;
exports.hex2rgb = hex.hex2rgb;
exports.hex2string = hex.hex2string;
exports.rgb2hex = hex.rgb2hex;
exports.string2hex = hex.string2hex;
exports.correctBlendMode = premultiply.correctBlendMode;
exports.premultiplyBlendMode = premultiply.premultiplyBlendMode;
exports.premultiplyRgba = premultiply.premultiplyRgba;
exports.premultiplyTint = premultiply.premultiplyTint;
exports.premultiplyTintToRgba = premultiply.premultiplyTintToRgba;
exports.DATA_URI = _const.DATA_URI;
exports.createIndicesForQuads = createIndicesForQuads.createIndicesForQuads;
exports.getBufferType = getBufferType.getBufferType;
exports.interleaveTypedArrays = interleaveTypedArrays.interleaveTypedArrays;
exports.isPow2 = pow2.isPow2;
exports.log2 = pow2.log2;
exports.nextPow2 = pow2.nextPow2;
exports.removeItems = removeItems.removeItems;
exports.sign = sign.sign;
exports.uid = uid.uid;
exports.deprecation = deprecation.deprecation;
exports.BoundingBox = BoundingBox.BoundingBox;
exports.BaseTextureCache = caches.BaseTextureCache;
exports.ProgramCache = caches.ProgramCache;
exports.TextureCache = caches.TextureCache;
exports.clearTextureCache = caches.clearTextureCache;
exports.destroyTextureCache = caches.destroyTextureCache;
exports.CanvasRenderTarget = CanvasRenderTarget.CanvasRenderTarget;
exports.getCanvasBoundingBox = getCanvasBoundingBox.getCanvasBoundingBox;
exports.trimCanvas = trimCanvas.trimCanvas;
exports.decomposeDataUri = decomposeDataUri.decomposeDataUri;
exports.determineCrossOrigin = determineCrossOrigin.determineCrossOrigin;
exports.getResolutionOfUrl = getResolutionOfUrl.getResolutionOfUrl;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/logging/deprecation.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/logging/deprecation.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const warnings = {};
function deprecation(version, message, ignoreDepth = 3) {
  if (warnings[message]) {
    return;
  }
  let stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${message}
Deprecated since v${version}`);
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
      console.warn(stack);
    }
  }
  warnings[message] = true;
}

exports.deprecation = deprecation;
//# sourceMappingURL=deprecation.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/media/BoundingBox.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/media/BoundingBox.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const _BoundingBox = class {
  constructor(left, top, right, bottom) {
    this.left = left;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
  }
  get width() {
    return this.right - this.left;
  }
  get height() {
    return this.bottom - this.top;
  }
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
};
let BoundingBox = _BoundingBox;
BoundingBox.EMPTY = new _BoundingBox(0, 0, 0, 0);

exports.BoundingBox = BoundingBox;
//# sourceMappingURL=BoundingBox.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/media/CanvasRenderTarget.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/media/CanvasRenderTarget.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");

class CanvasRenderTarget {
  constructor(width, height, resolution) {
    this._canvas = settings.settings.ADAPTER.createCanvas();
    this._context = this._canvas.getContext("2d");
    this.resolution = resolution || settings.settings.RESOLUTION;
    this.resize(width, height);
  }
  clear() {
    this._checkDestroyed();
    this._context.setTransform(1, 0, 0, 1, 0, 0);
    this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
  }
  resize(desiredWidth, desiredHeight) {
    this._checkDestroyed();
    this._canvas.width = Math.round(desiredWidth * this.resolution);
    this._canvas.height = Math.round(desiredHeight * this.resolution);
  }
  destroy() {
    this._context = null;
    this._canvas = null;
  }
  get width() {
    this._checkDestroyed();
    return this._canvas.width;
  }
  set width(val) {
    this._checkDestroyed();
    this._canvas.width = Math.round(val);
  }
  get height() {
    this._checkDestroyed();
    return this._canvas.height;
  }
  set height(val) {
    this._checkDestroyed();
    this._canvas.height = Math.round(val);
  }
  get canvas() {
    this._checkDestroyed();
    return this._canvas;
  }
  get context() {
    this._checkDestroyed();
    return this._context;
  }
  _checkDestroyed() {
    if (this._canvas === null) {
      throw new TypeError("The CanvasRenderTarget has already been destroyed");
    }
  }
}

exports.CanvasRenderTarget = CanvasRenderTarget;
//# sourceMappingURL=CanvasRenderTarget.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/media/caches.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/media/caches.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const ProgramCache = {};
const TextureCache = /* @__PURE__ */ Object.create(null);
const BaseTextureCache = /* @__PURE__ */ Object.create(null);
function destroyTextureCache() {
  let key;
  for (key in TextureCache) {
    TextureCache[key].destroy();
  }
  for (key in BaseTextureCache) {
    BaseTextureCache[key].destroy();
  }
}
function clearTextureCache() {
  let key;
  for (key in TextureCache) {
    delete TextureCache[key];
  }
  for (key in BaseTextureCache) {
    delete BaseTextureCache[key];
  }
}

exports.BaseTextureCache = BaseTextureCache;
exports.ProgramCache = ProgramCache;
exports.TextureCache = TextureCache;
exports.clearTextureCache = clearTextureCache;
exports.destroyTextureCache = destroyTextureCache;
//# sourceMappingURL=caches.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var BoundingBox = __webpack_require__(/*! ./BoundingBox.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/media/BoundingBox.js");

function checkRow(data, width, y) {
  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4) {
    if (data[index + 3] !== 0)
      return false;
  }
  return true;
}
function checkColumn(data, width, x, top, bottom) {
  const stride = 4 * width;
  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride) {
    if (data[index + 3] !== 0)
      return false;
  }
  return true;
}
function getCanvasBoundingBox(canvas) {
  const { width, height } = canvas;
  const context = canvas.getContext("2d", {
    willReadFrequently: true
  });
  if (context === null) {
    throw new TypeError("Failed to get canvas 2D context");
  }
  const imageData = context.getImageData(0, 0, width, height);
  const data = imageData.data;
  let left = 0;
  let top = 0;
  let right = width - 1;
  let bottom = height - 1;
  while (top < height && checkRow(data, width, top))
    ++top;
  if (top === height)
    return BoundingBox.BoundingBox.EMPTY;
  while (checkRow(data, width, bottom))
    --bottom;
  while (checkColumn(data, width, left, top, bottom))
    ++left;
  while (checkColumn(data, width, right, top, bottom))
    --right;
  ++right;
  ++bottom;
  return new BoundingBox.BoundingBox(left, top, right, bottom);
}

exports.getCanvasBoundingBox = getCanvasBoundingBox;
//# sourceMappingURL=getCanvasBoundingBox.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/media/trimCanvas.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/media/trimCanvas.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var getCanvasBoundingBox = __webpack_require__(/*! ./getCanvasBoundingBox.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.js");

function trimCanvas(canvas) {
  const boundingBox = getCanvasBoundingBox.getCanvasBoundingBox(canvas);
  const { width, height } = boundingBox;
  let data = null;
  if (!boundingBox.isEmpty()) {
    const context = canvas.getContext("2d");
    if (context === null) {
      throw new TypeError("Failed to get canvas 2D context");
    }
    data = context.getImageData(boundingBox.left, boundingBox.top, width, height);
  }
  return { width, height, data };
}

exports.trimCanvas = trimCanvas;
//# sourceMappingURL=trimCanvas.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/network/decomposeDataUri.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/network/decomposeDataUri.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/const.js");

function decomposeDataUri(dataUri) {
  const dataUriMatch = _const.DATA_URI.exec(dataUri);
  if (dataUriMatch) {
    return {
      mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : void 0,
      subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : void 0,
      charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : void 0,
      encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : void 0,
      data: dataUriMatch[5]
    };
  }
  return void 0;
}

exports.decomposeDataUri = decomposeDataUri;
//# sourceMappingURL=decomposeDataUri.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/network/determineCrossOrigin.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/network/determineCrossOrigin.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var url = __webpack_require__(/*! ../url.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/url.js");

let tempAnchor;
function determineCrossOrigin(url$1, loc = globalThis.location) {
  if (url$1.startsWith("data:")) {
    return "";
  }
  loc = loc || globalThis.location;
  if (!tempAnchor) {
    tempAnchor = document.createElement("a");
  }
  tempAnchor.href = url$1;
  const parsedUrl = url.url.parse(tempAnchor.href);
  const samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
  if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
    return "anonymous";
  }
  return "";
}

exports.determineCrossOrigin = determineCrossOrigin;
//# sourceMappingURL=determineCrossOrigin.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/network/getResolutionOfUrl.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/network/getResolutionOfUrl.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(/*! ../settings.js */ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/settings.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");

function getResolutionOfUrl(url, defaultValue = 1) {
  const resolution = settings.settings.RETINA_PREFIX?.exec(url);
  if (resolution) {
    return parseFloat(resolution[1]);
  }
  return defaultValue;
}

exports.getResolutionOfUrl = getResolutionOfUrl;
//# sourceMappingURL=getResolutionOfUrl.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/path.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/path.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");

function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
  }
}
function removeUrlParams(url) {
  const re = url.split("?")[0];
  return re.split("#")[0];
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str, find, replace) {
  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
function normalizeStringPosix(path2, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = -1;
  for (let i = 0; i <= path2.length; ++i) {
    if (i < path2.length) {
      code = path2.charCodeAt(i);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path2.slice(lastSlash + 1, i)}`;
        } else {
          res = path2.slice(lastSlash + 1, i);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
const path = {
  toPosix(path2) {
    return replaceAll(path2, "\\", "/");
  },
  isUrl(path2) {
    return /^https?:/.test(this.toPosix(path2));
  },
  isDataUrl(path2) {
    return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
  },
  hasProtocol(path2) {
    return /^[^/:]+:\//.test(this.toPosix(path2));
  },
  getProtocol(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    let protocol = "";
    const isFile = /^file:\/\/\//.exec(path2);
    const isHttp = /^[^/:]+:\/\//.exec(path2);
    const isWindows = /^[^/:]+:\//.exec(path2);
    if (isFile || isHttp || isWindows) {
      const arr = isFile?.[0] || isHttp?.[0] || isWindows?.[0];
      protocol = arr;
      path2 = path2.slice(arr.length);
    }
    return protocol;
  },
  toAbsolute(url, customBaseUrl, customRootUrl) {
    if (this.isDataUrl(url))
      return url;
    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? settings.settings.ADAPTER.getBaseUrl()));
    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
    assertPath(url);
    url = this.toPosix(url);
    if (url.startsWith("/")) {
      return path.join(rootUrl, url.slice(1));
    }
    const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
    return absolutePath;
  },
  normalize(path2) {
    path2 = this.toPosix(path2);
    assertPath(path2);
    if (path2.length === 0)
      return ".";
    let protocol = "";
    const isAbsolute = path2.startsWith("/");
    if (this.hasProtocol(path2)) {
      protocol = this.rootname(path2);
      path2 = path2.slice(protocol.length);
    }
    const trailingSeparator = path2.endsWith("/");
    path2 = normalizeStringPosix(path2, false);
    if (path2.length > 0 && trailingSeparator)
      path2 += "/";
    if (isAbsolute)
      return `/${path2}`;
    return protocol + path2;
  },
  isAbsolute(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    if (this.hasProtocol(path2))
      return true;
    return path2.startsWith("/");
  },
  join(...segments) {
    if (segments.length === 0) {
      return ".";
    }
    let joined;
    for (let i = 0; i < segments.length; ++i) {
      const arg = segments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === void 0)
          joined = arg;
        else {
          const prevArg = segments[i - 1] ?? "";
          if (this.extname(prevArg)) {
            joined += `/../${arg}`;
          } else {
            joined += `/${arg}`;
          }
        }
      }
    }
    if (joined === void 0) {
      return ".";
    }
    return this.normalize(joined);
  },
  dirname(path2) {
    assertPath(path2);
    if (path2.length === 0)
      return ".";
    path2 = this.toPosix(path2);
    let code = path2.charCodeAt(0);
    const hasRoot = code === 47;
    let end = -1;
    let matchedSlash = true;
    const proto = this.getProtocol(path2);
    const origpath = path2;
    path2 = path2.slice(proto.length);
    for (let i = path2.length - 1; i >= 1; --i) {
      code = path2.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1)
      return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
    if (hasRoot && end === 1)
      return "//";
    return proto + path2.slice(0, end);
  },
  rootname(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    let root = "";
    if (path2.startsWith("/"))
      root = "/";
    else {
      root = this.getProtocol(path2);
    }
    if (this.isUrl(path2)) {
      const index = path2.indexOf("/", root.length);
      if (index !== -1) {
        root = path2.slice(0, index);
      } else
        root = path2;
      if (!root.endsWith("/"))
        root += "/";
    }
    return root;
  },
  basename(path2, ext) {
    assertPath(path2);
    if (ext)
      assertPath(ext);
    path2 = removeUrlParams(this.toPosix(path2));
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
      if (ext.length === path2.length && ext === path2)
        return "";
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path2.length - 1; i >= 0; --i) {
        const code = path2.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path2.length;
      return path2.slice(start, end);
    }
    for (i = path2.length - 1; i >= 0; --i) {
      if (path2.charCodeAt(i) === 47) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1)
      return "";
    return path2.slice(start, end);
  },
  extname(path2) {
    assertPath(path2);
    path2 = removeUrlParams(this.toPosix(path2));
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i = path2.length - 1; i >= 0; --i) {
      const code = path2.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46) {
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path2.slice(startDot, end);
  },
  parse(path2) {
    assertPath(path2);
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path2.length === 0)
      return ret;
    path2 = removeUrlParams(this.toPosix(path2));
    let code = path2.charCodeAt(0);
    const isAbsolute = this.isAbsolute(path2);
    let start;
    const protocol = "";
    ret.root = this.rootname(path2);
    if (isAbsolute || this.hasProtocol(path2)) {
      start = 1;
    } else {
      start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path2.length - 1;
    let preDotState = 0;
    for (; i >= start; --i) {
      code = path2.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46) {
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute)
          ret.base = ret.name = path2.slice(1, end);
        else
          ret.base = ret.name = path2.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path2.slice(1, startDot);
        ret.base = path2.slice(1, end);
      } else {
        ret.name = path2.slice(startPart, startDot);
        ret.base = path2.slice(startPart, end);
      }
      ret.ext = path2.slice(startDot, end);
    }
    ret.dir = this.dirname(path2);
    if (protocol)
      ret.dir = protocol + ret.dir;
    return ret;
  },
  sep: "/",
  delimiter: ":"
};

exports.path = path;
//# sourceMappingURL=path.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/settings.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/settings.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/pixi.js/node_modules/@pixi/settings/lib/index.js");

settings.settings.RETINA_PREFIX = /@([0-9\.]+)x/;
settings.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;

Object.defineProperty(exports, "settings", ({
	enumerable: true,
	get: function () { return settings.settings; }
}));
//# sourceMappingURL=settings.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/types/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/types/index.js ***!
  \**************************************************************************/
/***/ (() => {

"use strict";


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/@pixi/utils/lib/url.js":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/@pixi/utils/lib/url.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var url$1 = __webpack_require__(/*! url */ "./node_modules/url/url.js");

const url = {
  parse: url$1.parse,
  format: url$1.format,
  resolve: url$1.resolve
};

exports.url = url;
//# sourceMappingURL=url.js.map


/***/ }),

/***/ "./node_modules/pixi.js/node_modules/eventemitter3/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/eventemitter3/index.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "./node_modules/priorityqueuejs/index.js":
/*!***********************************************!*\
  !*** ./node_modules/priorityqueuejs/index.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * Expose `PriorityQueue`.
 */
module.exports = PriorityQueue;

/**
 * Initializes a new empty `PriorityQueue` with the given `comparator(a, b)`
 * function, uses `.DEFAULT_COMPARATOR()` when no function is provided.
 *
 * The comparator function must return a positive number when `a > b`, 0 when
 * `a == b` and a negative number when `a < b`.
 *
 * @param {Function}
 * @return {PriorityQueue}
 * @api public
 */
function PriorityQueue(comparator) {
  this._comparator = comparator || PriorityQueue.DEFAULT_COMPARATOR;
  this._elements = [];
}

/**
 * Compares `a` and `b`, when `a > b` it returns a positive number, when
 * it returns 0 and when `a < b` it returns a negative number.
 *
 * @param {String|Number} a
 * @param {String|Number} b
 * @return {Number}
 * @api public
 */
PriorityQueue.DEFAULT_COMPARATOR = function(a, b) {
  if (typeof a === 'number' && typeof b === 'number') {
    return a - b;
  } else {
    a = a.toString();
    b = b.toString();

    if (a == b) return 0;

    return (a > b) ? 1 : -1;
  }
};

/**
 * Returns whether the priority queue is empty or not.
 *
 * @return {Boolean}
 * @api public
 */
PriorityQueue.prototype.isEmpty = function() {
  return this.size() === 0;
};

/**
 * Peeks at the top element of the priority queue.
 *
 * @return {Object}
 * @throws {Error} when the queue is empty.
 * @api public
 */
PriorityQueue.prototype.peek = function() {
  if (this.isEmpty()) throw new Error('PriorityQueue is empty');

  return this._elements[0];
};

/**
 * Dequeues the top element of the priority queue.
 *
 * @return {Object}
 * @throws {Error} when the queue is empty.
 * @api public
 */
PriorityQueue.prototype.deq = function() {
  var first = this.peek();
  var last = this._elements.pop();
  var size = this.size();

  if (size === 0) return first;

  this._elements[0] = last;
  var current = 0;

  while (current < size) {
    var largest = current;
    var left = (2 * current) + 1;
    var right = (2 * current) + 2;

    if (left < size && this._compare(left, largest) >= 0) {
      largest = left;
    }

    if (right < size && this._compare(right, largest) >= 0) {
      largest = right;
    }

    if (largest === current) break;

    this._swap(largest, current);
    current = largest;
  }

  return first;
};

/**
 * Enqueues the `element` at the priority queue and returns its new size.
 *
 * @param {Object} element
 * @return {Number}
 * @api public
 */
PriorityQueue.prototype.enq = function(element) {
  var size = this._elements.push(element);
  var current = size - 1;

  while (current > 0) {
    var parent = Math.floor((current - 1) / 2);

    if (this._compare(current, parent) <= 0) break;

    this._swap(parent, current);
    current = parent;
  }

  return size;
};

/**
 * Returns the size of the priority queue.
 *
 * @return {Number}
 * @api public
 */
PriorityQueue.prototype.size = function() {
  return this._elements.length;
};

/**
 *  Iterates over queue elements
 *
 *  @param {Function} fn
 */
PriorityQueue.prototype.forEach = function(fn) {
  return this._elements.forEach(fn);
};

/**
 * Compares the values at position `a` and `b` in the priority queue using its
 * comparator function.
 *
 * @param {Number} a
 * @param {Number} b
 * @return {Number}
 * @api private
 */
PriorityQueue.prototype._compare = function(a, b) {
  return this._comparator(this._elements[a], this._elements[b]);
};

/**
 * Swaps the values at position `a` and `b` in the priority queue.
 *
 * @param {Number} a
 * @param {Number} b
 * @api private
 */
PriorityQueue.prototype._swap = function(a, b) {
  var aux = this._elements[a];
  this._elements[a] = this._elements[b];
  this._elements[b] = aux;
};


/***/ }),

/***/ "./node_modules/querystring/decode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/decode.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};


/***/ }),

/***/ "./node_modules/querystring/encode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/encode.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};


/***/ }),

/***/ "./node_modules/querystring/index.js":
/*!*******************************************!*\
  !*** ./node_modules/querystring/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring/encode.js");


/***/ }),

/***/ "./node_modules/seedrandom/index.js":
/*!******************************************!*\
  !*** ./node_modules/seedrandom/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baage.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = __webpack_require__(/*! ./lib/alea */ "./node_modules/seedrandom/lib/alea.js");

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = __webpack_require__(/*! ./lib/xor128 */ "./node_modules/seedrandom/lib/xor128.js");

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = __webpack_require__(/*! ./lib/xorwow */ "./node_modules/seedrandom/lib/xorwow.js");

// xorshift7, by Franois Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = __webpack_require__(/*! ./lib/xorshift7 */ "./node_modules/seedrandom/lib/xorshift7.js");

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = __webpack_require__(/*! ./lib/xor4096 */ "./node_modules/seedrandom/lib/xor4096.js");

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = __webpack_require__(/*! ./lib/tychei */ "./node_modules/seedrandom/lib/tychei.js");

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = __webpack_require__(/*! ./seedrandom */ "./node_modules/seedrandom/seedrandom.js");

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;


/***/ }),

/***/ "./node_modules/seedrandom/lib/alea.js":
/*!*********************************************!*\
  !*** ./node_modules/seedrandom/lib/alea.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A port of an algorithm by Johannes Baage <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baage <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = String(data);
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.alea = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ "./node_modules/seedrandom/lib/tychei.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/tychei.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.tychei = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ "./node_modules/seedrandom/lib/xor128.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/xor128.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor128 = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ "./node_modules/seedrandom/lib/xor4096.js":
/*!************************************************!*\
  !*** ./node_modules/seedrandom/lib/xor4096.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);


/***/ }),

/***/ "./node_modules/seedrandom/lib/xorshift7.js":
/*!**************************************************!*\
  !*** ./node_modules/seedrandom/lib/xorshift7.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorshift7" algorithm by
// Franois Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorshift7 = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);



/***/ }),

/***/ "./node_modules/seedrandom/lib/xorwow.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/xorwow.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorwow = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ "./node_modules/seedrandom/seedrandom.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/seedrandom.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
Copyright 2019 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (global, pool, math) {
//
// The following constants are related to IEEE 754 limits.
//

var width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ( true && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = __webpack_require__(/*! crypto */ "?d4c0");
  } catch (ex) {}
} else if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return seedrandom; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}


// End anonymous scope, and pass initial values.
})(
  // global: `self` in browsers (including strict mode and web workers),
  // otherwise `this` in Node and other environments
  (typeof self !== 'undefined') ? self : this,
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const PIXI = __importStar(__webpack_require__(/*! pixi.js */ "./node_modules/pixi.js/lib/index.js"));
const Roots_1 = __webpack_require__(/*! ./roots/Roots */ "./src/roots/Roots.ts");
const GameRenderer_1 = __webpack_require__(/*! ./render/GameRenderer */ "./src/render/GameRenderer.ts");
window.onload = function () {
    // Create the application helper and add its render target to the page
    let app = new PIXI.Application({
        width: 1200,
        height: 800,
        antialias: true,
        autoDensity: true,
    });
    document.body.appendChild(app.view);
    let seed = Math.random().toString();
    let params = new URLSearchParams(window.location.search);
    if (params.has('seed')) {
        let paramSeed = params.get('seed');
        if (paramSeed.length > 0) {
            seed = paramSeed;
        }
    }
    let game = new Roots_1.Roots(seed);
    game.onNeedSave = (data) => {
        window.localStorage.setItem(seed, JSON.stringify(data));
    };
    let savedJSON = window.localStorage.getItem(seed);
    if (savedJSON != null) {
        try {
            let data = JSON.parse(savedJSON);
            game.deserialize(data);
        }
        catch (e) {
            console.error('filed to load save for seed', e);
        }
    }
    else {
        game.createNewLevel();
    }
    let renderer = new GameRenderer_1.GameRenderer(app, game);
    renderer.start();
    window.history.replaceState(null, null, `?seed=${seed}`);
    document.oncontextmenu = document.body.oncontextmenu = function (e) {
        e.preventDefault();
        // return false;
    };
};


/***/ }),

/***/ "./src/render/Animals.ts":
/*!*******************************!*\
  !*** ./src/render/Animals.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.animalIcons = void 0;
exports.animalIcons = `
alligator.png
anaconda.png
angelfish.png
ant.png
anteater.png
antelope.png
apatosaurus.png
atlas_beetle.png
baboon.png
bass.png
bat.png
bear.png
beaver.png
bee.png
bison.png
black_panther.png
blue_whale.png
boar.png
boxer_dog.png
buffalo.png
bull.png
bulldog.png
butterfly.png
butterflyfish.png
camel.png
cardinal.png
cat.png
catfish.png
catterpillar.png
centipede.png
chameleon.png
cheetah.png
chicken.png
chimera.png
chimpanzee.png
chinese_dragon.png
chipmunk.png
clam.png
cobra.png
cockatoo.png
cockroach.png
codfish.png
coral.png
cougar.png
cow.png
crab.png
crocodile.png
crow.png
dalmatian.png
deer.png
doberman.png
dolphin.png
donkey.png
dragonfly.png
duck.png
eagle.png
earthworm.png
earwig.png
electric_knifefish.png
elephant.png
falcon.png
finch.png
fish.png
flamingo.png
flatworm.png
flea.png
fly.png
flying_fish.png
fox.png
frog.png
frog2.png
gazelle.png
german_shepherd.png
gharial.png
giraffe.png
goat.png
golden_retriever.png
goldfish.png
goose.png
gorilla.png
grasshopper.png
greyhound.png
griffin.png
guinea_pig.png
gull.png
hare.png
hen.png
heron.png
herring.png
hippopotamus.png
hornbill.png
horse.png
howling_monkey.png
hummingbird.png
hyena.png
ibex.png
iguana.png
jackal.png
jellyfish.png
kangaroo.png
killer_whale.png
kingfisher.png
kiwi_bird.png
koala.png
kraken.png
ladybug.png
lemur.png
leopard.png
lion.png
lioness.png
llama.png
lobster.png
longhorn_beetle.png
lovebird.png
lumpfish.png
macaw.png
mammoth.png
manatee.png
mantaray.png
mantis.png
meerkat.png
millipede.png
mite.png
mole.png
monkey.png
moose.png
mosquito.png
mouse.png
octopus.png
ostrich.png
otter.png
owl.png
panda.png
pangolin.png
parakeet.png
parasaurolophus.png
parrot.png
peacock.png
pegasus.png
pelican.png
penguin.png
pheasant.png
pig.png
pigeon.png
pillbug.png
piranha.png
platypus.png
plesiosaur.png
polar_bear.png
prawn.png
pterosaur.png
pufferfish.png
puffin.png
python.png
rabbit.png
raccoon.png
ram.png
rat.png
rattlesnake.png
red_panda.png
rhinoceros.png
rhinoceros_beetle.png
robin.png
rooster.png
sailfish.png
salamander.png
salmon.png
scorpion.png
seahorse.png
seal.png
sealion.png
sea_anemone.png
sea_urchin.png
shark.png
sheep.png
sloth.png
slug.png
snail.png
sparrow.png
sperm_whale.png
spider.png
squid.png
squirrel.png
stag_beetle.png
starfish.png
stegosaurus.png
stork.png
sturgeon.png
swallow.png
swan.png
tadpole.png
tapir.png
tarantula.png
termite.png
tiger.png
toad.png
tortoise.png
toucan.png
triceratops.png
tuna.png
turkey.png
turtle.png
tyrannosaurus.png
unicorn.png
vulture.png
walrus.png
wasp.png
wild_dog.png
wolf.png
woodpecker.png
zebra.png
`;


/***/ }),

/***/ "./src/render/GameRenderer.ts":
/*!************************************!*\
  !*** ./src/render/GameRenderer.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GameRenderer = void 0;
const PIXI = __importStar(__webpack_require__(/*! pixi.js */ "./node_modules/pixi.js/lib/index.js"));
const GridRender_1 = __webpack_require__(/*! ./GridRender */ "./src/render/GridRender.ts");
const Animals_1 = __webpack_require__(/*! ./Animals */ "./src/render/Animals.ts");
const LevelGenerator_1 = __webpack_require__(/*! ../roots/LevelGenerator */ "./src/roots/LevelGenerator.ts");
const seedrandom_1 = __importDefault(__webpack_require__(/*! seedrandom */ "./node_modules/seedrandom/index.js"));
class GameRenderer {
    constructor(app, game) {
        this.app = app;
        this.game = game;
        this.container = new PIXI.Container();
        app.stage.addChild(this.container);
        this.initGroups();
        this.game.onNeedRefresh = () => {
            this.updateStones();
            this.gridRenderer.refresh();
        };
    }
    initGroups() {
        let rng = (0, seedrandom_1.default)(this.game.seed);
        let nBasicColors = 5;
        let basicColors = Array.from(new Array(nBasicColors).keys()).map(i => {
            return new PIXI.Color({ h: i * 360 / nBasicColors, s: 85, v: 100 });
        });
        // basicColors.forEach((c, i) => console.log(i, c.toRgbaString()))
        this.groupColors = basicColors;
        let nGroups = LevelGenerator_1.LevelGenerator.maxGroupIndex;
        let paths = Animals_1.animalIcons.split('\n').filter(s => s.length > 0).map(s => s.trim());
        // shuffle paths
        for (let i = paths.length - 1; i > 0; i--) {
            const j = Math.floor(rng() * (i + 1));
            [paths[i], paths[j]] = [paths[j], paths[i]];
        }
        this.groupAnimalPaths = Array.from(new Array(nGroups).keys())
            .map(i => paths[i % paths.length]);
    }
    updateStones() {
        this.stoneRenderers.forEach((sprite, i) => {
            sprite.visible = i < this.game.nFreeStones;
        });
    }
    colorForGroupIndex(index) {
        return this.groupColors[index];
    }
    iconPathForGroupIndex(index) {
        return `img/animals/${this.groupAnimalPaths[index]}`;
    }
    start() {
        this.app.ticker.add(delta => {
            this.update(delta);
        });
        this.gridRenderer = new GridRender_1.GridRenderer(this, this.game.grid);
        this.gridRenderer.init();
        this.container.addChild(this.gridRenderer.container);
        // this.gridRenderer.graphics.x = this.app.screen.width / 2;
        // this.gridRenderer.graphics.y = this.app.screen.height / 2;
        this.stoneRenderers = Array.from(new Array(LevelGenerator_1.LevelGenerator.maxStones).keys()).map(i => {
            let sprite = new PIXI.Graphics();
            sprite.beginFill(0xffffff);
            sprite.drawCircle(0, 0, 10);
            sprite.endFill();
            sprite.x = i * 25 + 10;
            sprite.y = this.app.screen.height - 20;
            this.container.addChild(sprite);
            return sprite;
        });
        this.updateStones();
    }
    update(delta) {
    }
}
exports.GameRenderer = GameRenderer;


/***/ }),

/***/ "./src/render/GridRender.ts":
/*!**********************************!*\
  !*** ./src/render/GridRender.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GridRenderer = void 0;
const PIXI = __importStar(__webpack_require__(/*! pixi.js */ "./node_modules/pixi.js/lib/index.js"));
const HexRenderer_1 = __webpack_require__(/*! ./HexRenderer */ "./src/render/HexRenderer.ts");
class GridRenderer {
    constructor(renderer, grid) {
        this.children = [];
        this.hoverGroupIndex = -1;
        this.grid = grid;
        this.renderer = renderer;
        this.container = new PIXI.Container();
        this.container.sortableChildren = true;
    }
    init() {
        this.grid.forEach(tile => {
            let hexRenderer = new HexRenderer_1.HexRenderer(tile, this);
            this.children.push(hexRenderer);
            this.container.addChild(hexRenderer);
        });
    }
    refresh() {
        this.children.forEach(hexRenderer => {
            hexRenderer.redraw();
        });
    }
    updateHover(index, hover) {
        let oldIndex = this.hoverGroupIndex;
        this.hoverGroupIndex = hover ? index : -1;
        this.children
            .filter(hexRenderer => {
            return hexRenderer.tile.groupIndex === oldIndex ||
                hexRenderer.tile.groupIndex === index;
        })
            .forEach(hexRenderer => {
            hexRenderer.redraw();
        });
    }
    update(delta) {
    }
}
exports.GridRenderer = GridRenderer;


/***/ }),

/***/ "./src/render/HexRenderer.ts":
/*!***********************************!*\
  !*** ./src/render/HexRenderer.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HexRenderer = void 0;
const PIXI = __importStar(__webpack_require__(/*! pixi.js */ "./node_modules/pixi.js/lib/index.js"));
const pixi_js_1 = __webpack_require__(/*! pixi.js */ "./node_modules/pixi.js/lib/index.js");
class HexRenderer extends pixi_js_1.Container {
    constructor(tile, gridRenderer) {
        super();
        this.hovered = false;
        this.gridRenderer = gridRenderer;
        this.tile = tile;
        let icon = this.icon = new PIXI.Sprite();
        if (tile.groupIndex !== undefined) {
            icon.texture = PIXI.Texture.from(this.gridRenderer.renderer.iconPathForGroupIndex(tile.groupIndex));
        }
        icon.anchor.set(0.5);
        let iconRatio = 0.6;
        icon.width = tile.width * iconRatio;
        icon.height = tile.height * iconRatio;
        icon.x = tile.width / 2;
        icon.y = tile.height / 2;
        let graphics = this.hex = new PIXI.Graphics();
        this.addChild(graphics);
        this.addChild(icon);
        this.x = -tile.center.x;
        this.y = -tile.center.y;
        this.redraw();
        graphics.interactive = true;
        graphics.onmouseenter = () => {
            if (this.tile.unlocked || this.tile.groupIndex === undefined)
                return;
            this.hovered = true;
            this.gridRenderer.updateHover(tile.groupIndex, true);
        };
        graphics.onmouseleave = () => {
            this.hovered = false;
            this.gridRenderer.updateHover(tile.groupIndex, false);
        };
        graphics.onrightclick = (e) => {
            console.log('right clicked', tile.id);
            this.gridRenderer.renderer.game.clearSelection();
        };
        graphics.onclick = (e) => {
            tile.clicked();
            // this.hovered = false;
            // this.gridRenderer.updateHover(tile.groupIndex, false);
            this.redraw();
            this.gridRenderer.renderer.updateStones();
            console.log('clicked', tile.id);
        };
    }
    redraw() {
        let tile = this.tile;
        let hex = this.hex;
        let active = tile.unlocked || tile.active;
        let color = this.gridRenderer.renderer.colorForGroupIndex(tile.groupCount - 2);
        if (tile.isStoneTile)
            color = new PIXI.Color(0x888888);
        let lineColor;
        let lineColorAlpha = 1;
        let zIndex = 0;
        if (tile.unlocked) {
            lineColor = 0xeeeeee;
            hex.zIndex = active ? 1 : 0;
            zIndex = 1;
        }
        else if (tile.active) {
            lineColor = 0xff00ff;
            zIndex = 2;
        }
        else if (this.gridRenderer.hoverGroupIndex === tile.groupIndex) {
            lineColor = 0xeeaaee;
            zIndex = 1;
        }
        else {
            lineColor = 0x000000;
        }
        this.zIndex = zIndex;
        hex.clear();
        hex.beginFill(color);
        hex.lineStyle(3, lineColor, lineColorAlpha);
        let translatedCorners = tile.corners.map(c => {
            return { x: c.x + tile.center.x, y: c.y + tile.center.y };
        });
        hex.drawPolygon(translatedCorners);
        hex.endFill();
        if (this.gridRenderer.hoverGroupIndex === tile.groupIndex) {
            hex.tint = active ? 0xeeeeee : 0xeeeeee;
        }
        else {
            hex.tint = active ? 0xffffff : 0x888888;
        }
    }
}
exports.HexRenderer = HexRenderer;


/***/ }),

/***/ "./src/roots/Clustering.ts":
/*!*********************************!*\
  !*** ./src/roots/Clustering.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Clustering = void 0;
class Clustering {
    constructor() {
        // this.map = new Map<number, number>();
        this.clusters = [];
    }
    getClusterIndex(tileID) {
        // return this.map.get(tileID);
        let index = this.clusters.findIndex(cluster => cluster.includes(tileID));
        if (index === -1)
            return undefined;
        return index;
    }
    addNewCluster(tileID) {
        let clusterID = this.clusters.length;
        // this.map.set(id, clusterID);
        this.clusters.push([tileID]);
        return clusterID;
    }
    addTileAndConnectNeighbors(tile) {
        let mergedClusters = [this.addNewCluster(tile.id)];
        let neighbors = tile.getPassableNeighbors();
        for (let neighbor of neighbors) {
            let neighborClusterIndex = this.getClusterIndex(neighbor.id);
            if (neighborClusterIndex === undefined)
                continue;
            if (!mergedClusters.includes(neighborClusterIndex)) {
                mergedClusters.push(neighborClusterIndex);
            }
        }
        // console.log(mergedClusters);
        this.join(mergedClusters);
    }
    join(clusterIDs) {
        // console.log('joining clusters', clusterIDs);
        if (clusterIDs.length <= 1)
            return;
        let newCluster = [];
        clusterIDs.sort((a, b) => a - b);
        clusterIDs.reverse();
        clusterIDs.forEach(id => {
            newCluster = newCluster.concat(this.clusters[id]);
            this.clusters.splice(id, 1);
        });
        this.clusters.push(newCluster);
        // This is insufficient - we'd need to shift all the clusterIDs after the one we just removed
        // Maybe can just get away without a map
        // newCluster.forEach(id => {
        //     this.map.set(id, this.clusters.length - 1);
        // });
    }
    copy() {
        let copy = new Clustering();
        // copy.map = new Map(this.map);
        copy.clusters = this.clusters.map(cluster => cluster.slice());
        return copy;
    }
}
exports.Clustering = Clustering;


/***/ }),

/***/ "./src/roots/LevelGenerator.ts":
/*!*************************************!*\
  !*** ./src/roots/LevelGenerator.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LevelGenerator = void 0;
const honeycomb_grid_1 = __webpack_require__(/*! honeycomb-grid */ "./node_modules/honeycomb-grid/dist/honeycomb-grid.umd.js");
const Tile_1 = __webpack_require__(/*! ./Tile */ "./src/roots/Tile.ts");
const Dijkstra_1 = __webpack_require__(/*! ../util/Dijkstra */ "./src/util/Dijkstra.ts");
const seedrandom_1 = __importDefault(__webpack_require__(/*! seedrandom */ "./node_modules/seedrandom/index.js"));
class GridAdapter {
    constructor(grid) {
        this.ignoreGroupingTiles = [];
        this.grid = grid;
    }
    getKey(node) {
        return node.id;
    }
    getEdges(node) {
        let baseWeight = this.getWeight(node);
        return node.getNeighbors().map(neighbor => {
            let weight = baseWeight + this.getWeight(neighbor);
            return {
                node: neighbor,
                weight,
            };
        });
    }
    getWeight(tile) {
        return (tile.groupIndex == null ||
            this.ignoreGroupingTiles.includes(tile)) ?
            0.5 : 0;
    }
}
class Moveset {
    constructor(stones) {
        this.tiles = new Set();
        this.footprint = new Set();
        this.moves = [];
        this.stones = stones;
    }
    addMove(move) {
        this.moves.push(move);
        move.forEach(tile => {
            this.tiles.add(tile);
            this.addFootprint(tile, this.footprint, this.stones);
        });
    }
    createFootprint(radius = 0) {
        let footprint = new Set();
        this.tiles.forEach(tile => this.addFootprint(tile, footprint, radius));
        return footprint;
    }
    addFootprint(tile, footprint, radius = 0) {
        const spiralTraverser = (0, honeycomb_grid_1.spiral)({ start: tile, radius });
        tile.grid.traverse(spiralTraverser).forEach(neighbor => {
            footprint.add(neighbor);
        });
    }
    setStones(stones) {
        this.stones = stones;
        this.tiles.forEach(tile => this.addFootprint(tile, this.footprint, this.stones));
    }
    add(other) {
        other.tiles.forEach(tile => this.tiles.add(tile));
        other.footprint.forEach(tile => this.footprint.add(tile));
        // One option: only keep the most recent move, which should be the one that joined them
        // This may cause the generator to stop, when that move isn't easy to build from
        // this.moves.splice(0, this.moves.length - 1);
        // Zipper in the other moves
        let offset = 0;
        for (let i = other.moves.length - 1; i >= 0; i--) {
            let index = Math.max(0, this.moves.length - offset - 1);
            offset++;
            this.moves.splice(index, 0, other.moves[i]);
        }
    }
}
class LevelGenerator {
    constructor(seed, width, height) {
        this.tileMap = new Map();
        console.log(findSubsetsThatSumTo);
        this.width = width;
        this.height = height;
        this.grid = new honeycomb_grid_1.Grid(Tile_1.Tile, (0, honeycomb_grid_1.rectangle)({ width: width, height: height }));
        let id = 0;
        this.grid.forEach(tile => {
            tile.id = id++;
            tile.grid = this.grid;
            this.tileMap.set(tile.id, tile);
        });
        this.seed = seed;
        this.random = (0, seedrandom_1.default)(seed);
    }
    findUngroupedTilesWithinDistance(adapter, tile, distance) {
        let paths = (0, Dijkstra_1.dijkstra)(adapter, tile, null, distance);
        return Object.entries(paths.costs).map(([key, value]) => {
            return { id: parseInt(key), cost: value };
        }).filter(pair => 
        // shouldn't be necessary, since all ungrouped will be at least 1 away
        // pair.cost >= 1 &&
        pair.id != tile.id &&
            this.tileMap.get(pair.id).groupIndex == null);
    }
    generate() {
        let gridAdapter = new GridAdapter(this.grid);
        let groupedTiles = [];
        let ungroupedTiles = this.grid.toArray();
        let movesets = [];
        let nextGroupIndex = 0;
        let stones = 2;
        let createMove = (tile, dependentMove = null, disallowedTiles = new Set(), maximizeCostGain = false) => {
            // console.log('attempting to group with tile', tile.id, tile);
            let maxPathCost = stones - 1;
            let possiblePairs = this.findUngroupedTilesWithinDistance(gridAdapter, tile, maxPathCost);
            possiblePairs = possiblePairs.filter(pair => !disallowedTiles.has(this.tileMap.get(pair.id)));
            // console.log('found possible pairs', possiblePairs.slice());
            if (possiblePairs.length == 0)
                return null;
            let remainingStones = stones - 1;
            let group;
            group = [];
            let addPair = (added) => {
                group.push(added);
                remainingStones -= added.cost;
                possiblePairs = possiblePairs.filter(pair => pair.id != added.id && pair.cost <= remainingStones);
            };
            if (dependentMove != null) {
                gridAdapter.ignoreGroupingTiles = dependentMove;
                let possiblePairsBeforeDependentMove = this.findUngroupedTilesWithinDistance(gridAdapter, tile, maxPathCost);
                gridAdapter.ignoreGroupingTiles = [];
                let costMap = new Map();
                possiblePairsBeforeDependentMove.forEach(pair => costMap.set(pair.id, pair.cost));
                let newlyPossiblePairs = possiblePairs
                    .filter(pair => !costMap.has(pair.id) || costMap.get(pair.id) > pair.cost);
                // Wouldn't normally need to break, but for testing
                if (newlyPossiblePairs.length == 0) {
                    console.log('no newly possible pairs');
                    // TODO: Need a more robust solution: this can get pretty expensive
                    return null;
                }
                let toAdd = newlyPossiblePairs[Math.floor(this.random() * newlyPossiblePairs.length)];
                if (maximizeCostGain) {
                    let costGain = (cost) => {
                        let costBefore = costMap.get(cost.id);
                        if (costBefore == null)
                            costBefore = Number.POSITIVE_INFINITY;
                        return costBefore - cost.cost;
                    };
                    // Sort from largest to smallest cost gain
                    newlyPossiblePairs.sort((a, b) => {
                        return costGain(b) - costGain(a);
                    });
                    toAdd = newlyPossiblePairs[0];
                }
                addPair(toAdd);
            }
            // Greedy approach: choose a random tile (which can be reached with the remaining stones)
            // and add it to the group; then adjust possible pairs based on the remaining stones
            // Note: this may result in a group that is below the target cost, but it's
            // possible that no group exists that is exactly the target cost, and even if it exists
            // finding it is very computationally expensive
            while (possiblePairs.length > 0 && remainingStones > 0) {
                let addedIndex = Math.floor(this.random() * possiblePairs.length);
                let added = possiblePairs[addedIndex];
                addPair(added);
            }
            // console.log('costgroup', group)
            let totalCost = group.map(g => g.cost).reduce((a, b) => a + b, 0);
            let tileGroup = group
                .map(g => this.tileMap.get(g.id));
            tileGroup.push(tile);
            // console.log('grouping', tileGroup.map(tile => tile.id), 'for cost', totalCost, '=>', nextGroupIndex);
            tileGroup.forEach(groupTile => {
                ungroupedTiles.splice(ungroupedTiles.indexOf(groupTile), 1);
                if (groupTile.groupIndex != null)
                    console.error("tile already has group index", groupTile.groupIndex);
                groupTile.groupIndex = nextGroupIndex;
                groupedTiles.push(groupTile);
                // if (addStone) groupTile.isStoneTile = true;
            });
            nextGroupIndex++;
            return tileGroup;
        };
        let addMoveset = () => {
            let available = new Set();
            ungroupedTiles.forEach(tile => available.add(tile));
            movesets.forEach(moveset => moveset.footprint.forEach(tile => available.delete(tile)));
            if (available.size == 0)
                return null;
            let preferredTiles = Array.from(available).filter(tile => {
                let neighbors = tile.getNeighbors();
                return neighbors.every(neighbor => available.has(neighbor));
            });
            if (preferredTiles.length == 0)
                preferredTiles = Array.from(available);
            let baseTile = preferredTiles[Math.floor(this.random() * preferredTiles.length)];
            let move = createMove(baseTile);
            if (move == null)
                return null;
            let moveset = new Moveset(stones);
            moveset.addMove(move);
            return moveset;
        };
        let createNewMovesets = () => {
            let reduction = Math.ceil((stones - 2) / 2);
            let maxMovesets = 4 - reduction, minMovesets = Math.max(0, 2 - reduction);
            let nMovesets = Math.floor(this.random() * (maxMovesets - minMovesets + 1)) + minMovesets;
            let createdMovesets = 0;
            for (let i = 0; i < nMovesets; i++) {
                let moveset = addMoveset();
                if (moveset != null) {
                    movesets.push(moveset);
                    createdMovesets++;
                }
            }
            console.log('created', createdMovesets, 'new movesets');
            return createdMovesets > 0;
        };
        let selectNextBaseTile = (moveset, disallowedTiles, useMostRecentMove = false) => {
            let moves = moveset.moves;
            let index = moves.length - 1;
            if (!useMostRecentMove) {
                while (index > 0 && this.random() > 0.4)
                    index--;
            }
            let dependentMove = moves[index];
            // console.log('dependent move', dependentMove);
            let possibleStartingTiles = new Set();
            dependentMove.forEach(tile => {
                this.findUngroupedTilesWithinDistance(gridAdapter, tile, stones - 1)
                    .forEach(pair => possibleStartingTiles.add(this.tileMap.get(pair.id)));
            });
            let originalStartingTiles = new Set(possibleStartingTiles);
            removeAllFrom(possibleStartingTiles, disallowedTiles);
            dependentMove.forEach(tile => possibleStartingTiles.delete(tile));
            if (possibleStartingTiles.size == 0) {
                console.log('no possible starting tiles for dependent move', dependentMove, disallowedTiles, originalStartingTiles);
                return null;
            }
            let tile = Array.from(possibleStartingTiles)[Math.floor(this.random() * possibleStartingTiles.size)];
            // console.log('tadm', tile, ...dependentMove);
            return { tile, dependentMove };
        };
        // TODO: Still some black tiles - could bail out early with a fix
        let maxAttempts = 50;
        let attemptsSinceLastProgress = 0;
        let allowUnions = false;
        // let stoneMoveset = null as Moveset;
        let joinableFootprints = [];
        // TODO: Should lower this bar: we want more joins
        let updateAllowUnions = () => {
            if (groupedTiles.length * this.random() > Math.pow(stones, 2.5) * 2.5) {
                allowUnions = true;
            }
        };
        // seed with initial movesets
        createNewMovesets();
        console.log('initial movesets', movesets);
        while (ungroupedTiles.length >= stones && nextGroupIndex < LevelGenerator.maxGroupIndex) {
            attemptsSinceLastProgress++;
            if (attemptsSinceLastProgress > maxAttempts) {
                // If we've tried enough with unions allowed, we're really stuck, so bail out
                if (allowUnions) {
                    break;
                }
                // If not, allow unions and keep trying
                allowUnions = true;
                attemptsSinceLastProgress = 0;
            }
            let moveset = movesets[Math.floor(this.random() * movesets.length)];
            // If set have a moveset marked to add a stone, use that moveset
            // TODO: Could add some randomness
            // let addStone = stoneMoveset != null;
            // if (addStone) {
            //     moveset = stoneMoveset;
            //     stoneMoveset = null;
            // }
            let disallowedTiles = new Set();
            movesets.forEach(ms => {
                if (ms == moveset)
                    return;
                ms.footprint.forEach(tile => disallowedTiles.add(tile));
            });
            let next = selectNextBaseTile(moveset, disallowedTiles, false);
            if (next == null)
                continue;
            let { tile, dependentMove } = next;
            if (disallowedTiles.has(tile))
                console.error('disallowed tile', tile);
            let move = createMove(tile, dependentMove, allowUnions ? new Set() : disallowedTiles, false);
            if (move == null)
                continue;
            moveset.addMove(move);
            attemptsSinceLastProgress = 0;
            updateAllowUnions();
            // TODO: Either need to guarantee somehow the movesets join earlier
            // Or allow stone increase outside of moveset joing (former preferred)
            if (stones < LevelGenerator.maxStones) {
                // BUG: This doesn't seem to trigger on some maps!!
                // For each tile in this move, check if it has a unique footprint
                // (it starts in one and outside of all others), and collect these
                let uniqueFootprints = move.map(m => {
                    let footprints = joinableFootprints.filter(jf => jf.has(m));
                    // If this move is part of multiple footprints, skip it since it's a border tile
                    if (footprints.length == 1)
                        return footprints[0];
                    return null;
                }).filter(jf => jf != null);
                // Filter to remove duplicates: we need multiple distinct "unique footprints"
                uniqueFootprints = uniqueFootprints.filter((v, i, a) => a.indexOf(v) === i);
                console.log(uniqueFootprints);
                // If this move joins 2 unique footprints, it's a stone move
                if (uniqueFootprints.length > 1) {
                    console.log('stone move', move, 'from joining', uniqueFootprints);
                    // Remove the footprints that are being joined
                    joinableFootprints = joinableFootprints.filter(jf => !uniqueFootprints.includes(jf));
                    move.forEach(tile => {
                        tile.isStoneTile = true;
                    });
                    stones++;
                    movesets.forEach(ms => ms.setStones(stones));
                    createNewMovesets();
                    // stoneMoveset = null;
                    // TODO: There still seems to be some way that stones are placed
                    // within one seeming group. I'm wondering if we need the big and
                    // small footprints (exclude from big, include in small)
                    // Or if maybe earlier footprints need to be removed when stones
                    // increase...? Need to think about it.
                }
            }
            // No need for this - unions can form when stones increase,
            // so we always sort of need to check
            // if (!allowUnions) continue;
            let joinedMovesetFootprints = [];
            let nFootprintStones = 1; // Math.ceil(stones / 2);
            // If we're allowed to join movesets, check if we have
            for (let i = 0; i < movesets.length; i++) {
                let ms = movesets[i];
                if (ms == moveset)
                    continue;
                if (move.some(t => ms.footprint.has(t))) {
                    // Record the footprints of each moveset (before joining!)
                    // The joinable footprint is 1 smaller than the regular footprint, since
                    // while it's possible to interfere with another moveset at "stones" radius
                    // joining would only require stones - 1 radius
                    if (joinedMovesetFootprints.length == 0) {
                        joinedMovesetFootprints.push(moveset.createFootprint(nFootprintStones));
                    }
                    joinedMovesetFootprints.push(ms.createFootprint(nFootprintStones));
                    console.log('joining movesets', moveset, ms);
                    moveset.add(ms);
                    movesets.splice(i, 1);
                    i--;
                }
            }
            ;
            // If we didn't join any movesets, continue
            if (joinedMovesetFootprints.length <= 1)
                continue;
            console.log('joined moveset footprints', joinedMovesetFootprints);
            // No more new unions until the criteria are met
            allowUnions = false;
            if (stones < LevelGenerator.maxStones) {
                joinedMovesetFootprints.forEach(ms => joinableFootprints.push(ms));
            }
        }
        return this.grid;
    }
}
exports.LevelGenerator = LevelGenerator;
LevelGenerator.maxStones = 6;
LevelGenerator.maxGroupIndex = 200;
function findSubsetsThatSumTo(target, numbers) {
    let wheel = [0];
    let resultsCount = 0;
    let sum = 0;
    let sumIndices = [];
    do {
        sum = incrementWheel(0, sum, numbers, wheel);
        //Use subtraction comparison due to javascript float imprecision
        if (sum != null && Math.abs(target - sum) < 0.000001) {
            //Found a subset. Add the result.
            sumIndices.push([...wheel.keys()].filter(i => wheel[i] === 1));
            resultsCount++;
        }
    } while (sum != null);
    return sumIndices;
}
function incrementWheel(position, sum, numbers, wheel) {
    if (position === numbers.length || sum === null) {
        return null;
    }
    wheel[position]++;
    if (wheel[position] === 2) {
        wheel[position] = 0;
        sum -= numbers[position];
        if (wheel.length < position + 2) {
            wheel.push(0);
        }
        sum = incrementWheel(position + 1, sum, numbers, wheel);
    }
    else {
        sum += numbers[position];
    }
    return sum;
}
function removeAllFrom(set, toRemove) {
    toRemove.forEach(item => set.delete(item));
}
function intersect(a, b) {
    let result = new Set();
    a.forEach(item => {
        if (b.has(item))
            result.add(item);
    });
    return result;
}


/***/ }),

/***/ "./src/roots/Roots.ts":
/*!****************************!*\
  !*** ./src/roots/Roots.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Roots = void 0;
const honeycomb_grid_1 = __webpack_require__(/*! honeycomb-grid */ "./node_modules/honeycomb-grid/dist/honeycomb-grid.umd.js");
const Tile_1 = __webpack_require__(/*! ./Tile */ "./src/roots/Tile.ts");
const Clustering_1 = __webpack_require__(/*! ./Clustering */ "./src/roots/Clustering.ts");
const LevelGenerator_1 = __webpack_require__(/*! ./LevelGenerator */ "./src/roots/LevelGenerator.ts");
class Roots {
    constructor(seed) {
        // serializable fields
        this.width = 20;
        this.height = 15;
        this.nStones = 2;
        // derived fields
        this.groups = [];
        this.clustering = new Clustering_1.Clustering();
        // client-only fields
        // TODO: Consider just passing this from the renderer
        this.activeTiles = [];
        this.seed = seed;
    }
    get nFreeStones() {
        return this.nStones - this.activeTiles.length;
    }
    createNewLevel() {
        let generator = new LevelGenerator_1.LevelGenerator(this.seed, this.width, this.height);
        this.grid = generator.generate();
        this.initializeGrid();
        this.save();
    }
    initializeGrid() {
        this.grid.forEach(tile => {
            tile.game = this;
            tile.grid = this.grid;
            if (!this.groups[tile.groupIndex]) {
                this.groups[tile.groupIndex] = [];
            }
            this.groups[tile.groupIndex].push(tile);
            if (tile.unlocked) {
                this.clustering.addTileAndConnectNeighbors(tile);
            }
        });
        this.grid.forEach(tile => {
            tile.groupCount = this.groups[tile.groupIndex].length;
        });
        console.log('created starting clustering', this.clustering);
    }
    save() {
        let data = this.serialize();
        // console.log('saving...', data);
        this.onNeedSave(this.serialize());
    }
    serialize() {
        return {
            seed: this.seed,
            width: this.width,
            height: this.height,
            tiles: this.grid.toArray().map(tile => tile.serialize()),
            nStones: this.nStones,
        };
    }
    deserialize(data) {
        console.log('loading...', data);
        this.seed = data.seed;
        this.nStones = data.nStones;
        this.width = data.width;
        this.height = data.height;
        this.grid = new honeycomb_grid_1.Grid(Tile_1.Tile, (0, honeycomb_grid_1.rectangle)({ width: data.width, height: data.height }));
        let i = 0;
        this.grid.forEach(tile => {
            tile.deserialize(i, data.tiles[i++]);
        });
        this.initializeGrid();
        console.log('finished loading', this);
    }
    // Either this or "Check Connections" still has a bug in it - need to find it
    tileClicked(tile) {
        if (tile.active) {
            tile.active = false;
            this.activeTiles.splice(this.activeTiles.indexOf(tile), 1);
            this.clustering = this.backupClustering.copy();
            this.activeTiles.forEach(tile => {
                // console.log(JSON.stringify(this.clustering), tile.id);
                this.clustering.addTileAndConnectNeighbors(tile);
            });
        }
        else {
            if (this.activeTiles.length >= this.nStones)
                return;
            // console.log(this.activeTiles.length, this.nStones);
            tile.active = true;
            this.activeTiles.push(tile);
            if (this.backupClustering == null) {
                this.backupClustering = this.clustering.copy();
            }
            this.clustering.addTileAndConnectNeighbors(tile);
            this.checkConnections();
            console.log(this.clustering);
        }
        // console.log(this.clustering.clusters);
    }
    clearSelection() {
        this.clearActive(false);
        this.onNeedRefresh();
    }
    checkConnections() {
        let activeGroupIndices = this.activeTiles.map(tile => tile.groupIndex);
        activeGroupIndices = activeGroupIndices.filter(groupIndex => groupIndex !== undefined);
        // remove duplicates
        activeGroupIndices = activeGroupIndices.filter((value, index, self) => self.indexOf(value) === index);
        if (activeGroupIndices.length === 0)
            return;
        // console.log('checking connections', activeGroupIndices);
        let clear = false, refresh = false;
        for (let i = 0; i < activeGroupIndices.length; i++) {
            let groupIndex = activeGroupIndices[i];
            let group = this.groups[groupIndex];
            let clusterIndex = this.clustering.getClusterIndex(group[0].id);
            console.log(group, group.map(tile => this.clustering.getClusterIndex(tile.id)));
            if (group.every(tile => {
                return this.activeTiles.includes(tile) &&
                    clusterIndex === this.clustering.getClusterIndex(tile.id);
            })) {
                group.forEach(tile => {
                    tile.unlocked = true;
                });
                if (group.length > 1)
                    clear = true;
                refresh = true;
                if (group[0].isStoneTile) {
                    this.nStones++;
                }
                // console.log('unlocked group ' + groupIndex);
            }
        }
        if (refresh) {
            this.clearActive(!clear);
            this.save();
            this.onNeedRefresh();
        }
    }
    clearActive(restoreActive) {
        if (this.backupClustering != null) {
            this.clustering = this.backupClustering.copy();
        }
        this.backupClustering = null;
        let toRestore = [];
        this.activeTiles.forEach(tile => {
            if (tile.unlocked) {
                this.clustering.addTileAndConnectNeighbors(tile);
            }
            else {
                toRestore.push(tile);
            }
            tile.active = false;
        });
        this.activeTiles = [];
        if (restoreActive) {
            this.backupClustering = this.clustering.copy();
            toRestore.forEach(tile => {
                tile.active = true;
                this.activeTiles.push(tile);
                this.clustering.addTileAndConnectNeighbors(tile);
            });
        }
    }
}
exports.Roots = Roots;


/***/ }),

/***/ "./src/roots/Tile.ts":
/*!***************************!*\
  !*** ./src/roots/Tile.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tile = void 0;
const honeycomb_grid_1 = __webpack_require__(/*! honeycomb-grid */ "./node_modules/honeycomb-grid/dist/honeycomb-grid.umd.js");
class Tile extends (0, honeycomb_grid_1.defineHex)({ dimensions: 30, origin: "topLeft" }) {
    constructor() {
        super(...arguments);
        this.isStoneTile = false;
        this.unlocked = false;
        this.active = false;
    }
    serialize() {
        return {
            unlocked: this.unlocked,
            groupIndex: this.groupIndex,
            isStoneTile: this.isStoneTile,
        };
    }
    deserialize(id, data) {
        this.id = id;
        this.unlocked = data.unlocked;
        this.groupIndex = data.groupIndex;
        this.isStoneTile = data.isStoneTile;
    }
    isPassable() {
        return this.active || this.unlocked;
    }
    clicked() {
        if (this.unlocked)
            return;
        this.game.tileClicked(this);
    }
    getNeighbors() {
        let neighbors = [];
        for (let i = 0; i < 8; i++) {
            let neighbor = this.grid.neighborOf(this, i, { allowOutside: false });
            if (neighbor) {
                neighbors.push(neighbor);
            }
        }
        return neighbors;
    }
    getPassableNeighbors() {
        return this.getNeighbors().filter(neighbor => neighbor.isPassable());
    }
}
exports.Tile = Tile;


/***/ }),

/***/ "./src/util/Dijkstra.ts":
/*!******************************!*\
  !*** ./src/util/Dijkstra.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findShortestPath = exports.dijkstra = void 0;
const priorityqueuejs_1 = __importDefault(__webpack_require__(/*! priorityqueuejs */ "./node_modules/priorityqueuejs/index.js"));
const getNodeKey = (node, adapter) => {
    if (typeof adapter.getKey === "function")
        return adapter.getKey(node);
    if (typeof node === "string" || typeof node === "number")
        return node;
    throw new Error("Adapter must implement method getKey");
};
const dijkstra = (adapter, startNode, finishNode, maxCost) => {
    const getKey = (node) => getNodeKey(node, adapter);
    const parents = Object.create(null);
    const costs = Object.create(null);
    const explored = Object.create(null);
    const prioQueue = new priorityqueuejs_1.default((a, b) => b.cost - a.cost);
    prioQueue.enq({ node: startNode, cost: 0 });
    do {
        let node = prioQueue.deq().node;
        let nodeKey = getKey(node);
        let cost = costs[nodeKey] || 0;
        if (maxCost != null && cost > maxCost)
            break;
        explored[nodeKey] = true;
        // Early return when the shortest path in our
        // graph is already the finishNode
        if (finishNode != null && nodeKey === getKey(finishNode))
            break;
        const edges = adapter.getEdges(node);
        for (let i = 0; i < edges.length; i++) {
            const childNode = edges[i].node;
            const childNodeKey = getKey(childNode);
            let alt = cost + edges[i].weight;
            if (alt <= maxCost && (undefined === costs[childNodeKey] || alt < costs[childNodeKey])) {
                costs[childNodeKey] = alt;
                parents[childNodeKey] = node;
                if (!explored[childNodeKey]) {
                    prioQueue.enq({ node: childNode, cost: alt });
                }
            }
        }
    } while (!prioQueue.isEmpty());
    return {
        costs,
        parents,
    };
};
exports.dijkstra = dijkstra;
const findShortestPath = (adapter, startNode, finishNode) => {
    const getKey = (node) => getNodeKey(node, adapter);
    const { costs, parents } = (0, exports.dijkstra)(adapter, startNode, finishNode);
    let optimalPath = [finishNode];
    let parent = parents[getKey(finishNode)];
    while (parent) {
        optimalPath.push(parent);
        parent = parents[getKey(parent)];
    }
    optimalPath.reverse();
    const results = {
        distance: costs[getKey(finishNode)],
        path: optimalPath,
    };
    return results;
};
exports.findShortestPath = findShortestPath;


/***/ }),

/***/ "./node_modules/url/node_modules/punycode/punycode.js":
/*!************************************************************!*\
  !*** ./node_modules/url/node_modules/punycode/punycode.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));


/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(/*! punycode */ "./node_modules/url/node_modules/punycode/punycode.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/url/util.js");

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),

/***/ "./node_modules/url/util.js":
/*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
/***/ ((module) => {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),

/***/ "?d4c0":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd define */
/******/ 	(() => {
/******/ 		__webpack_require__.amdD = function () {
/******/ 			throw new Error('define cannot be used indirect');
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	roots = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDOztBQUUxQztBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQzs7QUFFMUM7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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LE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0cscUJBQXFCO0FBQzNILDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsYUFBYSxtQkFBTyxDQUFDLCtGQUFhO0FBQ2xDLG1CQUFPLENBQUMsbUhBQXVCO0FBQy9CLGdDQUFnQyxtQkFBTyxDQUFDLDJKQUEyQzs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG1CQUFtQjtBQUNw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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQyxjQUFjLHFDQUFxQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBa0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7Ozs7Ozs7Ozs7OztBQzFXYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELFdBQVcsbUJBQU8sQ0FBQywrRUFBWTtBQUMvQixjQUFjLG1CQUFPLENBQUMsa0dBQXNCO0FBQzVDLGFBQWEsbUJBQU8sQ0FBQyxnR0FBcUI7QUFDMUMsbUJBQW1CLG1CQUFPLENBQUMsNEdBQTJCOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBLDZFQUE2RSx5QkFBeUI7QUFDdEc7QUFDQSx3REFBd0QsWUFBWTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxFQUFFO0FBQ3BDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsK0JBQStCLEVBQUUsa0JBQWtCO0FBQ25ELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCOzs7Ozs7Ozs7Ozs7QUNoRWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxpQkFBaUIsbUJBQU8sQ0FBQywyRkFBa0I7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsdUdBQXFCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25COzs7Ozs7Ozs7Ozs7QUN0RWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7Ozs7Ozs7Ozs7OztBQ25CYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCOzs7Ozs7Ozs7Ozs7QUN2QmE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxlQUFlLG1CQUFPLENBQUMsdUZBQWdCOztBQUV2QztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCOzs7Ozs7Ozs7Ozs7QUNYYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELGVBQWUsbUJBQU8sQ0FBQyx1RkFBZ0I7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5Qjs7Ozs7Ozs7Ozs7O0FDakNhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0Qsa0RBQWtELHNCQUFzQiwyQkFBMkIsdUNBQXVDLG9CQUFvQixpQkFBaUIsbURBQW1ELEdBQUc7O0FBRXJPLGtCQUFrQjtBQUNsQjs7Ozs7Ozs7Ozs7O0FDUGE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCwyQ0FBMkMsaUNBQWlDLCtCQUErQix3QkFBd0IsNkJBQTZCLGtDQUFrQyxpQ0FBaUMsb0JBQW9CLCtCQUErQixzQkFBc0IsMkJBQTJCLG9CQUFvQiwyR0FBMkcsc0NBQXNDLDhCQUE4Qiw2QkFBNkIsR0FBRzs7QUFFMWlCLGtCQUFrQjtBQUNsQjs7Ozs7Ozs7Ozs7O0FDUGE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxnQkFBZ0IsbUJBQU8sQ0FBQyx5RkFBaUI7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsMkZBQWtCO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyx1RkFBZ0I7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7Ozs7Ozs7Ozs7OztBQzFLYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELGdCQUFnQixtQkFBTyxDQUFDLHlGQUFpQjtBQUN6QyxjQUFjLG1CQUFPLENBQUMsa0dBQXNCO0FBQzVDLGFBQWEsbUJBQU8sQ0FBQyxnR0FBcUI7QUFDMUMsWUFBWSxtQkFBTyxDQUFDLDRGQUFtQjtBQUN2QyxzQkFBc0IsbUJBQU8sQ0FBQyx1R0FBb0I7QUFDbEQsb0JBQW9CLG1CQUFPLENBQUMseUdBQXFCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkOzs7Ozs7Ozs7Ozs7QUNqRGE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxnQkFBZ0IsbUJBQU8sQ0FBQyx5RkFBaUI7QUFDekMsV0FBVyxtQkFBTyxDQUFDLCtFQUFZOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7Ozs7Ozs7Ozs7O0FDN0JhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsZ0JBQWdCLG1CQUFPLENBQUMseUZBQWlCO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLDJGQUFrQjtBQUMzQyxXQUFXLG1CQUFPLENBQUMsK0VBQVk7QUFDL0Isd0JBQXdCLG1CQUFPLENBQUMsb0lBQXVDO0FBQ3ZFLG1CQUFtQixtQkFBTyxDQUFDLDRHQUEyQjtBQUN0RCxXQUFXLG1CQUFPLENBQUMsMEZBQWtCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyw4RkFBb0I7QUFDekMsa0JBQWtCLG1CQUFPLENBQUMsbUdBQWtCOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUMsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNDQUFzQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEs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Q0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxFQUFFLEtBQUssRUFBRTtBQUM3RTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTyxHQUFHLFlB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjs7Ozs7Ozs7Ozs7O0FDeE9hOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsV0FBVyxtQkFBTyxDQUFDLCtFQUFZOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUs7QUFDakM7QUFDQSx3RkFBd0YsS0FBSztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0Q0FBNEMsMkNBQTJDO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjs7Ozs7Ozs7Ozs7O0FDMW9CYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELFdBQVcsbUJBQU8sQ0FBQywrRUFBWTtBQUMvQixvQkFBb0IsbUJBQU8sQ0FBQyxpR0FBb0I7QUFDaEQsa0JBQWtCLG1CQUFPLENBQUMsNkZBQWtCO0FBQzVDLDRCQUE0QixtQkFBTyxDQUFDLGlIQUE0QjtBQUNoRSwwQkFBMEIsbUJBQU8sQ0FBQyw2R0FBMEI7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNDQUFzQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7Ozs7Ozs7Ozs7OztBQ2xhYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELFdBQVcsbUJBQU8sQ0FBQywrRUFBWTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Ozs7O0FBSWxELGtCQUFrQjtBQUNsQixzQkFBc0I7QUFDdEI7Ozs7Ozs7Ozs7OztBQ1hhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsV0FBVyxtQkFBTyxDQUFDLCtFQUFZO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLDBHQUFrQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtEQUErRDtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMkNBQTJDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhCQUE4QjtBQUMxQztBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMseUJBQXlCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7Ozs7Ozs7Ozs7OztBQ25lYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCOzs7Ozs7Ozs7Ozs7QUM3QmE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxXQUFXLG1CQUFPLENBQUMsK0VBQVk7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLHFGQUFlO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLGlHQUFtQjtBQUM5QyxZQUFZLG1CQUFPLENBQUMsK0ZBQWtCO0FBQ3RDLGdCQUFnQixtQkFBTyxDQUFDLHVHQUFzQjtBQUM5QyxnQkFBZ0IsbUJBQU8sQ0FBQyx1R0FBc0I7QUFDOUMsZ0JBQWdCLG1CQUFPLENBQUMsdUdBQXNCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0JBQXdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseUJBQXlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlDQUFpQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0FBQyxxRkFBZTtBQUNyQyxtQkFBbUIsbUJBQU8sQ0FBQyw2RkFBbUI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDBDQUEwQyxpQkFBaUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzRUFBc0U7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsV0FBVyxtQkFBTyxDQUFDLCtFQUFZO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyxxRkFBZTs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RCw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkMsc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7Ozs7Ozs7Ozs7O0FDdFlhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsYUFBYSxtQkFBTyxDQUFDLCtFQUFZO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQywrRUFBWTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxjQUFjO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCLEVBQUUsa0JBQWtCLEVBQUUsaUJBQWlCLEVBQUUsZ0JBQWdCLEVBQUUsdUJBQXVCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjs7Ozs7Ozs7Ozs7O0FDdFhhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjs7QUFFdEIscUJBQXFCO0FBQ3JCOzs7Ozs7Ozs7Ozs7QUNYYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELGFBQWEsbUJBQU8sQ0FBQywrRUFBWTtBQUNqQyxXQUFXLG1CQUFPLENBQUMsNkVBQVc7QUFDOUIsa0JBQWtCLG1CQUFPLENBQUMsMkZBQWtCO0FBQzVDLGdCQUFnQixtQkFBTyxDQUFDLHVGQUFnQjs7OztBQUl4QyxxQkFBcUI7QUFDckIsWUFBWTtBQUNaLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakI7Ozs7Ozs7Ozs7OztBQ2ZhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsYUFBYSxtQkFBTyxDQUFDLGlGQUFZO0FBQ2pDLHFCQUFxQixtQkFBTyxDQUFDLG1HQUFxQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDM3RCYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2ZBOzs7Ozs7VUNBQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDekJBO1dBQ0E7V0FDQTs7Ozs7V0NGQTs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxDQUFDOzs7OztXQ1BEOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7V0NOQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOzs7OztVRUpBO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29sb3IvbGliL0NvbG9yLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbG9yL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9jb2xvcmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvY29sb3JkL3BsdWdpbnMvbmFtZXMuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvZWFyY3V0L3NyYy9lYXJjdXQuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvaG9uZXljb21iLWdyaWQvZGlzdC9ob25leWNvbWItZ3JpZC51bWQuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvaXNtb2JpbGVqcy9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvaXNtb2JpbGVqcy9lc20vaXNNb2JpbGUuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZmlsdGVycy5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9hY2Nlc3NpYmlsaXR5L2xpYi9BY2Nlc3NpYmlsaXR5TWFuYWdlci5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9hY2Nlc3NpYmlsaXR5L2xpYi9hY2Nlc3NpYmxlVGFyZ2V0LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2FjY2Vzc2liaWxpdHkvbGliL2luZGV4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2FwcC9saWIvQXBwbGljYXRpb24uanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvYXBwL2xpYi9SZXNpemVQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvYXBwL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL0Fzc2V0RXh0ZW5zaW9uLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvQXNzZXRzLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvQmFja2dyb3VuZExvYWRlci5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2NhY2hlL0NhY2hlLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvY2FjaGUvQ2FjaGVQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9jYWNoZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2NhY2hlL3BhcnNlcnMvY2FjaGVUZXh0dXJlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9jYWNoZS9wYXJzZXJzL2luZGV4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvZGV0ZWN0aW9ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RBdmlmLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdERlZmF1bHRzLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdFdlYnAuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9kZXRlY3Rpb25zL3BhcnNlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci9Mb2FkZXIuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvcGFyc2Vycy9Mb2FkZXJQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvcGFyc2Vycy9Xb3JrZXJNYW5hZ2VyLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvcGFyc2Vycy9sb2FkSnNvbi5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci9wYXJzZXJzL2xvYWRUeHQuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvcGFyc2Vycy9sb2FkV2ViRm9udC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL2luZGV4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvbG9hZFNWRy5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL2xvYWRUZXh0dXJlcy5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL3V0aWxzL2NyZWF0ZVRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvcGFyc2Vycy90ZXh0dXJlcy91dGlscy9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci90eXBlcy5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3Jlc29sdmVyL1Jlc29sdmVyLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvcmVzb2x2ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9yZXNvbHZlci9wYXJzZXJzL2luZGV4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvcmVzb2x2ZXIvcGFyc2Vycy9yZXNvbHZlVGV4dHVyZVVybC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3Jlc29sdmVyL3R5cGVzLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvdXRpbHMvY2hlY2tEYXRhVXJsLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvdXRpbHMvY2hlY2tFeHRlbnNpb24uanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi91dGlscy9jb252ZXJ0VG9MaXN0LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvdXRpbHMvY29weVNlYXJjaFBhcmFtcy5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3V0aWxzL2NyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi91dGlscy9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3V0aWxzL2lzU2luZ2xlSXRlbS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9jb25zdC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9sb2FkZXJzL2NvbXByZXNzZWRUZXh0dXJlRXh0ZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9sb2FkZXJzL2RldGVjdENvbXByZXNzZWRUZXh0dXJlcy5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9sb2FkZXJzL2luZGV4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL2xvYWRlcnMvbG9hZEREUy5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9sb2FkZXJzL2xvYWRLVFguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcy9saWIvbG9hZGVycy9yZXNvbHZlQ29tcHJlc3NlZFRleHR1cmVVcmwuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcy9saWIvcGFyc2Vycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9wYXJzZXJzL3BhcnNlRERTLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL3BhcnNlcnMvcGFyc2VLVFguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcy9saWIvcmVzb3VyY2VzL0Jsb2JSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9yZXNvdXJjZXMvQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9yZXNvdXJjZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29uc3RhbnRzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9JUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYXV0b0RldGVjdFJlbmRlcmVyLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2JhY2tncm91bmQvQmFja2dyb3VuZFN5c3RlbS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9iYXRjaC9CYXRjaERyYXdDYWxsLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2JhdGNoL0JhdGNoR2VvbWV0cnkuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmF0Y2gvQmF0Y2hSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9iYXRjaC9CYXRjaFNoYWRlckdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9iYXRjaC9CYXRjaFN5c3RlbS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9iYXRjaC9CYXRjaFRleHR1cmVBcnJheS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9iYXRjaC9PYmplY3RSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9iYXRjaC9jYW5VcGxvYWRTYW1lQnVmZmVyLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2JhdGNoL21heFJlY29tbWVuZGVkVGV4dHVyZXMuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmF0Y2gvdGV4dHVyZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9iYXRjaC90ZXh0dXJlMi5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9jb250ZXh0L0NvbnRleHRTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZmlsdGVycy9GaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZmlsdGVycy9GaWx0ZXJTdGF0ZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9maWx0ZXJzL0ZpbHRlclN5c3RlbS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9maWx0ZXJzL0lGaWx0ZXJUYXJnZXQuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZmlsdGVycy9kZWZhdWx0RmlsdGVyLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZpbHRlcnMvZGVmYXVsdEZpbHRlcjIuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZmlsdGVycy9zcHJpdGVNYXNrL1Nwcml0ZU1hc2tGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZmlsdGVycy9zcHJpdGVNYXNrL3Nwcml0ZU1hc2tGaWx0ZXIyLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZpbHRlcnMvc3ByaXRlTWFzay9zcHJpdGVNYXNrRmlsdGVyMy5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9mcmFnbWVudHMvZGVmYXVsdC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9mcmFnbWVudHMvZGVmYXVsdEZpbHRlci5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9mcmFnbWVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZnJhbWVidWZmZXIvRnJhbWVidWZmZXIuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZnJhbWVidWZmZXIvRnJhbWVidWZmZXJTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZnJhbWVidWZmZXIvR0xGcmFtZWJ1ZmZlci5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9mcmFtZWJ1ZmZlci9NdWx0aXNhbXBsZVN5c3RlbS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9nZW9tZXRyeS9BdHRyaWJ1dGUuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZ2VvbWV0cnkvQnVmZmVyLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2dlb21ldHJ5L0J1ZmZlclN5c3RlbS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9nZW9tZXRyeS9HTEJ1ZmZlci5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9nZW9tZXRyeS9HZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9nZW9tZXRyeS9HZW9tZXRyeVN5c3RlbS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9nZW9tZXRyeS9WaWV3YWJsZUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9nZW9tZXRyeS91dGlscy9pbnRlcmxlYXZlVHlwZWRBcnJheXMuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvbWFzay9BYnN0cmFjdE1hc2tTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvbWFzay9NYXNrRGF0YS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9tYXNrL01hc2tTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvbWFzay9TY2lzc29yU3lzdGVtLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL21hc2svU3RlbmNpbFN5c3RlbS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9wbHVnaW4vUGx1Z2luU3lzdGVtLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3Byb2plY3Rpb24vUHJvamVjdGlvblN5c3RlbS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9yZW5kZXJUZXh0dXJlL0Jhc2VSZW5kZXJUZXh0dXJlLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3JlbmRlclRleHR1cmUvR2VuZXJhdGVUZXh0dXJlU3lzdGVtLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3JlbmRlclRleHR1cmUvUmVuZGVyVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9yZW5kZXJUZXh0dXJlL1JlbmRlclRleHR1cmVQb29sLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3JlbmRlclRleHR1cmUvUmVuZGVyVGV4dHVyZVN5c3RlbS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9yZW5kZXIvT2JqZWN0UmVuZGVyZXJTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL0dMUHJvZ3JhbS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvUHJvZ3JhbS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvU2hhZGVyLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci9TaGFkZXJTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL1VuaWZvcm1Hcm91cC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvZGVmYXVsdFByb2dyYW0uanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL2RlZmF1bHRQcm9ncmFtMi5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlci5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvY29tcGlsZVNoYWRlci5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvZGVmYXVsdFZhbHVlLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9nZW5lcmF0ZVByb2dyYW0uanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL2dlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL2dlbmVyYXRlVW5pZm9ybXNTeW5jLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9nZXRBdHRyaWJ1dGVEYXRhLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9nZXRNYXhGcmFnbWVudFByZWNpc2lvbi5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvZ2V0VGVzdENvbnRleHQuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL2dldFVuaWZvcm1EYXRhLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvbG9nUHJvZ3JhbUVycm9yLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9tYXBTaXplLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9tYXBUeXBlLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9zZXRQcmVjaXNpb24uanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL3VuaWZvcm1QYXJzZXJzLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy91bnNhZmVFdmFsU3VwcG9ydGVkLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3N0YXJ0dXAvU3RhcnR1cFN5c3RlbS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zdGF0ZS9TdGF0ZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zdGF0ZS9TdGF0ZVN5c3RlbS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zdGF0ZS91dGlscy9tYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc3lzdGVtL0lTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc3lzdGVtL1N5c3RlbU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc3lzdGVtcy5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9CYXNlVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9HTFRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9UZXh0dXJlR0NTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvVGV4dHVyZU1hdHJpeC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9UZXh0dXJlU3lzdGVtLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL1RleHR1cmVVdnMuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL0Fic3RyYWN0TXVsdGlSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9yZXNvdXJjZXMvQXJyYXlSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9yZXNvdXJjZXMvQmFzZUltYWdlUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL0J1ZmZlclJlc291cmNlLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9DYW52YXNSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9yZXNvdXJjZXMvQ3ViZVJlc291cmNlLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9EZXB0aFJlc291cmNlLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9JbWFnZUJpdG1hcFJlc291cmNlLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9JbWFnZVJlc291cmNlLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9SZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9yZXNvdXJjZXMvU1ZHUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL1ZpZGVvUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL2F1dG9EZXRlY3RSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9yZXNvdXJjZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvdXRpbHMvbWFwVHlwZUFuZEZvcm1hdFRvSW50ZXJuYWxGb3JtYXQuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdHJhbnNmb3JtRmVlZGJhY2svVHJhbnNmb3JtRmVlZGJhY2suanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdHJhbnNmb3JtRmVlZGJhY2svVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdXRpbHMvUXVhZC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi91dGlscy9RdWFkVXYuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdmlldy9WaWV3U3lzdGVtLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2Rpc3BsYXkvbGliL0JvdW5kcy5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9kaXNwbGF5L2xpYi9Db250YWluZXIuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvZGlzcGxheS9saWIvRGlzcGxheU9iamVjdC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9kaXNwbGF5L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9kaXNwbGF5L2xpYi9zZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9ldmVudHMvbGliL0V2ZW50Qm91bmRhcnkuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvZXZlbnRzL2xpYi9FdmVudFN5c3RlbS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9ldmVudHMvbGliL0V2ZW50VGlja2VyLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2V2ZW50cy9saWIvRmVkZXJhdGVkRXZlbnQuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvZXZlbnRzL2xpYi9GZWRlcmF0ZWRFdmVudE1hcC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9ldmVudHMvbGliL0ZlZGVyYXRlZEV2ZW50VGFyZ2V0LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2V2ZW50cy9saWIvRmVkZXJhdGVkTW91c2VFdmVudC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9ldmVudHMvbGliL0ZlZGVyYXRlZFBvaW50ZXJFdmVudC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9ldmVudHMvbGliL0ZlZGVyYXRlZFdoZWVsRXZlbnQuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvZXZlbnRzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9leHRlbnNpb25zL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9leHRyYWN0L2xpYi9FeHRyYWN0LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2V4dHJhY3QvbGliL2luZGV4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1hbHBoYS9saWIvQWxwaGFGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWFscGhhL2xpYi9hbHBoYS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItYWxwaGEvbGliL2luZGV4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1ibHVyL2xpYi9CbHVyRmlsdGVyLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1ibHVyL2xpYi9CbHVyRmlsdGVyUGFzcy5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItYmx1ci9saWIvZ2VuZXJhdGVCbHVyRnJhZ1NvdXJjZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItYmx1ci9saWIvZ2VuZXJhdGVCbHVyVmVydFNvdXJjZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItYmx1ci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWNvbG9yLW1hdHJpeC9saWIvQ29sb3JNYXRyaXhGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWNvbG9yLW1hdHJpeC9saWIvY29sb3JNYXRyaXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWNvbG9yLW1hdHJpeC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWRpc3BsYWNlbWVudC9saWIvRGlzcGxhY2VtZW50RmlsdGVyLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1kaXNwbGFjZW1lbnQvbGliL2Rpc3BsYWNlbWVudC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItZGlzcGxhY2VtZW50L2xpYi9kaXNwbGFjZW1lbnQyLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1kaXNwbGFjZW1lbnQvbGliL2luZGV4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1meGFhL2xpYi9GWEFBRmlsdGVyLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1meGFhL2xpYi9meGFhLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1meGFhL2xpYi9meGFhMi5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItZnhhYS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLW5vaXNlL2xpYi9Ob2lzZUZpbHRlci5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItbm9pc2UvbGliL2luZGV4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1ub2lzZS9saWIvbm9pc2UuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL0dyYXBoaWNzLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi9HcmFwaGljc0RhdGEuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL0dyYXBoaWNzR2VvbWV0cnkuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL2NvbnN0LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvc3R5bGVzL0ZpbGxTdHlsZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvc3R5bGVzL0xpbmVTdHlsZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvdXRpbHMvQXJjVXRpbHMuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL3V0aWxzL0JhdGNoUGFydC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvdXRpbHMvQmV6aWVyVXRpbHMuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL3V0aWxzL1F1YWRyYXRpY1V0aWxzLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi91dGlscy9idWlsZENpcmNsZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvdXRpbHMvYnVpbGRMaW5lLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi91dGlscy9idWlsZFBvbHkuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL3V0aWxzL2J1aWxkUmVjdGFuZ2xlLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi91dGlscy9idWlsZFJvdW5kZWRSZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL3V0aWxzL2luZGV4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL21hdGgvbGliL0lQb2ludC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9JUG9pbnREYXRhLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL21hdGgvbGliL01hdHJpeC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9PYnNlcnZhYmxlUG9pbnQuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvbWF0aC9saWIvUG9pbnQuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvbWF0aC9saWIvVHJhbnNmb3JtLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL21hdGgvbGliL2NvbnN0LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL21hdGgvbGliL2dyb3VwRDguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvbWF0aC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvbWF0aC9saWIvc2hhcGVzL0NpcmNsZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9zaGFwZXMvRWxsaXBzZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9zaGFwZXMvUG9seWdvbi5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9zaGFwZXMvUmVjdGFuZ2xlLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL21hdGgvbGliL3NoYXBlcy9Sb3VuZGVkUmVjdGFuZ2xlLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gtZXh0cmFzL2xpYi9OaW5lU2xpY2VQbGFuZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoLWV4dHJhcy9saWIvU2ltcGxlTWVzaC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoLWV4dHJhcy9saWIvU2ltcGxlUGxhbmUuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC1leHRyYXMvbGliL1NpbXBsZVJvcGUuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC1leHRyYXMvbGliL2dlb21ldHJ5L1BsYW5lR2VvbWV0cnkuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC1leHRyYXMvbGliL2dlb21ldHJ5L1JvcGVHZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoLWV4dHJhcy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC9saWIvTWVzaC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoL2xpYi9NZXNoQmF0Y2hVdnMuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC9saWIvTWVzaEdlb21ldHJ5LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gvbGliL01lc2hNYXRlcmlhbC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoL2xpYi9zaGFkZXIvbWVzaC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoL2xpYi9zaGFkZXIvbWVzaDIuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvbWl4aW4tY2FjaGUtYXMtYml0bWFwL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9taXhpbi1nZXQtY2hpbGQtYnktbmFtZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvbWl4aW4tZ2V0LWdsb2JhbC1wb3NpdGlvbi9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvcGFydGljbGUtY29udGFpbmVyL2xpYi9QYXJ0aWNsZUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9wYXJ0aWNsZS1jb250YWluZXIvbGliL1BhcnRpY2xlQ29udGFpbmVyLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3BhcnRpY2xlLWNvbnRhaW5lci9saWIvUGFydGljbGVSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9wYXJ0aWNsZS1jb250YWluZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3BhcnRpY2xlLWNvbnRhaW5lci9saWIvcGFydGljbGVzLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3BhcnRpY2xlLWNvbnRhaW5lci9saWIvcGFydGljbGVzMi5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9wcmVwYXJlL2xpYi9CYXNlUHJlcGFyZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9wcmVwYXJlL2xpYi9Db3VudExpbWl0ZXIuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvcHJlcGFyZS9saWIvUHJlcGFyZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9wcmVwYXJlL2xpYi9UaW1lTGltaXRlci5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9wcmVwYXJlL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9wcmVwYXJlL2xpYi9zZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9ydW5uZXIvbGliL1J1bm5lci5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9ydW5uZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3NldHRpbmdzL2xpYi9JQ2FudmFzLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3NldHRpbmdzL2xpYi9JQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3NldHRpbmdzL2xpYi9hZGFwdGVyLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3NldHRpbmdzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9zZXR0aW5ncy9saWIvc2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvc2V0dGluZ3MvbGliL3V0aWxzL2lzTW9iaWxlLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3Nwcml0ZS1hbmltYXRlZC9saWIvQW5pbWF0ZWRTcHJpdGUuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLWFuaW1hdGVkL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9zcHJpdGUtdGlsaW5nL2xpYi9UaWxpbmdTcHJpdGUuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLXRpbGluZy9saWIvVGlsaW5nU3ByaXRlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLXRpbGluZy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLXRpbGluZy9saWIvc3ByaXRlLXRpbGluZy1mYWxsYmFjay5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9zcHJpdGUtdGlsaW5nL2xpYi9zcHJpdGUtdGlsaW5nLWZhbGxiYWNrMi5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9zcHJpdGUtdGlsaW5nL2xpYi9zcHJpdGUtdGlsaW5nLXNpbXBsZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9zcHJpdGUtdGlsaW5nL2xpYi9zcHJpdGUtdGlsaW5nLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3Nwcml0ZS10aWxpbmcvbGliL3Nwcml0ZS10aWxpbmcyLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3Nwcml0ZS9saWIvU3ByaXRlLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3Nwcml0ZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlc2hlZXQvbGliL1Nwcml0ZXNoZWV0LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3Nwcml0ZXNoZWV0L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS9zcHJpdGVzaGVldC9saWIvc3ByaXRlc2hlZXRBc3NldC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvQml0bWFwRm9udC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvQml0bWFwRm9udERhdGEuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1iaXRtYXAvbGliL0JpdG1hcFRleHQuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1iaXRtYXAvbGliL0JpdG1hcFRleHRTdHlsZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvZm9ybWF0cy9UZXh0Rm9ybWF0LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9mb3JtYXRzL1hNTEZvcm1hdC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvZm9ybWF0cy9YTUxTdHJpbmdGb3JtYXQuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1iaXRtYXAvbGliL2Zvcm1hdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1iaXRtYXAvbGliL2luZGV4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9sb2FkQml0bWFwRm9udC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvc2hhZGVyL21zZGYuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1iaXRtYXAvbGliL3NoYWRlci9tc2RmMi5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvdXRpbHMvZHJhd0dseXBoLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi91dGlscy9leHRyYWN0Q2hhckNvZGUuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1iaXRtYXAvbGliL3V0aWxzL2dlbmVyYXRlRmlsbFN0eWxlLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi91dGlscy9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvdXRpbHMvcmVzb2x2ZUNoYXJhY3RlcnMuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1iaXRtYXAvbGliL3V0aWxzL3NwbGl0VGV4dFRvQ2hhcmFjdGVycy5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWh0bWwvbGliL0hUTUxUZXh0LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtaHRtbC9saWIvSFRNTFRleHRTdHlsZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWh0bWwvbGliL2luZGV4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQvbGliL1RleHQuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC9saWIvVGV4dE1ldHJpY3MuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC9saWIvVGV4dFN0eWxlLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQvbGliL2NvbnN0LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQvbGliL2luZGV4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3RpY2tlci9saWIvVGlja2VyLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3RpY2tlci9saWIvVGlja2VyTGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdGlja2VyL2xpYi9UaWNrZXJQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdGlja2VyL2xpYi9jb25zdC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS90aWNrZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3RpY2tlci9saWIvc2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2Jyb3dzZXIvaGVsbG8uanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2Jyb3dzZXIvaXNXZWJHTFN1cHBvcnRlZC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvY29sb3IvaGV4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9jb2xvci9wcmVtdWx0aXBseS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvY29uc3QuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2RhdGEvY3JlYXRlSW5kaWNlc0ZvclF1YWRzLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9kYXRhL2dldEJ1ZmZlclR5cGUuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2RhdGEvaW50ZXJsZWF2ZVR5cGVkQXJyYXlzLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9kYXRhL3BvdzIuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2RhdGEvcmVtb3ZlSXRlbXMuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2RhdGEvc2lnbi5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvZGF0YS91aWQuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2luZGV4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9sb2dnaW5nL2RlcHJlY2F0aW9uLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9tZWRpYS9Cb3VuZGluZ0JveC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvbWVkaWEvQ2FudmFzUmVuZGVyVGFyZ2V0LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9tZWRpYS9jYWNoZXMuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL21lZGlhL2dldENhbnZhc0JvdW5kaW5nQm94LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9tZWRpYS90cmltQ2FudmFzLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9uZXR3b3JrL2RlY29tcG9zZURhdGFVcmkuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL25ldHdvcmsvZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4uanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL25ldHdvcmsvZ2V0UmVzb2x1dGlvbk9mVXJsLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9wYXRoLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9zZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL3VybC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3ByaW9yaXR5cXVldWVqcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZW5jb2RlLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2luZGV4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIvYWxlYS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi90eWNoZWkuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yMTI4LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3hvcjQwOTYuanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yc2hpZnQ3LmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3hvcndvdy5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL3NlZWRyYW5kb20uanMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9zcmMvcmVuZGVyL0FuaW1hbHMudHMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9zcmMvcmVuZGVyL0dhbWVSZW5kZXJlci50cyIsIndlYnBhY2s6Ly9yb290cy8uL3NyYy9yZW5kZXIvR3JpZFJlbmRlci50cyIsIndlYnBhY2s6Ly9yb290cy8uL3NyYy9yZW5kZXIvSGV4UmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9zcmMvcm9vdHMvQ2x1c3RlcmluZy50cyIsIndlYnBhY2s6Ly9yb290cy8uL3NyYy9yb290cy9MZXZlbEdlbmVyYXRvci50cyIsIndlYnBhY2s6Ly9yb290cy8uL3NyYy9yb290cy9Sb290cy50cyIsIndlYnBhY2s6Ly9yb290cy8uL3NyYy9yb290cy9UaWxlLnRzIiwid2VicGFjazovL3Jvb3RzLy4vc3JjL3V0aWwvRGlqa3N0cmEudHMiLCJ3ZWJwYWNrOi8vcm9vdHMvLi9ub2RlX21vZHVsZXMvdXJsL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIndlYnBhY2s6Ly9yb290cy8uL25vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwid2VicGFjazovL3Jvb3RzLy4vbm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwid2VicGFjazovL3Jvb3RzL2lnbm9yZWR8QzpcXFVzZXJzXFxUaG9tYXNcXERvY3VtZW50c1xcR2l0SHViXFxyb290c1xcbm9kZV9tb2R1bGVzXFxzZWVkcmFuZG9tfGNyeXB0byIsIndlYnBhY2s6Ly9yb290cy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9yb290cy93ZWJwYWNrL3J1bnRpbWUvYW1kIGRlZmluZSIsIndlYnBhY2s6Ly9yb290cy93ZWJwYWNrL3J1bnRpbWUvYW1kIG9wdGlvbnMiLCJ3ZWJwYWNrOi8vcm9vdHMvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3Jvb3RzL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vcm9vdHMvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9yb290cy93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3Jvb3RzL3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vcm9vdHMvd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly9yb290cy93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vcm9vdHMvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvbG9yZCA9IHJlcXVpcmUoJ2NvbG9yZCcpO1xudmFyIG5hbWVzUGx1Z2luID0gcmVxdWlyZSgnY29sb3JkL3BsdWdpbnMvbmFtZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBuYW1lc1BsdWdpbl9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3kobmFtZXNQbHVnaW4pO1xuXG5jb2xvcmQuZXh0ZW5kKFtuYW1lc1BsdWdpbl9fZGVmYXVsdFtcImRlZmF1bHRcIl1dKTtcbmNvbnN0IF9Db2xvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodmFsdWUgPSAxNjc3NzIxNSkge1xuICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICB0aGlzLl9jb21wb25lbnRzID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICB0aGlzLl9jb21wb25lbnRzLmZpbGwoMSk7XG4gICAgdGhpcy5faW50ID0gMTY3NzcyMTU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIGdldCByZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbMF07XG4gIH1cbiAgZ2V0IGdyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzWzFdO1xuICB9XG4gIGdldCBibHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzWzJdO1xuICB9XG4gIGdldCBhbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c1szXTtcbiAgfVxuICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfQ29sb3IpIHtcbiAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5jbG9uZVNvdXJjZSh2YWx1ZS5fdmFsdWUpO1xuICAgICAgdGhpcy5faW50ID0gdmFsdWUuX2ludDtcbiAgICAgIHRoaXMuX2NvbXBvbmVudHMuc2V0KHZhbHVlLl9jb21wb25lbnRzKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IFBJWEkuQ29sb3IjdmFsdWUgdG8gbnVsbFwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3ZhbHVlID09PSBudWxsIHx8ICF0aGlzLmlzU291cmNlRXF1YWwodGhpcy5fdmFsdWUsIHZhbHVlKSkge1xuICAgICAgdGhpcy5ub3JtYWxpemUodmFsdWUpO1xuICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLmNsb25lU291cmNlKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBjbG9uZVNvdXJjZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IC4uLnZhbHVlIH07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpc1NvdXJjZUVxdWFsKHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgY29uc3QgdHlwZTEgPSB0eXBlb2YgdmFsdWUxO1xuICAgIGNvbnN0IHR5cGUyID0gdHlwZW9mIHZhbHVlMjtcbiAgICBpZiAodHlwZTEgIT09IHR5cGUyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh0eXBlMSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlMSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZTEgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTEgPT09IHZhbHVlMjtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUxKSAmJiBBcnJheS5pc0FycmF5KHZhbHVlMikgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlMSkgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlMikpIHtcbiAgICAgIGlmICh2YWx1ZTEubGVuZ3RoICE9PSB2YWx1ZTIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTEuZXZlcnkoKHYsIGkpID0+IHYgPT09IHZhbHVlMltpXSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZTEgIT09IG51bGwgJiYgdmFsdWUyICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKHZhbHVlMSk7XG4gICAgICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKHZhbHVlMik7XG4gICAgICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleXMxLmV2ZXJ5KChrZXkpID0+IHZhbHVlMVtrZXldID09PSB2YWx1ZTJba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTEgPT09IHZhbHVlMjtcbiAgfVxuICB0b1JnYmEoKSB7XG4gICAgY29uc3QgW3IsIGcsIGIsIGFdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICByZXR1cm4geyByLCBnLCBiLCBhIH07XG4gIH1cbiAgdG9SZ2IoKSB7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICByZXR1cm4geyByLCBnLCBiIH07XG4gIH1cbiAgdG9SZ2JhU3RyaW5nKCkge1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHRoaXMudG9VaW50OFJnYkFycmF5KCk7XG4gICAgcmV0dXJuIGByZ2JhKCR7cn0sJHtnfSwke2J9LCR7dGhpcy5hbHBoYX0pYDtcbiAgfVxuICB0b1VpbnQ4UmdiQXJyYXkob3V0KSB7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICBvdXQgPSBvdXQgPz8gW107XG4gICAgb3V0WzBdID0gTWF0aC5yb3VuZChyICogMjU1KTtcbiAgICBvdXRbMV0gPSBNYXRoLnJvdW5kKGcgKiAyNTUpO1xuICAgIG91dFsyXSA9IE1hdGgucm91bmQoYiAqIDI1NSk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICB0b1JnYkFycmF5KG91dCkge1xuICAgIG91dCA9IG91dCA/PyBbXTtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIG91dFswXSA9IHI7XG4gICAgb3V0WzFdID0gZztcbiAgICBvdXRbMl0gPSBiO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgdG9OdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludDtcbiAgfVxuICB0b0xpdHRsZUVuZGlhbk51bWJlcigpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2ludDtcbiAgICByZXR1cm4gKHZhbHVlID4+IDE2KSArICh2YWx1ZSAmIDY1MjgwKSArICgodmFsdWUgJiAyNTUpIDw8IDE2KTtcbiAgfVxuICBtdWx0aXBseSh2YWx1ZSkge1xuICAgIGNvbnN0IFtyLCBnLCBiLCBhXSA9IF9Db2xvci50ZW1wLnNldFZhbHVlKHZhbHVlKS5fY29tcG9uZW50cztcbiAgICB0aGlzLl9jb21wb25lbnRzWzBdICo9IHI7XG4gICAgdGhpcy5fY29tcG9uZW50c1sxXSAqPSBnO1xuICAgIHRoaXMuX2NvbXBvbmVudHNbMl0gKj0gYjtcbiAgICB0aGlzLl9jb21wb25lbnRzWzNdICo9IGE7XG4gICAgdGhpcy5yZWZyZXNoSW50KCk7XG4gICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHByZW11bHRpcGx5KGFscGhhLCBhcHBseVRvUkdCID0gdHJ1ZSkge1xuICAgIGlmIChhcHBseVRvUkdCKSB7XG4gICAgICB0aGlzLl9jb21wb25lbnRzWzBdICo9IGFscGhhO1xuICAgICAgdGhpcy5fY29tcG9uZW50c1sxXSAqPSBhbHBoYTtcbiAgICAgIHRoaXMuX2NvbXBvbmVudHNbMl0gKj0gYWxwaGE7XG4gICAgfVxuICAgIHRoaXMuX2NvbXBvbmVudHNbM10gPSBhbHBoYTtcbiAgICB0aGlzLnJlZnJlc2hJbnQoKTtcbiAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdG9QcmVtdWx0aXBsaWVkKGFscGhhLCBhcHBseVRvUkdCID0gdHJ1ZSkge1xuICAgIGlmIChhbHBoYSA9PT0gMSkge1xuICAgICAgcmV0dXJuICgyNTUgPDwgMjQpICsgdGhpcy5faW50O1xuICAgIH1cbiAgICBpZiAoYWxwaGEgPT09IDApIHtcbiAgICAgIHJldHVybiBhcHBseVRvUkdCID8gMCA6IHRoaXMuX2ludDtcbiAgICB9XG4gICAgbGV0IHIgPSB0aGlzLl9pbnQgPj4gMTYgJiAyNTU7XG4gICAgbGV0IGcgPSB0aGlzLl9pbnQgPj4gOCAmIDI1NTtcbiAgICBsZXQgYiA9IHRoaXMuX2ludCAmIDI1NTtcbiAgICBpZiAoYXBwbHlUb1JHQikge1xuICAgICAgciA9IHIgKiBhbHBoYSArIDAuNSB8IDA7XG4gICAgICBnID0gZyAqIGFscGhhICsgMC41IHwgMDtcbiAgICAgIGIgPSBiICogYWxwaGEgKyAwLjUgfCAwO1xuICAgIH1cbiAgICByZXR1cm4gKGFscGhhICogMjU1IDw8IDI0KSArIChyIDw8IDE2KSArIChnIDw8IDgpICsgYjtcbiAgfVxuICB0b0hleCgpIHtcbiAgICBjb25zdCBoZXhTdHJpbmcgPSB0aGlzLl9pbnQudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBgIyR7XCIwMDAwMDBcIi5zdWJzdHJpbmcoMCwgNiAtIGhleFN0cmluZy5sZW5ndGgpICsgaGV4U3RyaW5nfWA7XG4gIH1cbiAgdG9IZXhhKCkge1xuICAgIGNvbnN0IGFscGhhVmFsdWUgPSBNYXRoLnJvdW5kKHRoaXMuX2NvbXBvbmVudHNbM10gKiAyNTUpO1xuICAgIGNvbnN0IGFscGhhU3RyaW5nID0gYWxwaGFWYWx1ZS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIHRoaXMudG9IZXgoKSArIFwiMDBcIi5zdWJzdHJpbmcoMCwgMiAtIGFscGhhU3RyaW5nLmxlbmd0aCkgKyBhbHBoYVN0cmluZztcbiAgfVxuICBzZXRBbHBoYShhbHBoYSkge1xuICAgIHRoaXMuX2NvbXBvbmVudHNbM10gPSB0aGlzLl9jbGFtcChhbHBoYSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcm91bmQoc3RlcHMpIHtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHRoaXMuX2NvbXBvbmVudHNbMF0gPSBNYXRoLnJvdW5kKHIgKiBzdGVwcykgLyBzdGVwcztcbiAgICB0aGlzLl9jb21wb25lbnRzWzFdID0gTWF0aC5yb3VuZChnICogc3RlcHMpIC8gc3RlcHM7XG4gICAgdGhpcy5fY29tcG9uZW50c1syXSA9IE1hdGgucm91bmQoYiAqIHN0ZXBzKSAvIHN0ZXBzO1xuICAgIHRoaXMucmVmcmVzaEludCgpO1xuICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0b0FycmF5KG91dCkge1xuICAgIG91dCA9IG91dCA/PyBbXTtcbiAgICBjb25zdCBbciwgZywgYiwgYV0gPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIG91dFswXSA9IHI7XG4gICAgb3V0WzFdID0gZztcbiAgICBvdXRbMl0gPSBiO1xuICAgIG91dFszXSA9IGE7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBub3JtYWxpemUodmFsdWUpIHtcbiAgICBsZXQgcjtcbiAgICBsZXQgZztcbiAgICBsZXQgYjtcbiAgICBsZXQgYTtcbiAgICBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiYgdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSAxNjc3NzIxNSkge1xuICAgICAgY29uc3QgaW50ID0gdmFsdWU7XG4gICAgICByID0gKGludCA+PiAxNiAmIDI1NSkgLyAyNTU7XG4gICAgICBnID0gKGludCA+PiA4ICYgMjU1KSAvIDI1NTtcbiAgICAgIGIgPSAoaW50ICYgMjU1KSAvIDI1NTtcbiAgICAgIGEgPSAxO1xuICAgIH0gZWxzZSBpZiAoKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSAmJiB2YWx1ZS5sZW5ndGggPj0gMyAmJiB2YWx1ZS5sZW5ndGggPD0gNCkge1xuICAgICAgdmFsdWUgPSB0aGlzLl9jbGFtcCh2YWx1ZSk7XG4gICAgICBbciwgZywgYiwgYSA9IDFdID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICgodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IHZhbHVlIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpICYmIHZhbHVlLmxlbmd0aCA+PSAzICYmIHZhbHVlLmxlbmd0aCA8PSA0KSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuX2NsYW1wKHZhbHVlLCAwLCAyNTUpO1xuICAgICAgW3IsIGcsIGIsIGEgPSAyNTVdID0gdmFsdWU7XG4gICAgICByIC89IDI1NTtcbiAgICAgIGcgLz0gMjU1O1xuICAgICAgYiAvPSAyNTU7XG4gICAgICBhIC89IDI1NTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBfQ29sb3IuSEVYX1BBVFRFUk4uZXhlYyh2YWx1ZSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHZhbHVlID0gYCMke21hdGNoWzJdfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbG9yID0gY29sb3JkLmNvbG9yZCh2YWx1ZSk7XG4gICAgICBpZiAoY29sb3IuaXNWYWxpZCgpKSB7XG4gICAgICAgICh7IHIsIGcsIGIsIGEgfSA9IGNvbG9yLnJnYmEpO1xuICAgICAgICByIC89IDI1NTtcbiAgICAgICAgZyAvPSAyNTU7XG4gICAgICAgIGIgLz0gMjU1O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAociAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9jb21wb25lbnRzWzBdID0gcjtcbiAgICAgIHRoaXMuX2NvbXBvbmVudHNbMV0gPSBnO1xuICAgICAgdGhpcy5fY29tcG9uZW50c1syXSA9IGI7XG4gICAgICB0aGlzLl9jb21wb25lbnRzWzNdID0gYTtcbiAgICAgIHRoaXMucmVmcmVzaEludCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBjb252ZXJ0IGNvbG9yICR7dmFsdWV9YCk7XG4gICAgfVxuICB9XG4gIHJlZnJlc2hJbnQoKSB7XG4gICAgdGhpcy5fY2xhbXAodGhpcy5fY29tcG9uZW50cyk7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICB0aGlzLl9pbnQgPSAociAqIDI1NSA8PCAxNikgKyAoZyAqIDI1NSA8PCA4KSArIChiICogMjU1IHwgMCk7XG4gIH1cbiAgX2NsYW1wKHZhbHVlLCBtaW4gPSAwLCBtYXggPSAxKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xuICAgIH1cbiAgICB2YWx1ZS5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICB2YWx1ZVtpXSA9IE1hdGgubWluKE1hdGgubWF4KHYsIG1pbiksIG1heCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xubGV0IENvbG9yID0gX0NvbG9yO1xuQ29sb3Iuc2hhcmVkID0gbmV3IF9Db2xvcigpO1xuQ29sb3IudGVtcCA9IG5ldyBfQ29sb3IoKTtcbkNvbG9yLkhFWF9QQVRURVJOID0gL14oI3wweCk/KChbYS1mMC05XXszfSl7MSwyfShbYS1mMC05XXsyfSk/KSQvaTtcblxuZXhwb3J0cy5Db2xvciA9IENvbG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sb3IuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBDb2xvciA9IHJlcXVpcmUoJy4vQ29sb3IuanMnKTtcblxuXG5cbmV4cG9ydHMuQ29sb3IgPSBDb2xvci5Db2xvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9e2dyYWQ6LjksdHVybjozNjAscmFkOjM2MC8oMipNYXRoLlBJKX0sdD1mdW5jdGlvbihyKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2Ygcj9yLmxlbmd0aD4wOlwibnVtYmVyXCI9PXR5cGVvZiByfSxuPWZ1bmN0aW9uKHIsdCxuKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksdm9pZCAwPT09biYmKG49TWF0aC5wb3coMTAsdCkpLE1hdGgucm91bmQobipyKS9uKzB9LGU9ZnVuY3Rpb24ocix0LG4pe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1uJiYobj0xKSxyPm4/bjpyPnQ/cjp0fSx1PWZ1bmN0aW9uKHIpe3JldHVybihyPWlzRmluaXRlKHIpP3IlMzYwOjApPjA/cjpyKzM2MH0sbz1mdW5jdGlvbihyKXtyZXR1cm57cjplKHIuciwwLDI1NSksZzplKHIuZywwLDI1NSksYjplKHIuYiwwLDI1NSksYTplKHIuYSl9fSxhPWZ1bmN0aW9uKHIpe3JldHVybntyOm4oci5yKSxnOm4oci5nKSxiOm4oci5iKSxhOm4oci5hLDMpfX0scz0vXiMoWzAtOWEtZl17Myw4fSkkL2ksaT1mdW5jdGlvbihyKXt2YXIgdD1yLnRvU3RyaW5nKDE2KTtyZXR1cm4gdC5sZW5ndGg8Mj9cIjBcIit0OnR9LGg9ZnVuY3Rpb24ocil7dmFyIHQ9ci5yLG49ci5nLGU9ci5iLHU9ci5hLG89TWF0aC5tYXgodCxuLGUpLGE9by1NYXRoLm1pbih0LG4sZSkscz1hP289PT10PyhuLWUpL2E6bz09PW4/MisoZS10KS9hOjQrKHQtbikvYTowO3JldHVybntoOjYwKihzPDA/cys2OnMpLHM6bz9hL28qMTAwOjAsdjpvLzI1NSoxMDAsYTp1fX0sYj1mdW5jdGlvbihyKXt2YXIgdD1yLmgsbj1yLnMsZT1yLnYsdT1yLmE7dD10LzM2MCo2LG4vPTEwMCxlLz0xMDA7dmFyIG89TWF0aC5mbG9vcih0KSxhPWUqKDEtbikscz1lKigxLSh0LW8pKm4pLGk9ZSooMS0oMS10K28pKm4pLGg9byU2O3JldHVybntyOjI1NSpbZSxzLGEsYSxpLGVdW2hdLGc6MjU1KltpLGUsZSxzLGEsYV1baF0sYjoyNTUqW2EsYSxpLGUsZSxzXVtoXSxhOnV9fSxkPWZ1bmN0aW9uKHIpe3JldHVybntoOnUoci5oKSxzOmUoci5zLDAsMTAwKSxsOmUoci5sLDAsMTAwKSxhOmUoci5hKX19LGc9ZnVuY3Rpb24ocil7cmV0dXJue2g6bihyLmgpLHM6bihyLnMpLGw6bihyLmwpLGE6bihyLmEsMyl9fSxmPWZ1bmN0aW9uKHIpe3JldHVybiBiKChuPSh0PXIpLnMse2g6dC5oLHM6KG4qPSgoZT10LmwpPDUwP2U6MTAwLWUpLzEwMCk+MD8yKm4vKGUrbikqMTAwOjAsdjplK24sYTp0LmF9KSk7dmFyIHQsbixlfSxwPWZ1bmN0aW9uKHIpe3JldHVybntoOih0PWgocikpLmgsczoodT0oMjAwLShuPXQucykpKihlPXQudikvMTAwKT4wJiZ1PDIwMD9uKmUvMTAwLyh1PD0xMDA/dToyMDAtdSkqMTAwOjAsbDp1LzIsYTp0LmF9O3ZhciB0LG4sZSx1fSxsPS9eaHNsYT9cXChcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKShkZWd8cmFkfGdyYWR8dHVybik/XFxzKixcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSVcXHMqLFxccyooWystXT9cXGQqXFwuP1xcZCspJVxccyooPzosXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKik/XFwpJC9pLGM9L15oc2xhP1xcKFxccyooWystXT9cXGQqXFwuP1xcZCspKGRlZ3xyYWR8Z3JhZHx0dXJuKT9cXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSVcXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSVcXHMqKD86XFwvXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKik/XFwpJC9pLHY9L15yZ2JhP1xcKFxccyooWystXT9cXGQqXFwuP1xcZCspKCUpP1xccyosXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKixcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMqKD86LFxccyooWystXT9cXGQqXFwuP1xcZCspKCUpP1xccyopP1xcKSQvaSxtPS9ecmdiYT9cXChcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMqKD86XFwvXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKik/XFwpJC9pLHk9e3N0cmluZzpbW2Z1bmN0aW9uKHIpe3ZhciB0PXMuZXhlYyhyKTtyZXR1cm4gdD8ocj10WzFdKS5sZW5ndGg8PTQ/e3I6cGFyc2VJbnQoclswXStyWzBdLDE2KSxnOnBhcnNlSW50KHJbMV0rclsxXSwxNiksYjpwYXJzZUludChyWzJdK3JbMl0sMTYpLGE6ND09PXIubGVuZ3RoP24ocGFyc2VJbnQoclszXStyWzNdLDE2KS8yNTUsMik6MX06Nj09PXIubGVuZ3RofHw4PT09ci5sZW5ndGg/e3I6cGFyc2VJbnQoci5zdWJzdHIoMCwyKSwxNiksZzpwYXJzZUludChyLnN1YnN0cigyLDIpLDE2KSxiOnBhcnNlSW50KHIuc3Vic3RyKDQsMiksMTYpLGE6OD09PXIubGVuZ3RoP24ocGFyc2VJbnQoci5zdWJzdHIoNiwyKSwxNikvMjU1LDIpOjF9Om51bGw6bnVsbH0sXCJoZXhcIl0sW2Z1bmN0aW9uKHIpe3ZhciB0PXYuZXhlYyhyKXx8bS5leGVjKHIpO3JldHVybiB0P3RbMl0hPT10WzRdfHx0WzRdIT09dFs2XT9udWxsOm8oe3I6TnVtYmVyKHRbMV0pLyh0WzJdPzEwMC8yNTU6MSksZzpOdW1iZXIodFszXSkvKHRbNF0/MTAwLzI1NToxKSxiOk51bWJlcih0WzVdKS8odFs2XT8xMDAvMjU1OjEpLGE6dm9pZCAwPT09dFs3XT8xOk51bWJlcih0WzddKS8odFs4XT8xMDA6MSl9KTpudWxsfSxcInJnYlwiXSxbZnVuY3Rpb24odCl7dmFyIG49bC5leGVjKHQpfHxjLmV4ZWModCk7aWYoIW4pcmV0dXJuIG51bGw7dmFyIGUsdSxvPWQoe2g6KGU9blsxXSx1PW5bMl0sdm9pZCAwPT09dSYmKHU9XCJkZWdcIiksTnVtYmVyKGUpKihyW3VdfHwxKSksczpOdW1iZXIoblszXSksbDpOdW1iZXIobls0XSksYTp2b2lkIDA9PT1uWzVdPzE6TnVtYmVyKG5bNV0pLyhuWzZdPzEwMDoxKX0pO3JldHVybiBmKG8pfSxcImhzbFwiXV0sb2JqZWN0OltbZnVuY3Rpb24ocil7dmFyIG49ci5yLGU9ci5nLHU9ci5iLGE9ci5hLHM9dm9pZCAwPT09YT8xOmE7cmV0dXJuIHQobikmJnQoZSkmJnQodSk/byh7cjpOdW1iZXIobiksZzpOdW1iZXIoZSksYjpOdW1iZXIodSksYTpOdW1iZXIocyl9KTpudWxsfSxcInJnYlwiXSxbZnVuY3Rpb24ocil7dmFyIG49ci5oLGU9ci5zLHU9ci5sLG89ci5hLGE9dm9pZCAwPT09bz8xOm87aWYoIXQobil8fCF0KGUpfHwhdCh1KSlyZXR1cm4gbnVsbDt2YXIgcz1kKHtoOk51bWJlcihuKSxzOk51bWJlcihlKSxsOk51bWJlcih1KSxhOk51bWJlcihhKX0pO3JldHVybiBmKHMpfSxcImhzbFwiXSxbZnVuY3Rpb24ocil7dmFyIG49ci5oLG89ci5zLGE9ci52LHM9ci5hLGk9dm9pZCAwPT09cz8xOnM7aWYoIXQobil8fCF0KG8pfHwhdChhKSlyZXR1cm4gbnVsbDt2YXIgaD1mdW5jdGlvbihyKXtyZXR1cm57aDp1KHIuaCksczplKHIucywwLDEwMCksdjplKHIudiwwLDEwMCksYTplKHIuYSl9fSh7aDpOdW1iZXIobiksczpOdW1iZXIobyksdjpOdW1iZXIoYSksYTpOdW1iZXIoaSl9KTtyZXR1cm4gYihoKX0sXCJoc3ZcIl1dfSxOPWZ1bmN0aW9uKHIsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBlPXRbbl1bMF0ocik7aWYoZSlyZXR1cm5bZSx0W25dWzFdXX1yZXR1cm5bbnVsbCx2b2lkIDBdfSx4PWZ1bmN0aW9uKHIpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiByP04oci50cmltKCkseS5zdHJpbmcpOlwib2JqZWN0XCI9PXR5cGVvZiByJiZudWxsIT09cj9OKHIseS5vYmplY3QpOltudWxsLHZvaWQgMF19LE09ZnVuY3Rpb24ocix0KXt2YXIgbj1wKHIpO3JldHVybntoOm4uaCxzOmUobi5zKzEwMCp0LDAsMTAwKSxsOm4ubCxhOm4uYX19LEk9ZnVuY3Rpb24ocil7cmV0dXJuKDI5OSpyLnIrNTg3KnIuZysxMTQqci5iKS8xZTMvMjU1fSxIPWZ1bmN0aW9uKHIsdCl7dmFyIG49cChyKTtyZXR1cm57aDpuLmgsczpuLnMsbDplKG4ubCsxMDAqdCwwLDEwMCksYTpuLmF9fSwkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihyKXt0aGlzLnBhcnNlZD14KHIpWzBdLHRoaXMucmdiYT10aGlzLnBhcnNlZHx8e3I6MCxnOjAsYjowLGE6MX19cmV0dXJuIHIucHJvdG90eXBlLmlzVmFsaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucGFyc2VkfSxyLnByb3RvdHlwZS5icmlnaHRuZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIG4oSSh0aGlzLnJnYmEpLDIpfSxyLnByb3RvdHlwZS5pc0Rhcms9ZnVuY3Rpb24oKXtyZXR1cm4gSSh0aGlzLnJnYmEpPC41fSxyLnByb3RvdHlwZS5pc0xpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuIEkodGhpcy5yZ2JhKT49LjV9LHIucHJvdG90eXBlLnRvSGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHI9YSh0aGlzLnJnYmEpLHQ9ci5yLGU9ci5nLHU9ci5iLHM9KG89ci5hKTwxP2kobigyNTUqbykpOlwiXCIsXCIjXCIraSh0KStpKGUpK2kodSkrczt2YXIgcix0LGUsdSxvLHN9LHIucHJvdG90eXBlLnRvUmdiPWZ1bmN0aW9uKCl7cmV0dXJuIGEodGhpcy5yZ2JhKX0sci5wcm90b3R5cGUudG9SZ2JTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gcj1hKHRoaXMucmdiYSksdD1yLnIsbj1yLmcsZT1yLmIsKHU9ci5hKTwxP1wicmdiYShcIit0K1wiLCBcIituK1wiLCBcIitlK1wiLCBcIit1K1wiKVwiOlwicmdiKFwiK3QrXCIsIFwiK24rXCIsIFwiK2UrXCIpXCI7dmFyIHIsdCxuLGUsdX0sci5wcm90b3R5cGUudG9Ic2w9ZnVuY3Rpb24oKXtyZXR1cm4gZyhwKHRoaXMucmdiYSkpfSxyLnByb3RvdHlwZS50b0hzbFN0cmluZz1mdW5jdGlvbigpe3JldHVybiByPWcocCh0aGlzLnJnYmEpKSx0PXIuaCxuPXIucyxlPXIubCwodT1yLmEpPDE/XCJoc2xhKFwiK3QrXCIsIFwiK24rXCIlLCBcIitlK1wiJSwgXCIrdStcIilcIjpcImhzbChcIit0K1wiLCBcIituK1wiJSwgXCIrZStcIiUpXCI7dmFyIHIsdCxuLGUsdX0sci5wcm90b3R5cGUudG9Ic3Y9ZnVuY3Rpb24oKXtyZXR1cm4gcj1oKHRoaXMucmdiYSkse2g6bihyLmgpLHM6bihyLnMpLHY6bihyLnYpLGE6bihyLmEsMyl9O3ZhciByfSxyLnByb3RvdHlwZS5pbnZlcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gaih7cjoyNTUtKHI9dGhpcy5yZ2JhKS5yLGc6MjU1LXIuZyxiOjI1NS1yLmIsYTpyLmF9KTt2YXIgcn0sci5wcm90b3R5cGUuc2F0dXJhdGU9ZnVuY3Rpb24ocil7cmV0dXJuIHZvaWQgMD09PXImJihyPS4xKSxqKE0odGhpcy5yZ2JhLHIpKX0sci5wcm90b3R5cGUuZGVzYXR1cmF0ZT1mdW5jdGlvbihyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjEpLGooTSh0aGlzLnJnYmEsLXIpKX0sci5wcm90b3R5cGUuZ3JheXNjYWxlPWZ1bmN0aW9uKCl7cmV0dXJuIGooTSh0aGlzLnJnYmEsLTEpKX0sci5wcm90b3R5cGUubGlnaHRlbj1mdW5jdGlvbihyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjEpLGooSCh0aGlzLnJnYmEscikpfSxyLnByb3RvdHlwZS5kYXJrZW49ZnVuY3Rpb24ocil7cmV0dXJuIHZvaWQgMD09PXImJihyPS4xKSxqKEgodGhpcy5yZ2JhLC1yKSl9LHIucHJvdG90eXBlLnJvdGF0ZT1mdW5jdGlvbihyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9MTUpLHRoaXMuaHVlKHRoaXMuaHVlKCkrcil9LHIucHJvdG90eXBlLmFscGhhPWZ1bmN0aW9uKHIpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiByP2ooe3I6KHQ9dGhpcy5yZ2JhKS5yLGc6dC5nLGI6dC5iLGE6cn0pOm4odGhpcy5yZ2JhLmEsMyk7dmFyIHR9LHIucHJvdG90eXBlLmh1ZT1mdW5jdGlvbihyKXt2YXIgdD1wKHRoaXMucmdiYSk7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHI/aih7aDpyLHM6dC5zLGw6dC5sLGE6dC5hfSk6bih0LmgpfSxyLnByb3RvdHlwZS5pc0VxdWFsPWZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLnRvSGV4KCk9PT1qKHIpLnRvSGV4KCl9LHJ9KCksaj1mdW5jdGlvbihyKXtyZXR1cm4gciBpbnN0YW5jZW9mICQ/cjpuZXcgJChyKX0sdz1bXTtleHBvcnRzLkNvbG9yZD0kLGV4cG9ydHMuY29sb3JkPWosZXhwb3J0cy5leHRlbmQ9ZnVuY3Rpb24ocil7ci5mb3JFYWNoKGZ1bmN0aW9uKHIpe3cuaW5kZXhPZihyKTwwJiYocigkLHkpLHcucHVzaChyKSl9KX0sZXhwb3J0cy5nZXRGb3JtYXQ9ZnVuY3Rpb24ocil7cmV0dXJuIHgocilbMV19LGV4cG9ydHMucmFuZG9tPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyAkKHtyOjI1NSpNYXRoLnJhbmRvbSgpLGc6MjU1Kk1hdGgucmFuZG9tKCksYjoyNTUqTWF0aC5yYW5kb20oKX0pfTtcbiIsIm1vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGUsZil7dmFyIGE9e3doaXRlOlwiI2ZmZmZmZlwiLGJpc3F1ZTpcIiNmZmU0YzRcIixibHVlOlwiIzAwMDBmZlwiLGNhZGV0Ymx1ZTpcIiM1ZjllYTBcIixjaGFydHJldXNlOlwiIzdmZmYwMFwiLGNob2NvbGF0ZTpcIiNkMjY5MWVcIixjb3JhbDpcIiNmZjdmNTBcIixhbnRpcXVld2hpdGU6XCIjZmFlYmQ3XCIsYXF1YTpcIiMwMGZmZmZcIixhenVyZTpcIiNmMGZmZmZcIix3aGl0ZXNtb2tlOlwiI2Y1ZjVmNVwiLHBhcGF5YXdoaXA6XCIjZmZlZmQ1XCIscGx1bTpcIiNkZGEwZGRcIixibGFuY2hlZGFsbW9uZDpcIiNmZmViY2RcIixibGFjazpcIiMwMDAwMDBcIixnb2xkOlwiI2ZmZDcwMFwiLGdvbGRlbnJvZDpcIiNkYWE1MjBcIixnYWluc2Jvcm86XCIjZGNkY2RjXCIsY29ybnNpbGs6XCIjZmZmOGRjXCIsY29ybmZsb3dlcmJsdWU6XCIjNjQ5NWVkXCIsYnVybHl3b29kOlwiI2RlYjg4N1wiLGFxdWFtYXJpbmU6XCIjN2ZmZmQ0XCIsYmVpZ2U6XCIjZjVmNWRjXCIsY3JpbXNvbjpcIiNkYzE0M2NcIixjeWFuOlwiIzAwZmZmZlwiLGRhcmtibHVlOlwiIzAwMDA4YlwiLGRhcmtjeWFuOlwiIzAwOGI4YlwiLGRhcmtnb2xkZW5yb2Q6XCIjYjg4NjBiXCIsZGFya2toYWtpOlwiI2JkYjc2YlwiLGRhcmtncmF5OlwiI2E5YTlhOVwiLGRhcmtncmVlbjpcIiMwMDY0MDBcIixkYXJrZ3JleTpcIiNhOWE5YTlcIixwZWFjaHB1ZmY6XCIjZmZkYWI5XCIsZGFya21hZ2VudGE6XCIjOGIwMDhiXCIsZGFya3JlZDpcIiM4YjAwMDBcIixkYXJrb3JjaGlkOlwiIzk5MzJjY1wiLGRhcmtvcmFuZ2U6XCIjZmY4YzAwXCIsZGFya3NsYXRlYmx1ZTpcIiM0ODNkOGJcIixncmF5OlwiIzgwODA4MFwiLGRhcmtzbGF0ZWdyYXk6XCIjMmY0ZjRmXCIsZGFya3NsYXRlZ3JleTpcIiMyZjRmNGZcIixkZWVwcGluazpcIiNmZjE0OTNcIixkZWVwc2t5Ymx1ZTpcIiMwMGJmZmZcIix3aGVhdDpcIiNmNWRlYjNcIixmaXJlYnJpY2s6XCIjYjIyMjIyXCIsZmxvcmFsd2hpdGU6XCIjZmZmYWYwXCIsZ2hvc3R3aGl0ZTpcIiNmOGY4ZmZcIixkYXJrdmlvbGV0OlwiIzk0MDBkM1wiLG1hZ2VudGE6XCIjZmYwMGZmXCIsZ3JlZW46XCIjMDA4MDAwXCIsZG9kZ2VyYmx1ZTpcIiMxZTkwZmZcIixncmV5OlwiIzgwODA4MFwiLGhvbmV5ZGV3OlwiI2YwZmZmMFwiLGhvdHBpbms6XCIjZmY2OWI0XCIsYmx1ZXZpb2xldDpcIiM4YTJiZTJcIixmb3Jlc3RncmVlbjpcIiMyMjhiMjJcIixsYXduZ3JlZW46XCIjN2NmYzAwXCIsaW5kaWFucmVkOlwiI2NkNWM1Y1wiLGluZGlnbzpcIiM0YjAwODJcIixmdWNoc2lhOlwiI2ZmMDBmZlwiLGJyb3duOlwiI2E1MmEyYVwiLG1hcm9vbjpcIiM4MDAwMDBcIixtZWRpdW1ibHVlOlwiIzAwMDBjZFwiLGxpZ2h0Y29yYWw6XCIjZjA4MDgwXCIsZGFya3R1cnF1b2lzZTpcIiMwMGNlZDFcIixsaWdodGN5YW46XCIjZTBmZmZmXCIsaXZvcnk6XCIjZmZmZmYwXCIsbGlnaHR5ZWxsb3c6XCIjZmZmZmUwXCIsbGlnaHRzYWxtb246XCIjZmZhMDdhXCIsbGlnaHRzZWFncmVlbjpcIiMyMGIyYWFcIixsaW5lbjpcIiNmYWYwZTZcIixtZWRpdW1hcXVhbWFyaW5lOlwiIzY2Y2RhYVwiLGxlbW9uY2hpZmZvbjpcIiNmZmZhY2RcIixsaW1lOlwiIzAwZmYwMFwiLGtoYWtpOlwiI2YwZTY4Y1wiLG1lZGl1bXNlYWdyZWVuOlwiIzNjYjM3MVwiLGxpbWVncmVlbjpcIiMzMmNkMzJcIixtZWRpdW1zcHJpbmdncmVlbjpcIiMwMGZhOWFcIixsaWdodHNreWJsdWU6XCIjODdjZWZhXCIsbGlnaHRibHVlOlwiI2FkZDhlNlwiLG1pZG5pZ2h0Ymx1ZTpcIiMxOTE5NzBcIixsaWdodHBpbms6XCIjZmZiNmMxXCIsbWlzdHlyb3NlOlwiI2ZmZTRlMVwiLG1vY2Nhc2luOlwiI2ZmZTRiNVwiLG1pbnRjcmVhbTpcIiNmNWZmZmFcIixsaWdodHNsYXRlZ3JheTpcIiM3Nzg4OTlcIixsaWdodHNsYXRlZ3JleTpcIiM3Nzg4OTlcIixuYXZham93aGl0ZTpcIiNmZmRlYWRcIixuYXZ5OlwiIzAwMDA4MFwiLG1lZGl1bXZpb2xldHJlZDpcIiNjNzE1ODVcIixwb3dkZXJibHVlOlwiI2IwZTBlNlwiLHBhbGVnb2xkZW5yb2Q6XCIjZWVlOGFhXCIsb2xkbGFjZTpcIiNmZGY1ZTZcIixwYWxldHVycXVvaXNlOlwiI2FmZWVlZVwiLG1lZGl1bXR1cnF1b2lzZTpcIiM0OGQxY2NcIixtZWRpdW1vcmNoaWQ6XCIjYmE1NWQzXCIscmViZWNjYXB1cnBsZTpcIiM2NjMzOTlcIixsaWdodHN0ZWVsYmx1ZTpcIiNiMGM0ZGVcIixtZWRpdW1zbGF0ZWJsdWU6XCIjN2I2OGVlXCIsdGhpc3RsZTpcIiNkOGJmZDhcIix0YW46XCIjZDJiNDhjXCIsb3JjaGlkOlwiI2RhNzBkNlwiLG1lZGl1bXB1cnBsZTpcIiM5MzcwZGJcIixwdXJwbGU6XCIjODAwMDgwXCIscGluazpcIiNmZmMwY2JcIixza3libHVlOlwiIzg3Y2VlYlwiLHNwcmluZ2dyZWVuOlwiIzAwZmY3ZlwiLHBhbGVncmVlbjpcIiM5OGZiOThcIixyZWQ6XCIjZmYwMDAwXCIseWVsbG93OlwiI2ZmZmYwMFwiLHNsYXRlYmx1ZTpcIiM2YTVhY2RcIixsYXZlbmRlcmJsdXNoOlwiI2ZmZjBmNVwiLHBlcnU6XCIjY2Q4NTNmXCIscGFsZXZpb2xldHJlZDpcIiNkYjcwOTNcIix2aW9sZXQ6XCIjZWU4MmVlXCIsdGVhbDpcIiMwMDgwODBcIixzbGF0ZWdyYXk6XCIjNzA4MDkwXCIsc2xhdGVncmV5OlwiIzcwODA5MFwiLGFsaWNlYmx1ZTpcIiNmMGY4ZmZcIixkYXJrc2VhZ3JlZW46XCIjOGZiYzhmXCIsZGFya29saXZlZ3JlZW46XCIjNTU2YjJmXCIsZ3JlZW55ZWxsb3c6XCIjYWRmZjJmXCIsc2VhZ3JlZW46XCIjMmU4YjU3XCIsc2Vhc2hlbGw6XCIjZmZmNWVlXCIsdG9tYXRvOlwiI2ZmNjM0N1wiLHNpbHZlcjpcIiNjMGMwYzBcIixzaWVubmE6XCIjYTA1MjJkXCIsbGF2ZW5kZXI6XCIjZTZlNmZhXCIsbGlnaHRncmVlbjpcIiM5MGVlOTBcIixvcmFuZ2U6XCIjZmZhNTAwXCIsb3JhbmdlcmVkOlwiI2ZmNDUwMFwiLHN0ZWVsYmx1ZTpcIiM0NjgyYjRcIixyb3lhbGJsdWU6XCIjNDE2OWUxXCIsdHVycXVvaXNlOlwiIzQwZTBkMFwiLHllbGxvd2dyZWVuOlwiIzlhY2QzMlwiLHNhbG1vbjpcIiNmYTgwNzJcIixzYWRkbGVicm93bjpcIiM4YjQ1MTNcIixzYW5keWJyb3duOlwiI2Y0YTQ2MFwiLHJvc3licm93bjpcIiNiYzhmOGZcIixkYXJrc2FsbW9uOlwiI2U5OTY3YVwiLGxpZ2h0Z29sZGVucm9keWVsbG93OlwiI2ZhZmFkMlwiLHNub3c6XCIjZmZmYWZhXCIsbGlnaHRncmV5OlwiI2QzZDNkM1wiLGxpZ2h0Z3JheTpcIiNkM2QzZDNcIixkaW1ncmF5OlwiIzY5Njk2OVwiLGRpbWdyZXk6XCIjNjk2OTY5XCIsb2xpdmVkcmFiOlwiIzZiOGUyM1wiLG9saXZlOlwiIzgwODAwMFwifSxyPXt9O2Zvcih2YXIgZCBpbiBhKXJbYVtkXV09ZDt2YXIgbD17fTtlLnByb3RvdHlwZS50b05hbWU9ZnVuY3Rpb24oZil7aWYoISh0aGlzLnJnYmEuYXx8dGhpcy5yZ2JhLnJ8fHRoaXMucmdiYS5nfHx0aGlzLnJnYmEuYikpcmV0dXJuXCJ0cmFuc3BhcmVudFwiO3ZhciBkLGksbz1yW3RoaXMudG9IZXgoKV07aWYobylyZXR1cm4gbztpZihudWxsPT1mP3ZvaWQgMDpmLmNsb3Nlc3Qpe3ZhciBuPXRoaXMudG9SZ2IoKSx0PTEvMCxiPVwiYmxhY2tcIjtpZighbC5sZW5ndGgpZm9yKHZhciBjIGluIGEpbFtjXT1uZXcgZShhW2NdKS50b1JnYigpO2Zvcih2YXIgZyBpbiBhKXt2YXIgdT0oZD1uLGk9bFtnXSxNYXRoLnBvdyhkLnItaS5yLDIpK01hdGgucG93KGQuZy1pLmcsMikrTWF0aC5wb3coZC5iLWkuYiwyKSk7dTx0JiYodD11LGI9Zyl9cmV0dXJuIGJ9fTtmLnN0cmluZy5wdXNoKFtmdW5jdGlvbihmKXt2YXIgcj1mLnRvTG93ZXJDYXNlKCksZD1cInRyYW5zcGFyZW50XCI9PT1yP1wiIzAwMDBcIjphW3JdO3JldHVybiBkP25ldyBlKGQpLnRvUmdiKCk6bnVsbH0sXCJuYW1lXCJdKX07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZWFyY3V0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGVhcmN1dDtcblxuZnVuY3Rpb24gZWFyY3V0KGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0pIHtcblxuICAgIGRpbSA9IGRpbSB8fCAyO1xuXG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoLFxuICAgICAgICBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgb3V0ZXJOb2RlID0gbGlua2VkTGlzdChkYXRhLCAwLCBvdXRlckxlbiwgZGltLCB0cnVlKSxcbiAgICAgICAgdHJpYW5nbGVzID0gW107XG5cbiAgICBpZiAoIW91dGVyTm9kZSB8fCBvdXRlck5vZGUubmV4dCA9PT0gb3V0ZXJOb2RlLnByZXYpIHJldHVybiB0cmlhbmdsZXM7XG5cbiAgICB2YXIgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgeCwgeSwgaW52U2l6ZTtcblxuICAgIGlmIChoYXNIb2xlcykgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKTtcblxuICAgIC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDgwICogZGltKSB7XG4gICAgICAgIG1pblggPSBtYXhYID0gZGF0YVswXTtcbiAgICAgICAgbWluWSA9IG1heFkgPSBkYXRhWzFdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBkaW07IGkgPCBvdXRlckxlbjsgaSArPSBkaW0pIHtcbiAgICAgICAgICAgIHggPSBkYXRhW2ldO1xuICAgICAgICAgICAgeSA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgaWYgKHggPCBtaW5YKSBtaW5YID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG4gICAgICAgICAgICBpZiAoeCA+IG1heFgpIG1heFggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPiBtYXhZKSBtYXhZID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1pblgsIG1pblkgYW5kIGludlNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXG4gICAgICAgIGludlNpemUgPSBNYXRoLm1heChtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgICAgICBpbnZTaXplID0gaW52U2l6ZSAhPT0gMCA/IDMyNzY3IC8gaW52U2l6ZSA6IDA7XG4gICAgfVxuXG4gICAgZWFyY3V0TGlua2VkKG91dGVyTm9kZSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDApO1xuXG4gICAgcmV0dXJuIHRyaWFuZ2xlcztcbn1cblxuLy8gY3JlYXRlIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0IGZyb20gcG9seWdvbiBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCB3aW5kaW5nIG9yZGVyXG5mdW5jdGlvbiBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgY2xvY2t3aXNlKSB7XG4gICAgdmFyIGksIGxhc3Q7XG5cbiAgICBpZiAoY2xvY2t3aXNlID09PSAoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pID4gMCkpIHtcbiAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gZW5kIC0gZGltOyBpID49IHN0YXJ0OyBpIC09IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH1cblxuICAgIGlmIChsYXN0ICYmIGVxdWFscyhsYXN0LCBsYXN0Lm5leHQpKSB7XG4gICAgICAgIHJlbW92ZU5vZGUobGFzdCk7XG4gICAgICAgIGxhc3QgPSBsYXN0Lm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhc3Q7XG59XG5cbi8vIGVsaW1pbmF0ZSBjb2xpbmVhciBvciBkdXBsaWNhdGUgcG9pbnRzXG5mdW5jdGlvbiBmaWx0ZXJQb2ludHMoc3RhcnQsIGVuZCkge1xuICAgIGlmICghc3RhcnQpIHJldHVybiBzdGFydDtcbiAgICBpZiAoIWVuZCkgZW5kID0gc3RhcnQ7XG5cbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBhZ2FpbjtcbiAgICBkbyB7XG4gICAgICAgIGFnYWluID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFwLnN0ZWluZXIgJiYgKGVxdWFscyhwLCBwLm5leHQpIHx8IGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID09PSAwKSkge1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHAgPSBlbmQgPSBwLnByZXY7XG4gICAgICAgICAgICBpZiAocCA9PT0gcC5uZXh0KSBicmVhaztcbiAgICAgICAgICAgIGFnYWluID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGFnYWluIHx8IHAgIT09IGVuZCk7XG5cbiAgICByZXR1cm4gZW5kO1xufVxuXG4vLyBtYWluIGVhciBzbGljaW5nIGxvb3Agd2hpY2ggdHJpYW5ndWxhdGVzIGEgcG9seWdvbiAoZ2l2ZW4gYXMgYSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCBwYXNzKSB7XG4gICAgaWYgKCFlYXIpIHJldHVybjtcblxuICAgIC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbiAgICBpZiAoIXBhc3MgJiYgaW52U2l6ZSkgaW5kZXhDdXJ2ZShlYXIsIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgdmFyIHN0b3AgPSBlYXIsXG4gICAgICAgIHByZXYsIG5leHQ7XG5cbiAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcbiAgICB3aGlsZSAoZWFyLnByZXYgIT09IGVhci5uZXh0KSB7XG4gICAgICAgIHByZXYgPSBlYXIucHJldjtcbiAgICAgICAgbmV4dCA9IGVhci5uZXh0O1xuXG4gICAgICAgIGlmIChpbnZTaXplID8gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSA6IGlzRWFyKGVhcikpIHtcbiAgICAgICAgICAgIC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwcmV2LmkgLyBkaW0gfCAwKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGVhci5pIC8gZGltIHwgMCk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChuZXh0LmkgLyBkaW0gfCAwKTtcblxuICAgICAgICAgICAgcmVtb3ZlTm9kZShlYXIpO1xuXG4gICAgICAgICAgICAvLyBza2lwcGluZyB0aGUgbmV4dCB2ZXJ0ZXggbGVhZHMgdG8gbGVzcyBzbGl2ZXIgdHJpYW5nbGVzXG4gICAgICAgICAgICBlYXIgPSBuZXh0Lm5leHQ7XG4gICAgICAgICAgICBzdG9wID0gbmV4dC5uZXh0O1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhciA9IG5leHQ7XG5cbiAgICAgICAgLy8gaWYgd2UgbG9vcGVkIHRocm91Z2ggdGhlIHdob2xlIHJlbWFpbmluZyBwb2x5Z29uIGFuZCBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnNcbiAgICAgICAgaWYgKGVhciA9PT0gc3RvcCkge1xuICAgICAgICAgICAgLy8gdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIHNsaWNpbmcgYWdhaW5cbiAgICAgICAgICAgIGlmICghcGFzcykge1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDEpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZWFyID0gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0pO1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAyKTtcblxuICAgICAgICAgICAgLy8gYXMgYSBsYXN0IHJlc29ydCwgdHJ5IHNwbGl0dGluZyB0aGUgcmVtYWluaW5nIHBvbHlnb24gaW50byB0d29cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcyA9PT0gMikge1xuICAgICAgICAgICAgICAgIHNwbGl0RWFyY3V0KGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXG5mdW5jdGlvbiBpc0VhcihlYXIpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICAvLyBub3cgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgb3RoZXIgcG9pbnRzIGluc2lkZSB0aGUgcG90ZW50aWFsIGVhclxuICAgIHZhciBheCA9IGEueCwgYnggPSBiLngsIGN4ID0gYy54LCBheSA9IGEueSwgYnkgPSBiLnksIGN5ID0gYy55O1xuXG4gICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICB2YXIgeDAgPSBheCA8IGJ4ID8gKGF4IDwgY3ggPyBheCA6IGN4KSA6IChieCA8IGN4ID8gYnggOiBjeCksXG4gICAgICAgIHkwID0gYXkgPCBieSA/IChheSA8IGN5ID8gYXkgOiBjeSkgOiAoYnkgPCBjeSA/IGJ5IDogY3kpLFxuICAgICAgICB4MSA9IGF4ID4gYnggPyAoYXggPiBjeCA/IGF4IDogY3gpIDogKGJ4ID4gY3ggPyBieCA6IGN4KSxcbiAgICAgICAgeTEgPSBheSA+IGJ5ID8gKGF5ID4gY3kgPyBheSA6IGN5KSA6IChieSA+IGN5ID8gYnkgOiBjeSk7XG5cbiAgICB2YXIgcCA9IGMubmV4dDtcbiAgICB3aGlsZSAocCAhPT0gYSkge1xuICAgICAgICBpZiAocC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIHZhciBhID0gZWFyLnByZXYsXG4gICAgICAgIGIgPSBlYXIsXG4gICAgICAgIGMgPSBlYXIubmV4dDtcblxuICAgIGlmIChhcmVhKGEsIGIsIGMpID49IDApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcblxuICAgIHZhciBheCA9IGEueCwgYnggPSBiLngsIGN4ID0gYy54LCBheSA9IGEueSwgYnkgPSBiLnksIGN5ID0gYy55O1xuXG4gICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICB2YXIgeDAgPSBheCA8IGJ4ID8gKGF4IDwgY3ggPyBheCA6IGN4KSA6IChieCA8IGN4ID8gYnggOiBjeCksXG4gICAgICAgIHkwID0gYXkgPCBieSA/IChheSA8IGN5ID8gYXkgOiBjeSkgOiAoYnkgPCBjeSA/IGJ5IDogY3kpLFxuICAgICAgICB4MSA9IGF4ID4gYnggPyAoYXggPiBjeCA/IGF4IDogY3gpIDogKGJ4ID4gY3ggPyBieCA6IGN4KSxcbiAgICAgICAgeTEgPSBheSA+IGJ5ID8gKGF5ID4gY3kgPyBheSA6IGN5KSA6IChieSA+IGN5ID8gYnkgOiBjeSk7XG5cbiAgICAvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuICAgIHZhciBtaW5aID0gek9yZGVyKHgwLCB5MCwgbWluWCwgbWluWSwgaW52U2l6ZSksXG4gICAgICAgIG1heFogPSB6T3JkZXIoeDEsIHkxLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblxuICAgIHZhciBwID0gZWFyLnByZXZaLFxuICAgICAgICBuID0gZWFyLm5leHRaO1xuXG4gICAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgaW4gYm90aCBkaXJlY3Rpb25zXG4gICAgd2hpbGUgKHAgJiYgcC56ID49IG1pblogJiYgbiAmJiBuLnogPD0gbWF4Wikge1xuICAgICAgICBpZiAocC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmIHAgIT09IGEgJiYgcCAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHAueCwgcC55KSAmJiBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLnByZXZaO1xuXG4gICAgICAgIGlmIChuLnggPj0geDAgJiYgbi54IDw9IHgxICYmIG4ueSA+PSB5MCAmJiBuLnkgPD0geTEgJiYgbiAhPT0gYSAmJiBuICE9PSBjICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgbi54LCBuLnkpICYmIGFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgbiA9IG4ubmV4dFo7XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWikge1xuICAgICAgICBpZiAocC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmIHAgIT09IGEgJiYgcCAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHAueCwgcC55KSAmJiBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLnByZXZaO1xuICAgIH1cblxuICAgIC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gaW5jcmVhc2luZyB6LW9yZGVyXG4gICAgd2hpbGUgKG4gJiYgbi56IDw9IG1heFopIHtcbiAgICAgICAgaWYgKG4ueCA+PSB4MCAmJiBuLnggPD0geDEgJiYgbi55ID49IHkwICYmIG4ueSA8PSB5MSAmJiBuICE9PSBhICYmIG4gIT09IGMgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBuLngsIG4ueSkgJiYgYXJlYShuLnByZXYsIG4sIG4ubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBuID0gbi5uZXh0WjtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gZ28gdGhyb3VnaCBhbGwgcG9seWdvbiBub2RlcyBhbmQgY3VyZSBzbWFsbCBsb2NhbCBzZWxmLWludGVyc2VjdGlvbnNcbmZ1bmN0aW9uIGN1cmVMb2NhbEludGVyc2VjdGlvbnMoc3RhcnQsIHRyaWFuZ2xlcywgZGltKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBhID0gcC5wcmV2LFxuICAgICAgICAgICAgYiA9IHAubmV4dC5uZXh0O1xuXG4gICAgICAgIGlmICghZXF1YWxzKGEsIGIpICYmIGludGVyc2VjdHMoYSwgcCwgcC5uZXh0LCBiKSAmJiBsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkpIHtcblxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYS5pIC8gZGltIHwgMCk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwLmkgLyBkaW0gfCAwKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGIuaSAvIGRpbSB8IDApO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwLm5leHQpO1xuXG4gICAgICAgICAgICBwID0gc3RhcnQgPSBiO1xuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGZpbHRlclBvaW50cyhwKTtcbn1cblxuLy8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcbmZ1bmN0aW9uIHNwbGl0RWFyY3V0KHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXG4gICAgdmFyIGEgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBiID0gYS5uZXh0Lm5leHQ7XG4gICAgICAgIHdoaWxlIChiICE9PSBhLnByZXYpIHtcbiAgICAgICAgICAgIGlmIChhLmkgIT09IGIuaSAmJiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBzcGxpdFBvbHlnb24oYSwgYik7XG5cbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuICAgICAgICAgICAgICAgIGEgPSBmaWx0ZXJQb2ludHMoYSwgYS5uZXh0KTtcbiAgICAgICAgICAgICAgICBjID0gZmlsdGVyUG9pbnRzKGMsIGMubmV4dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGMsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhLm5leHQ7XG4gICAgfSB3aGlsZSAoYSAhPT0gc3RhcnQpO1xufVxuXG4vLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pIHtcbiAgICB2YXIgcXVldWUgPSBbXSxcbiAgICAgICAgaSwgbGVuLCBzdGFydCwgZW5kLCBsaXN0O1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgbGlzdCA9IGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBmYWxzZSk7XG4gICAgICAgIGlmIChsaXN0ID09PSBsaXN0Lm5leHQpIGxpc3Quc3RlaW5lciA9IHRydWU7XG4gICAgICAgIHF1ZXVlLnB1c2goZ2V0TGVmdG1vc3QobGlzdCkpO1xuICAgIH1cblxuICAgIHF1ZXVlLnNvcnQoY29tcGFyZVgpO1xuXG4gICAgLy8gcHJvY2VzcyBob2xlcyBmcm9tIGxlZnQgdG8gcmlnaHRcbiAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZShxdWV1ZVtpXSwgb3V0ZXJOb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0ZXJOb2RlO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlWChhLCBiKSB7XG4gICAgcmV0dXJuIGEueCAtIGIueDtcbn1cblxuLy8gZmluZCBhIGJyaWRnZSBiZXR3ZWVuIHZlcnRpY2VzIHRoYXQgY29ubmVjdHMgaG9sZSB3aXRoIGFuIG91dGVyIHJpbmcgYW5kIGFuZCBsaW5rIGl0XG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlKGhvbGUsIG91dGVyTm9kZSkge1xuICAgIHZhciBicmlkZ2UgPSBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpO1xuICAgIGlmICghYnJpZGdlKSB7XG4gICAgICAgIHJldHVybiBvdXRlck5vZGU7XG4gICAgfVxuXG4gICAgdmFyIGJyaWRnZVJldmVyc2UgPSBzcGxpdFBvbHlnb24oYnJpZGdlLCBob2xlKTtcblxuICAgIC8vIGZpbHRlciBjb2xsaW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuICAgIGZpbHRlclBvaW50cyhicmlkZ2VSZXZlcnNlLCBicmlkZ2VSZXZlcnNlLm5leHQpO1xuICAgIHJldHVybiBmaWx0ZXJQb2ludHMoYnJpZGdlLCBicmlkZ2UubmV4dCk7XG59XG5cbi8vIERhdmlkIEViZXJseSdzIGFsZ29yaXRobSBmb3IgZmluZGluZyBhIGJyaWRnZSBiZXR3ZWVuIGhvbGUgYW5kIG91dGVyIHBvbHlnb25cbmZ1bmN0aW9uIGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSkge1xuICAgIHZhciBwID0gb3V0ZXJOb2RlLFxuICAgICAgICBoeCA9IGhvbGUueCxcbiAgICAgICAgaHkgPSBob2xlLnksXG4gICAgICAgIHF4ID0gLUluZmluaXR5LFxuICAgICAgICBtO1xuXG4gICAgLy8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xuICAgIC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcbiAgICBkbyB7XG4gICAgICAgIGlmIChoeSA8PSBwLnkgJiYgaHkgPj0gcC5uZXh0LnkgJiYgcC5uZXh0LnkgIT09IHAueSkge1xuICAgICAgICAgICAgdmFyIHggPSBwLnggKyAoaHkgLSBwLnkpICogKHAubmV4dC54IC0gcC54KSAvIChwLm5leHQueSAtIHAueSk7XG4gICAgICAgICAgICBpZiAoeCA8PSBoeCAmJiB4ID4gcXgpIHtcbiAgICAgICAgICAgICAgICBxeCA9IHg7XG4gICAgICAgICAgICAgICAgbSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gaHgpIHJldHVybiBtOyAvLyBob2xlIHRvdWNoZXMgb3V0ZXIgc2VnbWVudDsgcGljayBsZWZ0bW9zdCBlbmRwb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gb3V0ZXJOb2RlKTtcblxuICAgIGlmICghbSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XG4gICAgLy8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcblxuICAgIHZhciBzdG9wID0gbSxcbiAgICAgICAgbXggPSBtLngsXG4gICAgICAgIG15ID0gbS55LFxuICAgICAgICB0YW5NaW4gPSBJbmZpbml0eSxcbiAgICAgICAgdGFuO1xuXG4gICAgcCA9IG07XG5cbiAgICBkbyB7XG4gICAgICAgIGlmIChoeCA+PSBwLnggJiYgcC54ID49IG14ICYmIGh4ICE9PSBwLnggJiZcbiAgICAgICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoaHkgPCBteSA/IGh4IDogcXgsIGh5LCBteCwgbXksIGh5IDwgbXkgPyBxeCA6IGh4LCBoeSwgcC54LCBwLnkpKSB7XG5cbiAgICAgICAgICAgIHRhbiA9IE1hdGguYWJzKGh5IC0gcC55KSAvIChoeCAtIHAueCk7IC8vIHRhbmdlbnRpYWxcblxuICAgICAgICAgICAgaWYgKGxvY2FsbHlJbnNpZGUocCwgaG9sZSkgJiZcbiAgICAgICAgICAgICAgICAodGFuIDwgdGFuTWluIHx8ICh0YW4gPT09IHRhbk1pbiAmJiAocC54ID4gbS54IHx8IChwLnggPT09IG0ueCAmJiBzZWN0b3JDb250YWluc1NlY3RvcihtLCBwKSkpKSkpIHtcbiAgICAgICAgICAgICAgICBtID0gcDtcbiAgICAgICAgICAgICAgICB0YW5NaW4gPSB0YW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0b3ApO1xuXG4gICAgcmV0dXJuIG07XG59XG5cbi8vIHdoZXRoZXIgc2VjdG9yIGluIHZlcnRleCBtIGNvbnRhaW5zIHNlY3RvciBpbiB2ZXJ0ZXggcCBpbiB0aGUgc2FtZSBjb29yZGluYXRlc1xuZnVuY3Rpb24gc2VjdG9yQ29udGFpbnNTZWN0b3IobSwgcCkge1xuICAgIHJldHVybiBhcmVhKG0ucHJldiwgbSwgcC5wcmV2KSA8IDAgJiYgYXJlYShwLm5leHQsIG0sIG0ubmV4dCkgPCAwO1xufVxuXG4vLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG5mdW5jdGlvbiBpbmRleEN1cnZlKHN0YXJ0LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLnogPT09IDApIHAueiA9IHpPcmRlcihwLngsIHAueSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgIHAucHJldlogPSBwLnByZXY7XG4gICAgICAgIHAubmV4dFogPSBwLm5leHQ7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcC5wcmV2Wi5uZXh0WiA9IG51bGw7XG4gICAgcC5wcmV2WiA9IG51bGw7XG5cbiAgICBzb3J0TGlua2VkKHApO1xufVxuXG4vLyBTaW1vbiBUYXRoYW0ncyBsaW5rZWQgbGlzdCBtZXJnZSBzb3J0IGFsZ29yaXRobVxuLy8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcbmZ1bmN0aW9uIHNvcnRMaW5rZWQobGlzdCkge1xuICAgIHZhciBpLCBwLCBxLCBlLCB0YWlsLCBudW1NZXJnZXMsIHBTaXplLCBxU2l6ZSxcbiAgICAgICAgaW5TaXplID0gMTtcblxuICAgIGRvIHtcbiAgICAgICAgcCA9IGxpc3Q7XG4gICAgICAgIGxpc3QgPSBudWxsO1xuICAgICAgICB0YWlsID0gbnVsbDtcbiAgICAgICAgbnVtTWVyZ2VzID0gMDtcblxuICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgbnVtTWVyZ2VzKys7XG4gICAgICAgICAgICBxID0gcDtcbiAgICAgICAgICAgIHBTaXplID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHBTaXplKys7XG4gICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgaWYgKCFxKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHFTaXplID0gaW5TaXplO1xuXG4gICAgICAgICAgICB3aGlsZSAocFNpemUgPiAwIHx8IChxU2l6ZSA+IDAgJiYgcSkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwU2l6ZSAhPT0gMCAmJiAocVNpemUgPT09IDAgfHwgIXEgfHwgcC56IDw9IHEueikpIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFpbCkgdGFpbC5uZXh0WiA9IGU7XG4gICAgICAgICAgICAgICAgZWxzZSBsaXN0ID0gZTtcblxuICAgICAgICAgICAgICAgIGUucHJldlogPSB0YWlsO1xuICAgICAgICAgICAgICAgIHRhaWwgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwID0gcTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhaWwubmV4dFogPSBudWxsO1xuICAgICAgICBpblNpemUgKj0gMjtcblxuICAgIH0gd2hpbGUgKG51bU1lcmdlcyA+IDEpO1xuXG4gICAgcmV0dXJuIGxpc3Q7XG59XG5cbi8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIGludmVyc2Ugb2YgdGhlIGxvbmdlciBzaWRlIG9mIGRhdGEgYmJveFxuZnVuY3Rpb24gek9yZGVyKHgsIHksIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICAvLyBjb29yZHMgYXJlIHRyYW5zZm9ybWVkIGludG8gbm9uLW5lZ2F0aXZlIDE1LWJpdCBpbnRlZ2VyIHJhbmdlXG4gICAgeCA9ICh4IC0gbWluWCkgKiBpbnZTaXplIHwgMDtcbiAgICB5ID0gKHkgLSBtaW5ZKSAqIGludlNpemUgfCAwO1xuXG4gICAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG4vLyBmaW5kIHRoZSBsZWZ0bW9zdCBub2RlIG9mIGEgcG9seWdvbiByaW5nXG5mdW5jdGlvbiBnZXRMZWZ0bW9zdChzdGFydCkge1xuICAgIHZhciBwID0gc3RhcnQsXG4gICAgICAgIGxlZnRtb3N0ID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC54IDwgbGVmdG1vc3QueCB8fCAocC54ID09PSBsZWZ0bW9zdC54ICYmIHAueSA8IGxlZnRtb3N0LnkpKSBsZWZ0bW9zdCA9IHA7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGxlZnRtb3N0O1xufVxuXG4vLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5KSB7XG4gICAgcmV0dXJuIChjeCAtIHB4KSAqIChheSAtIHB5KSA+PSAoYXggLSBweCkgKiAoY3kgLSBweSkgJiZcbiAgICAgICAgICAgKGF4IC0gcHgpICogKGJ5IC0gcHkpID49IChieCAtIHB4KSAqIChheSAtIHB5KSAmJlxuICAgICAgICAgICAoYnggLSBweCkgKiAoY3kgLSBweSkgPj0gKGN4IC0gcHgpICogKGJ5IC0gcHkpO1xufVxuXG4vLyBjaGVjayBpZiBhIGRpYWdvbmFsIGJldHdlZW4gdHdvIHBvbHlnb24gbm9kZXMgaXMgdmFsaWQgKGxpZXMgaW4gcG9seWdvbiBpbnRlcmlvcilcbmZ1bmN0aW9uIGlzVmFsaWREaWFnb25hbChhLCBiKSB7XG4gICAgcmV0dXJuIGEubmV4dC5pICE9PSBiLmkgJiYgYS5wcmV2LmkgIT09IGIuaSAmJiAhaW50ZXJzZWN0c1BvbHlnb24oYSwgYikgJiYgLy8gZG9uZXMndCBpbnRlcnNlY3Qgb3RoZXIgZWRnZXNcbiAgICAgICAgICAgKGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSAmJiBtaWRkbGVJbnNpZGUoYSwgYikgJiYgLy8gbG9jYWxseSB2aXNpYmxlXG4gICAgICAgICAgICAoYXJlYShhLnByZXYsIGEsIGIucHJldikgfHwgYXJlYShhLCBiLnByZXYsIGIpKSB8fCAvLyBkb2VzIG5vdCBjcmVhdGUgb3Bwb3NpdGUtZmFjaW5nIHNlY3RvcnNcbiAgICAgICAgICAgIGVxdWFscyhhLCBiKSAmJiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA+IDAgJiYgYXJlYShiLnByZXYsIGIsIGIubmV4dCkgPiAwKTsgLy8gc3BlY2lhbCB6ZXJvLWxlbmd0aCBjYXNlXG59XG5cbi8vIHNpZ25lZCBhcmVhIG9mIGEgdHJpYW5nbGVcbmZ1bmN0aW9uIGFyZWEocCwgcSwgcikge1xuICAgIHJldHVybiAocS55IC0gcC55KSAqIChyLnggLSBxLngpIC0gKHEueCAtIHAueCkgKiAoci55IC0gcS55KTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWxcbmZ1bmN0aW9uIGVxdWFscyhwMSwgcDIpIHtcbiAgICByZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xufVxuXG4vLyBjaGVjayBpZiB0d28gc2VnbWVudHMgaW50ZXJzZWN0XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHAxLCBxMSwgcDIsIHEyKSB7XG4gICAgdmFyIG8xID0gc2lnbihhcmVhKHAxLCBxMSwgcDIpKTtcbiAgICB2YXIgbzIgPSBzaWduKGFyZWEocDEsIHExLCBxMikpO1xuICAgIHZhciBvMyA9IHNpZ24oYXJlYShwMiwgcTIsIHAxKSk7XG4gICAgdmFyIG80ID0gc2lnbihhcmVhKHAyLCBxMiwgcTEpKTtcblxuICAgIGlmIChvMSAhPT0gbzIgJiYgbzMgIT09IG80KSByZXR1cm4gdHJ1ZTsgLy8gZ2VuZXJhbCBjYXNlXG5cbiAgICBpZiAobzEgPT09IDAgJiYgb25TZWdtZW50KHAxLCBwMiwgcTEpKSByZXR1cm4gdHJ1ZTsgLy8gcDEsIHExIGFuZCBwMiBhcmUgY29sbGluZWFyIGFuZCBwMiBsaWVzIG9uIHAxcTFcbiAgICBpZiAobzIgPT09IDAgJiYgb25TZWdtZW50KHAxLCBxMiwgcTEpKSByZXR1cm4gdHJ1ZTsgLy8gcDEsIHExIGFuZCBxMiBhcmUgY29sbGluZWFyIGFuZCBxMiBsaWVzIG9uIHAxcTFcbiAgICBpZiAobzMgPT09IDAgJiYgb25TZWdtZW50KHAyLCBwMSwgcTIpKSByZXR1cm4gdHJ1ZTsgLy8gcDIsIHEyIGFuZCBwMSBhcmUgY29sbGluZWFyIGFuZCBwMSBsaWVzIG9uIHAycTJcbiAgICBpZiAobzQgPT09IDAgJiYgb25TZWdtZW50KHAyLCBxMSwgcTIpKSByZXR1cm4gdHJ1ZTsgLy8gcDIsIHEyIGFuZCBxMSBhcmUgY29sbGluZWFyIGFuZCBxMSBsaWVzIG9uIHAycTJcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gZm9yIGNvbGxpbmVhciBwb2ludHMgcCwgcSwgciwgY2hlY2sgaWYgcG9pbnQgcSBsaWVzIG9uIHNlZ21lbnQgcHJcbmZ1bmN0aW9uIG9uU2VnbWVudChwLCBxLCByKSB7XG4gICAgcmV0dXJuIHEueCA8PSBNYXRoLm1heChwLngsIHIueCkgJiYgcS54ID49IE1hdGgubWluKHAueCwgci54KSAmJiBxLnkgPD0gTWF0aC5tYXgocC55LCByLnkpICYmIHEueSA+PSBNYXRoLm1pbihwLnksIHIueSk7XG59XG5cbmZ1bmN0aW9uIHNpZ24obnVtKSB7XG4gICAgcmV0dXJuIG51bSA+IDAgPyAxIDogbnVtIDwgMCA/IC0xIDogMDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGludGVyc2VjdHMgYW55IHBvbHlnb24gc2VnbWVudHNcbmZ1bmN0aW9uIGludGVyc2VjdHNQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgcCA9IGE7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC5pICE9PSBhLmkgJiYgcC5uZXh0LmkgIT09IGEuaSAmJiBwLmkgIT09IGIuaSAmJiBwLm5leHQuaSAhPT0gYi5pICYmXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0cyhwLCBwLm5leHQsIGEsIGIpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGxvY2FsbHkgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBsb2NhbGx5SW5zaWRlKGEsIGIpIHtcbiAgICByZXR1cm4gYXJlYShhLnByZXYsIGEsIGEubmV4dCkgPCAwID9cbiAgICAgICAgYXJlYShhLCBiLCBhLm5leHQpID49IDAgJiYgYXJlYShhLCBhLnByZXYsIGIpID49IDAgOlxuICAgICAgICBhcmVhKGEsIGIsIGEucHJldikgPCAwIHx8IGFyZWEoYSwgYS5uZXh0LCBiKSA8IDA7XG59XG5cbi8vIGNoZWNrIGlmIHRoZSBtaWRkbGUgcG9pbnQgb2YgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbWlkZGxlSW5zaWRlKGEsIGIpIHtcbiAgICB2YXIgcCA9IGEsXG4gICAgICAgIGluc2lkZSA9IGZhbHNlLFxuICAgICAgICBweCA9IChhLnggKyBiLngpIC8gMixcbiAgICAgICAgcHkgPSAoYS55ICsgYi55KSAvIDI7XG4gICAgZG8ge1xuICAgICAgICBpZiAoKChwLnkgPiBweSkgIT09IChwLm5leHQueSA+IHB5KSkgJiYgcC5uZXh0LnkgIT09IHAueSAmJlxuICAgICAgICAgICAgICAgIChweCA8IChwLm5leHQueCAtIHAueCkgKiAocHkgLSBwLnkpIC8gKHAubmV4dC55IC0gcC55KSArIHAueCkpXG4gICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGluc2lkZTtcbn1cblxuLy8gbGluayB0d28gcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgYnJpZGdlOyBpZiB0aGUgdmVydGljZXMgYmVsb25nIHRvIHRoZSBzYW1lIHJpbmcsIGl0IHNwbGl0cyBwb2x5Z29uIGludG8gdHdvO1xuLy8gaWYgb25lIGJlbG9uZ3MgdG8gdGhlIG91dGVyIHJpbmcgYW5kIGFub3RoZXIgdG8gYSBob2xlLCBpdCBtZXJnZXMgaXQgaW50byBhIHNpbmdsZSByaW5nXG5mdW5jdGlvbiBzcGxpdFBvbHlnb24oYSwgYikge1xuICAgIHZhciBhMiA9IG5ldyBOb2RlKGEuaSwgYS54LCBhLnkpLFxuICAgICAgICBiMiA9IG5ldyBOb2RlKGIuaSwgYi54LCBiLnkpLFxuICAgICAgICBhbiA9IGEubmV4dCxcbiAgICAgICAgYnAgPSBiLnByZXY7XG5cbiAgICBhLm5leHQgPSBiO1xuICAgIGIucHJldiA9IGE7XG5cbiAgICBhMi5uZXh0ID0gYW47XG4gICAgYW4ucHJldiA9IGEyO1xuXG4gICAgYjIubmV4dCA9IGEyO1xuICAgIGEyLnByZXYgPSBiMjtcblxuICAgIGJwLm5leHQgPSBiMjtcbiAgICBiMi5wcmV2ID0gYnA7XG5cbiAgICByZXR1cm4gYjI7XG59XG5cbi8vIGNyZWF0ZSBhIG5vZGUgYW5kIG9wdGlvbmFsbHkgbGluayBpdCB3aXRoIHByZXZpb3VzIG9uZSAoaW4gYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBpbnNlcnROb2RlKGksIHgsIHksIGxhc3QpIHtcbiAgICB2YXIgcCA9IG5ldyBOb2RlKGksIHgsIHkpO1xuXG4gICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIHAucHJldiA9IHA7XG4gICAgICAgIHAubmV4dCA9IHA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBwLm5leHQgPSBsYXN0Lm5leHQ7XG4gICAgICAgIHAucHJldiA9IGxhc3Q7XG4gICAgICAgIGxhc3QubmV4dC5wcmV2ID0gcDtcbiAgICAgICAgbGFzdC5uZXh0ID0gcDtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUocCkge1xuICAgIHAubmV4dC5wcmV2ID0gcC5wcmV2O1xuICAgIHAucHJldi5uZXh0ID0gcC5uZXh0O1xuXG4gICAgaWYgKHAucHJldlopIHAucHJldloubmV4dFogPSBwLm5leHRaO1xuICAgIGlmIChwLm5leHRaKSBwLm5leHRaLnByZXZaID0gcC5wcmV2Wjtcbn1cblxuZnVuY3Rpb24gTm9kZShpLCB4LCB5KSB7XG4gICAgLy8gdmVydGV4IGluZGV4IGluIGNvb3JkaW5hdGVzIGFycmF5XG4gICAgdGhpcy5pID0gaTtcblxuICAgIC8vIHZlcnRleCBjb29yZGluYXRlc1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcblxuICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IHZlcnRleCBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xuICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcblxuICAgIC8vIHotb3JkZXIgY3VydmUgdmFsdWVcbiAgICB0aGlzLnogPSAwO1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxuICAgIHRoaXMucHJldlogPSBudWxsO1xuICAgIHRoaXMubmV4dFogPSBudWxsO1xuXG4gICAgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcbiAgICB0aGlzLnN0ZWluZXIgPSBmYWxzZTtcbn1cblxuLy8gcmV0dXJuIGEgcGVyY2VudGFnZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHBvbHlnb24gYXJlYSBhbmQgaXRzIHRyaWFuZ3VsYXRpb24gYXJlYTtcbi8vIHVzZWQgdG8gdmVyaWZ5IGNvcnJlY3RuZXNzIG9mIHRyaWFuZ3VsYXRpb25cbmVhcmN1dC5kZXZpYXRpb24gPSBmdW5jdGlvbiAoZGF0YSwgaG9sZUluZGljZXMsIGRpbSwgdHJpYW5nbGVzKSB7XG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoO1xuICAgIHZhciBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcblxuICAgIHZhciBwb2x5Z29uQXJlYSA9IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSkpO1xuICAgIGlmIChoYXNIb2xlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBwb2x5Z29uQXJlYSAtPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyaWFuZ2xlc0FyZWEgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIGEgPSB0cmlhbmdsZXNbaV0gKiBkaW07XG4gICAgICAgIHZhciBiID0gdHJpYW5nbGVzW2kgKyAxXSAqIGRpbTtcbiAgICAgICAgdmFyIGMgPSB0cmlhbmdsZXNbaSArIDJdICogZGltO1xuICAgICAgICB0cmlhbmdsZXNBcmVhICs9IE1hdGguYWJzKFxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2NdKSAqIChkYXRhW2IgKyAxXSAtIGRhdGFbYSArIDFdKSAtXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbYl0pICogKGRhdGFbYyArIDFdIC0gZGF0YVthICsgMV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9seWdvbkFyZWEgPT09IDAgJiYgdHJpYW5nbGVzQXJlYSA9PT0gMCA/IDAgOlxuICAgICAgICBNYXRoLmFicygodHJpYW5nbGVzQXJlYSAtIHBvbHlnb25BcmVhKSAvIHBvbHlnb25BcmVhKTtcbn07XG5cbmZ1bmN0aW9uIHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0LCBqID0gZW5kIC0gZGltOyBpIDwgZW5kOyBpICs9IGRpbSkge1xuICAgICAgICBzdW0gKz0gKGRhdGFbal0gLSBkYXRhW2ldKSAqIChkYXRhW2kgKyAxXSArIGRhdGFbaiArIDFdKTtcbiAgICAgICAgaiA9IGk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG5cbi8vIHR1cm4gYSBwb2x5Z29uIGluIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgZm9ybSAoZS5nLiBhcyBpbiBHZW9KU09OKSBpbnRvIGEgZm9ybSBFYXJjdXQgYWNjZXB0c1xuZWFyY3V0LmZsYXR0ZW4gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBkaW0gPSBkYXRhWzBdWzBdLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0ge3ZlcnRpY2VzOiBbXSwgaG9sZXM6IFtdLCBkaW1lbnNpb25zOiBkaW19LFxuICAgICAgICBob2xlSW5kZXggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkaW07IGQrKykgcmVzdWx0LnZlcnRpY2VzLnB1c2goZGF0YVtpXVtqXVtkXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBob2xlSW5kZXggKz0gZGF0YVtpIC0gMV0ubGVuZ3RoO1xuICAgICAgICAgICAgcmVzdWx0LmhvbGVzLnB1c2goaG9sZUluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIihmdW5jdGlvbih1LGgpe3R5cGVvZiBleHBvcnRzPT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlPFwidVwiP2goZXhwb3J0cyk6dHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kP2RlZmluZShbXCJleHBvcnRzXCJdLGgpOih1PXR5cGVvZiBnbG9iYWxUaGlzPFwidVwiP2dsb2JhbFRoaXM6dXx8c2VsZixoKHUuSG9uZXljb21iPXt9KSl9KSh0aGlzLGZ1bmN0aW9uKHUpe1widXNlIHN0cmljdFwiO2NvbnN0IGg9ZT0+TnVtYmVyLmlzRmluaXRlKGUpJiYhTnVtYmVyLmlzTmFOKGUpLE49ZT0+dHlwZW9mIGU9PVwib2JqZWN0XCImJmUhPT1udWxsLHJ0PWU9Pk4oZSkmJmgoZS5xKSYmaChlLnIpLHN0PWU9PnR5cGVvZiBlPT1cImZ1bmN0aW9uXCIsTz1lPT5OKGUpJiZoKGUuY29sKSYmaChlLnJvdyksej1lPT5OKGUpJiZoKGUueCkmJmgoZS55KSxSPWU9PkFycmF5LmlzQXJyYXkoZSkmJmgoZVswXSkmJmgoZVsxXSksRT0oZSx0KT0+dCtlKih0JjEpPj4xO2Z1bmN0aW9uIG90KGUsdCl7cmV0dXJuKGUldCt0KSV0fWNvbnN0IGl0PShlLHQpPT5vdChlK3QsOCksUD0oW2UsdCxuPS1lLXRdKT0+KHtxOmUscjp0LHM6bn0pO2Z1bmN0aW9uIHgoe3E6ZSxyOnQsczpufSl7Y29uc3Qgcj1oKGUpLHM9aCh0KSxvPWgobik7aWYociYmcyYmbylyZXR1cm57cTplLHI6dCxzOm59O2lmKHImJnMpcmV0dXJue3E6ZSxyOnQsczotZS10fTtpZihyJiZvKXJldHVybntxOmUscjotZS1uLHM6bn07aWYocyYmbylyZXR1cm57cTotdC1uLHI6dCxzOm59O3Rocm93IG5ldyBUeXBlRXJyb3IoYENhbid0IGRldGVybWluZSB0aHJlZSBjdWJlIGNvb3JkaW5hdGVzIGZyb20gbGVzcyB0aGFuIHR3byBjb29yZGluYXRlcy4gUmVjZWl2ZWQ6IHsgcTogJHtlfSwgcjogJHt0fSwgczogJHtufSB9LmApfXZhciBkPShlPT4oZS5GTEFUPVwiRkxBVFwiLGUuUE9JTlRZPVwiUE9JTlRZXCIsZSkpKGR8fHt9KTtmdW5jdGlvbiBVKGUsdCl7aWYoTihlKSYmZS54UmFkaXVzPjAmJmUueVJhZGl1cz4wKXJldHVybiBlO2lmKE4oZSkmJmUud2lkdGg+MCYmZS5oZWlnaHQ+MCl7Y29uc3R7d2lkdGg6bixoZWlnaHQ6cn09ZTtyZXR1cm4gdD09PWQuUE9JTlRZP3t4UmFkaXVzOm4vTWF0aC5zcXJ0KDMpLHlSYWRpdXM6ci8yfTp7eFJhZGl1czpuLzIseVJhZGl1czpyL01hdGguc3FydCgzKX19aWYoZT4wKXJldHVybnt4UmFkaXVzOmUseVJhZGl1czplfTt0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGRpbWVuc2lvbnM6ICR7SlNPTi5zdHJpbmdpZnkoZSl9LiBEaW1lbnNpb25zIG11c3QgYmUgZXhwcmVzc2VkIGFzIGFuIEVsbGlwc2UgKHsgeFJhZGl1czogbnVtYmVyLCB5UmFkaXVzOiBudW1iZXIgfSksIGEgUmVjdGFuZ2xlICh7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH0pIG9yIGEgbnVtYmVyLmApfWZ1bmN0aW9uIF8oZSx0KXtpZih6KGUpKXJldHVybiBlO2lmKCF0KXRocm93IG5ldyBUeXBlRXJyb3IoYFN1cHBseSBhIGJvdW5kaW5nIGJveCAoeyB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9KS4gUmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkodCl9YCk7aWYoZT09PVwidG9wTGVmdFwiKXJldHVybnt4OnQud2lkdGgqLS41LHk6dC5oZWlnaHQqLS41fTt0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIG9yaWdpbjogJHtKU09OLnN0cmluZ2lmeShlKX0uIE9yaWdpbiBtdXN0IGJlIGV4cHJlc3NlZCBhcyBhIFBvaW50ICh7IHg6IG51bWJlciwgeTogbnVtYmVyIH0pIG9yIHRoZSBzdHJpbmcgJ3RvcExlZnQnLmApfWNsYXNzIFd7c3RhdGljIGdldCBzZXR0aW5ncygpe2NvbnN0e2RpbWVuc2lvbnM6dCxvcmllbnRhdGlvbjpuLG9yaWdpbjpyLG9mZnNldDpzfT10aGlzLnByb3RvdHlwZTtyZXR1cm57ZGltZW5zaW9uczp0LG9yaWVudGF0aW9uOm4sb3JpZ2luOnIsb2Zmc2V0OnN9fWdldCBjZW50ZXIoKXtjb25zdHt3aWR0aDp0LGhlaWdodDpuLHg6cix5OnN9PXRoaXM7cmV0dXJue3g6dC8yLXIseTpuLzItc319Z2V0IGNvbCgpe3JldHVybiBwKHRoaXMpLmNvbH1nZXQgY29ybmVycygpe2NvbnN0e29yaWVudGF0aW9uOnQsd2lkdGg6bixoZWlnaHQ6cix4OnMseTpvfT10aGlzO3JldHVybiB0PT09ZC5QT0lOVFk/Y3QobixyLHMsbyk6dXQobixyLHMsbyl9Z2V0IGRpbWVuc2lvbnMoKXtyZXR1cm4gYi5kaW1lbnNpb25zfWdldCBoZWlnaHQoKXtjb25zdHtvcmllbnRhdGlvbjp0LGRpbWVuc2lvbnM6e3lSYWRpdXM6bn19PXRoaXM7cmV0dXJuIHQ9PT1kLlBPSU5UWT9uKjI6bipNYXRoLnNxcnQoMyl9Z2V0IGlzRmxhdCgpe3JldHVybiB0aGlzLm9yaWVudGF0aW9uPT09ZC5GTEFUfWdldCBpc1BvaW50eSgpe3JldHVybiB0aGlzLm9yaWVudGF0aW9uPT09ZC5QT0lOVFl9Z2V0IG9yaWVudGF0aW9uKCl7cmV0dXJuIGIub3JpZW50YXRpb259Z2V0IG9yaWdpbigpe3JldHVybiBiLm9yaWdpbn1nZXQgb2Zmc2V0KCl7cmV0dXJuIGIub2Zmc2V0fWdldCByb3coKXtyZXR1cm4gcCh0aGlzKS5yb3d9Z2V0IHdpZHRoKCl7Y29uc3R7b3JpZW50YXRpb246dCxkaW1lbnNpb25zOnt4UmFkaXVzOm59fT10aGlzO3JldHVybiB0PT09ZC5QT0lOVFk/bipNYXRoLnNxcnQoMyk6bioyfWdldCB4KCl7cmV0dXJuICQodGhpcykueH1nZXQgeSgpe3JldHVybiAkKHRoaXMpLnl9Z2V0IHMoKXtyZXR1cm4tdGhpcy5xLXRoaXMucn1xO3I7Y29uc3RydWN0b3IodD1bMCwwXSl7Y29uc3R7cTpuLHJ9PXcodGhpcyx0KTt0aGlzLnE9bix0aGlzLnI9cn1jbG9uZSh0PXRoaXMpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0KX1lcXVhbHModCl7cmV0dXJuIGsodGhpcyxPKHQpP0IodGhpcyx0KTp0KX10b1N0cmluZygpe3JldHVybmAke3RoaXMuY29uc3RydWN0b3IubmFtZX0oJHt0aGlzLnF9LCR7dGhpcy5yfSlgfXRyYW5zbGF0ZSh0KXtyZXR1cm4gWCh0aGlzLHQpfX1jb25zdCBiPXtkaW1lbnNpb25zOnt4UmFkaXVzOjEseVJhZGl1czoxfSxvcmllbnRhdGlvbjpkLlBPSU5UWSxvcmlnaW46e3g6MCx5OjB9LG9mZnNldDotMX0sY3Q9KGUsdCxuLHIpPT5be3g6bitlKi41LHk6ci10Ki4yNX0se3g6bitlKi41LHk6cit0Ki4yNX0se3g6bix5OnIrdCouNX0se3g6bi1lKi41LHk6cit0Ki4yNX0se3g6bi1lKi41LHk6ci10Ki4yNX0se3g6bix5OnItdCouNX1dLHV0PShlLHQsbixyKT0+W3t4Om4rZSouMjUseTpyLXQqLjV9LHt4Om4rZSouNSx5OnJ9LHt4Om4rZSouMjUseTpyK3QqLjV9LHt4Om4tZSouMjUseTpyK3QqLjV9LHt4Om4tZSouNSx5OnJ9LHt4Om4tZSouMjUseTpyLXQqLjV9XTtmdW5jdGlvbiBaKGUpe2NvbnN0e2RpbWVuc2lvbnM6dCxvcmllbnRhdGlvbjpuLG9yaWdpbjpyLG9mZnNldDpzfT17Li4uYiwuLi5lfTtyZXR1cm4gY2xhc3MgZXh0ZW5kcyBXe2dldCBkaW1lbnNpb25zKCl7cmV0dXJuIFUodCxuKX1nZXQgb3JpZW50YXRpb24oKXtyZXR1cm4gbn1nZXQgb3JpZ2luKCl7cmV0dXJuIF8ocix0aGlzKX1nZXQgb2Zmc2V0KCl7cmV0dXJuIHN9fX1mdW5jdGlvbiBrKGUsdCl7aWYoTyhlKSYmTyh0KSlyZXR1cm4gZS5jb2w9PT10LmNvbCYmZS5yb3c9PT10LnJvdztpZihPYmplY3QuaGFzT3duKGUsXCJjb2xcIil8fE9iamVjdC5oYXNPd24odCxcImNvbFwiKSl0aHJvdyBuZXcgRXJyb3IoYENhbid0IGNvbXBhcmUgY29vcmRpbmF0ZXMgd2hlcmUgb25lIGFyZSBvZmZzZXQgY29vcmRpbmF0ZXMuIEVpdGhlciBwYXNzIHR3byBvZmZzZXQgY29vcmRpbmF0ZXMgb3IgdHdvIGF4aWFsL2N1YmUgY29vcmRpbmF0ZXMuIFJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KGUpfSBhbmQgJHtKU09OLnN0cmluZ2lmeSh0KX1gKTtjb25zdCBuPVIoZSk/UChlKTplLHI9Uih0KT9QKHQpOnQ7cmV0dXJuIG4ucT09PXIucSYmbi5yPT09ci5yfWNvbnN0IGZ0PShlLHQsbik9Pih7Y29sOmUrRShuLHQpLHJvdzp0fSksaHQ9KGUsdCxuKT0+KHtjb2w6ZSxyb3c6dCtFKG4sZSl9KSxwPSh7cTplLHI6dCxvZmZzZXQ6bixpc1BvaW50eTpyfSk9PnI/ZnQoZSx0LG4pOmh0KGUsdCxuKSwkPSh7b3JpZW50YXRpb246ZSxkaW1lbnNpb25zOnt4UmFkaXVzOnQseVJhZGl1czpufSxvcmlnaW46e3g6cix5OnN9LHE6byxyOml9KT0+ZT09PWQuUE9JTlRZP3t4OnQqTWF0aC5zcXJ0KDMpKihvK2kvMiktcix5Om4qMy8yKmktc306e3g6dCozLzIqby1yLHk6bipNYXRoLnNxcnQoMykqKGkrby8yKS1zfSxZPShlLHQsbik9Pntjb25zdCByPWUtRShuLHQpLHM9dCxvPS1yLXM7cmV0dXJue3E6cixyOnMsczpvfX0sSj0oZSx0LG4pPT57Y29uc3Qgcj1lLHM9dC1FKG4sZSksbz0tci1zO3JldHVybntxOnIscjpzLHM6b319LEI9KHtvZmZzZXQ6ZSxvcmllbnRhdGlvbjp0fSx7Y29sOm4scm93OnJ9KT0+dD09PWQuUE9JTlRZP1kobixyLGUpOkoobixyLGUpLEY9ZT0+e2NvbnN0e3E6dCxyOm4sczpyfT14KGUpO2xldCBzPU1hdGgucm91bmQodCksbz1NYXRoLnJvdW5kKG4pLGk9TWF0aC5yb3VuZChyKTtjb25zdCBjPU1hdGguYWJzKHQtcyksZj1NYXRoLmFicyhuLW8pLGw9TWF0aC5hYnMoci1pKTtyZXR1cm4gYz5mJiZjPmw/cz0tby1pOmY+bD9vPS1zLWk6aT0tcy1vLHtxOnMscjpvLHM6aX19LFY9KHtkaW1lbnNpb25zOnt4UmFkaXVzOmUseVJhZGl1czp0fSxvcmlnaW46bixvcmllbnRhdGlvbjpyfSx7eDpzLHk6b30pPT4ocys9bi54LG8rPW4ueSxyPT09ZC5QT0lOVFk/Rih7cTpNYXRoLnNxcnQoMykqcy8oMyplKS1vLygzKnQpLHI6Mi8zKihvL3QpfSk6Rih7cToyLzMqKHMvZSkscjpNYXRoLnNxcnQoMykqby8oMyp0KS1zLygzKmUpfSkpO2Z1bmN0aW9uIHcoZSx0KXtyZXR1cm4gUih0KT9QKHQpOk8odCk/QihlLHQpOngodCl9ZnVuY3Rpb24gWChlLHQpe2NvbnN0e3E6bixyLHN9PXgoZSkse3E6byxyOmksczpjfT14KHQpLGY9e3E6bitvLHI6citpLHM6cytjfTtyZXR1cm4gZSBpbnN0YW5jZW9mIFc/ZS5jbG9uZShmKTpmfWZ1bmN0aW9uIEkoZSx0LG4pe2NvbnN0e3E6cixyOnMsczpvfT13KGUsdCkse3E6aSxyOmMsczpmfT13KGUsbik7cmV0dXJuIE1hdGgubWF4KE1hdGguYWJzKHItaSksTWF0aC5hYnMocy1jKSxNYXRoLmFicyhvLWYpKX12YXIgTD0oZT0+KGUuQ0xPQ0tXSVNFPVwiQ0xPQ0tXSVNFXCIsZS5DT1VOVEVSQ0xPQ0tXSVNFPVwiQ09VTlRFUkNMT0NLV0lTRVwiLGUpKShMfHx7fSksYT0oZT0+KGVbZS5OPTBdPVwiTlwiLGVbZS5ORT0xXT1cIk5FXCIsZVtlLkU9Ml09XCJFXCIsZVtlLlNFPTNdPVwiU0VcIixlW2UuUz00XT1cIlNcIixlW2UuU1c9NV09XCJTV1wiLGVbZS5XPTZdPVwiV1wiLGVbZS5OVz03XT1cIk5XXCIsZSkpKGF8fHt9KTtjb25zdCBhdD1bbnVsbCx7cToxLHI6LTF9LHtxOjEscjowfSx7cTowLHI6MX0sbnVsbCx7cTotMSxyOjF9LHtxOi0xLHI6MH0se3E6MCxyOi0xfV0sbHQ9W3txOjAscjotMX0se3E6MSxyOi0xfSxudWxsLHtxOjEscjowfSx7cTowLHI6MX0se3E6LTEscjoxfSxudWxsLHtxOi0xLHI6MH1dLGd0PSh7b2Zmc2V0OmUscTp0LHI6bixjb2w6cixyb3c6c30sbyk9PntpZihvPT09YS5TfHxvPT09YS5OKXtjb25zdCBjPW89PT1hLlM/cysxOnMtMTtyZXR1cm4gWShyLGMsZSl9Y29uc3QgaT1hdFtvXTtyZXR1cm57cTp0K2kucSxyOm4raS5yfX0sZHQ9KHtvZmZzZXQ6ZSxxOnQscjpuLGNvbDpyLHJvdzpzfSxvKT0+e2lmKG89PT1hLkV8fG89PT1hLlcpe2NvbnN0IGM9bz09PWEuRT9yKzE6ci0xO3JldHVybiBKKGMscyxlKX1jb25zdCBpPWx0W29dO3JldHVybntxOnQraS5xLHI6bitpLnJ9fSxBPShlLHQpPT5lLmNsb25lKGUuaXNQb2ludHk/Z3QoZSx0KTpkdChlLHQpKTtmdW5jdGlvbiBDKGUpe3JldHVybiBBcnJheS5pc0FycmF5KGUpP2Z1bmN0aW9uKG4scil7Y29uc3Qgcz1bXTtsZXQgbz1yO2Zvcihjb25zdCBpIG9mIGUpZm9yKGNvbnN0IGMgb2YgaShuLG8pKXMucHVzaChvPWMpO3JldHVybiBzfTplfWNvbnN0IG10PSguLi5lKT0+dD0+ZS5tYXAodCk7ZnVuY3Rpb24gdihlKXtyZXR1cm4gcXQoZSk/eXQoZSk6VHQoZSl9ZnVuY3Rpb24gcXQoZSl7cmV0dXJuIGUuZGlyZWN0aW9uIGluIGF9ZnVuY3Rpb24geXQoe3N0YXJ0OmUsZGlyZWN0aW9uOnQsbGVuZ3RoOm59KXtyZXR1cm4gZnVuY3Rpb24ocyxvKXtjb25zdCBpPVtdO2xldCBmPXMoZT8/byk7IWUmJm8mJihmPUEoZix0KSk7Zm9yKGxldCBsPTA7bDxuO2wrKylpLnB1c2goZiksZj1BKGYsdCk7cmV0dXJuIGl9fWZ1bmN0aW9uIFR0KHtzdGFydDplLHN0b3A6dH0pe3JldHVybiBmdW5jdGlvbihyLHMpe2NvbnN0IG89W10saT1yKGU/P3MpLGM9RChpKSxmPUQodyhpLHQpKSxsPU90KGMsZiksZz1JKGksaSx0KSxTPTEvTWF0aC5tYXgoZywxKTtsZXQgVD0hZSYmcz8xOjA7Zm9yKFQ7VDw9ZztUKyspe2NvbnN0IEg9RihsKFMqVCkpO28ucHVzaChyKEgpKX1yZXR1cm4gb319ZnVuY3Rpb24gRCh7cTplLHI6dCxzOm59KXtyZXR1cm57cTplKzFlLTYscjp0KzFlLTYsczpuKy0yZS02fX1mdW5jdGlvbiBPdChlLHQpe3JldHVybiBuPT57Y29uc3Qgcj1lLnEqKDEtbikrdC5xKm4scz1lLnIqKDEtbikrdC5yKm47cmV0dXJue3E6cixyOnN9fX1jb25zdCB4dD1lPT4odCxuKT0+W0EodChuKSxlKV07ZnVuY3Rpb24gaihlLHQse2luY2x1ZGVTb3VyY2U6bj0hMH09e30pe3JldHVybiBmdW5jdGlvbihzLG8pe2NvbnN0IGk9W107Zm9yKGNvbnN0IGMgb2YgQyhlKShzLG8pKXtuJiZpLnB1c2goYyk7Zm9yKGNvbnN0IGYgb2YgQyh0KShzLGMpKWkucHVzaChmKX1yZXR1cm4gaX19ZnVuY3Rpb24gYnQoZSx0KXtyZXR1cm4gZnVuY3Rpb24ocixzKXtjb25zdHt3aWR0aDpvLGhlaWdodDppLHN0YXJ0OmMsZGlyZWN0aW9uOmY9YS5FfT10P3d0KGUsdCxyKCkpOmUsbD1jPz9zPz9bMCwwXSxnPWoodih7c3RhcnQ6bCxkaXJlY3Rpb246aXQoZiwyKSxsZW5ndGg6aX0pLHYoe2RpcmVjdGlvbjpmLGxlbmd0aDpvLTF9KSkocixsKTtyZXR1cm4hYyYmcz9nLnNsaWNlKDEpOmd9fWZ1bmN0aW9uIHd0KGUsdCx7aXNQb2ludHk6bixvZmZzZXQ6cn0pe2NvbnN0e2NvbDpzLHJvdzpvfT1HKGUsbixyKSx7Y29sOmkscm93OmN9PUcodCxuLHIpLGY9czxpP1wiQVwiOlwiQlwiLGw9bzxjP1wiQVwiOlwiQlwiLGc9ZitsLHtzd2FwV2lkdGhIZWlnaHQ6UyxkaXJlY3Rpb246VH09Q3RbZ10sSD1NYXRoLmFicyhzLWkpKzEsbT1NYXRoLmFicyhvLWMpKzE7cmV0dXJue3dpZHRoOlM/bTpILGhlaWdodDpTP0g6bSxzdGFydDplLGRpcmVjdGlvbjpUfX1mdW5jdGlvbiBHKGUsdCxuKXtpZihPKGUpKXJldHVybiBlO2NvbnN0e3E6cixyOnN9PVIoZSk/UChlKTp4KGUpO3JldHVybiBwKHtxOnIscjpzLGlzUG9pbnR5OnQsb2Zmc2V0Om59KX1jb25zdCBDdD17QUE6e3N3YXBXaWR0aEhlaWdodDohMSxkaXJlY3Rpb246YS5FfSxBQjp7c3dhcFdpZHRoSGVpZ2h0OiEwLGRpcmVjdGlvbjphLk59LEJBOntzd2FwV2lkdGhIZWlnaHQ6ITAsZGlyZWN0aW9uOmEuU30sQkI6e3N3YXBXaWR0aEhlaWdodDohMSxkaXJlY3Rpb246YS5XfX07ZnVuY3Rpb24gU3QoZSx0KXtyZXR1cm4gQyhBcnJheS5mcm9tKHtsZW5ndGg6ZX0sKCk9PkModCkpKX1mdW5jdGlvbiB0dChlKXtjb25zdHtjZW50ZXI6dCxyb3RhdGlvbjpuPUwuQ0xPQ0tXSVNFfT1lO3JldHVybiBmdW5jdGlvbihzLG8pe2NvbnN0IGk9bi50b1VwcGVyQ2FzZSgpLGM9W107bGV0e3JhZGl1czpmfT1lO2NvbnN0IGw9aChmKTtsZXQgZztsP2c9cyh0KS50cmFuc2xhdGUoe3E6ZixzOi1mfSk6KGc9cyhlLnN0YXJ0Pz9vKSxmPUkoZyx0LGcpKTtjb25zdHtxOlMscjpULHM6SH09dyhnLHQpO2xldCBtPXMoe3E6UyxyOlQtZixzOkgrZn0pO2lmKGk9PT1MLkNMT0NLV0lTRSlmb3IobGV0IHk9MDt5PDY7eSsrKWZvcihsZXQgTT0wO008ZjtNKyspe2NvbnN0e3E6SyxyOlF9PWV0W3ldO209cyh7cTptLnErSyxyOm0ucitRfSksYy5wdXNoKG0pfWVsc2UgZm9yKGxldCB5PTU7eT49MDt5LS0pZm9yKGxldCBNPTA7TTxmO00rKyl7Y29uc3R7cTpLLHI6UX09ZXRbeV07bT1zKHtxOm0ucS1LLHI6bS5yLVF9KSxjLnB1c2gobSl9Y29uc3QgTnQ9bD8hMTohZS5zdGFydCYmbyxudD1jLmZpbmRJbmRleCh5PT55LmVxdWFscyhnKSk7cmV0dXJuIGMuc2xpY2UobnQrKE50PzE6MCkpLmNvbmNhdChjLnNsaWNlKDAsbnQpKX19Y29uc3QgZXQ9W3txOjEscjowfSx7cTowLHI6MX0se3E6LTEscjoxfSx7cTotMSxyOjB9LHtxOjAscjotMX0se3E6MSxyOi0xfV07ZnVuY3Rpb24gSHQoe3JhZGl1czplLHN0YXJ0OnQscm90YXRpb246bn0pe3JldHVybiBmdW5jdGlvbihzLG8pe2NvbnN0IGk9dD8/bz8/WzAsMF0sYz0hdCYmbz9lOmUrMTtyZXR1cm4gaih2KHtzdGFydDp0LGRpcmVjdGlvbjphLk4sbGVuZ3RoOmN9KSx0dCh7Y2VudGVyOmkscm90YXRpb246bn0pKShzLG8pfX1jbGFzcyBxe3N0YXRpYyBmcm9tSXRlcmFibGUodCl7Y29uc3Qgbj10W1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCkudmFsdWU7aWYoIW4pdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuJ3QgY3JlYXRlIGdyaWQgZnJvbSBlbXB0eSBpdGVyYWJsZTogJHtKU09OLnN0cmluZ2lmeSh0KX1gKTtyZXR1cm4gbmV3IHEobi5jb25zdHJ1Y3Rvcix0KX1zdGF0aWMgZnJvbUpTT04oe2hleFNldHRpbmdzOnQsY29vcmRpbmF0ZXM6bn0scil7aWYocil7Y29uc3Qgbz1uLm1hcChyKSxpPW8ubGVuZ3RoPjA/b1swXS5jb25zdHJ1Y3RvcjpyKHtxOjAscjowfSwwLFt7cTowLHI6MH1dKS5jb25zdHJ1Y3RvcjtyZXR1cm4gbmV3IHEoaSxvKX1jb25zdCBzPVoodCk7cmV0dXJuIG5ldyBxKHMsbi5tYXAobz0+bmV3IHMobykpKX1nZXQgc2l6ZSgpe3JldHVybiB0aGlzLiNlLnNpemV9Z2V0IHBpeGVsV2lkdGgoKXtpZih0aGlzLnNpemU9PT0wKXJldHVybiAwO2NvbnN0e2lzUG9pbnR5OnQsd2lkdGg6bn09dGhpcy5oZXhQcm90b3R5cGUscj10aGlzLnRvQXJyYXkoKSx7MDpzLGxlbmd0aDpvLFtvLTFdOml9PXQ/ci5zb3J0KChjLGYpPT5mLnMtYy5zfHxjLnEtZi5xKTpyLnNvcnQoKGMsZik9PmMucS1mLnEpO3JldHVybiBpLngtcy54K259Z2V0IHBpeGVsSGVpZ2h0KCl7aWYodGhpcy5zaXplPT09MClyZXR1cm4gMDtjb25zdHtpc1BvaW50eTp0LGhlaWdodDpufT10aGlzLmhleFByb3RvdHlwZSxyPXRoaXMudG9BcnJheSgpLHswOnMsbGVuZ3RoOm8sW28tMV06aX09dD9yLnNvcnQoKGMsZik9PmMuci1mLnIpOnIuc29ydCgoYyxmKT0+Zi5zLWMuc3x8Yy5yLWYucik7cmV0dXJuIGkueS1zLnkrbn1bU3ltYm9sLml0ZXJhdG9yXSgpe3JldHVybiB0aGlzLiNlLnZhbHVlcygpfWdldCBoZXhQcm90b3R5cGUoKXtyZXR1cm4gdGhpcy4jdC5wcm90b3R5cGV9I3Q7I2U9bmV3IE1hcDtjb25zdHJ1Y3Rvcih0LG49W10pe2lmKHQgaW5zdGFuY2VvZiBxKXt0aGlzLiN0PXQuI3QsdGhpcy5zZXRIZXhlcyh0KTtyZXR1cm59dGhpcy4jdD10LHRoaXMuc2V0SGV4ZXModGhpcy4jcihuKSl9Y3JlYXRlSGV4KHQpe3JldHVybiBuZXcgdGhpcy4jdCh0KX1nZXRIZXgodCl7Y29uc3Qgbj10aGlzLmNyZWF0ZUhleCh0KTtyZXR1cm4gdGhpcy4jZS5nZXQobi50b1N0cmluZygpKX1oYXNIZXgodCl7cmV0dXJuIHRoaXMuI2UuaGFzKHQudG9TdHJpbmcoKSl9c2V0SGV4ZXModCl7Zm9yKGNvbnN0IG4gb2YgdCl7Y29uc3Qgcj1uIGluc3RhbmNlb2YgVz9uOm5ldyB0aGlzLiN0KG4pO3RoaXMuI24ocil9cmV0dXJuIHRoaXN9ZmlsdGVyKHQpe2NvbnN0IG49bmV3IHEodGhpcy4jdCk7Zm9yKGNvbnN0IHIgb2YgdGhpcyl0KHIpJiZuLiNuKHIpO3JldHVybiBufW1hcCh0KXtjb25zdCBuPW5ldyBxKHRoaXMuI3QpO2Zvcihjb25zdCByIG9mIHRoaXMpbi4jbih0KHIpKTtyZXR1cm4gbn10cmF2ZXJzZSh0LHtiYWlsOm49ITF9PXt9KXtjb25zdCByPW5ldyBxKHRoaXMuI3QpO2Zvcihjb25zdCBzIG9mIHRoaXMuI3IodCkpe2NvbnN0IG89dGhpcy5nZXRIZXgocyk7aWYobylyLiNuKG8pO2Vsc2UgaWYobilyZXR1cm4gcn1yZXR1cm4gcn1mb3JFYWNoKHQpe2Zvcihjb25zdCBuIG9mIHRoaXMpdChuKTtyZXR1cm4gdGhpc31yZWR1Y2UodCxuKXtpZihuPT09dm9pZCAwKXtsZXQgcyxvLGk7Zm9yKGNvbnN0IGMgb2YgdGhpcylvPWksaT1jLG8mJihzPXQobyxpKSk7cmV0dXJuIHN9bGV0IHI9bjtmb3IoY29uc3QgcyBvZiB0aGlzKXI9dChyLHMpO3JldHVybiByfXRvQXJyYXkoKXtyZXR1cm4gQXJyYXkuZnJvbSh0aGlzKX10b0pTT04oKXtjb25zdHtkaW1lbnNpb25zOnQsb3JpZW50YXRpb246bixvcmlnaW46cixvZmZzZXQ6c309dGhpcy5oZXhQcm90b3R5cGU7cmV0dXJue2hleFNldHRpbmdzOntkaW1lbnNpb25zOnQsb3JpZW50YXRpb246bixvcmlnaW46cixvZmZzZXQ6c30sY29vcmRpbmF0ZXM6dGhpcy50b0FycmF5KCl9fXRvU3RyaW5nKCl7cmV0dXJuYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSgke3RoaXMuc2l6ZX0pYH1wb2ludFRvSGV4KHQse2FsbG93T3V0c2lkZTpuPSEwfT17fSl7Y29uc3Qgcj1WKHRoaXMuaGV4UHJvdG90eXBlLHQpLHM9dGhpcy5nZXRIZXgocik7cmV0dXJuIG4/cz8/dGhpcy5jcmVhdGVIZXgocik6c31kaXN0YW5jZSh0LG4se2FsbG93T3V0c2lkZTpyPSEwfT17fSl7aWYocilyZXR1cm4gSSh0aGlzLmhleFByb3RvdHlwZSx0LG4pO2NvbnN0IHM9dGhpcy5nZXRIZXgodCksbz10aGlzLmdldEhleChuKTtpZighKCFzfHwhbykpcmV0dXJuIEkodGhpcy5oZXhQcm90b3R5cGUscyxvKX1uZWlnaGJvck9mKHQsbix7YWxsb3dPdXRzaWRlOnI9ITB9PXt9KXtjb25zdCBzPUEodGhpcy5jcmVhdGVIZXgodCksbiksbz10aGlzLmdldEhleChzKTtyZXR1cm4gcj9vPz9zOm99I24odCl7dGhpcy4jZS5zZXQodC50b1N0cmluZygpLHQpfSNyKHQpe3JldHVybiB0aGlzLiNzKHQpP3RoaXMuI28odCk6QXJyYXkuaXNBcnJheSh0KSYmdGhpcy4jcyh0WzBdKT90aGlzLiNvKEModCkpOnR9I3ModCl7cmV0dXJuIHN0KHQpfSNvKHQpe3JldHVybiB0KHRoaXMuY3JlYXRlSGV4LmJpbmQodGhpcykpfX11LkRpcmVjdGlvbj1hLHUuR3JpZD1xLHUuSGV4PVcsdS5PcmllbnRhdGlvbj1kLHUuUm90YXRpb249TCx1LmNvbXBsZXRlQ3ViZT14LHUuY29uY2F0PUMsdS5jcmVhdGVIZXhEaW1lbnNpb25zPVUsdS5jcmVhdGVIZXhPcmlnaW49Xyx1LmRlZmF1bHRIZXhTZXR0aW5ncz1iLHUuZGVmaW5lSGV4PVosdS5kaXN0YW5jZT1JLHUuZXF1YWxzPWssdS5mcm9tQ29vcmRpbmF0ZXM9bXQsdS5oZXhUb09mZnNldD1wLHUuaGV4VG9Qb2ludD0kLHUuaXNBeGlhbD1ydCx1LmlzT2Zmc2V0PU8sdS5pc1BvaW50PXosdS5pc1R1cGxlPVIsdS5saW5lPXYsdS5tb3ZlPXh0LHUubmVpZ2hib3JPZj1BLHUub2Zmc2V0RnJvbVplcm89RSx1Lm9mZnNldFRvQ3ViZT1CLHUub2Zmc2V0VG9DdWJlRmxhdD1KLHUub2Zmc2V0VG9DdWJlUG9pbnR5PVksdS5wb2ludFRvQ3ViZT1WLHUucmVjdGFuZ2xlPWJ0LHUucmVwZWF0PVN0LHUucmVwZWF0V2l0aD1qLHUucmluZz10dCx1LnJvdW5kPUYsdS5zcGlyYWw9SHQsdS50b0N1YmU9dyx1LnRyYW5zbGF0ZT1YLHUudHVwbGVUb0N1YmU9UCxPYmplY3QuZGVmaW5lUHJvcGVydHkodSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KX0pO1xuIiwiZXhwb3J0ICogZnJvbSAnLi9pc01vYmlsZSc7XG5leHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9pc01vYmlsZSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJ2YXIgYXBwbGVJcGhvbmUgPSAvaVBob25lL2k7XG52YXIgYXBwbGVJcG9kID0gL2lQb2QvaTtcbnZhciBhcHBsZVRhYmxldCA9IC9pUGFkL2k7XG52YXIgYXBwbGVVbml2ZXJzYWwgPSAvXFxiaU9TLXVuaXZlcnNhbCg/Oi4rKU1hY1xcYi9pO1xudmFyIGFuZHJvaWRQaG9uZSA9IC9cXGJBbmRyb2lkKD86LispTW9iaWxlXFxiL2k7XG52YXIgYW5kcm9pZFRhYmxldCA9IC9BbmRyb2lkL2k7XG52YXIgYW1hem9uUGhvbmUgPSAvKD86U0Q0OTMwVVJ8XFxiU2lsayg/Oi4rKU1vYmlsZVxcYikvaTtcbnZhciBhbWF6b25UYWJsZXQgPSAvU2lsay9pO1xudmFyIHdpbmRvd3NQaG9uZSA9IC9XaW5kb3dzIFBob25lL2k7XG52YXIgd2luZG93c1RhYmxldCA9IC9cXGJXaW5kb3dzKD86LispQVJNXFxiL2k7XG52YXIgb3RoZXJCbGFja0JlcnJ5ID0gL0JsYWNrQmVycnkvaTtcbnZhciBvdGhlckJsYWNrQmVycnkxMCA9IC9CQjEwL2k7XG52YXIgb3RoZXJPcGVyYSA9IC9PcGVyYSBNaW5pL2k7XG52YXIgb3RoZXJDaHJvbWUgPSAvXFxiKENyaU9TfENocm9tZSkoPzouKylNb2JpbGUvaTtcbnZhciBvdGhlckZpcmVmb3ggPSAvTW9iaWxlKD86LispRmlyZWZveFxcYi9pO1xudmFyIGlzQXBwbGVUYWJsZXRPbklvczEzID0gZnVuY3Rpb24gKG5hdmlnYXRvcikge1xuICAgIHJldHVybiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgbmF2aWdhdG9yLnBsYXRmb3JtID09PSAnTWFjSW50ZWwnICYmXG4gICAgICAgIHR5cGVvZiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPT09ICdudW1iZXInICYmXG4gICAgICAgIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDEgJiZcbiAgICAgICAgdHlwZW9mIE1TU3RyZWFtID09PSAndW5kZWZpbmVkJyk7XG59O1xuZnVuY3Rpb24gY3JlYXRlTWF0Y2godXNlckFnZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZWdleCkgeyByZXR1cm4gcmVnZXgudGVzdCh1c2VyQWdlbnQpOyB9O1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNNb2JpbGUocGFyYW0pIHtcbiAgICB2YXIgbmF2ID0ge1xuICAgICAgICB1c2VyQWdlbnQ6ICcnLFxuICAgICAgICBwbGF0Zm9ybTogJycsXG4gICAgICAgIG1heFRvdWNoUG9pbnRzOiAwXG4gICAgfTtcbiAgICBpZiAoIXBhcmFtICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG5hdiA9IHtcbiAgICAgICAgICAgIHVzZXJBZ2VudDogbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgICAgIHBsYXRmb3JtOiBuYXZpZ2F0b3IucGxhdGZvcm0sXG4gICAgICAgICAgICBtYXhUb3VjaFBvaW50czogbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIHx8IDBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYXYudXNlckFnZW50ID0gcGFyYW07XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcmFtICYmIHBhcmFtLnVzZXJBZ2VudCkge1xuICAgICAgICBuYXYgPSB7XG4gICAgICAgICAgICB1c2VyQWdlbnQ6IHBhcmFtLnVzZXJBZ2VudCxcbiAgICAgICAgICAgIHBsYXRmb3JtOiBwYXJhbS5wbGF0Zm9ybSxcbiAgICAgICAgICAgIG1heFRvdWNoUG9pbnRzOiBwYXJhbS5tYXhUb3VjaFBvaW50cyB8fCAwXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciB1c2VyQWdlbnQgPSBuYXYudXNlckFnZW50O1xuICAgIHZhciB0bXAgPSB1c2VyQWdlbnQuc3BsaXQoJ1tGQkFOJyk7XG4gICAgaWYgKHR5cGVvZiB0bXBbMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHVzZXJBZ2VudCA9IHRtcFswXTtcbiAgICB9XG4gICAgdG1wID0gdXNlckFnZW50LnNwbGl0KCdUd2l0dGVyJyk7XG4gICAgaWYgKHR5cGVvZiB0bXBbMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHVzZXJBZ2VudCA9IHRtcFswXTtcbiAgICB9XG4gICAgdmFyIG1hdGNoID0gY3JlYXRlTWF0Y2godXNlckFnZW50KTtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBhcHBsZToge1xuICAgICAgICAgICAgcGhvbmU6IG1hdGNoKGFwcGxlSXBob25lKSAmJiAhbWF0Y2god2luZG93c1Bob25lKSxcbiAgICAgICAgICAgIGlwb2Q6IG1hdGNoKGFwcGxlSXBvZCksXG4gICAgICAgICAgICB0YWJsZXQ6ICFtYXRjaChhcHBsZUlwaG9uZSkgJiZcbiAgICAgICAgICAgICAgICAobWF0Y2goYXBwbGVUYWJsZXQpIHx8IGlzQXBwbGVUYWJsZXRPbklvczEzKG5hdikpICYmXG4gICAgICAgICAgICAgICAgIW1hdGNoKHdpbmRvd3NQaG9uZSksXG4gICAgICAgICAgICB1bml2ZXJzYWw6IG1hdGNoKGFwcGxlVW5pdmVyc2FsKSxcbiAgICAgICAgICAgIGRldmljZTogKG1hdGNoKGFwcGxlSXBob25lKSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoKGFwcGxlSXBvZCkgfHxcbiAgICAgICAgICAgICAgICBtYXRjaChhcHBsZVRhYmxldCkgfHxcbiAgICAgICAgICAgICAgICBtYXRjaChhcHBsZVVuaXZlcnNhbCkgfHxcbiAgICAgICAgICAgICAgICBpc0FwcGxlVGFibGV0T25Jb3MxMyhuYXYpKSAmJlxuICAgICAgICAgICAgICAgICFtYXRjaCh3aW5kb3dzUGhvbmUpXG4gICAgICAgIH0sXG4gICAgICAgIGFtYXpvbjoge1xuICAgICAgICAgICAgcGhvbmU6IG1hdGNoKGFtYXpvblBob25lKSxcbiAgICAgICAgICAgIHRhYmxldDogIW1hdGNoKGFtYXpvblBob25lKSAmJiBtYXRjaChhbWF6b25UYWJsZXQpLFxuICAgICAgICAgICAgZGV2aWNlOiBtYXRjaChhbWF6b25QaG9uZSkgfHwgbWF0Y2goYW1hem9uVGFibGV0KVxuICAgICAgICB9LFxuICAgICAgICBhbmRyb2lkOiB7XG4gICAgICAgICAgICBwaG9uZTogKCFtYXRjaCh3aW5kb3dzUGhvbmUpICYmIG1hdGNoKGFtYXpvblBob25lKSkgfHxcbiAgICAgICAgICAgICAgICAoIW1hdGNoKHdpbmRvd3NQaG9uZSkgJiYgbWF0Y2goYW5kcm9pZFBob25lKSksXG4gICAgICAgICAgICB0YWJsZXQ6ICFtYXRjaCh3aW5kb3dzUGhvbmUpICYmXG4gICAgICAgICAgICAgICAgIW1hdGNoKGFtYXpvblBob25lKSAmJlxuICAgICAgICAgICAgICAgICFtYXRjaChhbmRyb2lkUGhvbmUpICYmXG4gICAgICAgICAgICAgICAgKG1hdGNoKGFtYXpvblRhYmxldCkgfHwgbWF0Y2goYW5kcm9pZFRhYmxldCkpLFxuICAgICAgICAgICAgZGV2aWNlOiAoIW1hdGNoKHdpbmRvd3NQaG9uZSkgJiZcbiAgICAgICAgICAgICAgICAobWF0Y2goYW1hem9uUGhvbmUpIHx8XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoKGFtYXpvblRhYmxldCkgfHxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2goYW5kcm9pZFBob25lKSB8fFxuICAgICAgICAgICAgICAgICAgICBtYXRjaChhbmRyb2lkVGFibGV0KSkpIHx8XG4gICAgICAgICAgICAgICAgbWF0Y2goL1xcYm9raHR0cFxcYi9pKVxuICAgICAgICB9LFxuICAgICAgICB3aW5kb3dzOiB7XG4gICAgICAgICAgICBwaG9uZTogbWF0Y2god2luZG93c1Bob25lKSxcbiAgICAgICAgICAgIHRhYmxldDogbWF0Y2god2luZG93c1RhYmxldCksXG4gICAgICAgICAgICBkZXZpY2U6IG1hdGNoKHdpbmRvd3NQaG9uZSkgfHwgbWF0Y2god2luZG93c1RhYmxldClcbiAgICAgICAgfSxcbiAgICAgICAgb3RoZXI6IHtcbiAgICAgICAgICAgIGJsYWNrYmVycnk6IG1hdGNoKG90aGVyQmxhY2tCZXJyeSksXG4gICAgICAgICAgICBibGFja2JlcnJ5MTA6IG1hdGNoKG90aGVyQmxhY2tCZXJyeTEwKSxcbiAgICAgICAgICAgIG9wZXJhOiBtYXRjaChvdGhlck9wZXJhKSxcbiAgICAgICAgICAgIGZpcmVmb3g6IG1hdGNoKG90aGVyRmlyZWZveCksXG4gICAgICAgICAgICBjaHJvbWU6IG1hdGNoKG90aGVyQ2hyb21lKSxcbiAgICAgICAgICAgIGRldmljZTogbWF0Y2gob3RoZXJCbGFja0JlcnJ5KSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoKG90aGVyQmxhY2tCZXJyeTEwKSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoKG90aGVyT3BlcmEpIHx8XG4gICAgICAgICAgICAgICAgbWF0Y2gob3RoZXJGaXJlZm94KSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoKG90aGVyQ2hyb21lKVxuICAgICAgICB9LFxuICAgICAgICBhbnk6IGZhbHNlLFxuICAgICAgICBwaG9uZTogZmFsc2UsXG4gICAgICAgIHRhYmxldDogZmFsc2VcbiAgICB9O1xuICAgIHJlc3VsdC5hbnkgPVxuICAgICAgICByZXN1bHQuYXBwbGUuZGV2aWNlIHx8XG4gICAgICAgICAgICByZXN1bHQuYW5kcm9pZC5kZXZpY2UgfHxcbiAgICAgICAgICAgIHJlc3VsdC53aW5kb3dzLmRldmljZSB8fFxuICAgICAgICAgICAgcmVzdWx0Lm90aGVyLmRldmljZTtcbiAgICByZXN1bHQucGhvbmUgPVxuICAgICAgICByZXN1bHQuYXBwbGUucGhvbmUgfHwgcmVzdWx0LmFuZHJvaWQucGhvbmUgfHwgcmVzdWx0LndpbmRvd3MucGhvbmU7XG4gICAgcmVzdWx0LnRhYmxldCA9XG4gICAgICAgIHJlc3VsdC5hcHBsZS50YWJsZXQgfHwgcmVzdWx0LmFuZHJvaWQudGFibGV0IHx8IHJlc3VsdC53aW5kb3dzLnRhYmxldDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNNb2JpbGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBmaWx0ZXJBbHBoYSA9IHJlcXVpcmUoJ0BwaXhpL2ZpbHRlci1hbHBoYScpO1xudmFyIGZpbHRlckJsdXIgPSByZXF1aXJlKCdAcGl4aS9maWx0ZXItYmx1cicpO1xudmFyIGZpbHRlckNvbG9yTWF0cml4ID0gcmVxdWlyZSgnQHBpeGkvZmlsdGVyLWNvbG9yLW1hdHJpeCcpO1xudmFyIGZpbHRlckRpc3BsYWNlbWVudCA9IHJlcXVpcmUoJ0BwaXhpL2ZpbHRlci1kaXNwbGFjZW1lbnQnKTtcbnZhciBmaWx0ZXJGeGFhID0gcmVxdWlyZSgnQHBpeGkvZmlsdGVyLWZ4YWEnKTtcbnZhciBmaWx0ZXJOb2lzZSA9IHJlcXVpcmUoJ0BwaXhpL2ZpbHRlci1ub2lzZScpO1xuXG5jb25zdCBmaWx0ZXJzID0ge1xuICBBbHBoYUZpbHRlcjogZmlsdGVyQWxwaGEuQWxwaGFGaWx0ZXIsXG4gIEJsdXJGaWx0ZXI6IGZpbHRlckJsdXIuQmx1ckZpbHRlcixcbiAgQmx1ckZpbHRlclBhc3M6IGZpbHRlckJsdXIuQmx1ckZpbHRlclBhc3MsXG4gIENvbG9yTWF0cml4RmlsdGVyOiBmaWx0ZXJDb2xvck1hdHJpeC5Db2xvck1hdHJpeEZpbHRlcixcbiAgRGlzcGxhY2VtZW50RmlsdGVyOiBmaWx0ZXJEaXNwbGFjZW1lbnQuRGlzcGxhY2VtZW50RmlsdGVyLFxuICBGWEFBRmlsdGVyOiBmaWx0ZXJGeGFhLkZYQUFGaWx0ZXIsXG4gIE5vaXNlRmlsdGVyOiBmaWx0ZXJOb2lzZS5Ob2lzZUZpbHRlclxufTtcbk9iamVjdC5lbnRyaWVzKGZpbHRlcnMpLmZvckVhY2goKFtrZXksIEZpbHRlckNsYXNzXSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmlsdGVycywga2V5LCB7XG4gICAgZ2V0KCkge1xuICAgICAgY29yZS51dGlscy5kZXByZWNhdGlvbihcIjcuMS4wXCIsIGBmaWx0ZXJzLiR7a2V5fSBoYXMgbW92ZWQgdG8gJHtrZXl9YCk7XG4gICAgICByZXR1cm4gRmlsdGVyQ2xhc3M7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5leHBvcnRzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVycy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxucmVxdWlyZSgnQHBpeGkvbWl4aW4tY2FjaGUtYXMtYml0bWFwJyk7XG5yZXF1aXJlKCdAcGl4aS9taXhpbi1nZXQtY2hpbGQtYnktbmFtZScpO1xucmVxdWlyZSgnQHBpeGkvbWl4aW4tZ2V0LWdsb2JhbC1wb3NpdGlvbicpO1xudmFyIGZpbHRlcnMgPSByZXF1aXJlKCcuL2ZpbHRlcnMuanMnKTtcbnZhciBhY2Nlc3NpYmlsaXR5ID0gcmVxdWlyZSgnQHBpeGkvYWNjZXNzaWJpbGl0eScpO1xudmFyIGFwcCA9IHJlcXVpcmUoJ0BwaXhpL2FwcCcpO1xudmFyIGFzc2V0cyA9IHJlcXVpcmUoJ0BwaXhpL2Fzc2V0cycpO1xudmFyIGNvbXByZXNzZWRUZXh0dXJlcyA9IHJlcXVpcmUoJ0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xudmFyIGRpc3BsYXkgPSByZXF1aXJlKCdAcGl4aS9kaXNwbGF5Jyk7XG52YXIgZXZlbnRzID0gcmVxdWlyZSgnQHBpeGkvZXZlbnRzJyk7XG52YXIgZXh0cmFjdCA9IHJlcXVpcmUoJ0BwaXhpL2V4dHJhY3QnKTtcbnZhciBmaWx0ZXJBbHBoYSA9IHJlcXVpcmUoJ0BwaXhpL2ZpbHRlci1hbHBoYScpO1xudmFyIGZpbHRlckJsdXIgPSByZXF1aXJlKCdAcGl4aS9maWx0ZXItYmx1cicpO1xudmFyIGZpbHRlckNvbG9yTWF0cml4ID0gcmVxdWlyZSgnQHBpeGkvZmlsdGVyLWNvbG9yLW1hdHJpeCcpO1xudmFyIGZpbHRlckRpc3BsYWNlbWVudCA9IHJlcXVpcmUoJ0BwaXhpL2ZpbHRlci1kaXNwbGFjZW1lbnQnKTtcbnZhciBmaWx0ZXJGeGFhID0gcmVxdWlyZSgnQHBpeGkvZmlsdGVyLWZ4YWEnKTtcbnZhciBmaWx0ZXJOb2lzZSA9IHJlcXVpcmUoJ0BwaXhpL2ZpbHRlci1ub2lzZScpO1xudmFyIGdyYXBoaWNzID0gcmVxdWlyZSgnQHBpeGkvZ3JhcGhpY3MnKTtcbnZhciBtZXNoID0gcmVxdWlyZSgnQHBpeGkvbWVzaCcpO1xudmFyIG1lc2hFeHRyYXMgPSByZXF1aXJlKCdAcGl4aS9tZXNoLWV4dHJhcycpO1xudmFyIHBhcnRpY2xlQ29udGFpbmVyID0gcmVxdWlyZSgnQHBpeGkvcGFydGljbGUtY29udGFpbmVyJyk7XG52YXIgcHJlcGFyZSA9IHJlcXVpcmUoJ0BwaXhpL3ByZXBhcmUnKTtcbnZhciBzcHJpdGUgPSByZXF1aXJlKCdAcGl4aS9zcHJpdGUnKTtcbnZhciBzcHJpdGVBbmltYXRlZCA9IHJlcXVpcmUoJ0BwaXhpL3Nwcml0ZS1hbmltYXRlZCcpO1xudmFyIHNwcml0ZVRpbGluZyA9IHJlcXVpcmUoJ0BwaXhpL3Nwcml0ZS10aWxpbmcnKTtcbnZhciBzcHJpdGVzaGVldCA9IHJlcXVpcmUoJ0BwaXhpL3Nwcml0ZXNoZWV0Jyk7XG52YXIgdGV4dCA9IHJlcXVpcmUoJ0BwaXhpL3RleHQnKTtcbnZhciB0ZXh0Qml0bWFwID0gcmVxdWlyZSgnQHBpeGkvdGV4dC1iaXRtYXAnKTtcbnZhciB0ZXh0SHRtbCA9IHJlcXVpcmUoJ0BwaXhpL3RleHQtaHRtbCcpO1xuXG5cblxuZXhwb3J0cy5maWx0ZXJzID0gZmlsdGVycy5maWx0ZXJzO1xuT2JqZWN0LmtleXMoYWNjZXNzaWJpbGl0eSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhY2Nlc3NpYmlsaXR5W2tdOyB9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhhcHApLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShrKSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXBwW2tdOyB9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhhc3NldHMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShrKSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXNzZXRzW2tdOyB9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhjb21wcmVzc2VkVGV4dHVyZXMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShrKSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcHJlc3NlZFRleHR1cmVzW2tdOyB9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhjb3JlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkoaykpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmVba107IH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGRpc3BsYXkpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShrKSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGxheVtrXTsgfVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkoaykpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV2ZW50c1trXTsgfVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZXh0cmFjdCkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleHRyYWN0W2tdOyB9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhmaWx0ZXJBbHBoYSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJBbHBoYVtrXTsgfVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZmlsdGVyQmx1cikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJCbHVyW2tdOyB9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhmaWx0ZXJDb2xvck1hdHJpeCkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJDb2xvck1hdHJpeFtrXTsgfVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZmlsdGVyRGlzcGxhY2VtZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkoaykpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZpbHRlckRpc3BsYWNlbWVudFtrXTsgfVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZmlsdGVyRnhhYSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJGeGFhW2tdOyB9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhmaWx0ZXJOb2lzZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJOb2lzZVtrXTsgfVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZ3JhcGhpY3MpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShrKSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ3JhcGhpY3Nba107IH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKG1lc2gpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShrKSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzaFtrXTsgfVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMobWVzaEV4dHJhcykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNoRXh0cmFzW2tdOyB9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhwYXJ0aWNsZUNvbnRhaW5lcikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJ0aWNsZUNvbnRhaW5lcltrXTsgfVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMocHJlcGFyZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcmVwYXJlW2tdOyB9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhzcHJpdGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShrKSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ByaXRlW2tdOyB9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhzcHJpdGVBbmltYXRlZCkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzcHJpdGVBbmltYXRlZFtrXTsgfVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoc3ByaXRlVGlsaW5nKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkoaykpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNwcml0ZVRpbGluZ1trXTsgfVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoc3ByaXRlc2hlZXQpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShrKSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ByaXRlc2hlZXRba107IH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKHRleHQpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShrKSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGV4dFtrXTsgfVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXModGV4dEJpdG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0ZXh0Qml0bWFwW2tdOyB9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyh0ZXh0SHRtbCkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0ZXh0SHRtbFtrXTsgfVxuXHR9KTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xudmFyIGRpc3BsYXkgPSByZXF1aXJlKCdAcGl4aS9kaXNwbGF5Jyk7XG52YXIgZXZlbnRzID0gcmVxdWlyZSgnQHBpeGkvZXZlbnRzJyk7XG52YXIgYWNjZXNzaWJsZVRhcmdldCA9IHJlcXVpcmUoJy4vYWNjZXNzaWJsZVRhcmdldC5qcycpO1xuXG5kaXNwbGF5LkRpc3BsYXlPYmplY3QubWl4aW4oYWNjZXNzaWJsZVRhcmdldC5hY2Nlc3NpYmxlVGFyZ2V0KTtcbmNvbnN0IEtFWV9DT0RFX1RBQiA9IDk7XG5jb25zdCBESVZfVE9VQ0hfU0laRSA9IDEwMDtcbmNvbnN0IERJVl9UT1VDSF9QT1NfWCA9IDA7XG5jb25zdCBESVZfVE9VQ0hfUE9TX1kgPSAwO1xuY29uc3QgRElWX1RPVUNIX1pJTkRFWCA9IDI7XG5jb25zdCBESVZfSE9PS19TSVpFID0gMTtcbmNvbnN0IERJVl9IT09LX1BPU19YID0gLTFlMztcbmNvbnN0IERJVl9IT09LX1BPU19ZID0gLTFlMztcbmNvbnN0IERJVl9IT09LX1pJTkRFWCA9IDI7XG5jbGFzcyBBY2Nlc3NpYmlsaXR5TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5kZWJ1ZyA9IGZhbHNlO1xuICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5faXNNb2JpbGVBY2Nlc3NpYmlsaXR5ID0gZmFsc2U7XG4gICAgdGhpcy5wb29sID0gW107XG4gICAgdGhpcy5yZW5kZXJJZCA9IDA7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuYW5kcm9pZFVwZGF0ZUNvdW50ID0gMDtcbiAgICB0aGlzLmFuZHJvaWRVcGRhdGVGcmVxdWVuY3kgPSA1MDA7XG4gICAgdGhpcy5faG9va0RpdiA9IG51bGw7XG4gICAgaWYgKGNvcmUudXRpbHMuaXNNb2JpbGUudGFibGV0IHx8IGNvcmUudXRpbHMuaXNNb2JpbGUucGhvbmUpIHtcbiAgICAgIHRoaXMuY3JlYXRlVG91Y2hIb29rKCk7XG4gICAgfVxuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LnN0eWxlLndpZHRoID0gYCR7RElWX1RPVUNIX1NJWkV9cHhgO1xuICAgIGRpdi5zdHlsZS5oZWlnaHQgPSBgJHtESVZfVE9VQ0hfU0laRX1weGA7XG4gICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIGRpdi5zdHlsZS50b3AgPSBgJHtESVZfVE9VQ0hfUE9TX1h9cHhgO1xuICAgIGRpdi5zdHlsZS5sZWZ0ID0gYCR7RElWX1RPVUNIX1BPU19ZfXB4YDtcbiAgICBkaXYuc3R5bGUuekluZGV4ID0gRElWX1RPVUNIX1pJTkRFWC50b1N0cmluZygpO1xuICAgIHRoaXMuZGl2ID0gZGl2O1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLl9vbktleURvd24gPSB0aGlzLl9vbktleURvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbk1vdXNlTW92ZSA9IHRoaXMuX29uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9vbktleURvd24sIGZhbHNlKTtcbiAgfVxuICBnZXQgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzQWN0aXZlO1xuICB9XG4gIGdldCBpc01vYmlsZUFjY2Vzc2liaWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzTW9iaWxlQWNjZXNzaWJpbGl0eTtcbiAgfVxuICBjcmVhdGVUb3VjaEhvb2soKSB7XG4gICAgY29uc3QgaG9va0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgaG9va0Rpdi5zdHlsZS53aWR0aCA9IGAke0RJVl9IT09LX1NJWkV9cHhgO1xuICAgIGhvb2tEaXYuc3R5bGUuaGVpZ2h0ID0gYCR7RElWX0hPT0tfU0laRX1weGA7XG4gICAgaG9va0Rpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBob29rRGl2LnN0eWxlLnRvcCA9IGAke0RJVl9IT09LX1BPU19YfXB4YDtcbiAgICBob29rRGl2LnN0eWxlLmxlZnQgPSBgJHtESVZfSE9PS19QT1NfWX1weGA7XG4gICAgaG9va0Rpdi5zdHlsZS56SW5kZXggPSBESVZfSE9PS19aSU5ERVgudG9TdHJpbmcoKTtcbiAgICBob29rRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiI0ZGMDAwMFwiO1xuICAgIGhvb2tEaXYudGl0bGUgPSBcInNlbGVjdCB0byBlbmFibGUgYWNjZXNzaWJpbGl0eSBmb3IgdGhpcyBjb250ZW50XCI7XG4gICAgaG9va0Rpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5faXNNb2JpbGVBY2Nlc3NpYmlsaXR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgIHRoaXMuZGVzdHJveVRvdWNoSG9vaygpO1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaG9va0Rpdik7XG4gICAgdGhpcy5faG9va0RpdiA9IGhvb2tEaXY7XG4gIH1cbiAgZGVzdHJveVRvdWNoSG9vaygpIHtcbiAgICBpZiAoIXRoaXMuX2hvb2tEaXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLl9ob29rRGl2KTtcbiAgICB0aGlzLl9ob29rRGl2ID0gbnVsbDtcbiAgfVxuICBhY3RpdmF0ZSgpIHtcbiAgICBpZiAodGhpcy5faXNBY3RpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faXNBY3RpdmUgPSB0cnVlO1xuICAgIGdsb2JhbFRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZSwgdHJ1ZSk7XG4gICAgZ2xvYmFsVGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9vbktleURvd24sIGZhbHNlKTtcbiAgICB0aGlzLnJlbmRlcmVyLm9uKFwicG9zdHJlbmRlclwiLCB0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgdGhpcy5yZW5kZXJlci52aWV3LnBhcmVudE5vZGU/LmFwcGVuZENoaWxkKHRoaXMuZGl2KTtcbiAgfVxuICBkZWFjdGl2YXRlKCkge1xuICAgIGlmICghdGhpcy5faXNBY3RpdmUgfHwgdGhpcy5faXNNb2JpbGVBY2Nlc3NpYmlsaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2U7XG4gICAgZ2xvYmFsVGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW91c2VNb3ZlLCB0cnVlKTtcbiAgICBnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xuICAgIHRoaXMucmVuZGVyZXIub2ZmKFwicG9zdHJlbmRlclwiLCB0aGlzLnVwZGF0ZSk7XG4gICAgdGhpcy5kaXYucGFyZW50Tm9kZT8ucmVtb3ZlQ2hpbGQodGhpcy5kaXYpO1xuICB9XG4gIHVwZGF0ZUFjY2Vzc2libGVPYmplY3RzKGRpc3BsYXlPYmplY3QpIHtcbiAgICBpZiAoIWRpc3BsYXlPYmplY3QudmlzaWJsZSB8fCAhZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlQ2hpbGRyZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZSAmJiBkaXNwbGF5T2JqZWN0LmlzSW50ZXJhY3RpdmUoKSkge1xuICAgICAgaWYgKCFkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlQWN0aXZlKSB7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQoZGlzcGxheU9iamVjdCk7XG4gICAgICB9XG4gICAgICBkaXNwbGF5T2JqZWN0LnJlbmRlcklkID0gdGhpcy5yZW5kZXJJZDtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnVwZGF0ZUFjY2Vzc2libGVPYmplY3RzKGNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGlmIChjb3JlLnV0aWxzLmlzTW9iaWxlLmFuZHJvaWQuZGV2aWNlICYmIG5vdyA8IHRoaXMuYW5kcm9pZFVwZGF0ZUNvdW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYW5kcm9pZFVwZGF0ZUNvdW50ID0gbm93ICsgdGhpcy5hbmRyb2lkVXBkYXRlRnJlcXVlbmN5O1xuICAgIGlmICghdGhpcy5yZW5kZXJlci5yZW5kZXJpbmdUb1NjcmVlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZW5kZXJlci5sYXN0T2JqZWN0UmVuZGVyZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlQWNjZXNzaWJsZU9iamVjdHModGhpcy5yZW5kZXJlci5sYXN0T2JqZWN0UmVuZGVyZWQpO1xuICAgIH1cbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMucmVuZGVyZXIudmlldy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB7IHdpZHRoOiB2aWV3V2lkdGgsIGhlaWdodDogdmlld0hlaWdodCwgcmVzb2x1dGlvbiB9ID0gdGhpcy5yZW5kZXJlcjtcbiAgICBjb25zdCBzeCA9IHdpZHRoIC8gdmlld1dpZHRoICogcmVzb2x1dGlvbjtcbiAgICBjb25zdCBzeSA9IGhlaWdodCAvIHZpZXdIZWlnaHQgKiByZXNvbHV0aW9uO1xuICAgIGxldCBkaXYgPSB0aGlzLmRpdjtcbiAgICBkaXYuc3R5bGUubGVmdCA9IGAke3h9cHhgO1xuICAgIGRpdi5zdHlsZS50b3AgPSBgJHt5fXB4YDtcbiAgICBkaXYuc3R5bGUud2lkdGggPSBgJHt2aWV3V2lkdGh9cHhgO1xuICAgIGRpdi5zdHlsZS5oZWlnaHQgPSBgJHt2aWV3SGVpZ2h0fXB4YDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaGlsZC5yZW5kZXJJZCAhPT0gdGhpcy5yZW5kZXJJZCkge1xuICAgICAgICBjaGlsZC5fYWNjZXNzaWJsZUFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBjb3JlLnV0aWxzLnJlbW92ZUl0ZW1zKHRoaXMuY2hpbGRyZW4sIGksIDEpO1xuICAgICAgICB0aGlzLmRpdi5yZW1vdmVDaGlsZChjaGlsZC5fYWNjZXNzaWJsZURpdik7XG4gICAgICAgIHRoaXMucG9vbC5wdXNoKGNoaWxkLl9hY2Nlc3NpYmxlRGl2KTtcbiAgICAgICAgY2hpbGQuX2FjY2Vzc2libGVEaXYgPSBudWxsO1xuICAgICAgICBpLS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXYgPSBjaGlsZC5fYWNjZXNzaWJsZURpdjtcbiAgICAgICAgbGV0IGhpdEFyZWEgPSBjaGlsZC5oaXRBcmVhO1xuICAgICAgICBjb25zdCB3dCA9IGNoaWxkLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICBpZiAoY2hpbGQuaGl0QXJlYSkge1xuICAgICAgICAgIGRpdi5zdHlsZS5sZWZ0ID0gYCR7KHd0LnR4ICsgaGl0QXJlYS54ICogd3QuYSkgKiBzeH1weGA7XG4gICAgICAgICAgZGl2LnN0eWxlLnRvcCA9IGAkeyh3dC50eSArIGhpdEFyZWEueSAqIHd0LmQpICogc3l9cHhgO1xuICAgICAgICAgIGRpdi5zdHlsZS53aWR0aCA9IGAke2hpdEFyZWEud2lkdGggKiB3dC5hICogc3h9cHhgO1xuICAgICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSBgJHtoaXRBcmVhLmhlaWdodCAqIHd0LmQgKiBzeX1weGA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGl0QXJlYSA9IGNoaWxkLmdldEJvdW5kcygpO1xuICAgICAgICAgIHRoaXMuY2FwSGl0QXJlYShoaXRBcmVhKTtcbiAgICAgICAgICBkaXYuc3R5bGUubGVmdCA9IGAke2hpdEFyZWEueCAqIHN4fXB4YDtcbiAgICAgICAgICBkaXYuc3R5bGUudG9wID0gYCR7aGl0QXJlYS55ICogc3l9cHhgO1xuICAgICAgICAgIGRpdi5zdHlsZS53aWR0aCA9IGAke2hpdEFyZWEud2lkdGggKiBzeH1weGA7XG4gICAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9IGAke2hpdEFyZWEuaGVpZ2h0ICogc3l9cHhgO1xuICAgICAgICAgIGlmIChkaXYudGl0bGUgIT09IGNoaWxkLmFjY2Vzc2libGVUaXRsZSAmJiBjaGlsZC5hY2Nlc3NpYmxlVGl0bGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRpdi50aXRsZSA9IGNoaWxkLmFjY2Vzc2libGVUaXRsZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRpdi5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpICE9PSBjaGlsZC5hY2Nlc3NpYmxlSGludCAmJiBjaGlsZC5hY2Nlc3NpYmxlSGludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgY2hpbGQuYWNjZXNzaWJsZUhpbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQuYWNjZXNzaWJsZVRpdGxlICE9PSBkaXYudGl0bGUgfHwgY2hpbGQudGFiSW5kZXggIT09IGRpdi50YWJJbmRleCkge1xuICAgICAgICAgIGRpdi50aXRsZSA9IGNoaWxkLmFjY2Vzc2libGVUaXRsZTtcbiAgICAgICAgICBkaXYudGFiSW5kZXggPSBjaGlsZC50YWJJbmRleDtcbiAgICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRGVidWdIVE1MKGRpdik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZW5kZXJJZCsrO1xuICB9XG4gIHVwZGF0ZURlYnVnSFRNTChkaXYpIHtcbiAgICBkaXYuaW5uZXJIVE1MID0gYHR5cGU6ICR7ZGl2LnR5cGV9PC9icj4gdGl0bGUgOiAke2Rpdi50aXRsZX08L2JyPiB0YWJJbmRleDogJHtkaXYudGFiSW5kZXh9YDtcbiAgfVxuICBjYXBIaXRBcmVhKGhpdEFyZWEpIHtcbiAgICBpZiAoaGl0QXJlYS54IDwgMCkge1xuICAgICAgaGl0QXJlYS53aWR0aCArPSBoaXRBcmVhLng7XG4gICAgICBoaXRBcmVhLnggPSAwO1xuICAgIH1cbiAgICBpZiAoaGl0QXJlYS55IDwgMCkge1xuICAgICAgaGl0QXJlYS5oZWlnaHQgKz0gaGl0QXJlYS55O1xuICAgICAgaGl0QXJlYS55ID0gMDtcbiAgICB9XG4gICAgY29uc3QgeyB3aWR0aDogdmlld1dpZHRoLCBoZWlnaHQ6IHZpZXdIZWlnaHQgfSA9IHRoaXMucmVuZGVyZXI7XG4gICAgaWYgKGhpdEFyZWEueCArIGhpdEFyZWEud2lkdGggPiB2aWV3V2lkdGgpIHtcbiAgICAgIGhpdEFyZWEud2lkdGggPSB2aWV3V2lkdGggLSBoaXRBcmVhLng7XG4gICAgfVxuICAgIGlmIChoaXRBcmVhLnkgKyBoaXRBcmVhLmhlaWdodCA+IHZpZXdIZWlnaHQpIHtcbiAgICAgIGhpdEFyZWEuaGVpZ2h0ID0gdmlld0hlaWdodCAtIGhpdEFyZWEueTtcbiAgICB9XG4gIH1cbiAgYWRkQ2hpbGQoZGlzcGxheU9iamVjdCkge1xuICAgIGxldCBkaXYgPSB0aGlzLnBvb2wucG9wKCk7XG4gICAgaWYgKCFkaXYpIHtcbiAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICBkaXYuc3R5bGUud2lkdGggPSBgJHtESVZfVE9VQ0hfU0laRX1weGA7XG4gICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gYCR7RElWX1RPVUNIX1NJWkV9cHhgO1xuICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZGVidWcgPyBcInJnYmEoMjU1LDI1NSwyNTUsMC41KVwiIDogXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgZGl2LnN0eWxlLnpJbmRleCA9IERJVl9UT1VDSF9aSU5ERVgudG9TdHJpbmcoKTtcbiAgICAgIGRpdi5zdHlsZS5ib3JkZXJTdHlsZSA9IFwibm9uZVwiO1xuICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImNocm9tZVwiKSkge1xuICAgICAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsIFwib2ZmXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcInBvbGl0ZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9ydjouKkdlY2tvXFwvLykpIHtcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtcmVsZXZhbnRcIiwgXCJhZGRpdGlvbnNcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1yZWxldmFudFwiLCBcInRleHRcIik7XG4gICAgICB9XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKSk7XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX29uRm9jdXMuYmluZCh0aGlzKSk7XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuX29uRm9jdXNPdXQuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIGRpdi5zdHlsZS5wb2ludGVyRXZlbnRzID0gZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlUG9pbnRlckV2ZW50cztcbiAgICBkaXYudHlwZSA9IGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZVR5cGU7XG4gICAgaWYgKGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZVRpdGxlICYmIGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZVRpdGxlICE9PSBudWxsKSB7XG4gICAgICBkaXYudGl0bGUgPSBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVUaXRsZTtcbiAgICB9IGVsc2UgaWYgKCFkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVIaW50IHx8IGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZUhpbnQgPT09IG51bGwpIHtcbiAgICAgIGRpdi50aXRsZSA9IGBkaXNwbGF5T2JqZWN0ICR7ZGlzcGxheU9iamVjdC50YWJJbmRleH1gO1xuICAgIH1cbiAgICBpZiAoZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlSGludCAmJiBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVIaW50ICE9PSBudWxsKSB7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVIaW50KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICB0aGlzLnVwZGF0ZURlYnVnSFRNTChkaXYpO1xuICAgIGRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVBY3RpdmUgPSB0cnVlO1xuICAgIGRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVEaXYgPSBkaXY7XG4gICAgZGl2LmRpc3BsYXlPYmplY3QgPSBkaXNwbGF5T2JqZWN0O1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaChkaXNwbGF5T2JqZWN0KTtcbiAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZChkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlRGl2KTtcbiAgICBkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlRGl2LnRhYkluZGV4ID0gZGlzcGxheU9iamVjdC50YWJJbmRleDtcbiAgfVxuICBfZGlzcGF0Y2hFdmVudChlLCB0eXBlKSB7XG4gICAgY29uc3QgeyBkaXNwbGF5T2JqZWN0OiB0YXJnZXQgfSA9IGUudGFyZ2V0O1xuICAgIGNvbnN0IGJvdW5kcnkgPSB0aGlzLnJlbmRlcmVyLmV2ZW50cy5yb290Qm91bmRhcnk7XG4gICAgY29uc3QgZXZlbnQgPSBPYmplY3QuYXNzaWduKG5ldyBldmVudHMuRmVkZXJhdGVkRXZlbnQoYm91bmRyeSksIHsgdGFyZ2V0IH0pO1xuICAgIGJvdW5kcnkucm9vdFRhcmdldCA9IHRoaXMucmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkO1xuICAgIHR5cGUuZm9yRWFjaCgodHlwZTIpID0+IGJvdW5kcnkuZGlzcGF0Y2hFdmVudChldmVudCwgdHlwZTIpKTtcbiAgfVxuICBfb25DbGljayhlKSB7XG4gICAgdGhpcy5fZGlzcGF0Y2hFdmVudChlLCBbXCJjbGlja1wiLCBcInBvaW50ZXJ0YXBcIiwgXCJ0YXBcIl0pO1xuICB9XG4gIF9vbkZvY3VzKGUpIHtcbiAgICBpZiAoIWUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiKSkge1xuICAgICAgZS50YXJnZXQuc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsIFwiYXNzZXJ0aXZlXCIpO1xuICAgIH1cbiAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KGUsIFtcIm1vdXNlb3ZlclwiXSk7XG4gIH1cbiAgX29uRm9jdXNPdXQoZSkge1xuICAgIGlmICghZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIpKSB7XG4gICAgICBlLnRhcmdldC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIiwgXCJwb2xpdGVcIik7XG4gICAgfVxuICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnQoZSwgW1wibW91c2VvdXRcIl0pO1xuICB9XG4gIF9vbktleURvd24oZSkge1xuICAgIGlmIChlLmtleUNvZGUgIT09IEtFWV9DT0RFX1RBQikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2YXRlKCk7XG4gIH1cbiAgX29uTW91c2VNb3ZlKGUpIHtcbiAgICBpZiAoZS5tb3ZlbWVudFggPT09IDAgJiYgZS5tb3ZlbWVudFkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lUb3VjaEhvb2soKTtcbiAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgZ2xvYmFsVGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW91c2VNb3ZlLCB0cnVlKTtcbiAgICBnbG9iYWxUaGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX29uS2V5RG93bik7XG4gICAgdGhpcy5wb29sID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkcmVuID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuQWNjZXNzaWJpbGl0eU1hbmFnZXIuZXh0ZW5zaW9uID0ge1xuICBuYW1lOiBcImFjY2Vzc2liaWxpdHlcIixcbiAgdHlwZTogW1xuICAgIGNvcmUuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclBsdWdpbixcbiAgICBjb3JlLkV4dGVuc2lvblR5cGUuQ2FudmFzUmVuZGVyZXJQbHVnaW5cbiAgXVxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQoQWNjZXNzaWJpbGl0eU1hbmFnZXIpO1xuXG5leHBvcnRzLkFjY2Vzc2liaWxpdHlNYW5hZ2VyID0gQWNjZXNzaWJpbGl0eU1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BY2Nlc3NpYmlsaXR5TWFuYWdlci5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY29uc3QgYWNjZXNzaWJsZVRhcmdldCA9IHtcbiAgYWNjZXNzaWJsZTogZmFsc2UsXG4gIGFjY2Vzc2libGVUaXRsZTogbnVsbCxcbiAgYWNjZXNzaWJsZUhpbnQ6IG51bGwsXG4gIHRhYkluZGV4OiAwLFxuICBfYWNjZXNzaWJsZUFjdGl2ZTogZmFsc2UsXG4gIF9hY2Nlc3NpYmxlRGl2OiBudWxsLFxuICBhY2Nlc3NpYmxlVHlwZTogXCJidXR0b25cIixcbiAgYWNjZXNzaWJsZVBvaW50ZXJFdmVudHM6IFwiYXV0b1wiLFxuICBhY2Nlc3NpYmxlQ2hpbGRyZW46IHRydWUsXG4gIHJlbmRlcklkOiAtMVxufTtcblxuZXhwb3J0cy5hY2Nlc3NpYmxlVGFyZ2V0ID0gYWNjZXNzaWJsZVRhcmdldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY2Vzc2libGVUYXJnZXQuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBBY2Nlc3NpYmlsaXR5TWFuYWdlciA9IHJlcXVpcmUoJy4vQWNjZXNzaWJpbGl0eU1hbmFnZXIuanMnKTtcbnZhciBhY2Nlc3NpYmxlVGFyZ2V0ID0gcmVxdWlyZSgnLi9hY2Nlc3NpYmxlVGFyZ2V0LmpzJyk7XG5cblxuXG5leHBvcnRzLkFjY2Vzc2liaWxpdHlNYW5hZ2VyID0gQWNjZXNzaWJpbGl0eU1hbmFnZXIuQWNjZXNzaWJpbGl0eU1hbmFnZXI7XG5leHBvcnRzLmFjY2Vzc2libGVUYXJnZXQgPSBhY2Nlc3NpYmxlVGFyZ2V0LmFjY2Vzc2libGVUYXJnZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgZGlzcGxheSA9IHJlcXVpcmUoJ0BwaXhpL2Rpc3BsYXknKTtcblxuY29uc3QgX0FwcGxpY2F0aW9uID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5zdGFnZSA9IG5ldyBkaXNwbGF5LkNvbnRhaW5lcigpO1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGZvcmNlQ2FudmFzOiBmYWxzZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHRoaXMucmVuZGVyZXIgPSBjb3JlLmF1dG9EZXRlY3RSZW5kZXJlcihvcHRpb25zKTtcbiAgICBfQXBwbGljYXRpb24uX3BsdWdpbnMuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICBwbHVnaW4uaW5pdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnN0YWdlKTtcbiAgfVxuICBnZXQgdmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlci52aWV3O1xuICB9XG4gIGdldCBzY3JlZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuc2NyZWVuO1xuICB9XG4gIGRlc3Ryb3kocmVtb3ZlVmlldywgc3RhZ2VPcHRpb25zKSB7XG4gICAgY29uc3QgcGx1Z2lucyA9IF9BcHBsaWNhdGlvbi5fcGx1Z2lucy5zbGljZSgwKTtcbiAgICBwbHVnaW5zLnJldmVyc2UoKTtcbiAgICBwbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgICAgcGx1Z2luLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9KTtcbiAgICB0aGlzLnN0YWdlLmRlc3Ryb3koc3RhZ2VPcHRpb25zKTtcbiAgICB0aGlzLnN0YWdlID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlcmVyLmRlc3Ryb3kocmVtb3ZlVmlldyk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn07XG5sZXQgQXBwbGljYXRpb24gPSBfQXBwbGljYXRpb247XG5BcHBsaWNhdGlvbi5fcGx1Z2lucyA9IFtdO1xuY29yZS5leHRlbnNpb25zLmhhbmRsZUJ5TGlzdChjb3JlLkV4dGVuc2lvblR5cGUuQXBwbGljYXRpb24sIEFwcGxpY2F0aW9uLl9wbHVnaW5zKTtcblxuZXhwb3J0cy5BcHBsaWNhdGlvbiA9IEFwcGxpY2F0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBwbGljYXRpb24uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xuXG5jbGFzcyBSZXNpemVQbHVnaW4ge1xuICBzdGF0aWMgaW5pdChvcHRpb25zKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzaXplVG9cIiwge1xuICAgICAgc2V0KGRvbSkge1xuICAgICAgICBnbG9iYWxUaGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5xdWV1ZVJlc2l6ZSk7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVRvID0gZG9tO1xuICAgICAgICBpZiAoZG9tKSB7XG4gICAgICAgICAgZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMucXVldWVSZXNpemUpO1xuICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNpemVUbztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnF1ZXVlUmVzaXplID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9yZXNpemVUbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmNhbmNlbFJlc2l6ZSgpO1xuICAgICAgdGhpcy5fcmVzaXplSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5yZXNpemUoKSk7XG4gICAgfTtcbiAgICB0aGlzLmNhbmNlbFJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9yZXNpemVJZCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yZXNpemVJZCk7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZUlkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVzaXplID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9yZXNpemVUbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmNhbmNlbFJlc2l6ZSgpO1xuICAgICAgbGV0IHdpZHRoO1xuICAgICAgbGV0IGhlaWdodDtcbiAgICAgIGlmICh0aGlzLl9yZXNpemVUbyA9PT0gZ2xvYmFsVGhpcy53aW5kb3cpIHtcbiAgICAgICAgd2lkdGggPSBnbG9iYWxUaGlzLmlubmVyV2lkdGg7XG4gICAgICAgIGhlaWdodCA9IGdsb2JhbFRoaXMuaW5uZXJIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IGNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQgfSA9IHRoaXMuX3Jlc2l6ZVRvO1xuICAgICAgICB3aWR0aCA9IGNsaWVudFdpZHRoO1xuICAgICAgICBoZWlnaHQgPSBjbGllbnRIZWlnaHQ7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfTtcbiAgICB0aGlzLl9yZXNpemVJZCA9IG51bGw7XG4gICAgdGhpcy5fcmVzaXplVG8gPSBudWxsO1xuICAgIHRoaXMucmVzaXplVG8gPSBvcHRpb25zLnJlc2l6ZVRvIHx8IG51bGw7XG4gIH1cbiAgc3RhdGljIGRlc3Ryb3koKSB7XG4gICAgZ2xvYmFsVGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMucXVldWVSZXNpemUpO1xuICAgIHRoaXMuY2FuY2VsUmVzaXplKCk7XG4gICAgdGhpcy5jYW5jZWxSZXNpemUgPSBudWxsO1xuICAgIHRoaXMucXVldWVSZXNpemUgPSBudWxsO1xuICAgIHRoaXMucmVzaXplVG8gPSBudWxsO1xuICAgIHRoaXMucmVzaXplID0gbnVsbDtcbiAgfVxufVxuUmVzaXplUGx1Z2luLmV4dGVuc2lvbiA9IGNvcmUuRXh0ZW5zaW9uVHlwZS5BcHBsaWNhdGlvbjtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQoUmVzaXplUGx1Z2luKTtcblxuZXhwb3J0cy5SZXNpemVQbHVnaW4gPSBSZXNpemVQbHVnaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXNpemVQbHVnaW4uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBBcHBsaWNhdGlvbiA9IHJlcXVpcmUoJy4vQXBwbGljYXRpb24uanMnKTtcbnZhciBSZXNpemVQbHVnaW4gPSByZXF1aXJlKCcuL1Jlc2l6ZVBsdWdpbi5qcycpO1xuXG5cblxuZXhwb3J0cy5BcHBsaWNhdGlvbiA9IEFwcGxpY2F0aW9uLkFwcGxpY2F0aW9uO1xuZXhwb3J0cy5SZXNpemVQbHVnaW4gPSBSZXNpemVQbHVnaW4uUmVzaXplUGx1Z2luO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xuXG5jb25zdCBhc3NldEtleU1hcCA9IHtcbiAgbG9hZGVyOiBjb3JlLkV4dGVuc2lvblR5cGUuTG9hZFBhcnNlcixcbiAgcmVzb2x2ZXI6IGNvcmUuRXh0ZW5zaW9uVHlwZS5SZXNvbHZlUGFyc2VyLFxuICBjYWNoZTogY29yZS5FeHRlbnNpb25UeXBlLkNhY2hlUGFyc2VyLFxuICBkZXRlY3Rpb246IGNvcmUuRXh0ZW5zaW9uVHlwZS5EZXRlY3Rpb25QYXJzZXJcbn07XG5jb3JlLmV4dGVuc2lvbnMuaGFuZGxlKGNvcmUuRXh0ZW5zaW9uVHlwZS5Bc3NldCwgKGV4dGVuc2lvbikgPT4ge1xuICBjb25zdCByZWYgPSBleHRlbnNpb24ucmVmO1xuICBPYmplY3QuZW50cmllcyhhc3NldEtleU1hcCkuZmlsdGVyKChba2V5XSkgPT4gISFyZWZba2V5XSkuZm9yRWFjaCgoW2tleSwgdHlwZV0pID0+IGNvcmUuZXh0ZW5zaW9ucy5hZGQoT2JqZWN0LmFzc2lnbihyZWZba2V5XSwgeyBleHRlbnNpb246IHJlZltrZXldLmV4dGVuc2lvbiA/PyB0eXBlIH0pKSk7XG59LCAoZXh0ZW5zaW9uKSA9PiB7XG4gIGNvbnN0IHJlZiA9IGV4dGVuc2lvbi5yZWY7XG4gIE9iamVjdC5rZXlzKGFzc2V0S2V5TWFwKS5maWx0ZXIoKGtleSkgPT4gISFyZWZba2V5XSkuZm9yRWFjaCgoa2V5KSA9PiBjb3JlLmV4dGVuc2lvbnMucmVtb3ZlKHJlZltrZXldKSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzc2V0RXh0ZW5zaW9uLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBCYWNrZ3JvdW5kTG9hZGVyID0gcmVxdWlyZSgnLi9CYWNrZ3JvdW5kTG9hZGVyLmpzJyk7XG52YXIgQ2FjaGUgPSByZXF1aXJlKCcuL2NhY2hlL0NhY2hlLmpzJyk7XG52YXIgTG9hZGVyID0gcmVxdWlyZSgnLi9sb2FkZXIvTG9hZGVyLmpzJyk7XG5yZXF1aXJlKCcuL2xvYWRlci9wYXJzZXJzL2luZGV4LmpzJyk7XG52YXIgUmVzb2x2ZXIgPSByZXF1aXJlKCcuL3Jlc29sdmVyL1Jlc29sdmVyLmpzJyk7XG52YXIgY29udmVydFRvTGlzdCA9IHJlcXVpcmUoJy4vdXRpbHMvY29udmVydFRvTGlzdC5qcycpO1xudmFyIGlzU2luZ2xlSXRlbSA9IHJlcXVpcmUoJy4vdXRpbHMvaXNTaW5nbGVJdGVtLmpzJyk7XG52YXIgbG9hZFRleHR1cmVzID0gcmVxdWlyZSgnLi9sb2FkZXIvcGFyc2Vycy90ZXh0dXJlcy9sb2FkVGV4dHVyZXMuanMnKTtcblxuY2xhc3MgQXNzZXRzQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9kZXRlY3Rpb25zID0gW107XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlc29sdmVyID0gbmV3IFJlc29sdmVyLlJlc29sdmVyKCk7XG4gICAgdGhpcy5sb2FkZXIgPSBuZXcgTG9hZGVyLkxvYWRlcigpO1xuICAgIHRoaXMuY2FjaGUgPSBDYWNoZS5DYWNoZTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kTG9hZGVyID0gbmV3IEJhY2tncm91bmRMb2FkZXIuQmFja2dyb3VuZExvYWRlcih0aGlzLmxvYWRlcik7XG4gICAgdGhpcy5fYmFja2dyb3VuZExvYWRlci5hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuICBhc3luYyBpbml0KG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgY29uc29sZS53YXJuKFwiW0Fzc2V0c11Bc3NldE1hbmFnZXIgYWxyZWFkeSBpbml0aWFsaXplZCwgZGlkIHlvdSBsb2FkIGJlZm9yZSBjYWxsaW5nIHRoaXMgQXNzZXQuaW5pdCgpP1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIGlmIChvcHRpb25zLmRlZmF1bHRTZWFyY2hQYXJhbXMpIHtcbiAgICAgIHRoaXMucmVzb2x2ZXIuc2V0RGVmYXVsdFNlYXJjaFBhcmFtcyhvcHRpb25zLmRlZmF1bHRTZWFyY2hQYXJhbXMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5iYXNlUGF0aCkge1xuICAgICAgdGhpcy5yZXNvbHZlci5iYXNlUGF0aCA9IG9wdGlvbnMuYmFzZVBhdGg7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmJ1bmRsZUlkZW50aWZpZXIpIHtcbiAgICAgIHRoaXMucmVzb2x2ZXIuc2V0QnVuZGxlSWRlbnRpZmllcihvcHRpb25zLmJ1bmRsZUlkZW50aWZpZXIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5tYW5pZmVzdCkge1xuICAgICAgbGV0IG1hbmlmZXN0ID0gb3B0aW9ucy5tYW5pZmVzdDtcbiAgICAgIGlmICh0eXBlb2YgbWFuaWZlc3QgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWFuaWZlc3QgPSBhd2FpdCB0aGlzLmxvYWQobWFuaWZlc3QpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNvbHZlci5hZGRNYW5pZmVzdChtYW5pZmVzdCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdXRpb25QcmVmID0gb3B0aW9ucy50ZXh0dXJlUHJlZmVyZW5jZT8ucmVzb2x1dGlvbiA/PyAxO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0eXBlb2YgcmVzb2x1dGlvblByZWYgPT09IFwibnVtYmVyXCIgPyBbcmVzb2x1dGlvblByZWZdIDogcmVzb2x1dGlvblByZWY7XG4gICAgbGV0IGZvcm1hdHMgPSBbXTtcbiAgICBpZiAob3B0aW9ucy50ZXh0dXJlUHJlZmVyZW5jZT8uZm9ybWF0KSB7XG4gICAgICBjb25zdCBmb3JtYXRQcmVmID0gb3B0aW9ucy50ZXh0dXJlUHJlZmVyZW5jZT8uZm9ybWF0O1xuICAgICAgZm9ybWF0cyA9IHR5cGVvZiBmb3JtYXRQcmVmID09PSBcInN0cmluZ1wiID8gW2Zvcm1hdFByZWZdIDogZm9ybWF0UHJlZjtcbiAgICAgIGZvciAoY29uc3QgZGV0ZWN0aW9uIG9mIHRoaXMuX2RldGVjdGlvbnMpIHtcbiAgICAgICAgaWYgKCFhd2FpdCBkZXRlY3Rpb24udGVzdCgpKSB7XG4gICAgICAgICAgZm9ybWF0cyA9IGF3YWl0IGRldGVjdGlvbi5yZW1vdmUoZm9ybWF0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBkZXRlY3Rpb24gb2YgdGhpcy5fZGV0ZWN0aW9ucykge1xuICAgICAgICBpZiAoYXdhaXQgZGV0ZWN0aW9uLnRlc3QoKSkge1xuICAgICAgICAgIGZvcm1hdHMgPSBhd2FpdCBkZXRlY3Rpb24uYWRkKGZvcm1hdHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVzb2x2ZXIucHJlZmVyKHtcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBmb3JtYXQ6IGZvcm1hdHMsXG4gICAgICAgIHJlc29sdXRpb25cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucy5wcmVmZXJlbmNlcykge1xuICAgICAgdGhpcy5zZXRQcmVmZXJlbmNlcyhvcHRpb25zLnByZWZlcmVuY2VzKTtcbiAgICB9XG4gIH1cbiAgYWRkKGtleXNJbiwgYXNzZXRzSW4sIGRhdGEpIHtcbiAgICB0aGlzLnJlc29sdmVyLmFkZChrZXlzSW4sIGFzc2V0c0luLCBkYXRhKTtcbiAgfVxuICBhc3luYyBsb2FkKHVybHMsIG9uUHJvZ3Jlc3MpIHtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgY29uc3Qgc2luZ2xlQXNzZXQgPSBpc1NpbmdsZUl0ZW0uaXNTaW5nbGVJdGVtKHVybHMpO1xuICAgIGNvbnN0IHVybEFycmF5ID0gY29udmVydFRvTGlzdC5jb252ZXJ0VG9MaXN0KHVybHMpLm1hcCgodXJsKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aGlzLnJlc29sdmVyLmFkZCh1cmwuc3JjLCB1cmwpO1xuICAgICAgICByZXR1cm4gdXJsLnNyYztcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5yZXNvbHZlci5oYXNLZXkodXJsKSkge1xuICAgICAgICB0aGlzLnJlc29sdmVyLmFkZCh1cmwsIHVybCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXJsO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc29sdmVSZXN1bHRzID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlKHVybEFycmF5KTtcbiAgICBjb25zdCBvdXQgPSBhd2FpdCB0aGlzLl9tYXBMb2FkVG9SZXNvbHZlKHJlc29sdmVSZXN1bHRzLCBvblByb2dyZXNzKTtcbiAgICByZXR1cm4gc2luZ2xlQXNzZXQgPyBvdXRbdXJsQXJyYXlbMF1dIDogb3V0O1xuICB9XG4gIGFkZEJ1bmRsZShidW5kbGVJZCwgYXNzZXRzKSB7XG4gICAgdGhpcy5yZXNvbHZlci5hZGRCdW5kbGUoYnVuZGxlSWQsIGFzc2V0cyk7XG4gIH1cbiAgYXN5bmMgbG9hZEJ1bmRsZShidW5kbGVJZHMsIG9uUHJvZ3Jlc3MpIHtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgbGV0IHNpbmdsZUFzc2V0ID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBidW5kbGVJZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHNpbmdsZUFzc2V0ID0gdHJ1ZTtcbiAgICAgIGJ1bmRsZUlkcyA9IFtidW5kbGVJZHNdO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlUmVzdWx0cyA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZUJ1bmRsZShidW5kbGVJZHMpO1xuICAgIGNvbnN0IG91dCA9IHt9O1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhyZXNvbHZlUmVzdWx0cyk7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGNvbnN0IF9vblByb2dyZXNzID0gKCkgPT4ge1xuICAgICAgb25Qcm9ncmVzcz8uKCsrY291bnQgLyB0b3RhbCk7XG4gICAgfTtcbiAgICBjb25zdCBwcm9taXNlcyA9IGtleXMubWFwKChidW5kbGVJZCkgPT4ge1xuICAgICAgY29uc3QgcmVzb2x2ZVJlc3VsdCA9IHJlc29sdmVSZXN1bHRzW2J1bmRsZUlkXTtcbiAgICAgIHRvdGFsICs9IE9iamVjdC5rZXlzKHJlc29sdmVSZXN1bHQpLmxlbmd0aDtcbiAgICAgIHJldHVybiB0aGlzLl9tYXBMb2FkVG9SZXNvbHZlKHJlc29sdmVSZXN1bHQsIF9vblByb2dyZXNzKS50aGVuKChyZXNvbHZlUmVzdWx0MikgPT4ge1xuICAgICAgICBvdXRbYnVuZGxlSWRdID0gcmVzb2x2ZVJlc3VsdDI7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgcmV0dXJuIHNpbmdsZUFzc2V0ID8gb3V0W2J1bmRsZUlkc1swXV0gOiBvdXQ7XG4gIH1cbiAgYXN5bmMgYmFja2dyb3VuZExvYWQodXJscykge1xuICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHVybHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHVybHMgPSBbdXJsc107XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVSZXN1bHRzID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlKHVybHMpO1xuICAgIHRoaXMuX2JhY2tncm91bmRMb2FkZXIuYWRkKE9iamVjdC52YWx1ZXMocmVzb2x2ZVJlc3VsdHMpKTtcbiAgfVxuICBhc3luYyBiYWNrZ3JvdW5kTG9hZEJ1bmRsZShidW5kbGVJZHMpIHtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBidW5kbGVJZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGJ1bmRsZUlkcyA9IFtidW5kbGVJZHNdO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlUmVzdWx0cyA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZUJ1bmRsZShidW5kbGVJZHMpO1xuICAgIE9iamVjdC52YWx1ZXMocmVzb2x2ZVJlc3VsdHMpLmZvckVhY2goKHJlc29sdmVSZXN1bHQpID0+IHtcbiAgICAgIHRoaXMuX2JhY2tncm91bmRMb2FkZXIuYWRkKE9iamVjdC52YWx1ZXMocmVzb2x2ZVJlc3VsdCkpO1xuICAgIH0pO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMucmVzb2x2ZXIucmVzZXQoKTtcbiAgICB0aGlzLmxvYWRlci5yZXNldCgpO1xuICAgIHRoaXMuY2FjaGUucmVzZXQoKTtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICB9XG4gIGdldChrZXlzKSB7XG4gICAgaWYgKHR5cGVvZiBrZXlzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gQ2FjaGUuQ2FjaGUuZ2V0KGtleXMpO1xuICAgIH1cbiAgICBjb25zdCBhc3NldHMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFzc2V0c1tpXSA9IENhY2hlLkNhY2hlLmdldChrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc2V0cztcbiAgfVxuICBhc3luYyBfbWFwTG9hZFRvUmVzb2x2ZShyZXNvbHZlUmVzdWx0cywgb25Qcm9ncmVzcykge1xuICAgIGNvbnN0IHJlc29sdmVBcnJheSA9IE9iamVjdC52YWx1ZXMocmVzb2x2ZVJlc3VsdHMpO1xuICAgIGNvbnN0IHJlc29sdmVLZXlzID0gT2JqZWN0LmtleXMocmVzb2x2ZVJlc3VsdHMpO1xuICAgIHRoaXMuX2JhY2tncm91bmRMb2FkZXIuYWN0aXZlID0gZmFsc2U7XG4gICAgY29uc3QgbG9hZGVkQXNzZXRzID0gYXdhaXQgdGhpcy5sb2FkZXIubG9hZChyZXNvbHZlQXJyYXksIG9uUHJvZ3Jlc3MpO1xuICAgIHRoaXMuX2JhY2tncm91bmRMb2FkZXIuYWN0aXZlID0gdHJ1ZTtcbiAgICBjb25zdCBvdXQgPSB7fTtcbiAgICByZXNvbHZlQXJyYXkuZm9yRWFjaCgocmVzb2x2ZVJlc3VsdCwgaSkgPT4ge1xuICAgICAgY29uc3QgYXNzZXQgPSBsb2FkZWRBc3NldHNbcmVzb2x2ZVJlc3VsdC5zcmNdO1xuICAgICAgY29uc3Qga2V5cyA9IFtyZXNvbHZlUmVzdWx0LnNyY107XG4gICAgICBpZiAocmVzb2x2ZVJlc3VsdC5hbGlhcykge1xuICAgICAgICBrZXlzLnB1c2goLi4ucmVzb2x2ZVJlc3VsdC5hbGlhcyk7XG4gICAgICB9XG4gICAgICBvdXRbcmVzb2x2ZUtleXNbaV1dID0gYXNzZXQ7XG4gICAgICBDYWNoZS5DYWNoZS5zZXQoa2V5cywgYXNzZXQpO1xuICAgIH0pO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgYXN5bmMgdW5sb2FkKHVybHMpIHtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgY29uc3QgdXJsQXJyYXkgPSBjb252ZXJ0VG9MaXN0LmNvbnZlcnRUb0xpc3QodXJscykubWFwKCh1cmwpID0+IHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIgPyB1cmwuc3JjIDogdXJsKTtcbiAgICBjb25zdCByZXNvbHZlUmVzdWx0cyA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZSh1cmxBcnJheSk7XG4gICAgYXdhaXQgdGhpcy5fdW5sb2FkRnJvbVJlc29sdmVkKHJlc29sdmVSZXN1bHRzKTtcbiAgfVxuICBhc3luYyB1bmxvYWRCdW5kbGUoYnVuZGxlSWRzKSB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIGJ1bmRsZUlkcyA9IGNvbnZlcnRUb0xpc3QuY29udmVydFRvTGlzdChidW5kbGVJZHMpO1xuICAgIGNvbnN0IHJlc29sdmVSZXN1bHRzID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlQnVuZGxlKGJ1bmRsZUlkcyk7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBPYmplY3Qua2V5cyhyZXNvbHZlUmVzdWx0cykubWFwKChidW5kbGVJZCkgPT4gdGhpcy5fdW5sb2FkRnJvbVJlc29sdmVkKHJlc29sdmVSZXN1bHRzW2J1bmRsZUlkXSkpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfVxuICBhc3luYyBfdW5sb2FkRnJvbVJlc29sdmVkKHJlc29sdmVSZXN1bHQpIHtcbiAgICBjb25zdCByZXNvbHZlQXJyYXkgPSBPYmplY3QudmFsdWVzKHJlc29sdmVSZXN1bHQpO1xuICAgIHJlc29sdmVBcnJheS5mb3JFYWNoKChyZXNvbHZlUmVzdWx0MikgPT4ge1xuICAgICAgQ2FjaGUuQ2FjaGUucmVtb3ZlKHJlc29sdmVSZXN1bHQyLnNyYyk7XG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy5sb2FkZXIudW5sb2FkKHJlc29sdmVBcnJheSk7XG4gIH1cbiAgZ2V0IGRldGVjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RldGVjdGlvbnM7XG4gIH1cbiAgZ2V0IHByZWZlcldvcmtlcnMoKSB7XG4gICAgcmV0dXJuIGxvYWRUZXh0dXJlcy5sb2FkVGV4dHVyZXMuY29uZmlnLnByZWZlcldvcmtlcnM7XG4gIH1cbiAgc2V0IHByZWZlcldvcmtlcnModmFsdWUpIHtcbiAgICBjb3JlLnV0aWxzLmRlcHJlY2F0aW9uKFwiNy4yLjBcIiwgXCJBc3NldHMucHJlZmVyc1dvcmtlcnMgaXMgZGVwcmVjYXRlZCwgdXNlIEFzc2V0cy5zZXRQcmVmZXJlbmNlcyh7IHByZWZlcldvcmtlcnM6IHRydWUgfSkgaW5zdGVhZC5cIik7XG4gICAgdGhpcy5zZXRQcmVmZXJlbmNlcyh7IHByZWZlcldvcmtlcnM6IHZhbHVlIH0pO1xuICB9XG4gIHNldFByZWZlcmVuY2VzKHByZWZlcmVuY2VzKSB7XG4gICAgdGhpcy5sb2FkZXIucGFyc2Vycy5mb3JFYWNoKChwYXJzZXIpID0+IHtcbiAgICAgIGlmICghcGFyc2VyLmNvbmZpZylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgT2JqZWN0LmtleXMocGFyc2VyLmNvbmZpZykuZmlsdGVyKChrZXkpID0+IGtleSBpbiBwcmVmZXJlbmNlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIHBhcnNlci5jb25maWdba2V5XSA9IHByZWZlcmVuY2VzW2tleV07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgQXNzZXRzID0gbmV3IEFzc2V0c0NsYXNzKCk7XG5jb3JlLmV4dGVuc2lvbnMuaGFuZGxlQnlMaXN0KGNvcmUuRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLCBBc3NldHMubG9hZGVyLnBhcnNlcnMpLmhhbmRsZUJ5TGlzdChjb3JlLkV4dGVuc2lvblR5cGUuUmVzb2x2ZVBhcnNlciwgQXNzZXRzLnJlc29sdmVyLnBhcnNlcnMpLmhhbmRsZUJ5TGlzdChjb3JlLkV4dGVuc2lvblR5cGUuQ2FjaGVQYXJzZXIsIEFzc2V0cy5jYWNoZS5wYXJzZXJzKS5oYW5kbGVCeUxpc3QoY29yZS5FeHRlbnNpb25UeXBlLkRldGVjdGlvblBhcnNlciwgQXNzZXRzLmRldGVjdGlvbnMpO1xuXG5leHBvcnRzLkFzc2V0cyA9IEFzc2V0cztcbmV4cG9ydHMuQXNzZXRzQ2xhc3MgPSBBc3NldHNDbGFzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzc2V0cy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY2xhc3MgQmFja2dyb3VuZExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKGxvYWRlciwgdmVyYm9zZSA9IGZhbHNlKSB7XG4gICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyO1xuICAgIHRoaXMuX2Fzc2V0TGlzdCA9IFtdO1xuICAgIHRoaXMuX2lzTG9hZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX21heENvbmN1cnJlbnQgPSAxO1xuICAgIHRoaXMudmVyYm9zZSA9IHZlcmJvc2U7XG4gIH1cbiAgYWRkKGFzc2V0VXJscykge1xuICAgIGFzc2V0VXJscy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICB0aGlzLl9hc3NldExpc3QucHVzaChhKTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy52ZXJib3NlKVxuICAgICAgY29uc29sZS5sb2coXCJbQmFja2dyb3VuZExvYWRlcl0gYXNzZXRzOiBcIiwgdGhpcy5fYXNzZXRMaXN0KTtcbiAgICBpZiAodGhpcy5faXNBY3RpdmUgJiYgIXRoaXMuX2lzTG9hZGluZykge1xuICAgICAgdGhpcy5fbmV4dCgpO1xuICAgIH1cbiAgfVxuICBhc3luYyBfbmV4dCgpIHtcbiAgICBpZiAodGhpcy5fYXNzZXRMaXN0Lmxlbmd0aCAmJiB0aGlzLl9pc0FjdGl2ZSkge1xuICAgICAgdGhpcy5faXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHRvTG9hZCA9IFtdO1xuICAgICAgY29uc3QgdG9Mb2FkQW1vdW50ID0gTWF0aC5taW4odGhpcy5fYXNzZXRMaXN0Lmxlbmd0aCwgdGhpcy5fbWF4Q29uY3VycmVudCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvTG9hZEFtb3VudDsgaSsrKSB7XG4gICAgICAgIHRvTG9hZC5wdXNoKHRoaXMuX2Fzc2V0TGlzdC5wb3AoKSk7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLl9sb2FkZXIubG9hZCh0b0xvYWQpO1xuICAgICAgdGhpcy5faXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9uZXh0KCk7XG4gICAgfVxuICB9XG4gIGdldCBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzQWN0aXZlO1xuICB9XG4gIHNldCBhY3RpdmUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5faXNBY3RpdmUgPT09IHZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2lzQWN0aXZlID0gdmFsdWU7XG4gICAgaWYgKHZhbHVlICYmICF0aGlzLl9pc0xvYWRpbmcpIHtcbiAgICAgIHRoaXMuX25leHQoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5CYWNrZ3JvdW5kTG9hZGVyID0gQmFja2dyb3VuZExvYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhY2tncm91bmRMb2FkZXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xucmVxdWlyZSgnLi4vdXRpbHMvaW5kZXguanMnKTtcbnZhciBjb252ZXJ0VG9MaXN0ID0gcmVxdWlyZSgnLi4vdXRpbHMvY29udmVydFRvTGlzdC5qcycpO1xuXG5jbGFzcyBDYWNoZUNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcGFyc2VycyA9IFtdO1xuICAgIHRoaXMuX2NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9jYWNoZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fY2FjaGVNYXAuY2xlYXIoKTtcbiAgICB0aGlzLl9jYWNoZS5jbGVhcigpO1xuICB9XG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUuaGFzKGtleSk7XG4gIH1cbiAgZ2V0KGtleSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2NhY2hlLmdldChrZXkpO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICBjb25zb2xlLndhcm4oYFtBc3NldHNdIEFzc2V0IGlkICR7a2V5fSB3YXMgbm90IGZvdW5kIGluIHRoZSBDYWNoZWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgY29uc3Qga2V5cyA9IGNvbnZlcnRUb0xpc3QuY29udmVydFRvTGlzdChrZXkpO1xuICAgIGxldCBjYWNoZWFibGVBc3NldHM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhcnNlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2Vyc1tpXTtcbiAgICAgIGlmIChwYXJzZXIudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgY2FjaGVhYmxlQXNzZXRzID0gcGFyc2VyLmdldENhY2hlYWJsZUFzc2V0cyhrZXlzLCB2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNhY2hlYWJsZUFzc2V0cykge1xuICAgICAgY2FjaGVhYmxlQXNzZXRzID0ge307XG4gICAgICBrZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgICAgY2FjaGVhYmxlQXNzZXRzW2tleTJdID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVLZXlzID0gT2JqZWN0LmtleXMoY2FjaGVhYmxlQXNzZXRzKTtcbiAgICBjb25zdCBjYWNoZWRBc3NldHMgPSB7XG4gICAgICBjYWNoZUtleXMsXG4gICAgICBrZXlzXG4gICAgfTtcbiAgICBrZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgIHRoaXMuX2NhY2hlTWFwLnNldChrZXkyLCBjYWNoZWRBc3NldHMpO1xuICAgIH0pO1xuICAgIGNhY2hlS2V5cy5mb3JFYWNoKChrZXkyKSA9PiB7XG4gICAgICBpZiAodGhpcy5fY2FjaGUuaGFzKGtleTIpICYmIHRoaXMuX2NhY2hlLmdldChrZXkyKSAhPT0gdmFsdWUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW0NhY2hlXSBhbHJlYWR5IGhhcyBrZXk6XCIsIGtleTIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2FjaGUuc2V0KGtleTIsIGNhY2hlYWJsZUFzc2V0c1trZXkyXSk7XG4gICAgfSk7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgY29yZS5UZXh0dXJlKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gdmFsdWU7XG4gICAgICBrZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgICAgaWYgKHRleHR1cmUuYmFzZVRleHR1cmUgIT09IGNvcmUuVGV4dHVyZS5FTVBUWS5iYXNlVGV4dHVyZSkge1xuICAgICAgICAgIGNvcmUuQmFzZVRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLCBrZXkyKTtcbiAgICAgICAgfVxuICAgICAgICBjb3JlLlRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLCBrZXkyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZW1vdmUoa2V5KSB7XG4gICAgdGhpcy5fY2FjaGVNYXAuZ2V0KGtleSk7XG4gICAgaWYgKCF0aGlzLl9jYWNoZU1hcC5oYXMoa2V5KSkge1xuICAgICAgY29uc29sZS53YXJuKGBbQXNzZXRzXSBBc3NldCBpZCAke2tleX0gd2FzIG5vdCBmb3VuZCBpbiB0aGUgQ2FjaGVgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVNYXAgPSB0aGlzLl9jYWNoZU1hcC5nZXQoa2V5KTtcbiAgICBjb25zdCBjYWNoZUtleXMgPSBjYWNoZU1hcC5jYWNoZUtleXM7XG4gICAgY2FjaGVLZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShrZXkyKTtcbiAgICB9KTtcbiAgICBjYWNoZU1hcC5rZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgIHRoaXMuX2NhY2hlTWFwLmRlbGV0ZShrZXkyKTtcbiAgICB9KTtcbiAgfVxuICBnZXQgcGFyc2VycygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VycztcbiAgfVxufVxuY29uc3QgQ2FjaGUgPSBuZXcgQ2FjaGVDbGFzcygpO1xuXG5leHBvcnRzLkNhY2hlID0gQ2FjaGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYWNoZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FjaGVQYXJzZXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBDYWNoZSA9IHJlcXVpcmUoJy4vQ2FjaGUuanMnKTtcbnJlcXVpcmUoJy4vQ2FjaGVQYXJzZXIuanMnKTtcbnJlcXVpcmUoJy4vcGFyc2Vycy9pbmRleC5qcycpO1xuXG5cblxuZXhwb3J0cy5DYWNoZSA9IENhY2hlLkNhY2hlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xuXG5jb25zdCBjYWNoZVRleHR1cmVBcnJheSA9IHtcbiAgZXh0ZW5zaW9uOiBjb3JlLkV4dGVuc2lvblR5cGUuQ2FjaGVQYXJzZXIsXG4gIHRlc3Q6IChhc3NldCkgPT4gQXJyYXkuaXNBcnJheShhc3NldCkgJiYgYXNzZXQuZXZlcnkoKHQpID0+IHQgaW5zdGFuY2VvZiBjb3JlLlRleHR1cmUpLFxuICBnZXRDYWNoZWFibGVBc3NldHM6IChrZXlzLCBhc3NldCkgPT4ge1xuICAgIGNvbnN0IG91dCA9IHt9O1xuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBhc3NldC5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIG91dFtrZXkgKyAoaSA9PT0gMCA/IFwiXCIgOiBpICsgMSldID0gaXRlbTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbn07XG5jb3JlLmV4dGVuc2lvbnMuYWRkKGNhY2hlVGV4dHVyZUFycmF5KTtcblxuZXhwb3J0cy5jYWNoZVRleHR1cmVBcnJheSA9IGNhY2hlVGV4dHVyZUFycmF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FjaGVUZXh0dXJlQXJyYXkuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjYWNoZVRleHR1cmVBcnJheSA9IHJlcXVpcmUoJy4vY2FjaGVUZXh0dXJlQXJyYXkuanMnKTtcblxuXG5cbmV4cG9ydHMuY2FjaGVUZXh0dXJlQXJyYXkgPSBjYWNoZVRleHR1cmVBcnJheS5jYWNoZVRleHR1cmVBcnJheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL3BhcnNlcnMvaW5kZXguanMnKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xuXG5jb25zdCBkZXRlY3RBdmlmID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBjb3JlLkV4dGVuc2lvblR5cGUuRGV0ZWN0aW9uUGFyc2VyLFxuICAgIHByaW9yaXR5OiAxXG4gIH0sXG4gIHRlc3Q6IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWdsb2JhbFRoaXMuY3JlYXRlSW1hZ2VCaXRtYXApXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgYXZpZkRhdGEgPSBcImRhdGE6aW1hZ2UvYXZpZjtiYXNlNjQsQUFBQUlHWjBlWEJoZG1sbUFBQUFBR0YyYVdadGFXWXhiV2xoWmsxQk1VSUFBQUR5YldWMFlRQUFBQUFBQUFBb2FHUnNjZ0FBQUFBQUFBQUFjR2xqZEFBQUFBQUFBQUFBQUFBQUFHeHBZbUYyYVdZQUFBQUFEbkJwZEcwQUFBQUFBQUVBQUFBZWFXeHZZd0FBQUFCRUFBQUJBQUVBQUFBQkFBQUJHZ0FBQUIwQUFBQW9hV2x1WmdBQUFBQUFBUUFBQUJwcGJtWmxBZ0FBQUFBQkFBQmhkakF4UTI5c2IzSUFBQUFBYW1sd2NuQUFBQUJMYVhCamJ3QUFBQlJwYzNCbEFBQUFBQUFBQUFJQUFBQUNBQUFBRUhCcGVHa0FBQUFBQXdnSUNBQUFBQXhoZGpGRGdRME1BQUFBQUJOamIyeHlibU5zZUFBQ0FBSUFBWUFBQUFBWGFYQnRZUUFBQUFBQUFBQUJBQUVFQVFLREJBQUFBQ1Z0WkdGMEVnQUtDQmdBTm9nUUVBd2dNZzhmOEQvLy84V2Zod0I4K0VySzQyQT1cIjtcbiAgICBjb25zdCBibG9iID0gYXdhaXQgY29yZS5zZXR0aW5ncy5BREFQVEVSLmZldGNoKGF2aWZEYXRhKS50aGVuKChyKSA9PiByLmJsb2IoKSk7XG4gICAgcmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKGJsb2IpLnRoZW4oKCkgPT4gdHJ1ZSwgKCkgPT4gZmFsc2UpO1xuICB9LFxuICBhZGQ6IGFzeW5jIChmb3JtYXRzKSA9PiBbLi4uZm9ybWF0cywgXCJhdmlmXCJdLFxuICByZW1vdmU6IGFzeW5jIChmb3JtYXRzKSA9PiBmb3JtYXRzLmZpbHRlcigoZikgPT4gZiAhPT0gXCJhdmlmXCIpXG59O1xuY29yZS5leHRlbnNpb25zLmFkZChkZXRlY3RBdmlmKTtcblxuZXhwb3J0cy5kZXRlY3RBdmlmID0gZGV0ZWN0QXZpZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdEF2aWYuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xuXG5jb25zdCBpbWFnZUZvcm1hdHMgPSBbXCJwbmdcIiwgXCJqcGdcIiwgXCJqcGVnXCJdO1xuY29uc3QgZGV0ZWN0RGVmYXVsdHMgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IGNvcmUuRXh0ZW5zaW9uVHlwZS5EZXRlY3Rpb25QYXJzZXIsXG4gICAgcHJpb3JpdHk6IC0xXG4gIH0sXG4gIHRlc3Q6ICgpID0+IFByb21pc2UucmVzb2x2ZSh0cnVlKSxcbiAgYWRkOiBhc3luYyAoZm9ybWF0cykgPT4gWy4uLmZvcm1hdHMsIC4uLmltYWdlRm9ybWF0c10sXG4gIHJlbW92ZTogYXN5bmMgKGZvcm1hdHMpID0+IGZvcm1hdHMuZmlsdGVyKChmKSA9PiAhaW1hZ2VGb3JtYXRzLmluY2x1ZGVzKGYpKVxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQoZGV0ZWN0RGVmYXVsdHMpO1xuXG5leHBvcnRzLmRldGVjdERlZmF1bHRzID0gZGV0ZWN0RGVmYXVsdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlY3REZWZhdWx0cy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG5cbmNvbnN0IGRldGVjdFdlYnAgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IGNvcmUuRXh0ZW5zaW9uVHlwZS5EZXRlY3Rpb25QYXJzZXIsXG4gICAgcHJpb3JpdHk6IDBcbiAgfSxcbiAgdGVzdDogYXN5bmMgKCkgPT4ge1xuICAgIGlmICghZ2xvYmFsVGhpcy5jcmVhdGVJbWFnZUJpdG1hcClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB3ZWJwRGF0YSA9IFwiZGF0YTppbWFnZS93ZWJwO2Jhc2U2NCxVa2xHUmg0QUFBQlhSVUpRVmxBNFRCRUFBQUF2QUFBQUFBZlEvLzczdi8rQmlPaC9BQUE9XCI7XG4gICAgY29uc3QgYmxvYiA9IGF3YWl0IGNvcmUuc2V0dGluZ3MuQURBUFRFUi5mZXRjaCh3ZWJwRGF0YSkudGhlbigocikgPT4gci5ibG9iKCkpO1xuICAgIHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcChibG9iKS50aGVuKCgpID0+IHRydWUsICgpID0+IGZhbHNlKTtcbiAgfSxcbiAgYWRkOiBhc3luYyAoZm9ybWF0cykgPT4gWy4uLmZvcm1hdHMsIFwid2VicFwiXSxcbiAgcmVtb3ZlOiBhc3luYyAoZm9ybWF0cykgPT4gZm9ybWF0cy5maWx0ZXIoKGYpID0+IGYgIT09IFwid2VicFwiKVxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQoZGV0ZWN0V2VicCk7XG5cbmV4cG9ydHMuZGV0ZWN0V2VicCA9IGRldGVjdFdlYnA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlY3RXZWJwLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZGV0ZWN0QXZpZiA9IHJlcXVpcmUoJy4vZGV0ZWN0QXZpZi5qcycpO1xudmFyIGRldGVjdFdlYnAgPSByZXF1aXJlKCcuL2RldGVjdFdlYnAuanMnKTtcbnZhciBkZXRlY3REZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGV0ZWN0RGVmYXVsdHMuanMnKTtcblxuXG5cbmV4cG9ydHMuZGV0ZWN0QXZpZiA9IGRldGVjdEF2aWYuZGV0ZWN0QXZpZjtcbmV4cG9ydHMuZGV0ZWN0V2VicCA9IGRldGVjdFdlYnAuZGV0ZWN0V2VicDtcbmV4cG9ydHMuZGV0ZWN0RGVmYXVsdHMgPSBkZXRlY3REZWZhdWx0cy5kZXRlY3REZWZhdWx0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5yZXF1aXJlKCcuL0Fzc2V0RXh0ZW5zaW9uLmpzJyk7XG52YXIgQXNzZXRzID0gcmVxdWlyZSgnLi9Bc3NldHMuanMnKTtcbnJlcXVpcmUoJy4vY2FjaGUvaW5kZXguanMnKTtcbnJlcXVpcmUoJy4vZGV0ZWN0aW9ucy9pbmRleC5qcycpO1xucmVxdWlyZSgnLi9sb2FkZXIvaW5kZXguanMnKTtcbnJlcXVpcmUoJy4vcmVzb2x2ZXIvaW5kZXguanMnKTtcbnJlcXVpcmUoJy4vdXRpbHMvaW5kZXguanMnKTtcbnZhciBDYWNoZSA9IHJlcXVpcmUoJy4vY2FjaGUvQ2FjaGUuanMnKTtcbnZhciBjYWNoZVRleHR1cmVBcnJheSA9IHJlcXVpcmUoJy4vY2FjaGUvcGFyc2Vycy9jYWNoZVRleHR1cmVBcnJheS5qcycpO1xudmFyIGRldGVjdEF2aWYgPSByZXF1aXJlKCcuL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RBdmlmLmpzJyk7XG52YXIgZGV0ZWN0V2VicCA9IHJlcXVpcmUoJy4vZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdFdlYnAuanMnKTtcbnZhciBkZXRlY3REZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdERlZmF1bHRzLmpzJyk7XG52YXIgTG9hZGVyUGFyc2VyID0gcmVxdWlyZSgnLi9sb2FkZXIvcGFyc2Vycy9Mb2FkZXJQYXJzZXIuanMnKTtcbnZhciBsb2FkSnNvbiA9IHJlcXVpcmUoJy4vbG9hZGVyL3BhcnNlcnMvbG9hZEpzb24uanMnKTtcbnZhciBsb2FkVHh0ID0gcmVxdWlyZSgnLi9sb2FkZXIvcGFyc2Vycy9sb2FkVHh0LmpzJyk7XG52YXIgbG9hZFdlYkZvbnQgPSByZXF1aXJlKCcuL2xvYWRlci9wYXJzZXJzL2xvYWRXZWJGb250LmpzJyk7XG52YXIgbG9hZFNWRyA9IHJlcXVpcmUoJy4vbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvbG9hZFNWRy5qcycpO1xudmFyIGxvYWRUZXh0dXJlcyA9IHJlcXVpcmUoJy4vbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvbG9hZFRleHR1cmVzLmpzJyk7XG52YXIgY3JlYXRlVGV4dHVyZSA9IHJlcXVpcmUoJy4vbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvdXRpbHMvY3JlYXRlVGV4dHVyZS5qcycpO1xudmFyIHJlc29sdmVUZXh0dXJlVXJsID0gcmVxdWlyZSgnLi9yZXNvbHZlci9wYXJzZXJzL3Jlc29sdmVUZXh0dXJlVXJsLmpzJyk7XG52YXIgY2hlY2tEYXRhVXJsID0gcmVxdWlyZSgnLi91dGlscy9jaGVja0RhdGFVcmwuanMnKTtcbnZhciBjaGVja0V4dGVuc2lvbiA9IHJlcXVpcmUoJy4vdXRpbHMvY2hlY2tFeHRlbnNpb24uanMnKTtcbnZhciBjb252ZXJ0VG9MaXN0ID0gcmVxdWlyZSgnLi91dGlscy9jb252ZXJ0VG9MaXN0LmpzJyk7XG52YXIgY29weVNlYXJjaFBhcmFtcyA9IHJlcXVpcmUoJy4vdXRpbHMvY29weVNlYXJjaFBhcmFtcy5qcycpO1xudmFyIGNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMgPSByZXF1aXJlKCcuL3V0aWxzL2NyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMuanMnKTtcbnZhciBpc1NpbmdsZUl0ZW0gPSByZXF1aXJlKCcuL3V0aWxzL2lzU2luZ2xlSXRlbS5qcycpO1xuXG5cblxuZXhwb3J0cy5Bc3NldHMgPSBBc3NldHMuQXNzZXRzO1xuZXhwb3J0cy5Bc3NldHNDbGFzcyA9IEFzc2V0cy5Bc3NldHNDbGFzcztcbmV4cG9ydHMuQ2FjaGUgPSBDYWNoZS5DYWNoZTtcbmV4cG9ydHMuY2FjaGVUZXh0dXJlQXJyYXkgPSBjYWNoZVRleHR1cmVBcnJheS5jYWNoZVRleHR1cmVBcnJheTtcbmV4cG9ydHMuZGV0ZWN0QXZpZiA9IGRldGVjdEF2aWYuZGV0ZWN0QXZpZjtcbmV4cG9ydHMuZGV0ZWN0V2VicCA9IGRldGVjdFdlYnAuZGV0ZWN0V2VicDtcbmV4cG9ydHMuZGV0ZWN0RGVmYXVsdHMgPSBkZXRlY3REZWZhdWx0cy5kZXRlY3REZWZhdWx0cztcbmV4cG9ydHMuTG9hZGVyUGFyc2VyUHJpb3JpdHkgPSBMb2FkZXJQYXJzZXIuTG9hZGVyUGFyc2VyUHJpb3JpdHk7XG5leHBvcnRzLmxvYWRKc29uID0gbG9hZEpzb24ubG9hZEpzb247XG5leHBvcnRzLmxvYWRUeHQgPSBsb2FkVHh0LmxvYWRUeHQ7XG5leHBvcnRzLmdldEZvbnRGYW1pbHlOYW1lID0gbG9hZFdlYkZvbnQuZ2V0Rm9udEZhbWlseU5hbWU7XG5leHBvcnRzLmxvYWRXZWJGb250ID0gbG9hZFdlYkZvbnQubG9hZFdlYkZvbnQ7XG5leHBvcnRzLmxvYWRTVkcgPSBsb2FkU1ZHLmxvYWRTVkc7XG5leHBvcnRzLmxvYWRJbWFnZUJpdG1hcCA9IGxvYWRUZXh0dXJlcy5sb2FkSW1hZ2VCaXRtYXA7XG5leHBvcnRzLmxvYWRUZXh0dXJlcyA9IGxvYWRUZXh0dXJlcy5sb2FkVGV4dHVyZXM7XG5leHBvcnRzLmNyZWF0ZVRleHR1cmUgPSBjcmVhdGVUZXh0dXJlLmNyZWF0ZVRleHR1cmU7XG5leHBvcnRzLnJlc29sdmVUZXh0dXJlVXJsID0gcmVzb2x2ZVRleHR1cmVVcmwucmVzb2x2ZVRleHR1cmVVcmw7XG5leHBvcnRzLmNoZWNrRGF0YVVybCA9IGNoZWNrRGF0YVVybC5jaGVja0RhdGFVcmw7XG5leHBvcnRzLmNoZWNrRXh0ZW5zaW9uID0gY2hlY2tFeHRlbnNpb24uY2hlY2tFeHRlbnNpb247XG5leHBvcnRzLmNvbnZlcnRUb0xpc3QgPSBjb252ZXJ0VG9MaXN0LmNvbnZlcnRUb0xpc3Q7XG5leHBvcnRzLmNvcHlTZWFyY2hQYXJhbXMgPSBjb3B5U2VhcmNoUGFyYW1zLmNvcHlTZWFyY2hQYXJhbXM7XG5leHBvcnRzLmNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMgPSBjcmVhdGVTdHJpbmdWYXJpYXRpb25zLmNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnM7XG5leHBvcnRzLmlzU2luZ2xlSXRlbSA9IGlzU2luZ2xlSXRlbS5pc1NpbmdsZUl0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG5yZXF1aXJlKCcuLi91dGlscy9pbmRleC5qcycpO1xudmFyIGlzU2luZ2xlSXRlbSA9IHJlcXVpcmUoJy4uL3V0aWxzL2lzU2luZ2xlSXRlbS5qcycpO1xudmFyIGNvbnZlcnRUb0xpc3QgPSByZXF1aXJlKCcuLi91dGlscy9jb252ZXJ0VG9MaXN0LmpzJyk7XG5cbmNsYXNzIExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3BhcnNlcnMgPSBbXTtcbiAgICB0aGlzLl9wYXJzZXJzVmFsaWRhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5wYXJzZXJzID0gbmV3IFByb3h5KHRoaXMuX3BhcnNlcnMsIHtcbiAgICAgIHNldDogKHRhcmdldCwga2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLl9wYXJzZXJzVmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucHJvbWlzZUNhY2hlID0ge307XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fcGFyc2Vyc1ZhbGlkYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMucHJvbWlzZUNhY2hlID0ge307XG4gIH1cbiAgX2dldExvYWRQcm9taXNlQW5kUGFyc2VyKHVybCwgZGF0YSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHByb21pc2U6IG51bGwsXG4gICAgICBwYXJzZXI6IG51bGxcbiAgICB9O1xuICAgIHJlc3VsdC5wcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBhc3NldCA9IG51bGw7XG4gICAgICBsZXQgcGFyc2VyID0gbnVsbDtcbiAgICAgIGlmIChkYXRhLmxvYWRQYXJzZXIpIHtcbiAgICAgICAgcGFyc2VyID0gdGhpcy5fcGFyc2VySGFzaFtkYXRhLmxvYWRQYXJzZXJdO1xuICAgICAgICBpZiAoIXBhcnNlcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgW0Fzc2V0c10gc3BlY2lmaWVkIGxvYWQgcGFyc2VyIFwiJHtkYXRhLmxvYWRQYXJzZXJ9XCIgbm90IGZvdW5kIHdoaWxlIGxvYWRpbmcgJHt1cmx9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcGFyc2VyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXJzZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VyWCA9IHRoaXMucGFyc2Vyc1tpXTtcbiAgICAgICAgICBpZiAocGFyc2VyWC5sb2FkICYmIHBhcnNlclgudGVzdD8uKHVybCwgZGF0YSwgdGhpcykpIHtcbiAgICAgICAgICAgIHBhcnNlciA9IHBhcnNlclg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJzZXIpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYFtBc3NldHNdICR7dXJsfSBjb3VsZCBub3QgYmUgbG9hZGVkIGFzIHdlIGRvbid0IGtub3cgaG93IHRvIHBhcnNlIGl0LCBlbnN1cmUgdGhlIGNvcnJlY3QgcGFyc2VyIGhhcyBiZWVuIGFkZGVkYCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFzc2V0ID0gYXdhaXQgcGFyc2VyLmxvYWQodXJsLCBkYXRhLCB0aGlzKTtcbiAgICAgIHJlc3VsdC5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGFyc2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJzZXIyID0gdGhpcy5wYXJzZXJzW2ldO1xuICAgICAgICBpZiAocGFyc2VyMi5wYXJzZSkge1xuICAgICAgICAgIGlmIChwYXJzZXIyLnBhcnNlICYmIGF3YWl0IHBhcnNlcjIudGVzdFBhcnNlPy4oYXNzZXQsIGRhdGEsIHRoaXMpKSB7XG4gICAgICAgICAgICBhc3NldCA9IGF3YWl0IHBhcnNlcjIucGFyc2UoYXNzZXQsIGRhdGEsIHRoaXMpIHx8IGFzc2V0O1xuICAgICAgICAgICAgcmVzdWx0LnBhcnNlciA9IHBhcnNlcjI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXNzZXQ7XG4gICAgfSkoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIGxvYWQoYXNzZXRzVG9Mb2FkSW4sIG9uUHJvZ3Jlc3MpIHtcbiAgICBpZiAoIXRoaXMuX3BhcnNlcnNWYWxpZGF0ZWQpIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlUGFyc2VycygpO1xuICAgIH1cbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGNvbnN0IGFzc2V0cyA9IHt9O1xuICAgIGNvbnN0IHNpbmdsZUFzc2V0ID0gaXNTaW5nbGVJdGVtLmlzU2luZ2xlSXRlbShhc3NldHNUb0xvYWRJbik7XG4gICAgY29uc3QgYXNzZXRzVG9Mb2FkID0gY29udmVydFRvTGlzdC5jb252ZXJ0VG9MaXN0KGFzc2V0c1RvTG9hZEluLCAoaXRlbSkgPT4gKHtcbiAgICAgIHNyYzogaXRlbVxuICAgIH0pKTtcbiAgICBjb25zdCB0b3RhbCA9IGFzc2V0c1RvTG9hZC5sZW5ndGg7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBhc3NldHNUb0xvYWQubWFwKGFzeW5jIChhc3NldCkgPT4ge1xuICAgICAgY29uc3QgdXJsID0gY29yZS51dGlscy5wYXRoLnRvQWJzb2x1dGUoYXNzZXQuc3JjKTtcbiAgICAgIGlmICghYXNzZXRzW2Fzc2V0LnNyY10pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIXRoaXMucHJvbWlzZUNhY2hlW3VybF0pIHtcbiAgICAgICAgICAgIHRoaXMucHJvbWlzZUNhY2hlW3VybF0gPSB0aGlzLl9nZXRMb2FkUHJvbWlzZUFuZFBhcnNlcih1cmwsIGFzc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzZXRzW2Fzc2V0LnNyY10gPSBhd2FpdCB0aGlzLnByb21pc2VDYWNoZVt1cmxdLnByb21pc2U7XG4gICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpXG4gICAgICAgICAgICBvblByb2dyZXNzKCsrY291bnQgLyB0b3RhbCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5wcm9taXNlQ2FjaGVbdXJsXTtcbiAgICAgICAgICBkZWxldGUgYXNzZXRzW2Fzc2V0LnNyY107XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbTG9hZGVyLmxvYWRdIEZhaWxlZCB0byBsb2FkICR7dXJsfS5cbiR7ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICByZXR1cm4gc2luZ2xlQXNzZXQgPyBhc3NldHNbYXNzZXRzVG9Mb2FkWzBdLnNyY10gOiBhc3NldHM7XG4gIH1cbiAgYXN5bmMgdW5sb2FkKGFzc2V0c1RvVW5sb2FkSW4pIHtcbiAgICBjb25zdCBhc3NldHNUb1VubG9hZCA9IGNvbnZlcnRUb0xpc3QuY29udmVydFRvTGlzdChhc3NldHNUb1VubG9hZEluLCAoaXRlbSkgPT4gKHtcbiAgICAgIHNyYzogaXRlbVxuICAgIH0pKTtcbiAgICBjb25zdCBwcm9taXNlcyA9IGFzc2V0c1RvVW5sb2FkLm1hcChhc3luYyAoYXNzZXQpID0+IHtcbiAgICAgIGNvbnN0IHVybCA9IGNvcmUudXRpbHMucGF0aC50b0Fic29sdXRlKGFzc2V0LnNyYyk7XG4gICAgICBjb25zdCBsb2FkUHJvbWlzZSA9IHRoaXMucHJvbWlzZUNhY2hlW3VybF07XG4gICAgICBpZiAobG9hZFByb21pc2UpIHtcbiAgICAgICAgY29uc3QgbG9hZGVkQXNzZXQgPSBhd2FpdCBsb2FkUHJvbWlzZS5wcm9taXNlO1xuICAgICAgICBsb2FkUHJvbWlzZS5wYXJzZXI/LnVubG9hZD8uKGxvYWRlZEFzc2V0LCBhc3NldCwgdGhpcyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnByb21pc2VDYWNoZVt1cmxdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfVxuICBfdmFsaWRhdGVQYXJzZXJzKCkge1xuICAgIHRoaXMuX3BhcnNlcnNWYWxpZGF0ZWQgPSB0cnVlO1xuICAgIHRoaXMuX3BhcnNlckhhc2ggPSB0aGlzLl9wYXJzZXJzLmZpbHRlcigocGFyc2VyKSA9PiBwYXJzZXIubmFtZSkucmVkdWNlKChoYXNoLCBwYXJzZXIpID0+IHtcbiAgICAgIGlmIChoYXNoW3BhcnNlci5uYW1lXSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFtBc3NldHNdIGxvYWRQYXJzZXIgbmFtZSBjb25mbGljdCBcIiR7cGFyc2VyLm5hbWV9XCJgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IC4uLmhhc2gsIFtwYXJzZXIubmFtZV06IHBhcnNlciB9O1xuICAgIH0sIHt9KTtcbiAgfVxufVxuXG5leHBvcnRzLkxvYWRlciA9IExvYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvYWRlci5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9wYXJzZXJzL2luZGV4LmpzJyk7XG5yZXF1aXJlKCcuL3R5cGVzLmpzJyk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgTG9hZGVyUGFyc2VyUHJpb3JpdHkgPSAvKiBAX19QVVJFX18gKi8gKChMb2FkZXJQYXJzZXJQcmlvcml0eTIpID0+IHtcbiAgTG9hZGVyUGFyc2VyUHJpb3JpdHkyW0xvYWRlclBhcnNlclByaW9yaXR5MltcIkxvd1wiXSA9IDBdID0gXCJMb3dcIjtcbiAgTG9hZGVyUGFyc2VyUHJpb3JpdHkyW0xvYWRlclBhcnNlclByaW9yaXR5MltcIk5vcm1hbFwiXSA9IDFdID0gXCJOb3JtYWxcIjtcbiAgTG9hZGVyUGFyc2VyUHJpb3JpdHkyW0xvYWRlclBhcnNlclByaW9yaXR5MltcIkhpZ2hcIl0gPSAyXSA9IFwiSGlnaFwiO1xuICByZXR1cm4gTG9hZGVyUGFyc2VyUHJpb3JpdHkyO1xufSkoTG9hZGVyUGFyc2VyUHJpb3JpdHkgfHwge30pO1xuXG5leHBvcnRzLkxvYWRlclBhcnNlclByaW9yaXR5ID0gTG9hZGVyUGFyc2VyUHJpb3JpdHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb2FkZXJQYXJzZXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmxldCBVVUlEID0gMDtcbmxldCBNQVhfV09SS0VSUztcbmNvbnN0IFdISVRFX1BORyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFCQ0FRQUFBQzFIQXdDQUFBQUMwbEVRVlI0Mm1QOC94OEFBd01DQU8raXAxc0FBQUFBU1VWT1JLNUNZSUk9XCI7XG5jb25zdCBjaGVja0ltYWdlQml0bWFwQ29kZSA9IHtcbiAgaWQ6IFwiY2hlY2tJbWFnZUJpdG1hcFwiLFxuICBjb2RlOiBgXG4gICAgYXN5bmMgZnVuY3Rpb24gY2hlY2tJbWFnZUJpdG1hcCgpXG4gICAge1xuICAgICAgICB0cnlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcke1dISVRFX1BOR30nKTtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlQmxvYiA9ICBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICBjb25zdCBpbWFnZUJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGltYWdlQmxvYik7XG5cbiAgICAgICAgICAgIHJldHVybiBpbWFnZUJpdG1hcC53aWR0aCA9PT0gMSAmJiBpbWFnZUJpdG1hcC5oZWlnaHQgPT09IDE7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0ltYWdlQml0bWFwKCkudGhlbigocmVzdWx0KSA9PiB7IHNlbGYucG9zdE1lc3NhZ2UocmVzdWx0KTsgfSk7XG4gICAgYFxufTtcbmNvbnN0IHdvcmtlckNvZGUgPSB7XG4gIGlkOiBcImxvYWRJbWFnZUJpdG1hcFwiLFxuICBjb2RlOiBgXG4gICAgYXN5bmMgZnVuY3Rpb24gbG9hZEltYWdlQml0bWFwKHVybClcbiAgICB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxgW1dvcmtlck1hbmFnZXIubG9hZEltYWdlQml0bWFwXSBGYWlsZWQgdG8gZmV0Y2ggXFwke3VybH06IFxcYFxuICAgICAgICAgICAgICAgICsgXFxgXFwke3Jlc3BvbnNlLnN0YXR1c30gXFwke3Jlc3BvbnNlLnN0YXR1c1RleHR9XFxgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGltYWdlQmxvYiA9ICBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgIGNvbnN0IGltYWdlQml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoaW1hZ2VCbG9iKTtcblxuICAgICAgICByZXR1cm4gaW1hZ2VCaXRtYXA7XG4gICAgfVxuICAgIHNlbGYub25tZXNzYWdlID0gYXN5bmMgKGV2ZW50KSA9PlxuICAgIHtcbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlQml0bWFwID0gYXdhaXQgbG9hZEltYWdlQml0bWFwKGV2ZW50LmRhdGEuZGF0YVswXSk7XG5cbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGltYWdlQml0bWFwLFxuICAgICAgICAgICAgICAgIHV1aWQ6IGV2ZW50LmRhdGEudXVpZCxcbiAgICAgICAgICAgICAgICBpZDogZXZlbnQuZGF0YS5pZCxcbiAgICAgICAgICAgIH0sIFtpbWFnZUJpdG1hcF0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgICAgIHV1aWQ6IGV2ZW50LmRhdGEudXVpZCxcbiAgICAgICAgICAgICAgICBpZDogZXZlbnQuZGF0YS5pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtgXG59O1xubGV0IHdvcmtlclVSTDtcbmNsYXNzIFdvcmtlck1hbmFnZXJDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5fY3JlYXRlZFdvcmtlcnMgPSAwO1xuICAgIHRoaXMud29ya2VyUG9vbCA9IFtdO1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB0aGlzLnJlc29sdmVIYXNoID0ge307XG4gIH1cbiAgaXNJbWFnZUJpdG1hcFN1cHBvcnRlZCgpIHtcbiAgICBpZiAodGhpcy5faXNJbWFnZUJpdG1hcFN1cHBvcnRlZCAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIHRoaXMuX2lzSW1hZ2VCaXRtYXBTdXBwb3J0ZWQ7XG4gICAgdGhpcy5faXNJbWFnZUJpdG1hcFN1cHBvcnRlZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCB3b3JrZXJVUkwyID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbY2hlY2tJbWFnZUJpdG1hcENvZGUuY29kZV0sIHsgdHlwZTogXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCIgfSkpO1xuICAgICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJVUkwyKTtcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHdvcmtlclVSTDIpO1xuICAgICAgICByZXNvbHZlKGV2ZW50LmRhdGEpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX2lzSW1hZ2VCaXRtYXBTdXBwb3J0ZWQ7XG4gIH1cbiAgbG9hZEltYWdlQml0bWFwKHNyYykge1xuICAgIHJldHVybiB0aGlzLl9ydW4oXCJsb2FkSW1hZ2VCaXRtYXBcIiwgW3NyY10pO1xuICB9XG4gIGFzeW5jIF9pbml0V29ya2VycygpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG4gIGdldFdvcmtlcigpIHtcbiAgICBpZiAoTUFYX1dPUktFUlMgPT09IHZvaWQgMCkge1xuICAgICAgTUFYX1dPUktFUlMgPSBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSB8fCA0O1xuICAgIH1cbiAgICBsZXQgd29ya2VyID0gdGhpcy53b3JrZXJQb29sLnBvcCgpO1xuICAgIGlmICghd29ya2VyICYmIHRoaXMuX2NyZWF0ZWRXb3JrZXJzIDwgTUFYX1dPUktFUlMpIHtcbiAgICAgIGlmICghd29ya2VyVVJMKSB7XG4gICAgICAgIHdvcmtlclVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3dvcmtlckNvZGUuY29kZV0sIHsgdHlwZTogXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCIgfSkpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY3JlYXRlZFdvcmtlcnMrKztcbiAgICAgIHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVVJMKTtcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZShldmVudC5kYXRhKTtcbiAgICAgICAgdGhpcy5yZXR1cm5Xb3JrZXIoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmtlcjtcbiAgfVxuICByZXR1cm5Xb3JrZXIod29ya2VyKSB7XG4gICAgdGhpcy53b3JrZXJQb29sLnB1c2god29ya2VyKTtcbiAgfVxuICBjb21wbGV0ZShkYXRhKSB7XG4gICAgaWYgKGRhdGEuZXJyb3IgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZXNvbHZlSGFzaFtkYXRhLnV1aWRdLnJlamVjdChkYXRhLmVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXNvbHZlSGFzaFtkYXRhLnV1aWRdLnJlc29sdmUoZGF0YS5kYXRhKTtcbiAgICB9XG4gICAgdGhpcy5yZXNvbHZlSGFzaFtkYXRhLnV1aWRdID0gbnVsbDtcbiAgfVxuICBhc3luYyBfcnVuKGlkLCBhcmdzKSB7XG4gICAgYXdhaXQgdGhpcy5faW5pdFdvcmtlcnMoKTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgaWQsIGFyZ3VtZW50czogYXJncywgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgIH0pO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIG5leHQoKSB7XG4gICAgaWYgKCF0aGlzLnF1ZXVlLmxlbmd0aClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB3b3JrZXIgPSB0aGlzLmdldFdvcmtlcigpO1xuICAgIGlmICghd29ya2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRvRG8gPSB0aGlzLnF1ZXVlLnBvcCgpO1xuICAgIGNvbnN0IGlkID0gdG9Eby5pZDtcbiAgICB0aGlzLnJlc29sdmVIYXNoW1VVSURdID0geyByZXNvbHZlOiB0b0RvLnJlc29sdmUsIHJlamVjdDogdG9Eby5yZWplY3QgfTtcbiAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgZGF0YTogdG9Eby5hcmd1bWVudHMsXG4gICAgICB1dWlkOiBVVUlEKyssXG4gICAgICBpZFxuICAgIH0pO1xuICB9XG59XG5jb25zdCBXb3JrZXJNYW5hZ2VyID0gbmV3IFdvcmtlck1hbmFnZXJDbGFzcygpO1xuXG5leHBvcnRzLldvcmtlck1hbmFnZXIgPSBXb3JrZXJNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V29ya2VyTWFuYWdlci5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIExvYWRlclBhcnNlciA9IHJlcXVpcmUoJy4vTG9hZGVyUGFyc2VyLmpzJyk7XG52YXIgbG9hZEpzb24gPSByZXF1aXJlKCcuL2xvYWRKc29uLmpzJyk7XG52YXIgbG9hZFR4dCA9IHJlcXVpcmUoJy4vbG9hZFR4dC5qcycpO1xudmFyIGxvYWRXZWJGb250ID0gcmVxdWlyZSgnLi9sb2FkV2ViRm9udC5qcycpO1xucmVxdWlyZSgnLi90ZXh0dXJlcy9pbmRleC5qcycpO1xuXG5cblxuZXhwb3J0cy5Mb2FkZXJQYXJzZXJQcmlvcml0eSA9IExvYWRlclBhcnNlci5Mb2FkZXJQYXJzZXJQcmlvcml0eTtcbmV4cG9ydHMubG9hZEpzb24gPSBsb2FkSnNvbi5sb2FkSnNvbjtcbmV4cG9ydHMubG9hZFR4dCA9IGxvYWRUeHQubG9hZFR4dDtcbmV4cG9ydHMuZ2V0Rm9udEZhbWlseU5hbWUgPSBsb2FkV2ViRm9udC5nZXRGb250RmFtaWx5TmFtZTtcbmV4cG9ydHMubG9hZFdlYkZvbnQgPSBsb2FkV2ViRm9udC5sb2FkV2ViRm9udDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBjaGVja0RhdGFVcmwgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jaGVja0RhdGFVcmwuanMnKTtcbnZhciBjaGVja0V4dGVuc2lvbiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NoZWNrRXh0ZW5zaW9uLmpzJyk7XG52YXIgTG9hZGVyUGFyc2VyID0gcmVxdWlyZSgnLi9Mb2FkZXJQYXJzZXIuanMnKTtcblxuY29uc3QgdmFsaWRKU09ORXh0ZW5zaW9uID0gXCIuanNvblwiO1xuY29uc3QgdmFsaWRKU09OTUlNRSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuY29uc3QgbG9hZEpzb24gPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IGNvcmUuRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgIHByaW9yaXR5OiBMb2FkZXJQYXJzZXIuTG9hZGVyUGFyc2VyUHJpb3JpdHkuTG93XG4gIH0sXG4gIG5hbWU6IFwibG9hZEpzb25cIixcbiAgdGVzdCh1cmwpIHtcbiAgICByZXR1cm4gY2hlY2tEYXRhVXJsLmNoZWNrRGF0YVVybCh1cmwsIHZhbGlkSlNPTk1JTUUpIHx8IGNoZWNrRXh0ZW5zaW9uLmNoZWNrRXh0ZW5zaW9uKHVybCwgdmFsaWRKU09ORXh0ZW5zaW9uKTtcbiAgfSxcbiAgYXN5bmMgbG9hZCh1cmwpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvcmUuc2V0dGluZ3MuQURBUFRFUi5mZXRjaCh1cmwpO1xuICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgcmV0dXJuIGpzb247XG4gIH1cbn07XG5jb3JlLmV4dGVuc2lvbnMuYWRkKGxvYWRKc29uKTtcblxuZXhwb3J0cy5sb2FkSnNvbiA9IGxvYWRKc29uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZEpzb24uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xudmFyIGNoZWNrRGF0YVVybCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NoZWNrRGF0YVVybC5qcycpO1xudmFyIGNoZWNrRXh0ZW5zaW9uID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY2hlY2tFeHRlbnNpb24uanMnKTtcbnZhciBMb2FkZXJQYXJzZXIgPSByZXF1aXJlKCcuL0xvYWRlclBhcnNlci5qcycpO1xuXG5jb25zdCB2YWxpZFRYVEV4dGVuc2lvbiA9IFwiLnR4dFwiO1xuY29uc3QgdmFsaWRUWFRNSU1FID0gXCJ0ZXh0L3BsYWluXCI7XG5jb25zdCBsb2FkVHh0ID0ge1xuICBuYW1lOiBcImxvYWRUeHRcIixcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogY29yZS5FeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IExvYWRlclBhcnNlci5Mb2FkZXJQYXJzZXJQcmlvcml0eS5Mb3dcbiAgfSxcbiAgdGVzdCh1cmwpIHtcbiAgICByZXR1cm4gY2hlY2tEYXRhVXJsLmNoZWNrRGF0YVVybCh1cmwsIHZhbGlkVFhUTUlNRSkgfHwgY2hlY2tFeHRlbnNpb24uY2hlY2tFeHRlbnNpb24odXJsLCB2YWxpZFRYVEV4dGVuc2lvbik7XG4gIH0sXG4gIGFzeW5jIGxvYWQodXJsKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb3JlLnNldHRpbmdzLkFEQVBURVIuZmV0Y2godXJsKTtcbiAgICBjb25zdCB0eHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgcmV0dXJuIHR4dDtcbiAgfVxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQobG9hZFR4dCk7XG5cbmV4cG9ydHMubG9hZFR4dCA9IGxvYWRUeHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkVHh0LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBjaGVja0RhdGFVcmwgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jaGVja0RhdGFVcmwuanMnKTtcbnZhciBjaGVja0V4dGVuc2lvbiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NoZWNrRXh0ZW5zaW9uLmpzJyk7XG52YXIgTG9hZGVyUGFyc2VyID0gcmVxdWlyZSgnLi9Mb2FkZXJQYXJzZXIuanMnKTtcblxuY29uc3QgdmFsaWRXZWlnaHRzID0gW1xuICBcIm5vcm1hbFwiLFxuICBcImJvbGRcIixcbiAgXCIxMDBcIixcbiAgXCIyMDBcIixcbiAgXCIzMDBcIixcbiAgXCI0MDBcIixcbiAgXCI1MDBcIixcbiAgXCI2MDBcIixcbiAgXCI3MDBcIixcbiAgXCI4MDBcIixcbiAgXCI5MDBcIlxuXTtcbmNvbnN0IHZhbGlkRm9udEV4dGVuc2lvbnMgPSBbXCIudHRmXCIsIFwiLm90ZlwiLCBcIi53b2ZmXCIsIFwiLndvZmYyXCJdO1xuY29uc3QgdmFsaWRGb250TUlNRXMgPSBbXG4gIFwiZm9udC90dGZcIixcbiAgXCJmb250L290ZlwiLFxuICBcImZvbnQvd29mZlwiLFxuICBcImZvbnQvd29mZjJcIlxuXTtcbmNvbnN0IENTU19JREVOVF9UT0tFTl9SRUdFWCA9IC9eKC0tfC0/W0EtWl9dKVswLTlBLVpfLV0qJC9pO1xuZnVuY3Rpb24gZ2V0Rm9udEZhbWlseU5hbWUodXJsKSB7XG4gIGNvbnN0IGV4dCA9IGNvcmUudXRpbHMucGF0aC5leHRuYW1lKHVybCk7XG4gIGNvbnN0IG5hbWUgPSBjb3JlLnV0aWxzLnBhdGguYmFzZW5hbWUodXJsLCBleHQpO1xuICBjb25zdCBuYW1lV2l0aFNwYWNlcyA9IG5hbWUucmVwbGFjZSgvKC18XykvZywgXCIgXCIpO1xuICBjb25zdCBuYW1lVG9rZW5zID0gbmFtZVdpdGhTcGFjZXMudG9Mb3dlckNhc2UoKS5zcGxpdChcIiBcIikubWFwKCh3b3JkKSA9PiB3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKSk7XG4gIGxldCB2YWxpZCA9IG5hbWVUb2tlbnMubGVuZ3RoID4gMDtcbiAgZm9yIChjb25zdCB0b2tlbiBvZiBuYW1lVG9rZW5zKSB7XG4gICAgaWYgKCF0b2tlbi5tYXRjaChDU1NfSURFTlRfVE9LRU5fUkVHRVgpKSB7XG4gICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGxldCBmb250RmFtaWx5TmFtZSA9IG5hbWVUb2tlbnMuam9pbihcIiBcIik7XG4gIGlmICghdmFsaWQpIHtcbiAgICBmb250RmFtaWx5TmFtZSA9IGBcIiR7Zm9udEZhbWlseU5hbWUucmVwbGFjZSgvW1xcXFxcIl0vZywgXCJcXFxcJCZcIil9XCJgO1xuICB9XG4gIHJldHVybiBmb250RmFtaWx5TmFtZTtcbn1cbmNvbnN0IGxvYWRXZWJGb250ID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBjb3JlLkV4dGVuc2lvblR5cGUuTG9hZFBhcnNlcixcbiAgICBwcmlvcml0eTogTG9hZGVyUGFyc2VyLkxvYWRlclBhcnNlclByaW9yaXR5Lkxvd1xuICB9LFxuICBuYW1lOiBcImxvYWRXZWJGb250XCIsXG4gIHRlc3QodXJsKSB7XG4gICAgcmV0dXJuIGNoZWNrRGF0YVVybC5jaGVja0RhdGFVcmwodXJsLCB2YWxpZEZvbnRNSU1FcykgfHwgY2hlY2tFeHRlbnNpb24uY2hlY2tFeHRlbnNpb24odXJsLCB2YWxpZEZvbnRFeHRlbnNpb25zKTtcbiAgfSxcbiAgYXN5bmMgbG9hZCh1cmwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmb250cyA9IGNvcmUuc2V0dGluZ3MuQURBUFRFUi5nZXRGb250RmFjZVNldCgpO1xuICAgIGlmIChmb250cykge1xuICAgICAgY29uc3QgZm9udEZhY2VzID0gW107XG4gICAgICBjb25zdCBuYW1lID0gb3B0aW9ucy5kYXRhPy5mYW1pbHkgPz8gZ2V0Rm9udEZhbWlseU5hbWUodXJsKTtcbiAgICAgIGNvbnN0IHdlaWdodHMgPSBvcHRpb25zLmRhdGE/LndlaWdodHM/LmZpbHRlcigod2VpZ2h0KSA9PiB2YWxpZFdlaWdodHMuaW5jbHVkZXMod2VpZ2h0KSkgPz8gW1wibm9ybWFsXCJdO1xuICAgICAgY29uc3QgZGF0YSA9IG9wdGlvbnMuZGF0YSA/PyB7fTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2VpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB3ZWlnaHQgPSB3ZWlnaHRzW2ldO1xuICAgICAgICBjb25zdCBmb250ID0gbmV3IEZvbnRGYWNlKG5hbWUsIGB1cmwoJHtlbmNvZGVVUkkodXJsKX0pYCwge1xuICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgd2VpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBmb250LmxvYWQoKTtcbiAgICAgICAgZm9udHMuYWRkKGZvbnQpO1xuICAgICAgICBmb250RmFjZXMucHVzaChmb250KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb250RmFjZXMubGVuZ3RoID09PSAxID8gZm9udEZhY2VzWzBdIDogZm9udEZhY2VzO1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4oXCJbbG9hZFdlYkZvbnRdIEZvbnRGYWNlIEFQSSBpcyBub3Qgc3VwcG9ydGVkLiBTa2lwcGluZyBsb2FkaW5nIGZvbnRcIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIHVubG9hZChmb250KSB7XG4gICAgKEFycmF5LmlzQXJyYXkoZm9udCkgPyBmb250IDogW2ZvbnRdKS5mb3JFYWNoKCh0KSA9PiBjb3JlLnNldHRpbmdzLkFEQVBURVIuZ2V0Rm9udEZhY2VTZXQoKS5kZWxldGUodCkpO1xuICB9XG59O1xuY29yZS5leHRlbnNpb25zLmFkZChsb2FkV2ViRm9udCk7XG5cbmV4cG9ydHMuZ2V0Rm9udEZhbWlseU5hbWUgPSBnZXRGb250RmFtaWx5TmFtZTtcbmV4cG9ydHMubG9hZFdlYkZvbnQgPSBsb2FkV2ViRm9udDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRXZWJGb250LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbG9hZFNWRyA9IHJlcXVpcmUoJy4vbG9hZFNWRy5qcycpO1xudmFyIGxvYWRUZXh0dXJlcyA9IHJlcXVpcmUoJy4vbG9hZFRleHR1cmVzLmpzJyk7XG5yZXF1aXJlKCcuL3V0aWxzL2luZGV4LmpzJyk7XG5cblxuXG5leHBvcnRzLmxvYWRTVkcgPSBsb2FkU1ZHLmxvYWRTVkc7XG5leHBvcnRzLmxvYWRJbWFnZUJpdG1hcCA9IGxvYWRUZXh0dXJlcy5sb2FkSW1hZ2VCaXRtYXA7XG5leHBvcnRzLmxvYWRUZXh0dXJlcyA9IGxvYWRUZXh0dXJlcy5sb2FkVGV4dHVyZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgY2hlY2tEYXRhVXJsID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvY2hlY2tEYXRhVXJsLmpzJyk7XG52YXIgY2hlY2tFeHRlbnNpb24gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9jaGVja0V4dGVuc2lvbi5qcycpO1xudmFyIExvYWRlclBhcnNlciA9IHJlcXVpcmUoJy4uL0xvYWRlclBhcnNlci5qcycpO1xudmFyIGxvYWRUZXh0dXJlcyA9IHJlcXVpcmUoJy4vbG9hZFRleHR1cmVzLmpzJyk7XG52YXIgY3JlYXRlVGV4dHVyZSA9IHJlcXVpcmUoJy4vdXRpbHMvY3JlYXRlVGV4dHVyZS5qcycpO1xuXG5jb25zdCB2YWxpZFNWR0V4dGVuc2lvbiA9IFwiLnN2Z1wiO1xuY29uc3QgdmFsaWRTVkdNSU1FID0gXCJpbWFnZS9zdmcreG1sXCI7XG5jb25zdCBsb2FkU1ZHID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBjb3JlLkV4dGVuc2lvblR5cGUuTG9hZFBhcnNlcixcbiAgICBwcmlvcml0eTogTG9hZGVyUGFyc2VyLkxvYWRlclBhcnNlclByaW9yaXR5LkhpZ2hcbiAgfSxcbiAgbmFtZTogXCJsb2FkU1ZHXCIsXG4gIHRlc3QodXJsKSB7XG4gICAgcmV0dXJuIGNoZWNrRGF0YVVybC5jaGVja0RhdGFVcmwodXJsLCB2YWxpZFNWR01JTUUpIHx8IGNoZWNrRXh0ZW5zaW9uLmNoZWNrRXh0ZW5zaW9uKHVybCwgdmFsaWRTVkdFeHRlbnNpb24pO1xuICB9LFxuICBhc3luYyB0ZXN0UGFyc2UoZGF0YSkge1xuICAgIHJldHVybiBjb3JlLlNWR1Jlc291cmNlLnRlc3QoZGF0YSk7XG4gIH0sXG4gIGFzeW5jIHBhcnNlKGFzc2V0LCBkYXRhLCBsb2FkZXIpIHtcbiAgICBjb25zdCBzcmMgPSBuZXcgY29yZS5TVkdSZXNvdXJjZShhc3NldCwgZGF0YT8uZGF0YT8ucmVzb3VyY2VPcHRpb25zKTtcbiAgICBhd2FpdCBzcmMubG9hZCgpO1xuICAgIGNvbnN0IGJhc2UgPSBuZXcgY29yZS5CYXNlVGV4dHVyZShzcmMsIHtcbiAgICAgIHJlc29sdXRpb246IGNvcmUudXRpbHMuZ2V0UmVzb2x1dGlvbk9mVXJsKGFzc2V0KSxcbiAgICAgIC4uLmRhdGE/LmRhdGFcbiAgICB9KTtcbiAgICBiYXNlLnJlc291cmNlLnNyYyA9IGFzc2V0O1xuICAgIGNvbnN0IHRleHR1cmUgPSBjcmVhdGVUZXh0dXJlLmNyZWF0ZVRleHR1cmUoYmFzZSwgbG9hZGVyLCBhc3NldCk7XG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH0sXG4gIGFzeW5jIGxvYWQodXJsLCBfb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29yZS5zZXR0aW5ncy5BREFQVEVSLmZldGNoKHVybCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfSxcbiAgdW5sb2FkOiBsb2FkVGV4dHVyZXMubG9hZFRleHR1cmVzLnVubG9hZFxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQobG9hZFNWRyk7XG5cbmV4cG9ydHMubG9hZFNWRyA9IGxvYWRTVkc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkU1ZHLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBjaGVja0RhdGFVcmwgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9jaGVja0RhdGFVcmwuanMnKTtcbnZhciBjaGVja0V4dGVuc2lvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL2NoZWNrRXh0ZW5zaW9uLmpzJyk7XG52YXIgTG9hZGVyUGFyc2VyID0gcmVxdWlyZSgnLi4vTG9hZGVyUGFyc2VyLmpzJyk7XG52YXIgV29ya2VyTWFuYWdlciA9IHJlcXVpcmUoJy4uL1dvcmtlck1hbmFnZXIuanMnKTtcbnZhciBjcmVhdGVUZXh0dXJlID0gcmVxdWlyZSgnLi91dGlscy9jcmVhdGVUZXh0dXJlLmpzJyk7XG5cbmNvbnN0IHZhbGlkSW1hZ2VFeHRlbnNpb25zID0gW1wiLmpwZWdcIiwgXCIuanBnXCIsIFwiLnBuZ1wiLCBcIi53ZWJwXCIsIFwiLmF2aWZcIl07XG5jb25zdCB2YWxpZEltYWdlTUlNRXMgPSBbXG4gIFwiaW1hZ2UvanBlZ1wiLFxuICBcImltYWdlL3BuZ1wiLFxuICBcImltYWdlL3dlYnBcIixcbiAgXCJpbWFnZS9hdmlmXCJcbl07XG5hc3luYyBmdW5jdGlvbiBsb2FkSW1hZ2VCaXRtYXAodXJsKSB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29yZS5zZXR0aW5ncy5BREFQVEVSLmZldGNoKHVybCk7XG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFtsb2FkSW1hZ2VCaXRtYXBdIEZhaWxlZCB0byBmZXRjaCAke3VybH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gIH1cbiAgY29uc3QgaW1hZ2VCbG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICBjb25zdCBpbWFnZUJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGltYWdlQmxvYik7XG4gIHJldHVybiBpbWFnZUJpdG1hcDtcbn1cbmNvbnN0IGxvYWRUZXh0dXJlcyA9IHtcbiAgbmFtZTogXCJsb2FkVGV4dHVyZXNcIixcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogY29yZS5FeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IExvYWRlclBhcnNlci5Mb2FkZXJQYXJzZXJQcmlvcml0eS5IaWdoXG4gIH0sXG4gIGNvbmZpZzoge1xuICAgIHByZWZlcldvcmtlcnM6IHRydWUsXG4gICAgcHJlZmVyQ3JlYXRlSW1hZ2VCaXRtYXA6IHRydWUsXG4gICAgY3Jvc3NPcmlnaW46IFwiYW5vbnltb3VzXCJcbiAgfSxcbiAgdGVzdCh1cmwpIHtcbiAgICByZXR1cm4gY2hlY2tEYXRhVXJsLmNoZWNrRGF0YVVybCh1cmwsIHZhbGlkSW1hZ2VNSU1FcykgfHwgY2hlY2tFeHRlbnNpb24uY2hlY2tFeHRlbnNpb24odXJsLCB2YWxpZEltYWdlRXh0ZW5zaW9ucyk7XG4gIH0sXG4gIGFzeW5jIGxvYWQodXJsLCBhc3NldCwgbG9hZGVyKSB7XG4gICAgbGV0IHNyYyA9IG51bGw7XG4gICAgaWYgKGdsb2JhbFRoaXMuY3JlYXRlSW1hZ2VCaXRtYXAgJiYgdGhpcy5jb25maWcucHJlZmVyQ3JlYXRlSW1hZ2VCaXRtYXApIHtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5wcmVmZXJXb3JrZXJzICYmIGF3YWl0IFdvcmtlck1hbmFnZXIuV29ya2VyTWFuYWdlci5pc0ltYWdlQml0bWFwU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgc3JjID0gYXdhaXQgV29ya2VyTWFuYWdlci5Xb3JrZXJNYW5hZ2VyLmxvYWRJbWFnZUJpdG1hcCh1cmwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3JjID0gYXdhaXQgbG9hZEltYWdlQml0bWFwKHVybCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNyYyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHNyYyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBzcmMuY3Jvc3NPcmlnaW4gPSB0aGlzLmNvbmZpZy5jcm9zc09yaWdpbjtcbiAgICAgICAgc3JjLnNyYyA9IHVybDtcbiAgICAgICAgaWYgKHNyYy5jb21wbGV0ZSkge1xuICAgICAgICAgIHJlc29sdmUoc3JjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcmMub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShzcmMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBiYXNlID0gbmV3IGNvcmUuQmFzZVRleHR1cmUoc3JjLCB7XG4gICAgICByZXNvbHV0aW9uOiBjb3JlLnV0aWxzLmdldFJlc29sdXRpb25PZlVybCh1cmwpLFxuICAgICAgLi4uYXNzZXQuZGF0YVxuICAgIH0pO1xuICAgIGJhc2UucmVzb3VyY2Uuc3JjID0gdXJsO1xuICAgIHJldHVybiBjcmVhdGVUZXh0dXJlLmNyZWF0ZVRleHR1cmUoYmFzZSwgbG9hZGVyLCB1cmwpO1xuICB9LFxuICB1bmxvYWQodGV4dHVyZSkge1xuICAgIHRleHR1cmUuZGVzdHJveSh0cnVlKTtcbiAgfVxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQobG9hZFRleHR1cmVzKTtcblxuZXhwb3J0cy5sb2FkSW1hZ2VCaXRtYXAgPSBsb2FkSW1hZ2VCaXRtYXA7XG5leHBvcnRzLmxvYWRUZXh0dXJlcyA9IGxvYWRUZXh0dXJlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRUZXh0dXJlcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUoYmFzZSwgbG9hZGVyLCB1cmwpIHtcbiAgY29uc3QgdGV4dHVyZSA9IG5ldyBjb3JlLlRleHR1cmUoYmFzZSk7XG4gIHRleHR1cmUuYmFzZVRleHR1cmUub24oXCJkaXNwb3NlXCIsICgpID0+IHtcbiAgICBkZWxldGUgbG9hZGVyLnByb21pc2VDYWNoZVt1cmxdO1xuICB9KTtcbiAgcmV0dXJuIHRleHR1cmU7XG59XG5cbmV4cG9ydHMuY3JlYXRlVGV4dHVyZSA9IGNyZWF0ZVRleHR1cmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVUZXh0dXJlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY3JlYXRlVGV4dHVyZSA9IHJlcXVpcmUoJy4vY3JlYXRlVGV4dHVyZS5qcycpO1xuXG5cblxuZXhwb3J0cy5jcmVhdGVUZXh0dXJlID0gY3JlYXRlVGV4dHVyZS5jcmVhdGVUZXh0dXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBjb252ZXJ0VG9MaXN0ID0gcmVxdWlyZSgnLi4vdXRpbHMvY29udmVydFRvTGlzdC5qcycpO1xudmFyIGNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMgPSByZXF1aXJlKCcuLi91dGlscy9jcmVhdGVTdHJpbmdWYXJpYXRpb25zLmpzJyk7XG52YXIgaXNTaW5nbGVJdGVtID0gcmVxdWlyZSgnLi4vdXRpbHMvaXNTaW5nbGVJdGVtLmpzJyk7XG5cbmNsYXNzIFJlc29sdmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZGVmYXVsdEJ1bmRsZUlkZW50aWZpZXJPcHRpb25zID0ge1xuICAgICAgY29ubmVjdG9yOiBcIi1cIixcbiAgICAgIGNyZWF0ZUJ1bmRsZUFzc2V0SWQ6IChidW5kbGVJZCwgYXNzZXRJZCkgPT4gYCR7YnVuZGxlSWR9JHt0aGlzLl9idW5kbGVJZENvbm5lY3Rvcn0ke2Fzc2V0SWR9YCxcbiAgICAgIGV4dHJhY3RBc3NldElkRnJvbUJ1bmRsZTogKGJ1bmRsZUlkLCBhc3NldEJ1bmRsZUlkKSA9PiBhc3NldEJ1bmRsZUlkLnJlcGxhY2UoYCR7YnVuZGxlSWR9JHt0aGlzLl9idW5kbGVJZENvbm5lY3Rvcn1gLCBcIlwiKVxuICAgIH07XG4gICAgdGhpcy5fYnVuZGxlSWRDb25uZWN0b3IgPSB0aGlzLl9kZWZhdWx0QnVuZGxlSWRlbnRpZmllck9wdGlvbnMuY29ubmVjdG9yO1xuICAgIHRoaXMuX2NyZWF0ZUJ1bmRsZUFzc2V0SWQgPSB0aGlzLl9kZWZhdWx0QnVuZGxlSWRlbnRpZmllck9wdGlvbnMuY3JlYXRlQnVuZGxlQXNzZXRJZDtcbiAgICB0aGlzLl9leHRyYWN0QXNzZXRJZEZyb21CdW5kbGUgPSB0aGlzLl9kZWZhdWx0QnVuZGxlSWRlbnRpZmllck9wdGlvbnMuZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlO1xuICAgIHRoaXMuX2Fzc2V0TWFwID0ge307XG4gICAgdGhpcy5fcHJlZmVycmVkT3JkZXIgPSBbXTtcbiAgICB0aGlzLl9wYXJzZXJzID0gW107XG4gICAgdGhpcy5fcmVzb2x2ZXJIYXNoID0ge307XG4gICAgdGhpcy5fYnVuZGxlcyA9IHt9O1xuICB9XG4gIHNldEJ1bmRsZUlkZW50aWZpZXIoYnVuZGxlSWRlbnRpZmllcikge1xuICAgIHRoaXMuX2J1bmRsZUlkQ29ubmVjdG9yID0gYnVuZGxlSWRlbnRpZmllci5jb25uZWN0b3IgPz8gdGhpcy5fYnVuZGxlSWRDb25uZWN0b3I7XG4gICAgdGhpcy5fY3JlYXRlQnVuZGxlQXNzZXRJZCA9IGJ1bmRsZUlkZW50aWZpZXIuY3JlYXRlQnVuZGxlQXNzZXRJZCA/PyB0aGlzLl9jcmVhdGVCdW5kbGVBc3NldElkO1xuICAgIHRoaXMuX2V4dHJhY3RBc3NldElkRnJvbUJ1bmRsZSA9IGJ1bmRsZUlkZW50aWZpZXIuZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlID8/IHRoaXMuX2V4dHJhY3RBc3NldElkRnJvbUJ1bmRsZTtcbiAgICBpZiAodGhpcy5fZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlKFwiZm9vXCIsIHRoaXMuX2NyZWF0ZUJ1bmRsZUFzc2V0SWQoXCJmb29cIiwgXCJiYXJcIikpICE9PSBcImJhclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbUmVzb2x2ZXJdIEdlbmVyYXRlQnVuZGxlQXNzZXRJZCBhcmUgbm90IHdvcmtpbmcgY29ycmVjdGx5XCIpO1xuICAgIH1cbiAgfVxuICBwcmVmZXIoLi4ucHJlZmVyT3JkZXJzKSB7XG4gICAgcHJlZmVyT3JkZXJzLmZvckVhY2goKHByZWZlcikgPT4ge1xuICAgICAgdGhpcy5fcHJlZmVycmVkT3JkZXIucHVzaChwcmVmZXIpO1xuICAgICAgaWYgKCFwcmVmZXIucHJpb3JpdHkpIHtcbiAgICAgICAgcHJlZmVyLnByaW9yaXR5ID0gT2JqZWN0LmtleXMocHJlZmVyLnBhcmFtcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fcmVzb2x2ZXJIYXNoID0ge307XG4gIH1cbiAgc2V0IGJhc2VQYXRoKGJhc2VQYXRoKSB7XG4gICAgdGhpcy5fYmFzZVBhdGggPSBiYXNlUGF0aDtcbiAgfVxuICBnZXQgYmFzZVBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jhc2VQYXRoO1xuICB9XG4gIHNldCByb290UGF0aChyb290UGF0aCkge1xuICAgIHRoaXMuX3Jvb3RQYXRoID0gcm9vdFBhdGg7XG4gIH1cbiAgZ2V0IHJvb3RQYXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9yb290UGF0aDtcbiAgfVxuICBnZXQgcGFyc2VycygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VycztcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnNldEJ1bmRsZUlkZW50aWZpZXIodGhpcy5fZGVmYXVsdEJ1bmRsZUlkZW50aWZpZXJPcHRpb25zKTtcbiAgICB0aGlzLl9hc3NldE1hcCA9IHt9O1xuICAgIHRoaXMuX3ByZWZlcnJlZE9yZGVyID0gW107XG4gICAgdGhpcy5fcmVzb2x2ZXJIYXNoID0ge307XG4gICAgdGhpcy5fcm9vdFBhdGggPSBudWxsO1xuICAgIHRoaXMuX2Jhc2VQYXRoID0gbnVsbDtcbiAgICB0aGlzLl9tYW5pZmVzdCA9IG51bGw7XG4gICAgdGhpcy5fYnVuZGxlcyA9IHt9O1xuICAgIHRoaXMuX2RlZmF1bHRTZWFyY2hQYXJhbXMgPSBudWxsO1xuICB9XG4gIHNldERlZmF1bHRTZWFyY2hQYXJhbXMoc2VhcmNoUGFyYW1zKSB7XG4gICAgaWYgKHR5cGVvZiBzZWFyY2hQYXJhbXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuX2RlZmF1bHRTZWFyY2hQYXJhbXMgPSBzZWFyY2hQYXJhbXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHF1ZXJ5VmFsdWVzID0gc2VhcmNoUGFyYW1zO1xuICAgICAgdGhpcy5fZGVmYXVsdFNlYXJjaFBhcmFtcyA9IE9iamVjdC5rZXlzKHF1ZXJ5VmFsdWVzKS5tYXAoKGtleSkgPT4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5VmFsdWVzW2tleV0pfWApLmpvaW4oXCImXCIpO1xuICAgIH1cbiAgfVxuICBhZGRNYW5pZmVzdChtYW5pZmVzdCkge1xuICAgIGlmICh0aGlzLl9tYW5pZmVzdCkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Jlc29sdmVyXSBNYW5pZmVzdCBhbHJlYWR5IGV4aXN0cywgdGhpcyB3aWxsIGJlIG92ZXJ3cml0dGVuXCIpO1xuICAgIH1cbiAgICB0aGlzLl9tYW5pZmVzdCA9IG1hbmlmZXN0O1xuICAgIG1hbmlmZXN0LmJ1bmRsZXMuZm9yRWFjaCgoYnVuZGxlKSA9PiB7XG4gICAgICB0aGlzLmFkZEJ1bmRsZShidW5kbGUubmFtZSwgYnVuZGxlLmFzc2V0cyk7XG4gICAgfSk7XG4gIH1cbiAgYWRkQnVuZGxlKGJ1bmRsZUlkLCBhc3NldHMpIHtcbiAgICBjb25zdCBhc3NldE5hbWVzID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXNzZXRzKSkge1xuICAgICAgYXNzZXRzLmZvckVhY2goKGFzc2V0KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgYXNzZXQubmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IGJ1bmRsZUFzc2V0SWQgPSB0aGlzLl9jcmVhdGVCdW5kbGVBc3NldElkKGJ1bmRsZUlkLCBhc3NldC5uYW1lKTtcbiAgICAgICAgICBhc3NldE5hbWVzLnB1c2goYnVuZGxlQXNzZXRJZCk7XG4gICAgICAgICAgdGhpcy5hZGQoW2Fzc2V0Lm5hbWUsIGJ1bmRsZUFzc2V0SWRdLCBhc3NldC5zcmNzLCBhc3NldC5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBidW5kbGVJZHMgPSBhc3NldC5uYW1lLm1hcCgobmFtZSkgPT4gdGhpcy5fY3JlYXRlQnVuZGxlQXNzZXRJZChidW5kbGVJZCwgbmFtZSkpO1xuICAgICAgICAgIGJ1bmRsZUlkcy5mb3JFYWNoKChidW5kbGVJZDIpID0+IHtcbiAgICAgICAgICAgIGFzc2V0TmFtZXMucHVzaChidW5kbGVJZDIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuYWRkKFsuLi5hc3NldC5uYW1lLCAuLi5idW5kbGVJZHNdLCBhc3NldC5zcmNzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5rZXlzKGFzc2V0cykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGFzc2V0TmFtZXMucHVzaCh0aGlzLl9jcmVhdGVCdW5kbGVBc3NldElkKGJ1bmRsZUlkLCBrZXkpKTtcbiAgICAgICAgdGhpcy5hZGQoW2tleSwgdGhpcy5fY3JlYXRlQnVuZGxlQXNzZXRJZChidW5kbGVJZCwga2V5KV0sIGFzc2V0c1trZXldKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9idW5kbGVzW2J1bmRsZUlkXSA9IGFzc2V0TmFtZXM7XG4gIH1cbiAgYWRkKGtleXNJbiwgYXNzZXRzSW4sIGRhdGEpIHtcbiAgICBjb25zdCBrZXlzID0gY29udmVydFRvTGlzdC5jb252ZXJ0VG9MaXN0KGtleXNJbik7XG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmICh0aGlzLmhhc0tleShrZXkpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgW1Jlc29sdmVyXSBhbHJlYWR5IGhhcyBrZXk6ICR7a2V5fSBvdmVyd3JpdGluZ2ApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhc3NldHNJbikpIHtcbiAgICAgIGlmICh0eXBlb2YgYXNzZXRzSW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYXNzZXRzSW4gPSBjcmVhdGVTdHJpbmdWYXJpYXRpb25zLmNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMoYXNzZXRzSW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXRzSW4gPSBbYXNzZXRzSW5dO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhc3NldE1hcCA9IGFzc2V0c0luLm1hcCgoYXNzZXQpID0+IHtcbiAgICAgIGxldCBmb3JtYXR0ZWRBc3NldCA9IGFzc2V0O1xuICAgICAgaWYgKHR5cGVvZiBhc3NldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsZXQgcGFyc2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcGFyc2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHBhcnNlciA9IHRoaXMuX3BhcnNlcnNbaV07XG4gICAgICAgICAgaWYgKHBhcnNlci50ZXN0KGFzc2V0KSkge1xuICAgICAgICAgICAgZm9ybWF0dGVkQXNzZXQgPSBwYXJzZXIucGFyc2UoYXNzZXQpO1xuICAgICAgICAgICAgcGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgIGZvcm1hdHRlZEFzc2V0ID0ge1xuICAgICAgICAgICAgc3JjOiBhc3NldFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZm9ybWF0dGVkQXNzZXQuZm9ybWF0KSB7XG4gICAgICAgIGZvcm1hdHRlZEFzc2V0LmZvcm1hdCA9IGZvcm1hdHRlZEFzc2V0LnNyYy5zcGxpdChcIi5cIikucG9wKCk7XG4gICAgICB9XG4gICAgICBpZiAoIWZvcm1hdHRlZEFzc2V0LmFsaWFzKSB7XG4gICAgICAgIGZvcm1hdHRlZEFzc2V0LmFsaWFzID0ga2V5cztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9iYXNlUGF0aCB8fCB0aGlzLl9yb290UGF0aCkge1xuICAgICAgICBmb3JtYXR0ZWRBc3NldC5zcmMgPSBjb3JlLnV0aWxzLnBhdGgudG9BYnNvbHV0ZShmb3JtYXR0ZWRBc3NldC5zcmMsIHRoaXMuX2Jhc2VQYXRoLCB0aGlzLl9yb290UGF0aCk7XG4gICAgICB9XG4gICAgICBmb3JtYXR0ZWRBc3NldC5zcmMgPSB0aGlzLl9hcHBlbmREZWZhdWx0U2VhcmNoUGFyYW1zKGZvcm1hdHRlZEFzc2V0LnNyYyk7XG4gICAgICBmb3JtYXR0ZWRBc3NldC5kYXRhID0gZm9ybWF0dGVkQXNzZXQuZGF0YSA/PyBkYXRhO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlZEFzc2V0O1xuICAgIH0pO1xuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICB0aGlzLl9hc3NldE1hcFtrZXldID0gYXNzZXRNYXA7XG4gICAgfSk7XG4gIH1cbiAgcmVzb2x2ZUJ1bmRsZShidW5kbGVJZHMpIHtcbiAgICBjb25zdCBzaW5nbGVBc3NldCA9IGlzU2luZ2xlSXRlbS5pc1NpbmdsZUl0ZW0oYnVuZGxlSWRzKTtcbiAgICBidW5kbGVJZHMgPSBjb252ZXJ0VG9MaXN0LmNvbnZlcnRUb0xpc3QoYnVuZGxlSWRzKTtcbiAgICBjb25zdCBvdXQgPSB7fTtcbiAgICBidW5kbGVJZHMuZm9yRWFjaCgoYnVuZGxlSWQpID0+IHtcbiAgICAgIGNvbnN0IGFzc2V0TmFtZXMgPSB0aGlzLl9idW5kbGVzW2J1bmRsZUlkXTtcbiAgICAgIGlmIChhc3NldE5hbWVzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSB0aGlzLnJlc29sdmUoYXNzZXROYW1lcyk7XG4gICAgICAgIGNvbnN0IGFzc2V0cyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHRzKSB7XG4gICAgICAgICAgY29uc3QgYXNzZXQgPSByZXN1bHRzW2tleV07XG4gICAgICAgICAgYXNzZXRzW3RoaXMuX2V4dHJhY3RBc3NldElkRnJvbUJ1bmRsZShidW5kbGVJZCwga2V5KV0gPSBhc3NldDtcbiAgICAgICAgfVxuICAgICAgICBvdXRbYnVuZGxlSWRdID0gYXNzZXRzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzaW5nbGVBc3NldCA/IG91dFtidW5kbGVJZHNbMF1dIDogb3V0O1xuICB9XG4gIHJlc29sdmVVcmwoa2V5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXNvbHZlKGtleSk7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IG91dCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBpIGluIHJlc3VsdCkge1xuICAgICAgICBvdXRbaV0gPSByZXN1bHRbaV0uc3JjO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5zcmM7XG4gIH1cbiAgcmVzb2x2ZShrZXlzKSB7XG4gICAgY29uc3Qgc2luZ2xlQXNzZXQgPSBpc1NpbmdsZUl0ZW0uaXNTaW5nbGVJdGVtKGtleXMpO1xuICAgIGtleXMgPSBjb252ZXJ0VG9MaXN0LmNvbnZlcnRUb0xpc3Qoa2V5cyk7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmICghdGhpcy5fcmVzb2x2ZXJIYXNoW2tleV0pIHtcbiAgICAgICAgaWYgKHRoaXMuX2Fzc2V0TWFwW2tleV0pIHtcbiAgICAgICAgICBsZXQgYXNzZXRzID0gdGhpcy5fYXNzZXRNYXBba2V5XTtcbiAgICAgICAgICBjb25zdCBwcmVmZXJyZWRPcmRlciA9IHRoaXMuX2dldFByZWZlcnJlZE9yZGVyKGFzc2V0cyk7XG4gICAgICAgICAgY29uc3QgYmVzdEFzc2V0ID0gYXNzZXRzWzBdO1xuICAgICAgICAgIHByZWZlcnJlZE9yZGVyPy5wcmlvcml0eS5mb3JFYWNoKChwcmlvcml0eUtleSkgPT4ge1xuICAgICAgICAgICAgcHJlZmVycmVkT3JkZXIucGFyYW1zW3ByaW9yaXR5S2V5XS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZEFzc2V0cyA9IGFzc2V0cy5maWx0ZXIoKGFzc2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFzc2V0W3ByaW9yaXR5S2V5XSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzc2V0W3ByaW9yaXR5S2V5XSA9PT0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChmaWx0ZXJlZEFzc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhc3NldHMgPSBmaWx0ZXJlZEFzc2V0cztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZXJIYXNoW2tleV0gPSBhc3NldHNbMF0gPz8gYmVzdEFzc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBzcmMgPSBrZXk7XG4gICAgICAgICAgaWYgKHRoaXMuX2Jhc2VQYXRoIHx8IHRoaXMuX3Jvb3RQYXRoKSB7XG4gICAgICAgICAgICBzcmMgPSBjb3JlLnV0aWxzLnBhdGgudG9BYnNvbHV0ZShzcmMsIHRoaXMuX2Jhc2VQYXRoLCB0aGlzLl9yb290UGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNyYyA9IHRoaXMuX2FwcGVuZERlZmF1bHRTZWFyY2hQYXJhbXMoc3JjKTtcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlckhhc2hba2V5XSA9IHtcbiAgICAgICAgICAgIHNyY1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdFtrZXldID0gdGhpcy5fcmVzb2x2ZXJIYXNoW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHNpbmdsZUFzc2V0ID8gcmVzdWx0W2tleXNbMF1dIDogcmVzdWx0O1xuICB9XG4gIGhhc0tleShrZXkpIHtcbiAgICByZXR1cm4gISF0aGlzLl9hc3NldE1hcFtrZXldO1xuICB9XG4gIGhhc0J1bmRsZShrZXkpIHtcbiAgICByZXR1cm4gISF0aGlzLl9idW5kbGVzW2tleV07XG4gIH1cbiAgX2dldFByZWZlcnJlZE9yZGVyKGFzc2V0cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXNzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhc3NldCA9IGFzc2V0c1swXTtcbiAgICAgIGNvbnN0IHByZWZlcnJlZCA9IHRoaXMuX3ByZWZlcnJlZE9yZGVyLmZpbmQoKHByZWZlcmVuY2UpID0+IHByZWZlcmVuY2UucGFyYW1zLmZvcm1hdC5pbmNsdWRlcyhhc3NldC5mb3JtYXQpKTtcbiAgICAgIGlmIChwcmVmZXJyZWQpIHtcbiAgICAgICAgcmV0dXJuIHByZWZlcnJlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ByZWZlcnJlZE9yZGVyWzBdO1xuICB9XG4gIF9hcHBlbmREZWZhdWx0U2VhcmNoUGFyYW1zKHVybCkge1xuICAgIGlmICghdGhpcy5fZGVmYXVsdFNlYXJjaFBhcmFtcylcbiAgICAgIHJldHVybiB1cmw7XG4gICAgY29uc3QgcGFyYW1Db25uZWN0b3IgPSAvXFw/Ly50ZXN0KHVybCkgPyBcIiZcIiA6IFwiP1wiO1xuICAgIHJldHVybiBgJHt1cmx9JHtwYXJhbUNvbm5lY3Rvcn0ke3RoaXMuX2RlZmF1bHRTZWFyY2hQYXJhbXN9YDtcbiAgfVxufVxuXG5leHBvcnRzLlJlc29sdmVyID0gUmVzb2x2ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXNvbHZlci5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9wYXJzZXJzL2luZGV4LmpzJyk7XG5yZXF1aXJlKCcuL3R5cGVzLmpzJyk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgcmVzb2x2ZVRleHR1cmVVcmwgPSByZXF1aXJlKCcuL3Jlc29sdmVUZXh0dXJlVXJsLmpzJyk7XG5cblxuXG5leHBvcnRzLnJlc29sdmVUZXh0dXJlVXJsID0gcmVzb2x2ZVRleHR1cmVVcmwucmVzb2x2ZVRleHR1cmVVcmw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG5yZXF1aXJlKCcuLi8uLi9sb2FkZXIvaW5kZXguanMnKTtcbnZhciBsb2FkVGV4dHVyZXMgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvcGFyc2Vycy90ZXh0dXJlcy9sb2FkVGV4dHVyZXMuanMnKTtcblxuY29uc3QgcmVzb2x2ZVRleHR1cmVVcmwgPSB7XG4gIGV4dGVuc2lvbjogY29yZS5FeHRlbnNpb25UeXBlLlJlc29sdmVQYXJzZXIsXG4gIHRlc3Q6IGxvYWRUZXh0dXJlcy5sb2FkVGV4dHVyZXMudGVzdCxcbiAgcGFyc2U6ICh2YWx1ZSkgPT4gKHtcbiAgICByZXNvbHV0aW9uOiBwYXJzZUZsb2F0KGNvcmUuc2V0dGluZ3MuUkVUSU5BX1BSRUZJWC5leGVjKHZhbHVlKT8uWzFdID8/IFwiMVwiKSxcbiAgICBmb3JtYXQ6IHZhbHVlLnNwbGl0KFwiLlwiKS5wb3AoKSxcbiAgICBzcmM6IHZhbHVlXG4gIH0pXG59O1xuY29yZS5leHRlbnNpb25zLmFkZChyZXNvbHZlVGV4dHVyZVVybCk7XG5cbmV4cG9ydHMucmVzb2x2ZVRleHR1cmVVcmwgPSByZXNvbHZlVGV4dHVyZVVybDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVUZXh0dXJlVXJsLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gY2hlY2tEYXRhVXJsKHVybCwgbWltZXMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWltZXMpKSB7XG4gICAgZm9yIChjb25zdCBtaW1lIG9mIG1pbWVzKSB7XG4gICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoYGRhdGE6JHttaW1lfWApKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB1cmwuc3RhcnRzV2l0aChgZGF0YToke21pbWVzfWApO1xufVxuXG5leHBvcnRzLmNoZWNrRGF0YVVybCA9IGNoZWNrRGF0YVVybDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrRGF0YVVybC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG5cbmZ1bmN0aW9uIGNoZWNrRXh0ZW5zaW9uKHVybCwgZXh0ZW5zaW9uKSB7XG4gIGNvbnN0IHRlbXBVUkwgPSB1cmwuc3BsaXQoXCI/XCIpWzBdO1xuICBjb25zdCBleHQgPSBjb3JlLnV0aWxzLnBhdGguZXh0bmFtZSh0ZW1wVVJMKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoQXJyYXkuaXNBcnJheShleHRlbnNpb24pKSB7XG4gICAgcmV0dXJuIGV4dGVuc2lvbi5pbmNsdWRlcyhleHQpO1xuICB9XG4gIHJldHVybiBleHQgPT09IGV4dGVuc2lvbjtcbn1cblxuZXhwb3J0cy5jaGVja0V4dGVuc2lvbiA9IGNoZWNrRXh0ZW5zaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tFeHRlbnNpb24uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNvbnN0IGNvbnZlcnRUb0xpc3QgPSAoaW5wdXQsIHRyYW5zZm9ybSkgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgaW5wdXQgPSBbaW5wdXRdO1xuICB9XG4gIGlmICghdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIHJldHVybiBpbnB1dC5tYXAoKGl0ZW0pID0+IHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm0oaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9KTtcbn07XG5cbmV4cG9ydHMuY29udmVydFRvTGlzdCA9IGNvbnZlcnRUb0xpc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252ZXJ0VG9MaXN0LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jb25zdCBjb3B5U2VhcmNoUGFyYW1zID0gKHRhcmdldFVybCwgc291cmNlVXJsKSA9PiB7XG4gIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHNvdXJjZVVybC5zcGxpdChcIj9cIilbMV07XG4gIGlmIChzZWFyY2hQYXJhbXMpIHtcbiAgICB0YXJnZXRVcmwgKz0gYD8ke3NlYXJjaFBhcmFtc31gO1xuICB9XG4gIHJldHVybiB0YXJnZXRVcmw7XG59O1xuXG5leHBvcnRzLmNvcHlTZWFyY2hQYXJhbXMgPSBjb3B5U2VhcmNoUGFyYW1zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29weVNlYXJjaFBhcmFtcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gcHJvY2Vzc1goYmFzZSwgaWRzLCBkZXB0aCwgcmVzdWx0LCB0YWdzKSB7XG4gIGNvbnN0IGlkID0gaWRzW2RlcHRoXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gaWRbaV07XG4gICAgaWYgKGRlcHRoIDwgaWRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHByb2Nlc3NYKGJhc2UucmVwbGFjZShyZXN1bHRbZGVwdGhdLCB2YWx1ZSksIGlkcywgZGVwdGggKyAxLCByZXN1bHQsIHRhZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWdzLnB1c2goYmFzZS5yZXBsYWNlKHJlc3VsdFtkZXB0aF0sIHZhbHVlKSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVTdHJpbmdWYXJpYXRpb25zKHN0cmluZykge1xuICBjb25zdCByZWdleCA9IC9cXHsoLio/KVxcfS9nO1xuICBjb25zdCByZXN1bHQgPSBzdHJpbmcubWF0Y2gocmVnZXgpO1xuICBjb25zdCB0YWdzID0gW107XG4gIGlmIChyZXN1bHQpIHtcbiAgICBjb25zdCBpZHMgPSBbXTtcbiAgICByZXN1bHQuZm9yRWFjaCgodmFycykgPT4ge1xuICAgICAgY29uc3Qgc3BsaXQgPSB2YXJzLnN1YnN0cmluZygxLCB2YXJzLmxlbmd0aCAtIDEpLnNwbGl0KFwiLFwiKTtcbiAgICAgIGlkcy5wdXNoKHNwbGl0KTtcbiAgICB9KTtcbiAgICBwcm9jZXNzWChzdHJpbmcsIGlkcywgMCwgcmVzdWx0LCB0YWdzKTtcbiAgfSBlbHNlIHtcbiAgICB0YWdzLnB1c2goc3RyaW5nKTtcbiAgfVxuICByZXR1cm4gdGFncztcbn1cblxuZXhwb3J0cy5jcmVhdGVTdHJpbmdWYXJpYXRpb25zID0gY3JlYXRlU3RyaW5nVmFyaWF0aW9ucztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjaGVja0RhdGFVcmwgPSByZXF1aXJlKCcuL2NoZWNrRGF0YVVybC5qcycpO1xudmFyIGNoZWNrRXh0ZW5zaW9uID0gcmVxdWlyZSgnLi9jaGVja0V4dGVuc2lvbi5qcycpO1xudmFyIGNvbnZlcnRUb0xpc3QgPSByZXF1aXJlKCcuL2NvbnZlcnRUb0xpc3QuanMnKTtcbnZhciBjb3B5U2VhcmNoUGFyYW1zID0gcmVxdWlyZSgnLi9jb3B5U2VhcmNoUGFyYW1zLmpzJyk7XG52YXIgY3JlYXRlU3RyaW5nVmFyaWF0aW9ucyA9IHJlcXVpcmUoJy4vY3JlYXRlU3RyaW5nVmFyaWF0aW9ucy5qcycpO1xudmFyIGlzU2luZ2xlSXRlbSA9IHJlcXVpcmUoJy4vaXNTaW5nbGVJdGVtLmpzJyk7XG5cblxuXG5leHBvcnRzLmNoZWNrRGF0YVVybCA9IGNoZWNrRGF0YVVybC5jaGVja0RhdGFVcmw7XG5leHBvcnRzLmNoZWNrRXh0ZW5zaW9uID0gY2hlY2tFeHRlbnNpb24uY2hlY2tFeHRlbnNpb247XG5leHBvcnRzLmNvbnZlcnRUb0xpc3QgPSBjb252ZXJ0VG9MaXN0LmNvbnZlcnRUb0xpc3Q7XG5leHBvcnRzLmNvcHlTZWFyY2hQYXJhbXMgPSBjb3B5U2VhcmNoUGFyYW1zLmNvcHlTZWFyY2hQYXJhbXM7XG5leHBvcnRzLmNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMgPSBjcmVhdGVTdHJpbmdWYXJpYXRpb25zLmNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnM7XG5leHBvcnRzLmlzU2luZ2xlSXRlbSA9IGlzU2luZ2xlSXRlbS5pc1NpbmdsZUl0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY29uc3QgaXNTaW5nbGVJdGVtID0gKGl0ZW0pID0+ICFBcnJheS5pc0FycmF5KGl0ZW0pO1xuXG5leHBvcnRzLmlzU2luZ2xlSXRlbSA9IGlzU2luZ2xlSXRlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzU2luZ2xlSXRlbS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIElOVEVSTkFMX0ZPUk1BVFMgPSAvKiBAX19QVVJFX18gKi8gKChJTlRFUk5BTF9GT1JNQVRTMikgPT4ge1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFRcIl0gPSAzMzc3Nl0gPSBcIkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVFwiXSA9IDMzNzc3XSA9IFwiQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVFwiXSA9IDMzNzc4XSA9IFwiQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVFwiXSA9IDMzNzc5XSA9IFwiQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQxX0VYVFwiXSA9IDM1OTE3XSA9IFwiQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUMV9FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQzX0VYVFwiXSA9IDM1OTE4XSA9IFwiQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUM19FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQ1X0VYVFwiXSA9IDM1OTE5XSA9IFwiQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUNV9FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1NSR0JfUzNUQ19EWFQxX0VYVFwiXSA9IDM1OTE2XSA9IFwiQ09NUFJFU1NFRF9TUkdCX1MzVENfRFhUMV9FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1IxMV9FQUNcIl0gPSAzNzQ4OF0gPSBcIkNPTVBSRVNTRURfUjExX0VBQ1wiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfU0lHTkVEX1IxMV9FQUNcIl0gPSAzNzQ4OV0gPSBcIkNPTVBSRVNTRURfU0lHTkVEX1IxMV9FQUNcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1JHMTFfRUFDXCJdID0gMzc0OTBdID0gXCJDT01QUkVTU0VEX1JHMTFfRUFDXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9TSUdORURfUkcxMV9FQUNcIl0gPSAzNzQ5MV0gPSBcIkNPTVBSRVNTRURfU0lHTkVEX1JHMTFfRUFDXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9SR0I4X0VUQzJcIl0gPSAzNzQ5Ml0gPSBcIkNPTVBSRVNTRURfUkdCOF9FVEMyXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQ1wiXSA9IDM3NDk2XSA9IFwiQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQ1wiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfU1JHQjhfRVRDMlwiXSA9IDM3NDkzXSA9IFwiQ09NUFJFU1NFRF9TUkdCOF9FVEMyXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfRVRDMl9FQUNcIl0gPSAzNzQ5N10gPSBcIkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0VUQzJfRUFDXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9SR0I4X1BVTkNIVEhST1VHSF9BTFBIQTFfRVRDMlwiXSA9IDM3NDk0XSA9IFwiQ09NUFJFU1NFRF9SR0I4X1BVTkNIVEhST1VHSF9BTFBIQTFfRVRDMlwiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfU1JHQjhfUFVOQ0hUSFJPVUdIX0FMUEhBMV9FVEMyXCJdID0gMzc0OTVdID0gXCJDT01QUkVTU0VEX1NSR0I4X1BVTkNIVEhST1VHSF9BTFBIQTFfRVRDMlwiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUdcIl0gPSAzNTg0MF0gPSBcIkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUdcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNR1wiXSA9IDM1ODQyXSA9IFwiQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUdcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HXCJdID0gMzU4NDFdID0gXCJDT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUdcIl0gPSAzNTg0M10gPSBcIkNPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9SR0JfRVRDMV9XRUJHTFwiXSA9IDM2MTk2XSA9IFwiQ09NUFJFU1NFRF9SR0JfRVRDMV9XRUJHTFwiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfUkdCX0FUQ19XRUJHTFwiXSA9IDM1OTg2XSA9IFwiQ09NUFJFU1NFRF9SR0JfQVRDX1dFQkdMXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9SR0JBX0FUQ19FWFBMSUNJVF9BTFBIQV9XRUJHTFwiXSA9IDM1OTg2XSA9IFwiQ09NUFJFU1NFRF9SR0JBX0FUQ19FWFBMSUNJVF9BTFBIQV9XRUJHTFwiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfUkdCQV9BVENfSU5URVJQT0xBVEVEX0FMUEhBX1dFQkdMXCJdID0gMzQ3OThdID0gXCJDT01QUkVTU0VEX1JHQkFfQVRDX0lOVEVSUE9MQVRFRF9BTFBIQV9XRUJHTFwiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfUkdCQV9BU1RDXzR4NF9LSFJcIl0gPSAzNzgwOF0gPSBcIkNPTVBSRVNTRURfUkdCQV9BU1RDXzR4NF9LSFJcIjtcbiAgcmV0dXJuIElOVEVSTkFMX0ZPUk1BVFMyO1xufSkoSU5URVJOQUxfRk9STUFUUyB8fCB7fSk7XG5jb25zdCBJTlRFUk5BTF9GT1JNQVRfVE9fQllURVNfUEVSX1BJWEVMID0ge1xuICBbMzM3NzYgLyogQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVCAqL106IDAuNSxcbiAgWzMzNzc3IC8qIENPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUICovXTogMC41LFxuICBbMzM3NzggLyogQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQgKi9dOiAxLFxuICBbMzM3NzkgLyogQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQgKi9dOiAxLFxuICBbMzU5MTYgLyogQ09NUFJFU1NFRF9TUkdCX1MzVENfRFhUMV9FWFQgKi9dOiAwLjUsXG4gIFszNTkxNyAvKiBDT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQxX0VYVCAqL106IDAuNSxcbiAgWzM1OTE4IC8qIENPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDNfRVhUICovXTogMSxcbiAgWzM1OTE5IC8qIENPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDVfRVhUICovXTogMSxcbiAgWzM3NDg4IC8qIENPTVBSRVNTRURfUjExX0VBQyAqL106IDAuNSxcbiAgWzM3NDg5IC8qIENPTVBSRVNTRURfU0lHTkVEX1IxMV9FQUMgKi9dOiAwLjUsXG4gIFszNzQ5MCAvKiBDT01QUkVTU0VEX1JHMTFfRUFDICovXTogMSxcbiAgWzM3NDkxIC8qIENPTVBSRVNTRURfU0lHTkVEX1JHMTFfRUFDICovXTogMSxcbiAgWzM3NDkyIC8qIENPTVBSRVNTRURfUkdCOF9FVEMyICovXTogMC41LFxuICBbMzc0OTYgLyogQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQyAqL106IDEsXG4gIFszNzQ5MyAvKiBDT01QUkVTU0VEX1NSR0I4X0VUQzIgKi9dOiAwLjUsXG4gIFszNzQ5NyAvKiBDT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9FVEMyX0VBQyAqL106IDEsXG4gIFszNzQ5NCAvKiBDT01QUkVTU0VEX1JHQjhfUFVOQ0hUSFJPVUdIX0FMUEhBMV9FVEMyICovXTogMC41LFxuICBbMzc0OTUgLyogQ09NUFJFU1NFRF9TUkdCOF9QVU5DSFRIUk9VR0hfQUxQSEExX0VUQzIgKi9dOiAwLjUsXG4gIFszNTg0MCAvKiBDT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HICovXTogMC41LFxuICBbMzU4NDIgLyogQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUcgKi9dOiAwLjUsXG4gIFszNTg0MSAvKiBDT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HICovXTogMC4yNSxcbiAgWzM1ODQzIC8qIENPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HICovXTogMC4yNSxcbiAgWzM2MTk2IC8qIENPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0wgKi9dOiAwLjUsXG4gIFszNTk4NiAvKiBDT01QUkVTU0VEX1JHQl9BVENfV0VCR0wgKi9dOiAwLjUsXG4gIFszNTk4NiAvKiBDT01QUkVTU0VEX1JHQkFfQVRDX0VYUExJQ0lUX0FMUEhBX1dFQkdMICovXTogMSxcbiAgWzM0Nzk4IC8qIENPTVBSRVNTRURfUkdCQV9BVENfSU5URVJQT0xBVEVEX0FMUEhBX1dFQkdMICovXTogMSxcbiAgWzM3ODA4IC8qIENPTVBSRVNTRURfUkdCQV9BU1RDXzR4NF9LSFIgKi9dOiAxXG59O1xuXG5leHBvcnRzLklOVEVSTkFMX0ZPUk1BVFMgPSBJTlRFUk5BTF9GT1JNQVRTO1xuZXhwb3J0cy5JTlRFUk5BTF9GT1JNQVRfVE9fQllURVNfUEVSX1BJWEVMID0gSU5URVJOQUxfRk9STUFUX1RPX0JZVEVTX1BFUl9QSVhFTDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi9jb25zdC5qcycpO1xucmVxdWlyZSgnLi9sb2FkZXJzL2luZGV4LmpzJyk7XG5yZXF1aXJlKCcuL3BhcnNlcnMvaW5kZXguanMnKTtcbnJlcXVpcmUoJy4vcmVzb3VyY2VzL2luZGV4LmpzJyk7XG52YXIgZGV0ZWN0Q29tcHJlc3NlZFRleHR1cmVzID0gcmVxdWlyZSgnLi9sb2FkZXJzL2RldGVjdENvbXByZXNzZWRUZXh0dXJlcy5qcycpO1xudmFyIGxvYWRERFMgPSByZXF1aXJlKCcuL2xvYWRlcnMvbG9hZEREUy5qcycpO1xudmFyIGxvYWRLVFggPSByZXF1aXJlKCcuL2xvYWRlcnMvbG9hZEtUWC5qcycpO1xudmFyIHJlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybCA9IHJlcXVpcmUoJy4vbG9hZGVycy9yZXNvbHZlQ29tcHJlc3NlZFRleHR1cmVVcmwuanMnKTtcbnZhciBwYXJzZUREUyA9IHJlcXVpcmUoJy4vcGFyc2Vycy9wYXJzZUREUy5qcycpO1xudmFyIHBhcnNlS1RYID0gcmVxdWlyZSgnLi9wYXJzZXJzL3BhcnNlS1RYLmpzJyk7XG52YXIgQmxvYlJlc291cmNlID0gcmVxdWlyZSgnLi9yZXNvdXJjZXMvQmxvYlJlc291cmNlLmpzJyk7XG52YXIgQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZSA9IHJlcXVpcmUoJy4vcmVzb3VyY2VzL0NvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UuanMnKTtcblxuXG5cbmV4cG9ydHMuSU5URVJOQUxfRk9STUFUUyA9IF9jb25zdC5JTlRFUk5BTF9GT1JNQVRTO1xuZXhwb3J0cy5JTlRFUk5BTF9GT1JNQVRfVE9fQllURVNfUEVSX1BJWEVMID0gX2NvbnN0LklOVEVSTkFMX0ZPUk1BVF9UT19CWVRFU19QRVJfUElYRUw7XG5leHBvcnRzLmRldGVjdENvbXByZXNzZWRUZXh0dXJlcyA9IGRldGVjdENvbXByZXNzZWRUZXh0dXJlcy5kZXRlY3RDb21wcmVzc2VkVGV4dHVyZXM7XG5leHBvcnRzLmxvYWRERFMgPSBsb2FkRERTLmxvYWRERFM7XG5leHBvcnRzLmxvYWRLVFggPSBsb2FkS1RYLmxvYWRLVFg7XG5leHBvcnRzLnJlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybCA9IHJlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybC5yZXNvbHZlQ29tcHJlc3NlZFRleHR1cmVVcmw7XG5leHBvcnRzLnBhcnNlRERTID0gcGFyc2VERFMucGFyc2VERFM7XG5leHBvcnRzLkZPUk1BVFNfVE9fQ09NUE9ORU5UUyA9IHBhcnNlS1RYLkZPUk1BVFNfVE9fQ09NUE9ORU5UUztcbmV4cG9ydHMuVFlQRVNfVE9fQllURVNfUEVSX0NPTVBPTkVOVCA9IHBhcnNlS1RYLlRZUEVTX1RPX0JZVEVTX1BFUl9DT01QT05FTlQ7XG5leHBvcnRzLlRZUEVTX1RPX0JZVEVTX1BFUl9QSVhFTCA9IHBhcnNlS1RYLlRZUEVTX1RPX0JZVEVTX1BFUl9QSVhFTDtcbmV4cG9ydHMucGFyc2VLVFggPSBwYXJzZUtUWC5wYXJzZUtUWDtcbmV4cG9ydHMuQmxvYlJlc291cmNlID0gQmxvYlJlc291cmNlLkJsb2JSZXNvdXJjZTtcbmV4cG9ydHMuQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZSA9IENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UuQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wcmVzc2VkVGV4dHVyZUV4dGVuc2lvbnMuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xuXG5sZXQgc3RvcmVkR2w7XG5sZXQgZXh0ZW5zaW9ucztcbmZ1bmN0aW9uIGdldENvbXByZXNzZWRUZXh0dXJlRXh0ZW5zaW9ucygpIHtcbiAgZXh0ZW5zaW9ucyA9IHtcbiAgICBzM3RjOiBzdG9yZWRHbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiKSxcbiAgICBzM3RjX3NSR0I6IHN0b3JlZEdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjX3NyZ2JcIiksXG4gICAgZXRjOiBzdG9yZWRHbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjXCIpLFxuICAgIGV0YzE6IHN0b3JlZEdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxXCIpLFxuICAgIHB2cnRjOiBzdG9yZWRHbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcIikgfHwgc3RvcmVkR2wuZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1wiKSxcbiAgICBhdGM6IHN0b3JlZEdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hdGNcIiksXG4gICAgYXN0Yzogc3RvcmVkR2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2FzdGNcIilcbiAgfTtcbn1cbmNvbnN0IGRldGVjdENvbXByZXNzZWRUZXh0dXJlcyA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogY29yZS5FeHRlbnNpb25UeXBlLkRldGVjdGlvblBhcnNlcixcbiAgICBwcmlvcml0eTogMlxuICB9LFxuICB0ZXN0OiBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY29yZS5zZXR0aW5ncy5BREFQVEVSLmNyZWF0ZUNhbnZhcygpO1xuICAgIGNvbnN0IGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiKTtcbiAgICBpZiAoIWdsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJXZWJHTCBub3QgYXZhaWxhYmxlIGZvciBjb21wcmVzc2VkIHRleHR1cmVzLlwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3RvcmVkR2wgPSBnbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgYWRkOiBhc3luYyAoZm9ybWF0cykgPT4ge1xuICAgIGlmICghZXh0ZW5zaW9ucylcbiAgICAgIGdldENvbXByZXNzZWRUZXh0dXJlRXh0ZW5zaW9ucygpO1xuICAgIGNvbnN0IHRleHR1cmVGb3JtYXRzID0gW107XG4gICAgZm9yIChjb25zdCBleHRlbnNpb25OYW1lIGluIGV4dGVuc2lvbnMpIHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV07XG4gICAgICBpZiAoIWV4dGVuc2lvbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRleHR1cmVGb3JtYXRzLnB1c2goZXh0ZW5zaW9uTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBbLi4udGV4dHVyZUZvcm1hdHMsIC4uLmZvcm1hdHNdO1xuICB9LFxuICByZW1vdmU6IGFzeW5jIChmb3JtYXRzKSA9PiB7XG4gICAgaWYgKCFleHRlbnNpb25zKVxuICAgICAgZ2V0Q29tcHJlc3NlZFRleHR1cmVFeHRlbnNpb25zKCk7XG4gICAgcmV0dXJuIGZvcm1hdHMuZmlsdGVyKChmKSA9PiAhKGYgaW4gZXh0ZW5zaW9ucykpO1xuICB9XG59O1xuY29yZS5leHRlbnNpb25zLmFkZChkZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMpO1xuXG5leHBvcnRzLmRldGVjdENvbXByZXNzZWRUZXh0dXJlcyA9IGRldGVjdENvbXByZXNzZWRUZXh0dXJlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdENvbXByZXNzZWRUZXh0dXJlcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxucmVxdWlyZSgnLi9jb21wcmVzc2VkVGV4dHVyZUV4dGVuc2lvbnMuanMnKTtcbnZhciBkZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMgPSByZXF1aXJlKCcuL2RldGVjdENvbXByZXNzZWRUZXh0dXJlcy5qcycpO1xudmFyIGxvYWRERFMgPSByZXF1aXJlKCcuL2xvYWRERFMuanMnKTtcbnZhciBsb2FkS1RYID0gcmVxdWlyZSgnLi9sb2FkS1RYLmpzJyk7XG52YXIgcmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsID0gcmVxdWlyZSgnLi9yZXNvbHZlQ29tcHJlc3NlZFRleHR1cmVVcmwuanMnKTtcblxuXG5cbmV4cG9ydHMuZGV0ZWN0Q29tcHJlc3NlZFRleHR1cmVzID0gZGV0ZWN0Q29tcHJlc3NlZFRleHR1cmVzLmRldGVjdENvbXByZXNzZWRUZXh0dXJlcztcbmV4cG9ydHMubG9hZEREUyA9IGxvYWRERFMubG9hZEREUztcbmV4cG9ydHMubG9hZEtUWCA9IGxvYWRLVFgubG9hZEtUWDtcbmV4cG9ydHMucmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsID0gcmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsLnJlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgYXNzZXRzID0gcmVxdWlyZSgnQHBpeGkvYXNzZXRzJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnJlcXVpcmUoJy4uL3BhcnNlcnMvaW5kZXguanMnKTtcbnZhciBwYXJzZUREUyA9IHJlcXVpcmUoJy4uL3BhcnNlcnMvcGFyc2VERFMuanMnKTtcblxuY29uc3QgbG9hZEREUyA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogY29yZS5FeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IGFzc2V0cy5Mb2FkZXJQYXJzZXJQcmlvcml0eS5IaWdoXG4gIH0sXG4gIG5hbWU6IFwibG9hZEREU1wiLFxuICB0ZXN0KHVybCkge1xuICAgIHJldHVybiBhc3NldHMuY2hlY2tFeHRlbnNpb24odXJsLCBcIi5kZHNcIik7XG4gIH0sXG4gIGFzeW5jIGxvYWQodXJsLCBhc3NldCwgbG9hZGVyKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb3JlLnNldHRpbmdzLkFEQVBURVIuZmV0Y2godXJsKTtcbiAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgY29uc3QgcmVzb3VyY2VzID0gcGFyc2VERFMucGFyc2VERFMoYXJyYXlCdWZmZXIpO1xuICAgIGNvbnN0IHRleHR1cmVzID0gcmVzb3VyY2VzLm1hcCgocmVzb3VyY2UpID0+IHtcbiAgICAgIGNvbnN0IGJhc2UgPSBuZXcgY29yZS5CYXNlVGV4dHVyZShyZXNvdXJjZSwge1xuICAgICAgICBtaXBtYXA6IGNvcmUuTUlQTUFQX01PREVTLk9GRixcbiAgICAgICAgYWxwaGFNb2RlOiBjb3JlLkFMUEhBX01PREVTLk5PX1BSRU1VTFRJUExJRURfQUxQSEEsXG4gICAgICAgIHJlc29sdXRpb246IGNvcmUudXRpbHMuZ2V0UmVzb2x1dGlvbk9mVXJsKHVybCksXG4gICAgICAgIC4uLmFzc2V0LmRhdGFcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFzc2V0cy5jcmVhdGVUZXh0dXJlKGJhc2UsIGxvYWRlciwgdXJsKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGV4dHVyZXMubGVuZ3RoID09PSAxID8gdGV4dHVyZXNbMF0gOiB0ZXh0dXJlcztcbiAgfSxcbiAgdW5sb2FkKHRleHR1cmUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0ZXh0dXJlKSkge1xuICAgICAgdGV4dHVyZS5mb3JFYWNoKCh0KSA9PiB0LmRlc3Ryb3kodHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0dXJlLmRlc3Ryb3kodHJ1ZSk7XG4gICAgfVxuICB9XG59O1xuY29yZS5leHRlbnNpb25zLmFkZChsb2FkRERTKTtcblxuZXhwb3J0cy5sb2FkRERTID0gbG9hZEREUztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRERFMuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBhc3NldHMgPSByZXF1aXJlKCdAcGl4aS9hc3NldHMnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xucmVxdWlyZSgnLi4vcGFyc2Vycy9pbmRleC5qcycpO1xudmFyIHBhcnNlS1RYID0gcmVxdWlyZSgnLi4vcGFyc2Vycy9wYXJzZUtUWC5qcycpO1xuXG5jb25zdCBsb2FkS1RYID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBjb3JlLkV4dGVuc2lvblR5cGUuTG9hZFBhcnNlcixcbiAgICBwcmlvcml0eTogYXNzZXRzLkxvYWRlclBhcnNlclByaW9yaXR5LkhpZ2hcbiAgfSxcbiAgbmFtZTogXCJsb2FkS1RYXCIsXG4gIHRlc3QodXJsKSB7XG4gICAgcmV0dXJuIGFzc2V0cy5jaGVja0V4dGVuc2lvbih1cmwsIFwiLmt0eFwiKTtcbiAgfSxcbiAgYXN5bmMgbG9hZCh1cmwsIGFzc2V0LCBsb2FkZXIpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvcmUuc2V0dGluZ3MuQURBUFRFUi5mZXRjaCh1cmwpO1xuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICBjb25zdCB7IGNvbXByZXNzZWQsIHVuY29tcHJlc3NlZCwga3ZEYXRhIH0gPSBwYXJzZUtUWC5wYXJzZUtUWCh1cmwsIGFycmF5QnVmZmVyKTtcbiAgICBjb25zdCByZXNvdXJjZXMgPSBjb21wcmVzc2VkID8/IHVuY29tcHJlc3NlZDtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgbWlwbWFwOiBjb3JlLk1JUE1BUF9NT0RFUy5PRkYsXG4gICAgICBhbHBoYU1vZGU6IGNvcmUuQUxQSEFfTU9ERVMuTk9fUFJFTVVMVElQTElFRF9BTFBIQSxcbiAgICAgIHJlc29sdXRpb246IGNvcmUudXRpbHMuZ2V0UmVzb2x1dGlvbk9mVXJsKHVybCksXG4gICAgICAuLi5hc3NldC5kYXRhXG4gICAgfTtcbiAgICBjb25zdCB0ZXh0dXJlcyA9IHJlc291cmNlcy5tYXAoKHJlc291cmNlKSA9PiB7XG4gICAgICBpZiAocmVzb3VyY2VzID09PSB1bmNvbXByZXNzZWQpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7XG4gICAgICAgICAgdHlwZTogcmVzb3VyY2UudHlwZSxcbiAgICAgICAgICBmb3JtYXQ6IHJlc291cmNlLmZvcm1hdFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJhc2UgPSBuZXcgY29yZS5CYXNlVGV4dHVyZShyZXNvdXJjZSwgb3B0aW9ucyk7XG4gICAgICBiYXNlLmt0eEtleVZhbHVlRGF0YSA9IGt2RGF0YTtcbiAgICAgIHJldHVybiBhc3NldHMuY3JlYXRlVGV4dHVyZShiYXNlLCBsb2FkZXIsIHVybCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRleHR1cmVzLmxlbmd0aCA9PT0gMSA/IHRleHR1cmVzWzBdIDogdGV4dHVyZXM7XG4gIH0sXG4gIHVubG9hZCh0ZXh0dXJlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGV4dHVyZSkpIHtcbiAgICAgIHRleHR1cmUuZm9yRWFjaCgodCkgPT4gdC5kZXN0cm95KHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dHVyZS5kZXN0cm95KHRydWUpO1xuICAgIH1cbiAgfVxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQobG9hZEtUWCk7XG5cbmV4cG9ydHMubG9hZEtUWCA9IGxvYWRLVFg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkS1RYLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcblxuY29uc3QgcmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsID0ge1xuICBleHRlbnNpb246IGNvcmUuRXh0ZW5zaW9uVHlwZS5SZXNvbHZlUGFyc2VyLFxuICB0ZXN0OiAodmFsdWUpID0+IHtcbiAgICBjb25zdCB0ZW1wID0gdmFsdWUuc3BsaXQoXCI/XCIpWzBdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRlbXAuc3BsaXQoXCIuXCIpLnBvcCgpO1xuICAgIHJldHVybiBbXCJiYXNpc1wiLCBcImt0eFwiLCBcImRkc1wiXS5pbmNsdWRlcyhleHRlbnNpb24pO1xuICB9LFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgdGVtcCA9IHZhbHVlLnNwbGl0KFwiP1wiKVswXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSB0ZW1wLnNwbGl0KFwiLlwiKS5wb3AoKTtcbiAgICBpZiAoZXh0ZW5zaW9uID09PSBcImt0eFwiKSB7XG4gICAgICBjb25zdCBleHRlbnNpb25zMiA9IFtcbiAgICAgICAgXCIuczN0Yy5rdHhcIixcbiAgICAgICAgXCIuczN0Y19zUkdCLmt0eFwiLFxuICAgICAgICBcIi5ldGMua3R4XCIsXG4gICAgICAgIFwiLmV0YzEua3R4XCIsXG4gICAgICAgIFwiLnB2cnQua3R4XCIsXG4gICAgICAgIFwiLmF0Yy5rdHhcIixcbiAgICAgICAgXCIuYXN0Yy5rdHhcIlxuICAgICAgXTtcbiAgICAgIGlmIChleHRlbnNpb25zMi5zb21lKChleHQpID0+IHZhbHVlLmVuZHNXaXRoKGV4dCkpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzb2x1dGlvbjogcGFyc2VGbG9hdChjb3JlLnNldHRpbmdzLlJFVElOQV9QUkVGSVguZXhlYyh2YWx1ZSk/LlsxXSA/PyBcIjFcIiksXG4gICAgICAgICAgZm9ybWF0OiBleHRlbnNpb25zMi5maW5kKChleHQpID0+IHZhbHVlLmVuZHNXaXRoKGV4dCkpLFxuICAgICAgICAgIHNyYzogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc29sdXRpb246IHBhcnNlRmxvYXQoY29yZS5zZXR0aW5ncy5SRVRJTkFfUFJFRklYLmV4ZWModmFsdWUpPy5bMV0gPz8gXCIxXCIpLFxuICAgICAgZm9ybWF0OiB2YWx1ZS5zcGxpdChcIi5cIikucG9wKCksXG4gICAgICBzcmM6IHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQocmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsKTtcblxuZXhwb3J0cy5yZXNvbHZlQ29tcHJlc3NlZFRleHR1cmVVcmwgPSByZXNvbHZlQ29tcHJlc3NlZFRleHR1cmVVcmw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlQ29tcHJlc3NlZFRleHR1cmVVcmwuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBwYXJzZUREUyA9IHJlcXVpcmUoJy4vcGFyc2VERFMuanMnKTtcbnZhciBwYXJzZUtUWCA9IHJlcXVpcmUoJy4vcGFyc2VLVFguanMnKTtcblxuXG5cbmV4cG9ydHMucGFyc2VERFMgPSBwYXJzZUREUy5wYXJzZUREUztcbmV4cG9ydHMuRk9STUFUU19UT19DT01QT05FTlRTID0gcGFyc2VLVFguRk9STUFUU19UT19DT01QT05FTlRTO1xuZXhwb3J0cy5UWVBFU19UT19CWVRFU19QRVJfQ09NUE9ORU5UID0gcGFyc2VLVFguVFlQRVNfVE9fQllURVNfUEVSX0NPTVBPTkVOVDtcbmV4cG9ydHMuVFlQRVNfVE9fQllURVNfUEVSX1BJWEVMID0gcGFyc2VLVFguVFlQRVNfVE9fQllURVNfUEVSX1BJWEVMO1xuZXhwb3J0cy5wYXJzZUtUWCA9IHBhcnNlS1RYLnBhcnNlS1RYO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi9jb25zdC5qcycpO1xucmVxdWlyZSgnLi4vcmVzb3VyY2VzL2luZGV4LmpzJyk7XG52YXIgQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZSA9IHJlcXVpcmUoJy4uL3Jlc291cmNlcy9Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlLmpzJyk7XG5cbmNvbnN0IEREU19NQUdJQ19TSVpFID0gNDtcbmNvbnN0IEREU19IRUFERVJfU0laRSA9IDEyNDtcbmNvbnN0IEREU19IRUFERVJfUEZfU0laRSA9IDMyO1xuY29uc3QgRERTX0hFQURFUl9EWDEwX1NJWkUgPSAyMDtcbmNvbnN0IEREU19NQUdJQyA9IDU0MjMyNzg3NjtcbmNvbnN0IEREU19GSUVMRFMgPSB7XG4gIFNJWkU6IDEsXG4gIEZMQUdTOiAyLFxuICBIRUlHSFQ6IDMsXG4gIFdJRFRIOiA0LFxuICBNSVBNQVBfQ09VTlQ6IDcsXG4gIFBJWEVMX0ZPUk1BVDogMTlcbn07XG5jb25zdCBERFNfUEZfRklFTERTID0ge1xuICBTSVpFOiAwLFxuICBGTEFHUzogMSxcbiAgRk9VUkNDOiAyLFxuICBSR0JfQklUQ09VTlQ6IDMsXG4gIFJfQklUX01BU0s6IDQsXG4gIEdfQklUX01BU0s6IDUsXG4gIEJfQklUX01BU0s6IDYsXG4gIEFfQklUX01BU0s6IDdcbn07XG5jb25zdCBERFNfRFgxMF9GSUVMRFMgPSB7XG4gIERYR0lfRk9STUFUOiAwLFxuICBSRVNPVVJDRV9ESU1FTlNJT046IDEsXG4gIE1JU0NfRkxBRzogMixcbiAgQVJSQVlfU0laRTogMyxcbiAgTUlTQ19GTEFHUzI6IDRcbn07XG52YXIgRFhHSV9GT1JNQVQgPSAvKiBAX19QVVJFX18gKi8gKChEWEdJX0ZPUk1BVDIpID0+IHtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1VOS05PV05cIl0gPSAwXSA9IFwiRFhHSV9GT1JNQVRfVU5LTk9XTlwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyRzMyQjMyQTMyX1RZUEVMRVNTXCJdID0gMV0gPSBcIkRYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9UWVBFTEVTU1wiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyRzMyQjMyQTMyX0ZMT0FUXCJdID0gMl0gPSBcIkRYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9GTE9BVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyRzMyQjMyQTMyX1VJTlRcIl0gPSAzXSA9IFwiRFhHSV9GT1JNQVRfUjMyRzMyQjMyQTMyX1VJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9TSU5UXCJdID0gNF0gPSBcIkRYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9TSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMzJHMzJCMzJfVFlQRUxFU1NcIl0gPSA1XSA9IFwiRFhHSV9GT1JNQVRfUjMyRzMyQjMyX1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMzJHMzJCMzJfRkxPQVRcIl0gPSA2XSA9IFwiRFhHSV9GT1JNQVRfUjMyRzMyQjMyX0ZMT0FUXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMzJHMzJCMzJfVUlOVFwiXSA9IDddID0gXCJEWEdJX0ZPUk1BVF9SMzJHMzJCMzJfVUlOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyRzMyQjMyX1NJTlRcIl0gPSA4XSA9IFwiRFhHSV9GT1JNQVRfUjMyRzMyQjMyX1NJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxNkcxNkIxNkExNl9UWVBFTEVTU1wiXSA9IDldID0gXCJEWEdJX0ZPUk1BVF9SMTZHMTZCMTZBMTZfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxNkcxNkIxNkExNl9GTE9BVFwiXSA9IDEwXSA9IFwiRFhHSV9GT1JNQVRfUjE2RzE2QjE2QTE2X0ZMT0FUXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTZHMTZCMTZBMTZfVU5PUk1cIl0gPSAxMV0gPSBcIkRYR0lfRk9STUFUX1IxNkcxNkIxNkExNl9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjE2RzE2QjE2QTE2X1VJTlRcIl0gPSAxMl0gPSBcIkRYR0lfRk9STUFUX1IxNkcxNkIxNkExNl9VSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTZHMTZCMTZBMTZfU05PUk1cIl0gPSAxM10gPSBcIkRYR0lfRk9STUFUX1IxNkcxNkIxNkExNl9TTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjE2RzE2QjE2QTE2X1NJTlRcIl0gPSAxNF0gPSBcIkRYR0lfRk9STUFUX1IxNkcxNkIxNkExNl9TSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMzJHMzJfVFlQRUxFU1NcIl0gPSAxNV0gPSBcIkRYR0lfRk9STUFUX1IzMkczMl9UWVBFTEVTU1wiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyRzMyX0ZMT0FUXCJdID0gMTZdID0gXCJEWEdJX0ZPUk1BVF9SMzJHMzJfRkxPQVRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IzMkczMl9VSU5UXCJdID0gMTddID0gXCJEWEdJX0ZPUk1BVF9SMzJHMzJfVUlOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyRzMyX1NJTlRcIl0gPSAxOF0gPSBcIkRYR0lfRk9STUFUX1IzMkczMl9TSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMzJHOFgyNF9UWVBFTEVTU1wiXSA9IDE5XSA9IFwiRFhHSV9GT1JNQVRfUjMyRzhYMjRfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0QzMl9GTE9BVF9TOFgyNF9VSU5UXCJdID0gMjBdID0gXCJEWEdJX0ZPUk1BVF9EMzJfRkxPQVRfUzhYMjRfVUlOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyX0ZMT0FUX1g4WDI0X1RZUEVMRVNTXCJdID0gMjFdID0gXCJEWEdJX0ZPUk1BVF9SMzJfRkxPQVRfWDhYMjRfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1gzMl9UWVBFTEVTU19HOFgyNF9VSU5UXCJdID0gMjJdID0gXCJEWEdJX0ZPUk1BVF9YMzJfVFlQRUxFU1NfRzhYMjRfVUlOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjEwRzEwQjEwQTJfVFlQRUxFU1NcIl0gPSAyM10gPSBcIkRYR0lfRk9STUFUX1IxMEcxMEIxMEEyX1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTBHMTBCMTBBMl9VTk9STVwiXSA9IDI0XSA9IFwiRFhHSV9GT1JNQVRfUjEwRzEwQjEwQTJfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxMEcxMEIxMEEyX1VJTlRcIl0gPSAyNV0gPSBcIkRYR0lfRk9STUFUX1IxMEcxMEIxMEEyX1VJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxMUcxMUIxMF9GTE9BVFwiXSA9IDI2XSA9IFwiRFhHSV9GT1JNQVRfUjExRzExQjEwX0ZMT0FUXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SOEc4QjhBOF9UWVBFTEVTU1wiXSA9IDI3XSA9IFwiRFhHSV9GT1JNQVRfUjhHOEI4QThfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1I4RzhCOEE4X1VOT1JNXCJdID0gMjhdID0gXCJEWEdJX0ZPUk1BVF9SOEc4QjhBOF9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjhHOEI4QThfVU5PUk1fU1JHQlwiXSA9IDI5XSA9IFwiRFhHSV9GT1JNQVRfUjhHOEI4QThfVU5PUk1fU1JHQlwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjhHOEI4QThfVUlOVFwiXSA9IDMwXSA9IFwiRFhHSV9GT1JNQVRfUjhHOEI4QThfVUlOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjhHOEI4QThfU05PUk1cIl0gPSAzMV0gPSBcIkRYR0lfRk9STUFUX1I4RzhCOEE4X1NOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SOEc4QjhBOF9TSU5UXCJdID0gMzJdID0gXCJEWEdJX0ZPUk1BVF9SOEc4QjhBOF9TSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTZHMTZfVFlQRUxFU1NcIl0gPSAzM10gPSBcIkRYR0lfRk9STUFUX1IxNkcxNl9UWVBFTEVTU1wiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjE2RzE2X0ZMT0FUXCJdID0gMzRdID0gXCJEWEdJX0ZPUk1BVF9SMTZHMTZfRkxPQVRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxNkcxNl9VTk9STVwiXSA9IDM1XSA9IFwiRFhHSV9GT1JNQVRfUjE2RzE2X1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTZHMTZfVUlOVFwiXSA9IDM2XSA9IFwiRFhHSV9GT1JNQVRfUjE2RzE2X1VJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxNkcxNl9TTk9STVwiXSA9IDM3XSA9IFwiRFhHSV9GT1JNQVRfUjE2RzE2X1NOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTZHMTZfU0lOVFwiXSA9IDM4XSA9IFwiRFhHSV9GT1JNQVRfUjE2RzE2X1NJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IzMl9UWVBFTEVTU1wiXSA9IDM5XSA9IFwiRFhHSV9GT1JNQVRfUjMyX1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9EMzJfRkxPQVRcIl0gPSA0MF0gPSBcIkRYR0lfRk9STUFUX0QzMl9GTE9BVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyX0ZMT0FUXCJdID0gNDFdID0gXCJEWEdJX0ZPUk1BVF9SMzJfRkxPQVRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IzMl9VSU5UXCJdID0gNDJdID0gXCJEWEdJX0ZPUk1BVF9SMzJfVUlOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyX1NJTlRcIl0gPSA0M10gPSBcIkRYR0lfRk9STUFUX1IzMl9TSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMjRHOF9UWVBFTEVTU1wiXSA9IDQ0XSA9IFwiRFhHSV9GT1JNQVRfUjI0RzhfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0QyNF9VTk9STV9TOF9VSU5UXCJdID0gNDVdID0gXCJEWEdJX0ZPUk1BVF9EMjRfVU5PUk1fUzhfVUlOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjI0X1VOT1JNX1g4X1RZUEVMRVNTXCJdID0gNDZdID0gXCJEWEdJX0ZPUk1BVF9SMjRfVU5PUk1fWDhfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1gyNF9UWVBFTEVTU19HOF9VSU5UXCJdID0gNDddID0gXCJEWEdJX0ZPUk1BVF9YMjRfVFlQRUxFU1NfRzhfVUlOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjhHOF9UWVBFTEVTU1wiXSA9IDQ4XSA9IFwiRFhHSV9GT1JNQVRfUjhHOF9UWVBFTEVTU1wiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjhHOF9VTk9STVwiXSA9IDQ5XSA9IFwiRFhHSV9GT1JNQVRfUjhHOF9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjhHOF9VSU5UXCJdID0gNTBdID0gXCJEWEdJX0ZPUk1BVF9SOEc4X1VJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1I4RzhfU05PUk1cIl0gPSA1MV0gPSBcIkRYR0lfRk9STUFUX1I4RzhfU05PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1I4RzhfU0lOVFwiXSA9IDUyXSA9IFwiRFhHSV9GT1JNQVRfUjhHOF9TSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTZfVFlQRUxFU1NcIl0gPSA1M10gPSBcIkRYR0lfRk9STUFUX1IxNl9UWVBFTEVTU1wiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjE2X0ZMT0FUXCJdID0gNTRdID0gXCJEWEdJX0ZPUk1BVF9SMTZfRkxPQVRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0QxNl9VTk9STVwiXSA9IDU1XSA9IFwiRFhHSV9GT1JNQVRfRDE2X1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTZfVU5PUk1cIl0gPSA1Nl0gPSBcIkRYR0lfRk9STUFUX1IxNl9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjE2X1VJTlRcIl0gPSA1N10gPSBcIkRYR0lfRk9STUFUX1IxNl9VSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTZfU05PUk1cIl0gPSA1OF0gPSBcIkRYR0lfRk9STUFUX1IxNl9TTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjE2X1NJTlRcIl0gPSA1OV0gPSBcIkRYR0lfRk9STUFUX1IxNl9TSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SOF9UWVBFTEVTU1wiXSA9IDYwXSA9IFwiRFhHSV9GT1JNQVRfUjhfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1I4X1VOT1JNXCJdID0gNjFdID0gXCJEWEdJX0ZPUk1BVF9SOF9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjhfVUlOVFwiXSA9IDYyXSA9IFwiRFhHSV9GT1JNQVRfUjhfVUlOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjhfU05PUk1cIl0gPSA2M10gPSBcIkRYR0lfRk9STUFUX1I4X1NOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SOF9TSU5UXCJdID0gNjRdID0gXCJEWEdJX0ZPUk1BVF9SOF9TSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9BOF9VTk9STVwiXSA9IDY1XSA9IFwiRFhHSV9GT1JNQVRfQThfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxX1VOT1JNXCJdID0gNjZdID0gXCJEWEdJX0ZPUk1BVF9SMV9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjlHOUI5RTVfU0hBUkVERVhQXCJdID0gNjddID0gXCJEWEdJX0ZPUk1BVF9SOUc5QjlFNV9TSEFSRURFWFBcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1I4RzhfQjhHOF9VTk9STVwiXSA9IDY4XSA9IFwiRFhHSV9GT1JNQVRfUjhHOF9COEc4X1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9HOFI4X0c4QjhfVU5PUk1cIl0gPSA2OV0gPSBcIkRYR0lfRk9STUFUX0c4UjhfRzhCOF9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQkMxX1RZUEVMRVNTXCJdID0gNzBdID0gXCJEWEdJX0ZPUk1BVF9CQzFfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDMV9VTk9STVwiXSA9IDcxXSA9IFwiRFhHSV9GT1JNQVRfQkMxX1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzFfVU5PUk1fU1JHQlwiXSA9IDcyXSA9IFwiRFhHSV9GT1JNQVRfQkMxX1VOT1JNX1NSR0JcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDMl9UWVBFTEVTU1wiXSA9IDczXSA9IFwiRFhHSV9GT1JNQVRfQkMyX1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzJfVU5PUk1cIl0gPSA3NF0gPSBcIkRYR0lfRk9STUFUX0JDMl9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQkMyX1VOT1JNX1NSR0JcIl0gPSA3NV0gPSBcIkRYR0lfRk9STUFUX0JDMl9VTk9STV9TUkdCXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzNfVFlQRUxFU1NcIl0gPSA3Nl0gPSBcIkRYR0lfRk9STUFUX0JDM19UWVBFTEVTU1wiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQkMzX1VOT1JNXCJdID0gNzddID0gXCJEWEdJX0ZPUk1BVF9CQzNfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDM19VTk9STV9TUkdCXCJdID0gNzhdID0gXCJEWEdJX0ZPUk1BVF9CQzNfVU5PUk1fU1JHQlwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQkM0X1RZUEVMRVNTXCJdID0gNzldID0gXCJEWEdJX0ZPUk1BVF9CQzRfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDNF9VTk9STVwiXSA9IDgwXSA9IFwiRFhHSV9GT1JNQVRfQkM0X1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzRfU05PUk1cIl0gPSA4MV0gPSBcIkRYR0lfRk9STUFUX0JDNF9TTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQkM1X1RZUEVMRVNTXCJdID0gODJdID0gXCJEWEdJX0ZPUk1BVF9CQzVfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDNV9VTk9STVwiXSA9IDgzXSA9IFwiRFhHSV9GT1JNQVRfQkM1X1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzVfU05PUk1cIl0gPSA4NF0gPSBcIkRYR0lfRk9STUFUX0JDNV9TTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQjVHNlI1X1VOT1JNXCJdID0gODVdID0gXCJEWEdJX0ZPUk1BVF9CNUc2UjVfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0I1RzVSNUExX1VOT1JNXCJdID0gODZdID0gXCJEWEdJX0ZPUk1BVF9CNUc1UjVBMV9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQjhHOFI4QThfVU5PUk1cIl0gPSA4N10gPSBcIkRYR0lfRk9STUFUX0I4RzhSOEE4X1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9COEc4UjhYOF9VTk9STVwiXSA9IDg4XSA9IFwiRFhHSV9GT1JNQVRfQjhHOFI4WDhfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxMEcxMEIxMF9YUl9CSUFTX0EyX1VOT1JNXCJdID0gODldID0gXCJEWEdJX0ZPUk1BVF9SMTBHMTBCMTBfWFJfQklBU19BMl9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQjhHOFI4QThfVFlQRUxFU1NcIl0gPSA5MF0gPSBcIkRYR0lfRk9STUFUX0I4RzhSOEE4X1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9COEc4UjhBOF9VTk9STV9TUkdCXCJdID0gOTFdID0gXCJEWEdJX0ZPUk1BVF9COEc4UjhBOF9VTk9STV9TUkdCXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9COEc4UjhYOF9UWVBFTEVTU1wiXSA9IDkyXSA9IFwiRFhHSV9GT1JNQVRfQjhHOFI4WDhfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0I4RzhSOFg4X1VOT1JNX1NSR0JcIl0gPSA5M10gPSBcIkRYR0lfRk9STUFUX0I4RzhSOFg4X1VOT1JNX1NSR0JcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDNkhfVFlQRUxFU1NcIl0gPSA5NF0gPSBcIkRYR0lfRk9STUFUX0JDNkhfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDNkhfVUYxNlwiXSA9IDk1XSA9IFwiRFhHSV9GT1JNQVRfQkM2SF9VRjE2XCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzZIX1NGMTZcIl0gPSA5Nl0gPSBcIkRYR0lfRk9STUFUX0JDNkhfU0YxNlwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQkM3X1RZUEVMRVNTXCJdID0gOTddID0gXCJEWEdJX0ZPUk1BVF9CQzdfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDN19VTk9STVwiXSA9IDk4XSA9IFwiRFhHSV9GT1JNQVRfQkM3X1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzdfVU5PUk1fU1JHQlwiXSA9IDk5XSA9IFwiRFhHSV9GT1JNQVRfQkM3X1VOT1JNX1NSR0JcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0FZVVZcIl0gPSAxMDBdID0gXCJEWEdJX0ZPUk1BVF9BWVVWXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9ZNDEwXCJdID0gMTAxXSA9IFwiRFhHSV9GT1JNQVRfWTQxMFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfWTQxNlwiXSA9IDEwMl0gPSBcIkRYR0lfRk9STUFUX1k0MTZcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX05WMTJcIl0gPSAxMDNdID0gXCJEWEdJX0ZPUk1BVF9OVjEyXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9QMDEwXCJdID0gMTA0XSA9IFwiRFhHSV9GT1JNQVRfUDAxMFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUDAxNlwiXSA9IDEwNV0gPSBcIkRYR0lfRk9STUFUX1AwMTZcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUXzQyMF9PUEFRVUVcIl0gPSAxMDZdID0gXCJEWEdJX0ZPUk1BVF80MjBfT1BBUVVFXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9ZVVkyXCJdID0gMTA3XSA9IFwiRFhHSV9GT1JNQVRfWVVZMlwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfWTIxMFwiXSA9IDEwOF0gPSBcIkRYR0lfRk9STUFUX1kyMTBcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1kyMTZcIl0gPSAxMDldID0gXCJEWEdJX0ZPUk1BVF9ZMjE2XCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9OVjExXCJdID0gMTEwXSA9IFwiRFhHSV9GT1JNQVRfTlYxMVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQUk0NFwiXSA9IDExMV0gPSBcIkRYR0lfRk9STUFUX0FJNDRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0lBNDRcIl0gPSAxMTJdID0gXCJEWEdJX0ZPUk1BVF9JQTQ0XCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9QOFwiXSA9IDExM10gPSBcIkRYR0lfRk9STUFUX1A4XCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9BOFA4XCJdID0gMTE0XSA9IFwiRFhHSV9GT1JNQVRfQThQOFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQjRHNFI0QTRfVU5PUk1cIl0gPSAxMTVdID0gXCJEWEdJX0ZPUk1BVF9CNEc0UjRBNF9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUDIwOFwiXSA9IDExNl0gPSBcIkRYR0lfRk9STUFUX1AyMDhcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1YyMDhcIl0gPSAxMTddID0gXCJEWEdJX0ZPUk1BVF9WMjA4XCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9WNDA4XCJdID0gMTE4XSA9IFwiRFhHSV9GT1JNQVRfVjQwOFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfU0FNUExFUl9GRUVEQkFDS19NSU5fTUlQX09QQVFVRVwiXSA9IDExOV0gPSBcIkRYR0lfRk9STUFUX1NBTVBMRVJfRkVFREJBQ0tfTUlOX01JUF9PUEFRVUVcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1NBTVBMRVJfRkVFREJBQ0tfTUlQX1JFR0lPTl9VU0VEX09QQVFVRVwiXSA9IDEyMF0gPSBcIkRYR0lfRk9STUFUX1NBTVBMRVJfRkVFREJBQ0tfTUlQX1JFR0lPTl9VU0VEX09QQVFVRVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfRk9SQ0VfVUlOVFwiXSA9IDEyMV0gPSBcIkRYR0lfRk9STUFUX0ZPUkNFX1VJTlRcIjtcbiAgcmV0dXJuIERYR0lfRk9STUFUMjtcbn0pKERYR0lfRk9STUFUIHx8IHt9KTtcbnZhciBEM0QxMF9SRVNPVVJDRV9ESU1FTlNJT04gPSAvKiBAX19QVVJFX18gKi8gKChEM0QxMF9SRVNPVVJDRV9ESU1FTlNJT04yKSA9PiB7XG4gIEQzRDEwX1JFU09VUkNFX0RJTUVOU0lPTjJbRDNEMTBfUkVTT1VSQ0VfRElNRU5TSU9OMltcIkREU19ESU1FTlNJT05fVEVYVFVSRTFEXCJdID0gMl0gPSBcIkREU19ESU1FTlNJT05fVEVYVFVSRTFEXCI7XG4gIEQzRDEwX1JFU09VUkNFX0RJTUVOU0lPTjJbRDNEMTBfUkVTT1VSQ0VfRElNRU5TSU9OMltcIkREU19ESU1FTlNJT05fVEVYVFVSRTJEXCJdID0gM10gPSBcIkREU19ESU1FTlNJT05fVEVYVFVSRTJEXCI7XG4gIEQzRDEwX1JFU09VUkNFX0RJTUVOU0lPTjJbRDNEMTBfUkVTT1VSQ0VfRElNRU5TSU9OMltcIkREU19ESU1FTlNJT05fVEVYVFVSRTNEXCJdID0gNl0gPSBcIkREU19ESU1FTlNJT05fVEVYVFVSRTNEXCI7XG4gIHJldHVybiBEM0QxMF9SRVNPVVJDRV9ESU1FTlNJT04yO1xufSkoRDNEMTBfUkVTT1VSQ0VfRElNRU5TSU9OIHx8IHt9KTtcbmNvbnN0IFBGX0ZMQUdTID0gMTtcbmNvbnN0IEREUEZfQUxQSEEgPSAyO1xuY29uc3QgRERQRl9GT1VSQ0MgPSA0O1xuY29uc3QgRERQRl9SR0IgPSA2NDtcbmNvbnN0IEREUEZfWVVWID0gNTEyO1xuY29uc3QgRERQRl9MVU1JTkFOQ0UgPSAxMzEwNzI7XG5jb25zdCBGT1VSQ0NfRFhUMSA9IDgyNzYxMTIwNDtcbmNvbnN0IEZPVVJDQ19EWFQzID0gODYxMTY1NjM2O1xuY29uc3QgRk9VUkNDX0RYVDUgPSA4OTQ3MjAwNjg7XG5jb25zdCBGT1VSQ0NfRFgxMCA9IDgwODU0MDIyODtcbmNvbnN0IEREU19SRVNPVVJDRV9NSVNDX1RFWFRVUkVDVUJFID0gNDtcbmNvbnN0IEZPVVJDQ19UT19GT1JNQVQgPSB7XG4gIFtGT1VSQ0NfRFhUMV06IF9jb25zdC5JTlRFUk5BTF9GT1JNQVRTLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhULFxuICBbRk9VUkNDX0RYVDNdOiBfY29uc3QuSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVCxcbiAgW0ZPVVJDQ19EWFQ1XTogX2NvbnN0LklOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFRcbn07XG5jb25zdCBEWEdJX1RPX0ZPUk1BVCA9IHtcbiAgWzcwIC8qIERYR0lfRk9STUFUX0JDMV9UWVBFTEVTUyAqL106IF9jb25zdC5JTlRFUk5BTF9GT1JNQVRTLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhULFxuICBbNzEgLyogRFhHSV9GT1JNQVRfQkMxX1VOT1JNICovXTogX2NvbnN0LklOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQsXG4gIFs3MyAvKiBEWEdJX0ZPUk1BVF9CQzJfVFlQRUxFU1MgKi9dOiBfY29uc3QuSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVCxcbiAgWzc0IC8qIERYR0lfRk9STUFUX0JDMl9VTk9STSAqL106IF9jb25zdC5JTlRFUk5BTF9GT1JNQVRTLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhULFxuICBbNzYgLyogRFhHSV9GT1JNQVRfQkMzX1RZUEVMRVNTICovXTogX2NvbnN0LklOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQsXG4gIFs3NyAvKiBEWEdJX0ZPUk1BVF9CQzNfVU5PUk0gKi9dOiBfY29uc3QuSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVCxcbiAgWzcyIC8qIERYR0lfRk9STUFUX0JDMV9VTk9STV9TUkdCICovXTogX2NvbnN0LklOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUMV9FWFQsXG4gIFs3NSAvKiBEWEdJX0ZPUk1BVF9CQzJfVU5PUk1fU1JHQiAqL106IF9jb25zdC5JTlRFUk5BTF9GT1JNQVRTLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDNfRVhULFxuICBbNzggLyogRFhHSV9GT1JNQVRfQkMzX1VOT1JNX1NSR0IgKi9dOiBfY29uc3QuSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQ1X0VYVFxufTtcbmZ1bmN0aW9uIHBhcnNlRERTKGFycmF5QnVmZmVyKSB7XG4gIGNvbnN0IGRhdGEgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWZmZXIpO1xuICBjb25zdCBtYWdpY1dvcmQgPSBkYXRhWzBdO1xuICBpZiAobWFnaWNXb3JkICE9PSBERFNfTUFHSUMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEREUyBmaWxlIG1hZ2ljIHdvcmRcIik7XG4gIH1cbiAgY29uc3QgaGVhZGVyID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyLCAwLCBERFNfSEVBREVSX1NJWkUgLyBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gIGNvbnN0IGhlaWdodCA9IGhlYWRlcltERFNfRklFTERTLkhFSUdIVF07XG4gIGNvbnN0IHdpZHRoID0gaGVhZGVyW0REU19GSUVMRFMuV0lEVEhdO1xuICBjb25zdCBtaXBtYXBDb3VudCA9IGhlYWRlcltERFNfRklFTERTLk1JUE1BUF9DT1VOVF07XG4gIGNvbnN0IHBpeGVsRm9ybWF0ID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyLCBERFNfRklFTERTLlBJWEVMX0ZPUk1BVCAqIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCBERFNfSEVBREVSX1BGX1NJWkUgLyBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gIGNvbnN0IGZvcm1hdEZsYWdzID0gcGl4ZWxGb3JtYXRbUEZfRkxBR1NdO1xuICBpZiAoZm9ybWF0RmxhZ3MgJiBERFBGX0ZPVVJDQykge1xuICAgIGNvbnN0IGZvdXJDQyA9IHBpeGVsRm9ybWF0W0REU19QRl9GSUVMRFMuRk9VUkNDXTtcbiAgICBpZiAoZm91ckNDICE9PSBGT1VSQ0NfRFgxMCkge1xuICAgICAgY29uc3QgaW50ZXJuYWxGb3JtYXQyID0gRk9VUkNDX1RPX0ZPUk1BVFtmb3VyQ0NdO1xuICAgICAgY29uc3QgZGF0YU9mZnNldDIgPSBERFNfTUFHSUNfU0laRSArIEREU19IRUFERVJfU0laRTtcbiAgICAgIGNvbnN0IHRleERhdGEgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciwgZGF0YU9mZnNldDIpO1xuICAgICAgY29uc3QgcmVzb3VyY2UgPSBuZXcgQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlKHRleERhdGEsIHtcbiAgICAgICAgZm9ybWF0OiBpbnRlcm5hbEZvcm1hdDIsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGxldmVsczogbWlwbWFwQ291bnRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtyZXNvdXJjZV07XG4gICAgfVxuICAgIGNvbnN0IGR4MTBPZmZzZXQgPSBERFNfTUFHSUNfU0laRSArIEREU19IRUFERVJfU0laRTtcbiAgICBjb25zdCBkeDEwSGVhZGVyID0gbmV3IFVpbnQzMkFycmF5KGRhdGEuYnVmZmVyLCBkeDEwT2Zmc2V0LCBERFNfSEVBREVSX0RYMTBfU0laRSAvIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgICBjb25zdCBkeGdpRm9ybWF0ID0gZHgxMEhlYWRlcltERFNfRFgxMF9GSUVMRFMuRFhHSV9GT1JNQVRdO1xuICAgIGNvbnN0IHJlc291cmNlRGltZW5zaW9uID0gZHgxMEhlYWRlcltERFNfRFgxMF9GSUVMRFMuUkVTT1VSQ0VfRElNRU5TSU9OXTtcbiAgICBjb25zdCBtaXNjRmxhZyA9IGR4MTBIZWFkZXJbRERTX0RYMTBfRklFTERTLk1JU0NfRkxBR107XG4gICAgY29uc3QgYXJyYXlTaXplID0gZHgxMEhlYWRlcltERFNfRFgxMF9GSUVMRFMuQVJSQVlfU0laRV07XG4gICAgY29uc3QgaW50ZXJuYWxGb3JtYXQgPSBEWEdJX1RPX0ZPUk1BVFtkeGdpRm9ybWF0XTtcbiAgICBpZiAoaW50ZXJuYWxGb3JtYXQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBERFNQYXJzZXIgY2Fubm90IHBhcnNlIHRleHR1cmUgZGF0YSB3aXRoIERYR0kgZm9ybWF0ICR7ZHhnaUZvcm1hdH1gKTtcbiAgICB9XG4gICAgaWYgKG1pc2NGbGFnID09PSBERFNfUkVTT1VSQ0VfTUlTQ19URVhUVVJFQ1VCRSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRERTUGFyc2VyIGRvZXMgbm90IHN1cHBvcnQgY3ViZW1hcCB0ZXh0dXJlc1wiKTtcbiAgICB9XG4gICAgaWYgKHJlc291cmNlRGltZW5zaW9uID09PSA2IC8qIEREU19ESU1FTlNJT05fVEVYVFVSRTNEICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJERFNQYXJzZXIgZG9lcyBub3Qgc3VwcG9ydGVkIDNEIHRleHR1cmUgZGF0YVwiKTtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VCdWZmZXJzID0gbmV3IEFycmF5KCk7XG4gICAgY29uc3QgZGF0YU9mZnNldCA9IEREU19NQUdJQ19TSVpFICsgRERTX0hFQURFUl9TSVpFICsgRERTX0hFQURFUl9EWDEwX1NJWkU7XG4gICAgaWYgKGFycmF5U2l6ZSA9PT0gMSkge1xuICAgICAgaW1hZ2VCdWZmZXJzLnB1c2gobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGl4ZWxTaXplID0gX2NvbnN0LklOVEVSTkFMX0ZPUk1BVF9UT19CWVRFU19QRVJfUElYRUxbaW50ZXJuYWxGb3JtYXRdO1xuICAgICAgbGV0IGltYWdlU2l6ZSA9IDA7XG4gICAgICBsZXQgbGV2ZWxXaWR0aCA9IHdpZHRoO1xuICAgICAgbGV0IGxldmVsSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaXBtYXBDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFsaWduZWRMZXZlbFdpZHRoID0gTWF0aC5tYXgoMSwgbGV2ZWxXaWR0aCArIDMgJiB+Myk7XG4gICAgICAgIGNvbnN0IGFsaWduZWRMZXZlbEhlaWdodCA9IE1hdGgubWF4KDEsIGxldmVsSGVpZ2h0ICsgMyAmIH4zKTtcbiAgICAgICAgY29uc3QgbGV2ZWxTaXplID0gYWxpZ25lZExldmVsV2lkdGggKiBhbGlnbmVkTGV2ZWxIZWlnaHQgKiBwaXhlbFNpemU7XG4gICAgICAgIGltYWdlU2l6ZSArPSBsZXZlbFNpemU7XG4gICAgICAgIGxldmVsV2lkdGggPSBsZXZlbFdpZHRoID4+PiAxO1xuICAgICAgICBsZXZlbEhlaWdodCA9IGxldmVsSGVpZ2h0ID4+PiAxO1xuICAgICAgfVxuICAgICAgbGV0IGltYWdlT2Zmc2V0ID0gZGF0YU9mZnNldDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlTaXplOyBpKyspIHtcbiAgICAgICAgaW1hZ2VCdWZmZXJzLnB1c2gobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIGltYWdlT2Zmc2V0LCBpbWFnZVNpemUpKTtcbiAgICAgICAgaW1hZ2VPZmZzZXQgKz0gaW1hZ2VTaXplO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW1hZ2VCdWZmZXJzLm1hcCgoYnVmZmVyKSA9PiBuZXcgQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlKGJ1ZmZlciwge1xuICAgICAgZm9ybWF0OiBpbnRlcm5hbEZvcm1hdCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbGV2ZWxzOiBtaXBtYXBDb3VudFxuICAgIH0pKTtcbiAgfVxuICBpZiAoZm9ybWF0RmxhZ3MgJiBERFBGX1JHQikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkREU1BhcnNlciBkb2VzIG5vdCBzdXBwb3J0IHVuY29tcHJlc3NlZCB0ZXh0dXJlIGRhdGEuXCIpO1xuICB9XG4gIGlmIChmb3JtYXRGbGFncyAmIEREUEZfWVVWKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRERTUGFyc2VyIGRvZXMgbm90IHN1cHBvcnRlZCBZVVYgdW5jb21wcmVzc2VkIHRleHR1cmUgZGF0YS5cIik7XG4gIH1cbiAgaWYgKGZvcm1hdEZsYWdzICYgRERQRl9MVU1JTkFOQ0UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJERFNQYXJzZXIgZG9lcyBub3Qgc3VwcG9ydCBzaW5nbGUtY2hhbm5lbCAobHVtbmluYW5jZSkgdGV4dHVyZSBkYXRhIVwiKTtcbiAgfVxuICBpZiAoZm9ybWF0RmxhZ3MgJiBERFBGX0FMUEhBKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRERTUGFyc2VyIGRvZXMgbm90IHN1cHBvcnQgc2luZ2xlLWNoYW5uZWwgKGFscGhhKSB0ZXh0dXJlIGRhdGEhXCIpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkREU1BhcnNlciBmYWlsZWQgdG8gbG9hZCBhIHRleHR1cmUgZmlsZSBkdWUgdG8gYW4gdW5rbm93biByZWFzb24hXCIpO1xufVxuXG5leHBvcnRzLnBhcnNlRERTID0gcGFyc2VERFM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZUREUy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QuanMnKTtcbnJlcXVpcmUoJy4uL3Jlc291cmNlcy9pbmRleC5qcycpO1xudmFyIENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UgPSByZXF1aXJlKCcuLi9yZXNvdXJjZXMvQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5qcycpO1xuXG5jb25zdCBGSUxFX0lERU5USUZJRVIgPSBbMTcxLCA3NSwgODQsIDg4LCAzMiwgNDksIDQ5LCAxODcsIDEzLCAxMCwgMjYsIDEwXTtcbmNvbnN0IEVORElBTk5FU1MgPSA2NzMwNTk4NTtcbmNvbnN0IEtUWF9GSUVMRFMgPSB7XG4gIEZJTEVfSURFTlRJRklFUjogMCxcbiAgRU5ESUFOTkVTUzogMTIsXG4gIEdMX1RZUEU6IDE2LFxuICBHTF9UWVBFX1NJWkU6IDIwLFxuICBHTF9GT1JNQVQ6IDI0LFxuICBHTF9JTlRFUk5BTF9GT1JNQVQ6IDI4LFxuICBHTF9CQVNFX0lOVEVSTkFMX0ZPUk1BVDogMzIsXG4gIFBJWEVMX1dJRFRIOiAzNixcbiAgUElYRUxfSEVJR0hUOiA0MCxcbiAgUElYRUxfREVQVEg6IDQ0LFxuICBOVU1CRVJfT0ZfQVJSQVlfRUxFTUVOVFM6IDQ4LFxuICBOVU1CRVJfT0ZfRkFDRVM6IDUyLFxuICBOVU1CRVJfT0ZfTUlQTUFQX0xFVkVMUzogNTYsXG4gIEJZVEVTX09GX0tFWV9WQUxVRV9EQVRBOiA2MFxufTtcbmNvbnN0IEZJTEVfSEVBREVSX1NJWkUgPSA2NDtcbmNvbnN0IFRZUEVTX1RPX0JZVEVTX1BFUl9DT01QT05FTlQgPSB7XG4gIFtjb3JlLlRZUEVTLlVOU0lHTkVEX0JZVEVdOiAxLFxuICBbY29yZS5UWVBFUy5VTlNJR05FRF9TSE9SVF06IDIsXG4gIFtjb3JlLlRZUEVTLklOVF06IDQsXG4gIFtjb3JlLlRZUEVTLlVOU0lHTkVEX0lOVF06IDQsXG4gIFtjb3JlLlRZUEVTLkZMT0FUXTogNCxcbiAgW2NvcmUuVFlQRVMuSEFMRl9GTE9BVF06IDhcbn07XG5jb25zdCBGT1JNQVRTX1RPX0NPTVBPTkVOVFMgPSB7XG4gIFtjb3JlLkZPUk1BVFMuUkdCQV06IDQsXG4gIFtjb3JlLkZPUk1BVFMuUkdCXTogMyxcbiAgW2NvcmUuRk9STUFUUy5SR106IDIsXG4gIFtjb3JlLkZPUk1BVFMuUkVEXTogMSxcbiAgW2NvcmUuRk9STUFUUy5MVU1JTkFOQ0VdOiAxLFxuICBbY29yZS5GT1JNQVRTLkxVTUlOQU5DRV9BTFBIQV06IDIsXG4gIFtjb3JlLkZPUk1BVFMuQUxQSEFdOiAxXG59O1xuY29uc3QgVFlQRVNfVE9fQllURVNfUEVSX1BJWEVMID0ge1xuICBbY29yZS5UWVBFUy5VTlNJR05FRF9TSE9SVF80XzRfNF80XTogMixcbiAgW2NvcmUuVFlQRVMuVU5TSUdORURfU0hPUlRfNV81XzVfMV06IDIsXG4gIFtjb3JlLlRZUEVTLlVOU0lHTkVEX1NIT1JUXzVfNl81XTogMlxufTtcbmZ1bmN0aW9uIHBhcnNlS1RYKHVybCwgYXJyYXlCdWZmZXIsIGxvYWRLZXlWYWx1ZURhdGEgPSBmYWxzZSkge1xuICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gIGlmICghdmFsaWRhdGUodXJsLCBkYXRhVmlldykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBsaXR0bGVFbmRpYW4gPSBkYXRhVmlldy5nZXRVaW50MzIoS1RYX0ZJRUxEUy5FTkRJQU5ORVNTLCB0cnVlKSA9PT0gRU5ESUFOTkVTUztcbiAgY29uc3QgZ2xUeXBlID0gZGF0YVZpZXcuZ2V0VWludDMyKEtUWF9GSUVMRFMuR0xfVFlQRSwgbGl0dGxlRW5kaWFuKTtcbiAgY29uc3QgZ2xGb3JtYXQgPSBkYXRhVmlldy5nZXRVaW50MzIoS1RYX0ZJRUxEUy5HTF9GT1JNQVQsIGxpdHRsZUVuZGlhbik7XG4gIGNvbnN0IGdsSW50ZXJuYWxGb3JtYXQgPSBkYXRhVmlldy5nZXRVaW50MzIoS1RYX0ZJRUxEUy5HTF9JTlRFUk5BTF9GT1JNQVQsIGxpdHRsZUVuZGlhbik7XG4gIGNvbnN0IHBpeGVsV2lkdGggPSBkYXRhVmlldy5nZXRVaW50MzIoS1RYX0ZJRUxEUy5QSVhFTF9XSURUSCwgbGl0dGxlRW5kaWFuKTtcbiAgY29uc3QgcGl4ZWxIZWlnaHQgPSBkYXRhVmlldy5nZXRVaW50MzIoS1RYX0ZJRUxEUy5QSVhFTF9IRUlHSFQsIGxpdHRsZUVuZGlhbikgfHwgMTtcbiAgY29uc3QgcGl4ZWxEZXB0aCA9IGRhdGFWaWV3LmdldFVpbnQzMihLVFhfRklFTERTLlBJWEVMX0RFUFRILCBsaXR0bGVFbmRpYW4pIHx8IDE7XG4gIGNvbnN0IG51bWJlck9mQXJyYXlFbGVtZW50cyA9IGRhdGFWaWV3LmdldFVpbnQzMihLVFhfRklFTERTLk5VTUJFUl9PRl9BUlJBWV9FTEVNRU5UUywgbGl0dGxlRW5kaWFuKSB8fCAxO1xuICBjb25zdCBudW1iZXJPZkZhY2VzID0gZGF0YVZpZXcuZ2V0VWludDMyKEtUWF9GSUVMRFMuTlVNQkVSX09GX0ZBQ0VTLCBsaXR0bGVFbmRpYW4pO1xuICBjb25zdCBudW1iZXJPZk1pcG1hcExldmVscyA9IGRhdGFWaWV3LmdldFVpbnQzMihLVFhfRklFTERTLk5VTUJFUl9PRl9NSVBNQVBfTEVWRUxTLCBsaXR0bGVFbmRpYW4pO1xuICBjb25zdCBieXRlc09mS2V5VmFsdWVEYXRhID0gZGF0YVZpZXcuZ2V0VWludDMyKEtUWF9GSUVMRFMuQllURVNfT0ZfS0VZX1ZBTFVFX0RBVEEsIGxpdHRsZUVuZGlhbik7XG4gIGlmIChwaXhlbEhlaWdodCA9PT0gMCB8fCBwaXhlbERlcHRoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSAyRCB0ZXh0dXJlcyBhcmUgc3VwcG9ydGVkXCIpO1xuICB9XG4gIGlmIChudW1iZXJPZkZhY2VzICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ3ViZVRleHR1cmVzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IEtUWExvYWRlciB5ZXQhXCIpO1xuICB9XG4gIGlmIChudW1iZXJPZkFycmF5RWxlbWVudHMgIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBkb2VzIG5vdCBzdXBwb3J0IGFycmF5IHRleHR1cmVzXCIpO1xuICB9XG4gIGNvbnN0IGJsb2NrV2lkdGggPSA0O1xuICBjb25zdCBibG9ja0hlaWdodCA9IDQ7XG4gIGNvbnN0IGFsaWduZWRXaWR0aCA9IHBpeGVsV2lkdGggKyAzICYgfjM7XG4gIGNvbnN0IGFsaWduZWRIZWlnaHQgPSBwaXhlbEhlaWdodCArIDMgJiB+MztcbiAgY29uc3QgaW1hZ2VCdWZmZXJzID0gbmV3IEFycmF5KG51bWJlck9mQXJyYXlFbGVtZW50cyk7XG4gIGxldCBpbWFnZVBpeGVscyA9IHBpeGVsV2lkdGggKiBwaXhlbEhlaWdodDtcbiAgaWYgKGdsVHlwZSA9PT0gMCkge1xuICAgIGltYWdlUGl4ZWxzID0gYWxpZ25lZFdpZHRoICogYWxpZ25lZEhlaWdodDtcbiAgfVxuICBsZXQgaW1hZ2VQaXhlbEJ5dGVTaXplO1xuICBpZiAoZ2xUeXBlICE9PSAwKSB7XG4gICAgaWYgKFRZUEVTX1RPX0JZVEVTX1BFUl9DT01QT05FTlRbZ2xUeXBlXSkge1xuICAgICAgaW1hZ2VQaXhlbEJ5dGVTaXplID0gVFlQRVNfVE9fQllURVNfUEVSX0NPTVBPTkVOVFtnbFR5cGVdICogRk9STUFUU19UT19DT01QT05FTlRTW2dsRm9ybWF0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW1hZ2VQaXhlbEJ5dGVTaXplID0gVFlQRVNfVE9fQllURVNfUEVSX1BJWEVMW2dsVHlwZV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGltYWdlUGl4ZWxCeXRlU2l6ZSA9IF9jb25zdC5JTlRFUk5BTF9GT1JNQVRfVE9fQllURVNfUEVSX1BJWEVMW2dsSW50ZXJuYWxGb3JtYXRdO1xuICB9XG4gIGlmIChpbWFnZVBpeGVsQnl0ZVNpemUgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byByZXNvbHZlIHRoZSBwaXhlbCBmb3JtYXQgc3RvcmVkIGluIHRoZSAqLmt0eCBmaWxlIVwiKTtcbiAgfVxuICBjb25zdCBrdkRhdGEgPSBsb2FkS2V5VmFsdWVEYXRhID8gcGFyc2VLdkRhdGEoZGF0YVZpZXcsIGJ5dGVzT2ZLZXlWYWx1ZURhdGEsIGxpdHRsZUVuZGlhbikgOiBudWxsO1xuICBjb25zdCBpbWFnZUJ5dGVTaXplID0gaW1hZ2VQaXhlbHMgKiBpbWFnZVBpeGVsQnl0ZVNpemU7XG4gIGxldCBtaXBCeXRlU2l6ZSA9IGltYWdlQnl0ZVNpemU7XG4gIGxldCBtaXBXaWR0aCA9IHBpeGVsV2lkdGg7XG4gIGxldCBtaXBIZWlnaHQgPSBwaXhlbEhlaWdodDtcbiAgbGV0IGFsaWduZWRNaXBXaWR0aCA9IGFsaWduZWRXaWR0aDtcbiAgbGV0IGFsaWduZWRNaXBIZWlnaHQgPSBhbGlnbmVkSGVpZ2h0O1xuICBsZXQgaW1hZ2VPZmZzZXQgPSBGSUxFX0hFQURFUl9TSVpFICsgYnl0ZXNPZktleVZhbHVlRGF0YTtcbiAgZm9yIChsZXQgbWlwbWFwTGV2ZWwgPSAwOyBtaXBtYXBMZXZlbCA8IG51bWJlck9mTWlwbWFwTGV2ZWxzOyBtaXBtYXBMZXZlbCsrKSB7XG4gICAgY29uc3QgaW1hZ2VTaXplID0gZGF0YVZpZXcuZ2V0VWludDMyKGltYWdlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICAgIGxldCBlbGVtZW50T2Zmc2V0ID0gaW1hZ2VPZmZzZXQgKyA0O1xuICAgIGZvciAobGV0IGFycmF5RWxlbWVudCA9IDA7IGFycmF5RWxlbWVudCA8IG51bWJlck9mQXJyYXlFbGVtZW50czsgYXJyYXlFbGVtZW50KyspIHtcbiAgICAgIGxldCBtaXBzID0gaW1hZ2VCdWZmZXJzW2FycmF5RWxlbWVudF07XG4gICAgICBpZiAoIW1pcHMpIHtcbiAgICAgICAgbWlwcyA9IGltYWdlQnVmZmVyc1thcnJheUVsZW1lbnRdID0gbmV3IEFycmF5KG51bWJlck9mTWlwbWFwTGV2ZWxzKTtcbiAgICAgIH1cbiAgICAgIG1pcHNbbWlwbWFwTGV2ZWxdID0ge1xuICAgICAgICBsZXZlbElEOiBtaXBtYXBMZXZlbCxcbiAgICAgICAgbGV2ZWxXaWR0aDogbnVtYmVyT2ZNaXBtYXBMZXZlbHMgPiAxIHx8IGdsVHlwZSAhPT0gMCA/IG1pcFdpZHRoIDogYWxpZ25lZE1pcFdpZHRoLFxuICAgICAgICBsZXZlbEhlaWdodDogbnVtYmVyT2ZNaXBtYXBMZXZlbHMgPiAxIHx8IGdsVHlwZSAhPT0gMCA/IG1pcEhlaWdodCA6IGFsaWduZWRNaXBIZWlnaHQsXG4gICAgICAgIGxldmVsQnVmZmVyOiBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciwgZWxlbWVudE9mZnNldCwgbWlwQnl0ZVNpemUpXG4gICAgICB9O1xuICAgICAgZWxlbWVudE9mZnNldCArPSBtaXBCeXRlU2l6ZTtcbiAgICB9XG4gICAgaW1hZ2VPZmZzZXQgKz0gaW1hZ2VTaXplICsgNDtcbiAgICBpbWFnZU9mZnNldCA9IGltYWdlT2Zmc2V0ICUgNCAhPT0gMCA/IGltYWdlT2Zmc2V0ICsgNCAtIGltYWdlT2Zmc2V0ICUgNCA6IGltYWdlT2Zmc2V0O1xuICAgIG1pcFdpZHRoID0gbWlwV2lkdGggPj4gMSB8fCAxO1xuICAgIG1pcEhlaWdodCA9IG1pcEhlaWdodCA+PiAxIHx8IDE7XG4gICAgYWxpZ25lZE1pcFdpZHRoID0gbWlwV2lkdGggKyBibG9ja1dpZHRoIC0gMSAmIH4oYmxvY2tXaWR0aCAtIDEpO1xuICAgIGFsaWduZWRNaXBIZWlnaHQgPSBtaXBIZWlnaHQgKyBibG9ja0hlaWdodCAtIDEgJiB+KGJsb2NrSGVpZ2h0IC0gMSk7XG4gICAgbWlwQnl0ZVNpemUgPSBhbGlnbmVkTWlwV2lkdGggKiBhbGlnbmVkTWlwSGVpZ2h0ICogaW1hZ2VQaXhlbEJ5dGVTaXplO1xuICB9XG4gIGlmIChnbFR5cGUgIT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdW5jb21wcmVzc2VkOiBpbWFnZUJ1ZmZlcnMubWFwKChsZXZlbEJ1ZmZlcnMpID0+IHtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IGxldmVsQnVmZmVyc1swXS5sZXZlbEJ1ZmZlcjtcbiAgICAgICAgbGV0IGNvbnZlcnRUb0ludCA9IGZhbHNlO1xuICAgICAgICBpZiAoZ2xUeXBlID09PSBjb3JlLlRZUEVTLkZMT0FUKSB7XG4gICAgICAgICAgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxCdWZmZXIuYnVmZmVyLCBsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxCdWZmZXIuYnl0ZU9mZnNldCwgbGV2ZWxCdWZmZXJzWzBdLmxldmVsQnVmZmVyLmJ5dGVMZW5ndGggLyA0KTtcbiAgICAgICAgfSBlbHNlIGlmIChnbFR5cGUgPT09IGNvcmUuVFlQRVMuVU5TSUdORURfSU5UKSB7XG4gICAgICAgICAgY29udmVydFRvSW50ID0gdHJ1ZTtcbiAgICAgICAgICBidWZmZXIgPSBuZXcgVWludDMyQXJyYXkobGV2ZWxCdWZmZXJzWzBdLmxldmVsQnVmZmVyLmJ1ZmZlciwgbGV2ZWxCdWZmZXJzWzBdLmxldmVsQnVmZmVyLmJ5dGVPZmZzZXQsIGxldmVsQnVmZmVyc1swXS5sZXZlbEJ1ZmZlci5ieXRlTGVuZ3RoIC8gNCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ2xUeXBlID09PSBjb3JlLlRZUEVTLklOVCkge1xuICAgICAgICAgIGNvbnZlcnRUb0ludCA9IHRydWU7XG4gICAgICAgICAgYnVmZmVyID0gbmV3IEludDMyQXJyYXkobGV2ZWxCdWZmZXJzWzBdLmxldmVsQnVmZmVyLmJ1ZmZlciwgbGV2ZWxCdWZmZXJzWzBdLmxldmVsQnVmZmVyLmJ5dGVPZmZzZXQsIGxldmVsQnVmZmVyc1swXS5sZXZlbEJ1ZmZlci5ieXRlTGVuZ3RoIC8gNCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNvdXJjZTogbmV3IGNvcmUuQnVmZmVyUmVzb3VyY2UoYnVmZmVyLCB7XG4gICAgICAgICAgICB3aWR0aDogbGV2ZWxCdWZmZXJzWzBdLmxldmVsV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGxldmVsQnVmZmVyc1swXS5sZXZlbEhlaWdodFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHR5cGU6IGdsVHlwZSxcbiAgICAgICAgICBmb3JtYXQ6IGNvbnZlcnRUb0ludCA/IGNvbnZlcnRGb3JtYXRUb0ludGVnZXIoZ2xGb3JtYXQpIDogZ2xGb3JtYXRcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAga3ZEYXRhXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGNvbXByZXNzZWQ6IGltYWdlQnVmZmVycy5tYXAoKGxldmVsQnVmZmVycykgPT4gbmV3IENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UuQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZShudWxsLCB7XG4gICAgICBmb3JtYXQ6IGdsSW50ZXJuYWxGb3JtYXQsXG4gICAgICB3aWR0aDogcGl4ZWxXaWR0aCxcbiAgICAgIGhlaWdodDogcGl4ZWxIZWlnaHQsXG4gICAgICBsZXZlbHM6IG51bWJlck9mTWlwbWFwTGV2ZWxzLFxuICAgICAgbGV2ZWxCdWZmZXJzXG4gICAgfSkpLFxuICAgIGt2RGF0YVxuICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGUodXJsLCBkYXRhVmlldykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IEZJTEVfSURFTlRJRklFUi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChkYXRhVmlldy5nZXRVaW50OChpKSAhPT0gRklMRV9JREVOVElGSUVSW2ldKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGAke3VybH0gaXMgbm90IGEgdmFsaWQgKi5rdHggZmlsZSFgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb252ZXJ0Rm9ybWF0VG9JbnRlZ2VyKGZvcm1hdCkge1xuICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgIGNhc2UgY29yZS5GT1JNQVRTLlJHQkE6XG4gICAgICByZXR1cm4gY29yZS5GT1JNQVRTLlJHQkFfSU5URUdFUjtcbiAgICBjYXNlIGNvcmUuRk9STUFUUy5SR0I6XG4gICAgICByZXR1cm4gY29yZS5GT1JNQVRTLlJHQl9JTlRFR0VSO1xuICAgIGNhc2UgY29yZS5GT1JNQVRTLlJHOlxuICAgICAgcmV0dXJuIGNvcmUuRk9STUFUUy5SR19JTlRFR0VSO1xuICAgIGNhc2UgY29yZS5GT1JNQVRTLlJFRDpcbiAgICAgIHJldHVybiBjb3JlLkZPUk1BVFMuUkVEX0lOVEVHRVI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlS3ZEYXRhKGRhdGFWaWV3LCBieXRlc09mS2V5VmFsdWVEYXRhLCBsaXR0bGVFbmRpYW4pIHtcbiAgY29uc3Qga3ZEYXRhID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IGJ5dGVzSW50b0tleVZhbHVlRGF0YSA9IDA7XG4gIHdoaWxlIChieXRlc0ludG9LZXlWYWx1ZURhdGEgPCBieXRlc09mS2V5VmFsdWVEYXRhKSB7XG4gICAgY29uc3Qga2V5QW5kVmFsdWVCeXRlU2l6ZSA9IGRhdGFWaWV3LmdldFVpbnQzMihGSUxFX0hFQURFUl9TSVpFICsgYnl0ZXNJbnRvS2V5VmFsdWVEYXRhLCBsaXR0bGVFbmRpYW4pO1xuICAgIGNvbnN0IGtleUFuZFZhbHVlQnl0ZU9mZnNldCA9IEZJTEVfSEVBREVSX1NJWkUgKyBieXRlc0ludG9LZXlWYWx1ZURhdGEgKyA0O1xuICAgIGNvbnN0IHZhbHVlUGFkZGluZyA9IDMgLSAoa2V5QW5kVmFsdWVCeXRlU2l6ZSArIDMpICUgNDtcbiAgICBpZiAoa2V5QW5kVmFsdWVCeXRlU2l6ZSA9PT0gMCB8fCBrZXlBbmRWYWx1ZUJ5dGVTaXplID4gYnl0ZXNPZktleVZhbHVlRGF0YSAtIGJ5dGVzSW50b0tleVZhbHVlRGF0YSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIktUWExvYWRlcjoga2V5QW5kVmFsdWVCeXRlU2l6ZSBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCBrZXlOdWxCeXRlID0gMDtcbiAgICBmb3IgKDsga2V5TnVsQnl0ZSA8IGtleUFuZFZhbHVlQnl0ZVNpemU7IGtleU51bEJ5dGUrKykge1xuICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQ4KGtleUFuZFZhbHVlQnl0ZU9mZnNldCArIGtleU51bEJ5dGUpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5TnVsQnl0ZSA9PT0gLTEpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJLVFhMb2FkZXI6IEZhaWxlZCB0byBmaW5kIG51bGwgYnl0ZSB0ZXJtaW5hdGluZyBrdkRhdGEga2V5XCIpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShuZXcgVWludDhBcnJheShkYXRhVmlldy5idWZmZXIsIGtleUFuZFZhbHVlQnl0ZU9mZnNldCwga2V5TnVsQnl0ZSkpO1xuICAgIGNvbnN0IHZhbHVlID0gbmV3IERhdGFWaWV3KGRhdGFWaWV3LmJ1ZmZlciwga2V5QW5kVmFsdWVCeXRlT2Zmc2V0ICsga2V5TnVsQnl0ZSArIDEsIGtleUFuZFZhbHVlQnl0ZVNpemUgLSBrZXlOdWxCeXRlIC0gMSk7XG4gICAga3ZEYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICBieXRlc0ludG9LZXlWYWx1ZURhdGEgKz0gNCArIGtleUFuZFZhbHVlQnl0ZVNpemUgKyB2YWx1ZVBhZGRpbmc7XG4gIH1cbiAgcmV0dXJuIGt2RGF0YTtcbn1cblxuZXhwb3J0cy5GT1JNQVRTX1RPX0NPTVBPTkVOVFMgPSBGT1JNQVRTX1RPX0NPTVBPTkVOVFM7XG5leHBvcnRzLlRZUEVTX1RPX0JZVEVTX1BFUl9DT01QT05FTlQgPSBUWVBFU19UT19CWVRFU19QRVJfQ09NUE9ORU5UO1xuZXhwb3J0cy5UWVBFU19UT19CWVRFU19QRVJfUElYRUwgPSBUWVBFU19UT19CWVRFU19QRVJfUElYRUw7XG5leHBvcnRzLnBhcnNlS1RYID0gcGFyc2VLVFg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZUtUWC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG5cbmNsYXNzIEJsb2JSZXNvdXJjZSBleHRlbmRzIGNvcmUuQnVmZmVyUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMgPSB7IHdpZHRoOiAxLCBoZWlnaHQ6IDEsIGF1dG9Mb2FkOiB0cnVlIH0pIHtcbiAgICBsZXQgb3JpZ2luO1xuICAgIGxldCBkYXRhO1xuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBvcmlnaW4gPSBzb3VyY2U7XG4gICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JpZ2luID0gbnVsbDtcbiAgICAgIGRhdGEgPSBzb3VyY2U7XG4gICAgfVxuICAgIHN1cGVyKGRhdGEsIG9wdGlvbnMpO1xuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luO1xuICAgIHRoaXMuYnVmZmVyID0gZGF0YSA/IG5ldyBjb3JlLlZpZXdhYmxlQnVmZmVyKGRhdGEpIDogbnVsbDtcbiAgICB0aGlzLl9sb2FkID0gbnVsbDtcbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLm9yaWdpbiAhPT0gbnVsbCAmJiBvcHRpb25zLmF1dG9Mb2FkICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5sb2FkKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gbnVsbCAmJiB0aGlzLmJ1ZmZlcikge1xuICAgICAgdGhpcy5fbG9hZCA9IFByb21pc2UucmVzb2x2ZSh0aGlzKTtcbiAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMub25CbG9iTG9hZGVkKHRoaXMuYnVmZmVyLnJhd0JpbmFyeURhdGEpO1xuICAgIH1cbiAgfVxuICBvbkJsb2JMb2FkZWQoX2RhdGEpIHtcbiAgfVxuICBsb2FkKCkge1xuICAgIGlmICh0aGlzLl9sb2FkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9hZDtcbiAgICB9XG4gICAgdGhpcy5fbG9hZCA9IGZldGNoKHRoaXMub3JpZ2luKS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuYmxvYigpKS50aGVuKChibG9iKSA9PiBibG9iLmFycmF5QnVmZmVyKCkpLnRoZW4oKGFycmF5QnVmZmVyKSA9PiB7XG4gICAgICB0aGlzLmRhdGEgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgICAgdGhpcy5idWZmZXIgPSBuZXcgY29yZS5WaWV3YWJsZUJ1ZmZlcihhcnJheUJ1ZmZlcik7XG4gICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgICB0aGlzLm9uQmxvYkxvYWRlZChhcnJheUJ1ZmZlcik7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gIH1cbn1cblxuZXhwb3J0cy5CbG9iUmVzb3VyY2UgPSBCbG9iUmVzb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CbG9iUmVzb3VyY2UuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi9jb25zdC5qcycpO1xudmFyIEJsb2JSZXNvdXJjZSA9IHJlcXVpcmUoJy4vQmxvYlJlc291cmNlLmpzJyk7XG5cbmNsYXNzIENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UgZXh0ZW5kcyBCbG9iUmVzb3VyY2UuQmxvYlJlc291cmNlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoc291cmNlLCBvcHRpb25zKTtcbiAgICB0aGlzLmZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0O1xuICAgIHRoaXMubGV2ZWxzID0gb3B0aW9ucy5sZXZlbHMgfHwgMTtcbiAgICB0aGlzLl93aWR0aCA9IG9wdGlvbnMud2lkdGg7XG4gICAgdGhpcy5faGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gICAgdGhpcy5fZXh0ZW5zaW9uID0gQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5fZm9ybWF0VG9FeHRlbnNpb24odGhpcy5mb3JtYXQpO1xuICAgIGlmIChvcHRpb25zLmxldmVsQnVmZmVycyB8fCB0aGlzLmJ1ZmZlcikge1xuICAgICAgdGhpcy5fbGV2ZWxCdWZmZXJzID0gb3B0aW9ucy5sZXZlbEJ1ZmZlcnMgfHwgQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5fY3JlYXRlTGV2ZWxCdWZmZXJzKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBzb3VyY2UgOiB0aGlzLmJ1ZmZlci51aW50OFZpZXcsIHRoaXMuZm9ybWF0LCB0aGlzLmxldmVscywgNCwgNCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cbiAgfVxuICB1cGxvYWQocmVuZGVyZXIsIF90ZXh0dXJlLCBfZ2xUZXh0dXJlKSB7XG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nbDtcbiAgICBjb25zdCBleHRlbnNpb24gPSByZW5kZXJlci5jb250ZXh0LmV4dGVuc2lvbnNbdGhpcy5fZXh0ZW5zaW9uXTtcbiAgICBpZiAoIWV4dGVuc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMuX2V4dGVuc2lvbn0gdGV4dHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gdGhlIGN1cnJlbnQgbWFjaGluZWApO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2xldmVsQnVmZmVycykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IHRoaXMubGV2ZWxzOyBpIDwgajsgaSsrKSB7XG4gICAgICBjb25zdCB7IGxldmVsSUQsIGxldmVsV2lkdGgsIGxldmVsSGVpZ2h0LCBsZXZlbEJ1ZmZlciB9ID0gdGhpcy5fbGV2ZWxCdWZmZXJzW2ldO1xuICAgICAgZ2wuY29tcHJlc3NlZFRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgbGV2ZWxJRCwgdGhpcy5mb3JtYXQsIGxldmVsV2lkdGgsIGxldmVsSGVpZ2h0LCAwLCBsZXZlbEJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG9uQmxvYkxvYWRlZCgpIHtcbiAgICB0aGlzLl9sZXZlbEJ1ZmZlcnMgPSBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlLl9jcmVhdGVMZXZlbEJ1ZmZlcnModGhpcy5idWZmZXIudWludDhWaWV3LCB0aGlzLmZvcm1hdCwgdGhpcy5sZXZlbHMsIDQsIDQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgfVxuICBzdGF0aWMgX2Zvcm1hdFRvRXh0ZW5zaW9uKGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPj0gMzM3NzYgJiYgZm9ybWF0IDw9IDMzNzc5KSB7XG4gICAgICByZXR1cm4gXCJzM3RjXCI7XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPj0gMzc0ODggJiYgZm9ybWF0IDw9IDM3NDk3KSB7XG4gICAgICByZXR1cm4gXCJldGNcIjtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA+PSAzNTg0MCAmJiBmb3JtYXQgPD0gMzU4NDMpIHtcbiAgICAgIHJldHVybiBcInB2cnRjXCI7XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPj0gMzYxOTYpIHtcbiAgICAgIHJldHVybiBcImV0YzFcIjtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA+PSAzNTk4NiAmJiBmb3JtYXQgPD0gMzQ3OTgpIHtcbiAgICAgIHJldHVybiBcImF0Y1wiO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIChjb21wcmVzc2VkKSB0ZXh0dXJlIGZvcm1hdCBnaXZlbiFcIik7XG4gIH1cbiAgc3RhdGljIF9jcmVhdGVMZXZlbEJ1ZmZlcnMoYnVmZmVyLCBmb3JtYXQsIGxldmVscywgYmxvY2tXaWR0aCwgYmxvY2tIZWlnaHQsIGltYWdlV2lkdGgsIGltYWdlSGVpZ2h0KSB7XG4gICAgY29uc3QgYnVmZmVycyA9IG5ldyBBcnJheShsZXZlbHMpO1xuICAgIGxldCBvZmZzZXQgPSBidWZmZXIuYnl0ZU9mZnNldDtcbiAgICBsZXQgbGV2ZWxXaWR0aCA9IGltYWdlV2lkdGg7XG4gICAgbGV0IGxldmVsSGVpZ2h0ID0gaW1hZ2VIZWlnaHQ7XG4gICAgbGV0IGFsaWduZWRMZXZlbFdpZHRoID0gbGV2ZWxXaWR0aCArIGJsb2NrV2lkdGggLSAxICYgfihibG9ja1dpZHRoIC0gMSk7XG4gICAgbGV0IGFsaWduZWRMZXZlbEhlaWdodCA9IGxldmVsSGVpZ2h0ICsgYmxvY2tIZWlnaHQgLSAxICYgfihibG9ja0hlaWdodCAtIDEpO1xuICAgIGxldCBsZXZlbFNpemUgPSBhbGlnbmVkTGV2ZWxXaWR0aCAqIGFsaWduZWRMZXZlbEhlaWdodCAqIF9jb25zdC5JTlRFUk5BTF9GT1JNQVRfVE9fQllURVNfUEVSX1BJWEVMW2Zvcm1hdF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHM7IGkrKykge1xuICAgICAgYnVmZmVyc1tpXSA9IHtcbiAgICAgICAgbGV2ZWxJRDogaSxcbiAgICAgICAgbGV2ZWxXaWR0aDogbGV2ZWxzID4gMSA/IGxldmVsV2lkdGggOiBhbGlnbmVkTGV2ZWxXaWR0aCxcbiAgICAgICAgbGV2ZWxIZWlnaHQ6IGxldmVscyA+IDEgPyBsZXZlbEhlaWdodCA6IGFsaWduZWRMZXZlbEhlaWdodCxcbiAgICAgICAgbGV2ZWxCdWZmZXI6IG5ldyBVaW50OEFycmF5KGJ1ZmZlci5idWZmZXIsIG9mZnNldCwgbGV2ZWxTaXplKVxuICAgICAgfTtcbiAgICAgIG9mZnNldCArPSBsZXZlbFNpemU7XG4gICAgICBsZXZlbFdpZHRoID0gbGV2ZWxXaWR0aCA+PiAxIHx8IDE7XG4gICAgICBsZXZlbEhlaWdodCA9IGxldmVsSGVpZ2h0ID4+IDEgfHwgMTtcbiAgICAgIGFsaWduZWRMZXZlbFdpZHRoID0gbGV2ZWxXaWR0aCArIGJsb2NrV2lkdGggLSAxICYgfihibG9ja1dpZHRoIC0gMSk7XG4gICAgICBhbGlnbmVkTGV2ZWxIZWlnaHQgPSBsZXZlbEhlaWdodCArIGJsb2NrSGVpZ2h0IC0gMSAmIH4oYmxvY2tIZWlnaHQgLSAxKTtcbiAgICAgIGxldmVsU2l6ZSA9IGFsaWduZWRMZXZlbFdpZHRoICogYWxpZ25lZExldmVsSGVpZ2h0ICogX2NvbnN0LklOVEVSTkFMX0ZPUk1BVF9UT19CWVRFU19QRVJfUElYRUxbZm9ybWF0XTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcnM7XG4gIH1cbn1cblxuZXhwb3J0cy5Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlID0gQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBCbG9iUmVzb3VyY2UgPSByZXF1aXJlKCcuL0Jsb2JSZXNvdXJjZS5qcycpO1xudmFyIENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UgPSByZXF1aXJlKCcuL0NvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UuanMnKTtcblxuXG5cbmV4cG9ydHMuQmxvYlJlc291cmNlID0gQmxvYlJlc291cmNlLkJsb2JSZXNvdXJjZTtcbmV4cG9ydHMuQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZSA9IENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UuQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgRU5WID0gLyogQF9fUFVSRV9fICovICgoRU5WMikgPT4ge1xuICBFTlYyW0VOVjJbXCJXRUJHTF9MRUdBQ1lcIl0gPSAwXSA9IFwiV0VCR0xfTEVHQUNZXCI7XG4gIEVOVjJbRU5WMltcIldFQkdMXCJdID0gMV0gPSBcIldFQkdMXCI7XG4gIEVOVjJbRU5WMltcIldFQkdMMlwiXSA9IDJdID0gXCJXRUJHTDJcIjtcbiAgcmV0dXJuIEVOVjI7XG59KShFTlYgfHwge30pO1xudmFyIFJFTkRFUkVSX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gKChSRU5ERVJFUl9UWVBFMikgPT4ge1xuICBSRU5ERVJFUl9UWVBFMltSRU5ERVJFUl9UWVBFMltcIlVOS05PV05cIl0gPSAwXSA9IFwiVU5LTk9XTlwiO1xuICBSRU5ERVJFUl9UWVBFMltSRU5ERVJFUl9UWVBFMltcIldFQkdMXCJdID0gMV0gPSBcIldFQkdMXCI7XG4gIFJFTkRFUkVSX1RZUEUyW1JFTkRFUkVSX1RZUEUyW1wiQ0FOVkFTXCJdID0gMl0gPSBcIkNBTlZBU1wiO1xuICByZXR1cm4gUkVOREVSRVJfVFlQRTI7XG59KShSRU5ERVJFUl9UWVBFIHx8IHt9KTtcbnZhciBCVUZGRVJfQklUUyA9IC8qIEBfX1BVUkVfXyAqLyAoKEJVRkZFUl9CSVRTMikgPT4ge1xuICBCVUZGRVJfQklUUzJbQlVGRkVSX0JJVFMyW1wiQ09MT1JcIl0gPSAxNjM4NF0gPSBcIkNPTE9SXCI7XG4gIEJVRkZFUl9CSVRTMltCVUZGRVJfQklUUzJbXCJERVBUSFwiXSA9IDI1Nl0gPSBcIkRFUFRIXCI7XG4gIEJVRkZFUl9CSVRTMltCVUZGRVJfQklUUzJbXCJTVEVOQ0lMXCJdID0gMTAyNF0gPSBcIlNURU5DSUxcIjtcbiAgcmV0dXJuIEJVRkZFUl9CSVRTMjtcbn0pKEJVRkZFUl9CSVRTIHx8IHt9KTtcbnZhciBCTEVORF9NT0RFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKEJMRU5EX01PREVTMikgPT4ge1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiTk9STUFMXCJdID0gMF0gPSBcIk5PUk1BTFwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiQUREXCJdID0gMV0gPSBcIkFERFwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiTVVMVElQTFlcIl0gPSAyXSA9IFwiTVVMVElQTFlcIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIlNDUkVFTlwiXSA9IDNdID0gXCJTQ1JFRU5cIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIk9WRVJMQVlcIl0gPSA0XSA9IFwiT1ZFUkxBWVwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiREFSS0VOXCJdID0gNV0gPSBcIkRBUktFTlwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiTElHSFRFTlwiXSA9IDZdID0gXCJMSUdIVEVOXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJDT0xPUl9ET0RHRVwiXSA9IDddID0gXCJDT0xPUl9ET0RHRVwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiQ09MT1JfQlVSTlwiXSA9IDhdID0gXCJDT0xPUl9CVVJOXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJIQVJEX0xJR0hUXCJdID0gOV0gPSBcIkhBUkRfTElHSFRcIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIlNPRlRfTElHSFRcIl0gPSAxMF0gPSBcIlNPRlRfTElHSFRcIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIkRJRkZFUkVOQ0VcIl0gPSAxMV0gPSBcIkRJRkZFUkVOQ0VcIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIkVYQ0xVU0lPTlwiXSA9IDEyXSA9IFwiRVhDTFVTSU9OXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJIVUVcIl0gPSAxM10gPSBcIkhVRVwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiU0FUVVJBVElPTlwiXSA9IDE0XSA9IFwiU0FUVVJBVElPTlwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiQ09MT1JcIl0gPSAxNV0gPSBcIkNPTE9SXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJMVU1JTk9TSVRZXCJdID0gMTZdID0gXCJMVU1JTk9TSVRZXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJOT1JNQUxfTlBNXCJdID0gMTddID0gXCJOT1JNQUxfTlBNXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJBRERfTlBNXCJdID0gMThdID0gXCJBRERfTlBNXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJTQ1JFRU5fTlBNXCJdID0gMTldID0gXCJTQ1JFRU5fTlBNXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJOT05FXCJdID0gMjBdID0gXCJOT05FXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJTUkNfT1ZFUlwiXSA9IDBdID0gXCJTUkNfT1ZFUlwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiU1JDX0lOXCJdID0gMjFdID0gXCJTUkNfSU5cIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIlNSQ19PVVRcIl0gPSAyMl0gPSBcIlNSQ19PVVRcIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIlNSQ19BVE9QXCJdID0gMjNdID0gXCJTUkNfQVRPUFwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiRFNUX09WRVJcIl0gPSAyNF0gPSBcIkRTVF9PVkVSXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJEU1RfSU5cIl0gPSAyNV0gPSBcIkRTVF9JTlwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiRFNUX09VVFwiXSA9IDI2XSA9IFwiRFNUX09VVFwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiRFNUX0FUT1BcIl0gPSAyN10gPSBcIkRTVF9BVE9QXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJFUkFTRVwiXSA9IDI2XSA9IFwiRVJBU0VcIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIlNVQlRSQUNUXCJdID0gMjhdID0gXCJTVUJUUkFDVFwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiWE9SXCJdID0gMjldID0gXCJYT1JcIjtcbiAgcmV0dXJuIEJMRU5EX01PREVTMjtcbn0pKEJMRU5EX01PREVTIHx8IHt9KTtcbnZhciBEUkFXX01PREVTID0gLyogQF9fUFVSRV9fICovICgoRFJBV19NT0RFUzIpID0+IHtcbiAgRFJBV19NT0RFUzJbRFJBV19NT0RFUzJbXCJQT0lOVFNcIl0gPSAwXSA9IFwiUE9JTlRTXCI7XG4gIERSQVdfTU9ERVMyW0RSQVdfTU9ERVMyW1wiTElORVNcIl0gPSAxXSA9IFwiTElORVNcIjtcbiAgRFJBV19NT0RFUzJbRFJBV19NT0RFUzJbXCJMSU5FX0xPT1BcIl0gPSAyXSA9IFwiTElORV9MT09QXCI7XG4gIERSQVdfTU9ERVMyW0RSQVdfTU9ERVMyW1wiTElORV9TVFJJUFwiXSA9IDNdID0gXCJMSU5FX1NUUklQXCI7XG4gIERSQVdfTU9ERVMyW0RSQVdfTU9ERVMyW1wiVFJJQU5HTEVTXCJdID0gNF0gPSBcIlRSSUFOR0xFU1wiO1xuICBEUkFXX01PREVTMltEUkFXX01PREVTMltcIlRSSUFOR0xFX1NUUklQXCJdID0gNV0gPSBcIlRSSUFOR0xFX1NUUklQXCI7XG4gIERSQVdfTU9ERVMyW0RSQVdfTU9ERVMyW1wiVFJJQU5HTEVfRkFOXCJdID0gNl0gPSBcIlRSSUFOR0xFX0ZBTlwiO1xuICByZXR1cm4gRFJBV19NT0RFUzI7XG59KShEUkFXX01PREVTIHx8IHt9KTtcbnZhciBGT1JNQVRTID0gLyogQF9fUFVSRV9fICovICgoRk9STUFUUzIpID0+IHtcbiAgRk9STUFUUzJbRk9STUFUUzJbXCJSR0JBXCJdID0gNjQwOF0gPSBcIlJHQkFcIjtcbiAgRk9STUFUUzJbRk9STUFUUzJbXCJSR0JcIl0gPSA2NDA3XSA9IFwiUkdCXCI7XG4gIEZPUk1BVFMyW0ZPUk1BVFMyW1wiUkdcIl0gPSAzMzMxOV0gPSBcIlJHXCI7XG4gIEZPUk1BVFMyW0ZPUk1BVFMyW1wiUkVEXCJdID0gNjQwM10gPSBcIlJFRFwiO1xuICBGT1JNQVRTMltGT1JNQVRTMltcIlJHQkFfSU5URUdFUlwiXSA9IDM2MjQ5XSA9IFwiUkdCQV9JTlRFR0VSXCI7XG4gIEZPUk1BVFMyW0ZPUk1BVFMyW1wiUkdCX0lOVEVHRVJcIl0gPSAzNjI0OF0gPSBcIlJHQl9JTlRFR0VSXCI7XG4gIEZPUk1BVFMyW0ZPUk1BVFMyW1wiUkdfSU5URUdFUlwiXSA9IDMzMzIwXSA9IFwiUkdfSU5URUdFUlwiO1xuICBGT1JNQVRTMltGT1JNQVRTMltcIlJFRF9JTlRFR0VSXCJdID0gMzYyNDRdID0gXCJSRURfSU5URUdFUlwiO1xuICBGT1JNQVRTMltGT1JNQVRTMltcIkFMUEhBXCJdID0gNjQwNl0gPSBcIkFMUEhBXCI7XG4gIEZPUk1BVFMyW0ZPUk1BVFMyW1wiTFVNSU5BTkNFXCJdID0gNjQwOV0gPSBcIkxVTUlOQU5DRVwiO1xuICBGT1JNQVRTMltGT1JNQVRTMltcIkxVTUlOQU5DRV9BTFBIQVwiXSA9IDY0MTBdID0gXCJMVU1JTkFOQ0VfQUxQSEFcIjtcbiAgRk9STUFUUzJbRk9STUFUUzJbXCJERVBUSF9DT01QT05FTlRcIl0gPSA2NDAyXSA9IFwiREVQVEhfQ09NUE9ORU5UXCI7XG4gIEZPUk1BVFMyW0ZPUk1BVFMyW1wiREVQVEhfU1RFTkNJTFwiXSA9IDM0MDQxXSA9IFwiREVQVEhfU1RFTkNJTFwiO1xuICByZXR1cm4gRk9STUFUUzI7XG59KShGT1JNQVRTIHx8IHt9KTtcbnZhciBUQVJHRVRTID0gLyogQF9fUFVSRV9fICovICgoVEFSR0VUUzIpID0+IHtcbiAgVEFSR0VUUzJbVEFSR0VUUzJbXCJURVhUVVJFXzJEXCJdID0gMzU1M10gPSBcIlRFWFRVUkVfMkRcIjtcbiAgVEFSR0VUUzJbVEFSR0VUUzJbXCJURVhUVVJFX0NVQkVfTUFQXCJdID0gMzQwNjddID0gXCJURVhUVVJFX0NVQkVfTUFQXCI7XG4gIFRBUkdFVFMyW1RBUkdFVFMyW1wiVEVYVFVSRV8yRF9BUlJBWVwiXSA9IDM1ODY2XSA9IFwiVEVYVFVSRV8yRF9BUlJBWVwiO1xuICBUQVJHRVRTMltUQVJHRVRTMltcIlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWFwiXSA9IDM0MDY5XSA9IFwiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YXCI7XG4gIFRBUkdFVFMyW1RBUkdFVFMyW1wiVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YXCJdID0gMzQwNzBdID0gXCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1hcIjtcbiAgVEFSR0VUUzJbVEFSR0VUUzJbXCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1lcIl0gPSAzNDA3MV0gPSBcIlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWVwiO1xuICBUQVJHRVRTMltUQVJHRVRTMltcIlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWVwiXSA9IDM0MDcyXSA9IFwiVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZXCI7XG4gIFRBUkdFVFMyW1RBUkdFVFMyW1wiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aXCJdID0gMzQwNzNdID0gXCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1pcIjtcbiAgVEFSR0VUUzJbVEFSR0VUUzJbXCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1pcIl0gPSAzNDA3NF0gPSBcIlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWlwiO1xuICByZXR1cm4gVEFSR0VUUzI7XG59KShUQVJHRVRTIHx8IHt9KTtcbnZhciBUWVBFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKFRZUEVTMikgPT4ge1xuICBUWVBFUzJbVFlQRVMyW1wiVU5TSUdORURfQllURVwiXSA9IDUxMjFdID0gXCJVTlNJR05FRF9CWVRFXCI7XG4gIFRZUEVTMltUWVBFUzJbXCJVTlNJR05FRF9TSE9SVFwiXSA9IDUxMjNdID0gXCJVTlNJR05FRF9TSE9SVFwiO1xuICBUWVBFUzJbVFlQRVMyW1wiVU5TSUdORURfU0hPUlRfNV82XzVcIl0gPSAzMzYzNV0gPSBcIlVOU0lHTkVEX1NIT1JUXzVfNl81XCI7XG4gIFRZUEVTMltUWVBFUzJbXCJVTlNJR05FRF9TSE9SVF80XzRfNF80XCJdID0gMzI4MTldID0gXCJVTlNJR05FRF9TSE9SVF80XzRfNF80XCI7XG4gIFRZUEVTMltUWVBFUzJbXCJVTlNJR05FRF9TSE9SVF81XzVfNV8xXCJdID0gMzI4MjBdID0gXCJVTlNJR05FRF9TSE9SVF81XzVfNV8xXCI7XG4gIFRZUEVTMltUWVBFUzJbXCJVTlNJR05FRF9JTlRcIl0gPSA1MTI1XSA9IFwiVU5TSUdORURfSU5UXCI7XG4gIFRZUEVTMltUWVBFUzJbXCJVTlNJR05FRF9JTlRfMTBGXzExRl8xMUZfUkVWXCJdID0gMzU4OTldID0gXCJVTlNJR05FRF9JTlRfMTBGXzExRl8xMUZfUkVWXCI7XG4gIFRZUEVTMltUWVBFUzJbXCJVTlNJR05FRF9JTlRfMl8xMF8xMF8xMF9SRVZcIl0gPSAzMzY0MF0gPSBcIlVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFVlwiO1xuICBUWVBFUzJbVFlQRVMyW1wiVU5TSUdORURfSU5UXzI0XzhcIl0gPSAzNDA0Ml0gPSBcIlVOU0lHTkVEX0lOVF8yNF84XCI7XG4gIFRZUEVTMltUWVBFUzJbXCJVTlNJR05FRF9JTlRfNV85XzlfOV9SRVZcIl0gPSAzNTkwMl0gPSBcIlVOU0lHTkVEX0lOVF81XzlfOV85X1JFVlwiO1xuICBUWVBFUzJbVFlQRVMyW1wiQllURVwiXSA9IDUxMjBdID0gXCJCWVRFXCI7XG4gIFRZUEVTMltUWVBFUzJbXCJTSE9SVFwiXSA9IDUxMjJdID0gXCJTSE9SVFwiO1xuICBUWVBFUzJbVFlQRVMyW1wiSU5UXCJdID0gNTEyNF0gPSBcIklOVFwiO1xuICBUWVBFUzJbVFlQRVMyW1wiRkxPQVRcIl0gPSA1MTI2XSA9IFwiRkxPQVRcIjtcbiAgVFlQRVMyW1RZUEVTMltcIkZMT0FUXzMyX1VOU0lHTkVEX0lOVF8yNF84X1JFVlwiXSA9IDM2MjY5XSA9IFwiRkxPQVRfMzJfVU5TSUdORURfSU5UXzI0XzhfUkVWXCI7XG4gIFRZUEVTMltUWVBFUzJbXCJIQUxGX0ZMT0FUXCJdID0gMzYxOTNdID0gXCJIQUxGX0ZMT0FUXCI7XG4gIHJldHVybiBUWVBFUzI7XG59KShUWVBFUyB8fCB7fSk7XG52YXIgU0FNUExFUl9UWVBFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKFNBTVBMRVJfVFlQRVMyKSA9PiB7XG4gIFNBTVBMRVJfVFlQRVMyW1NBTVBMRVJfVFlQRVMyW1wiRkxPQVRcIl0gPSAwXSA9IFwiRkxPQVRcIjtcbiAgU0FNUExFUl9UWVBFUzJbU0FNUExFUl9UWVBFUzJbXCJJTlRcIl0gPSAxXSA9IFwiSU5UXCI7XG4gIFNBTVBMRVJfVFlQRVMyW1NBTVBMRVJfVFlQRVMyW1wiVUlOVFwiXSA9IDJdID0gXCJVSU5UXCI7XG4gIHJldHVybiBTQU1QTEVSX1RZUEVTMjtcbn0pKFNBTVBMRVJfVFlQRVMgfHwge30pO1xudmFyIFNDQUxFX01PREVTID0gLyogQF9fUFVSRV9fICovICgoU0NBTEVfTU9ERVMyKSA9PiB7XG4gIFNDQUxFX01PREVTMltTQ0FMRV9NT0RFUzJbXCJORUFSRVNUXCJdID0gMF0gPSBcIk5FQVJFU1RcIjtcbiAgU0NBTEVfTU9ERVMyW1NDQUxFX01PREVTMltcIkxJTkVBUlwiXSA9IDFdID0gXCJMSU5FQVJcIjtcbiAgcmV0dXJuIFNDQUxFX01PREVTMjtcbn0pKFNDQUxFX01PREVTIHx8IHt9KTtcbnZhciBXUkFQX01PREVTID0gLyogQF9fUFVSRV9fICovICgoV1JBUF9NT0RFUzIpID0+IHtcbiAgV1JBUF9NT0RFUzJbV1JBUF9NT0RFUzJbXCJDTEFNUFwiXSA9IDMzMDcxXSA9IFwiQ0xBTVBcIjtcbiAgV1JBUF9NT0RFUzJbV1JBUF9NT0RFUzJbXCJSRVBFQVRcIl0gPSAxMDQ5N10gPSBcIlJFUEVBVFwiO1xuICBXUkFQX01PREVTMltXUkFQX01PREVTMltcIk1JUlJPUkVEX1JFUEVBVFwiXSA9IDMzNjQ4XSA9IFwiTUlSUk9SRURfUkVQRUFUXCI7XG4gIHJldHVybiBXUkFQX01PREVTMjtcbn0pKFdSQVBfTU9ERVMgfHwge30pO1xudmFyIE1JUE1BUF9NT0RFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKE1JUE1BUF9NT0RFUzIpID0+IHtcbiAgTUlQTUFQX01PREVTMltNSVBNQVBfTU9ERVMyW1wiT0ZGXCJdID0gMF0gPSBcIk9GRlwiO1xuICBNSVBNQVBfTU9ERVMyW01JUE1BUF9NT0RFUzJbXCJQT1cyXCJdID0gMV0gPSBcIlBPVzJcIjtcbiAgTUlQTUFQX01PREVTMltNSVBNQVBfTU9ERVMyW1wiT05cIl0gPSAyXSA9IFwiT05cIjtcbiAgTUlQTUFQX01PREVTMltNSVBNQVBfTU9ERVMyW1wiT05fTUFOVUFMXCJdID0gM10gPSBcIk9OX01BTlVBTFwiO1xuICByZXR1cm4gTUlQTUFQX01PREVTMjtcbn0pKE1JUE1BUF9NT0RFUyB8fCB7fSk7XG52YXIgQUxQSEFfTU9ERVMgPSAvKiBAX19QVVJFX18gKi8gKChBTFBIQV9NT0RFUzIpID0+IHtcbiAgQUxQSEFfTU9ERVMyW0FMUEhBX01PREVTMltcIk5QTVwiXSA9IDBdID0gXCJOUE1cIjtcbiAgQUxQSEFfTU9ERVMyW0FMUEhBX01PREVTMltcIlVOUEFDS1wiXSA9IDFdID0gXCJVTlBBQ0tcIjtcbiAgQUxQSEFfTU9ERVMyW0FMUEhBX01PREVTMltcIlBNQVwiXSA9IDJdID0gXCJQTUFcIjtcbiAgQUxQSEFfTU9ERVMyW0FMUEhBX01PREVTMltcIk5PX1BSRU1VTFRJUExJRURfQUxQSEFcIl0gPSAwXSA9IFwiTk9fUFJFTVVMVElQTElFRF9BTFBIQVwiO1xuICBBTFBIQV9NT0RFUzJbQUxQSEFfTU9ERVMyW1wiUFJFTVVMVElQTFlfT05fVVBMT0FEXCJdID0gMV0gPSBcIlBSRU1VTFRJUExZX09OX1VQTE9BRFwiO1xuICBBTFBIQV9NT0RFUzJbQUxQSEFfTU9ERVMyW1wiUFJFTVVMVElQTElFRF9BTFBIQVwiXSA9IDJdID0gXCJQUkVNVUxUSVBMSUVEX0FMUEhBXCI7XG4gIHJldHVybiBBTFBIQV9NT0RFUzI7XG59KShBTFBIQV9NT0RFUyB8fCB7fSk7XG52YXIgQ0xFQVJfTU9ERVMgPSAvKiBAX19QVVJFX18gKi8gKChDTEVBUl9NT0RFUzIpID0+IHtcbiAgQ0xFQVJfTU9ERVMyW0NMRUFSX01PREVTMltcIk5PXCJdID0gMF0gPSBcIk5PXCI7XG4gIENMRUFSX01PREVTMltDTEVBUl9NT0RFUzJbXCJZRVNcIl0gPSAxXSA9IFwiWUVTXCI7XG4gIENMRUFSX01PREVTMltDTEVBUl9NT0RFUzJbXCJBVVRPXCJdID0gMl0gPSBcIkFVVE9cIjtcbiAgQ0xFQVJfTU9ERVMyW0NMRUFSX01PREVTMltcIkJMRU5EXCJdID0gMF0gPSBcIkJMRU5EXCI7XG4gIENMRUFSX01PREVTMltDTEVBUl9NT0RFUzJbXCJDTEVBUlwiXSA9IDFdID0gXCJDTEVBUlwiO1xuICBDTEVBUl9NT0RFUzJbQ0xFQVJfTU9ERVMyW1wiQkxJVFwiXSA9IDJdID0gXCJCTElUXCI7XG4gIHJldHVybiBDTEVBUl9NT0RFUzI7XG59KShDTEVBUl9NT0RFUyB8fCB7fSk7XG52YXIgR0NfTU9ERVMgPSAvKiBAX19QVVJFX18gKi8gKChHQ19NT0RFUzIpID0+IHtcbiAgR0NfTU9ERVMyW0dDX01PREVTMltcIkFVVE9cIl0gPSAwXSA9IFwiQVVUT1wiO1xuICBHQ19NT0RFUzJbR0NfTU9ERVMyW1wiTUFOVUFMXCJdID0gMV0gPSBcIk1BTlVBTFwiO1xuICByZXR1cm4gR0NfTU9ERVMyO1xufSkoR0NfTU9ERVMgfHwge30pO1xudmFyIFBSRUNJU0lPTiA9IC8qIEBfX1BVUkVfXyAqLyAoKFBSRUNJU0lPTjIpID0+IHtcbiAgUFJFQ0lTSU9OMltcIkxPV1wiXSA9IFwibG93cFwiO1xuICBQUkVDSVNJT04yW1wiTUVESVVNXCJdID0gXCJtZWRpdW1wXCI7XG4gIFBSRUNJU0lPTjJbXCJISUdIXCJdID0gXCJoaWdocFwiO1xuICByZXR1cm4gUFJFQ0lTSU9OMjtcbn0pKFBSRUNJU0lPTiB8fCB7fSk7XG52YXIgTUFTS19UWVBFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKE1BU0tfVFlQRVMyKSA9PiB7XG4gIE1BU0tfVFlQRVMyW01BU0tfVFlQRVMyW1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gIE1BU0tfVFlQRVMyW01BU0tfVFlQRVMyW1wiU0NJU1NPUlwiXSA9IDFdID0gXCJTQ0lTU09SXCI7XG4gIE1BU0tfVFlQRVMyW01BU0tfVFlQRVMyW1wiU1RFTkNJTFwiXSA9IDJdID0gXCJTVEVOQ0lMXCI7XG4gIE1BU0tfVFlQRVMyW01BU0tfVFlQRVMyW1wiU1BSSVRFXCJdID0gM10gPSBcIlNQUklURVwiO1xuICBNQVNLX1RZUEVTMltNQVNLX1RZUEVTMltcIkNPTE9SXCJdID0gNF0gPSBcIkNPTE9SXCI7XG4gIHJldHVybiBNQVNLX1RZUEVTMjtcbn0pKE1BU0tfVFlQRVMgfHwge30pO1xudmFyIENPTE9SX01BU0tfQklUUyA9IC8qIEBfX1BVUkVfXyAqLyAoKENPTE9SX01BU0tfQklUUzIpID0+IHtcbiAgQ09MT1JfTUFTS19CSVRTMltDT0xPUl9NQVNLX0JJVFMyW1wiUkVEXCJdID0gMV0gPSBcIlJFRFwiO1xuICBDT0xPUl9NQVNLX0JJVFMyW0NPTE9SX01BU0tfQklUUzJbXCJHUkVFTlwiXSA9IDJdID0gXCJHUkVFTlwiO1xuICBDT0xPUl9NQVNLX0JJVFMyW0NPTE9SX01BU0tfQklUUzJbXCJCTFVFXCJdID0gNF0gPSBcIkJMVUVcIjtcbiAgQ09MT1JfTUFTS19CSVRTMltDT0xPUl9NQVNLX0JJVFMyW1wiQUxQSEFcIl0gPSA4XSA9IFwiQUxQSEFcIjtcbiAgcmV0dXJuIENPTE9SX01BU0tfQklUUzI7XG59KShDT0xPUl9NQVNLX0JJVFMgfHwge30pO1xudmFyIE1TQUFfUVVBTElUWSA9IC8qIEBfX1BVUkVfXyAqLyAoKE1TQUFfUVVBTElUWTIpID0+IHtcbiAgTVNBQV9RVUFMSVRZMltNU0FBX1FVQUxJVFkyW1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gIE1TQUFfUVVBTElUWTJbTVNBQV9RVUFMSVRZMltcIkxPV1wiXSA9IDJdID0gXCJMT1dcIjtcbiAgTVNBQV9RVUFMSVRZMltNU0FBX1FVQUxJVFkyW1wiTUVESVVNXCJdID0gNF0gPSBcIk1FRElVTVwiO1xuICBNU0FBX1FVQUxJVFkyW01TQUFfUVVBTElUWTJbXCJISUdIXCJdID0gOF0gPSBcIkhJR0hcIjtcbiAgcmV0dXJuIE1TQUFfUVVBTElUWTI7XG59KShNU0FBX1FVQUxJVFkgfHwge30pO1xudmFyIEJVRkZFUl9UWVBFID0gLyogQF9fUFVSRV9fICovICgoQlVGRkVSX1RZUEUyKSA9PiB7XG4gIEJVRkZFUl9UWVBFMltCVUZGRVJfVFlQRTJbXCJFTEVNRU5UX0FSUkFZX0JVRkZFUlwiXSA9IDM0OTYzXSA9IFwiRUxFTUVOVF9BUlJBWV9CVUZGRVJcIjtcbiAgQlVGRkVSX1RZUEUyW0JVRkZFUl9UWVBFMltcIkFSUkFZX0JVRkZFUlwiXSA9IDM0OTYyXSA9IFwiQVJSQVlfQlVGRkVSXCI7XG4gIEJVRkZFUl9UWVBFMltCVUZGRVJfVFlQRTJbXCJVTklGT1JNX0JVRkZFUlwiXSA9IDM1MzQ1XSA9IFwiVU5JRk9STV9CVUZGRVJcIjtcbiAgcmV0dXJuIEJVRkZFUl9UWVBFMjtcbn0pKEJVRkZFUl9UWVBFIHx8IHt9KTtcblxuZXhwb3J0cy5BTFBIQV9NT0RFUyA9IEFMUEhBX01PREVTO1xuZXhwb3J0cy5CTEVORF9NT0RFUyA9IEJMRU5EX01PREVTO1xuZXhwb3J0cy5CVUZGRVJfQklUUyA9IEJVRkZFUl9CSVRTO1xuZXhwb3J0cy5CVUZGRVJfVFlQRSA9IEJVRkZFUl9UWVBFO1xuZXhwb3J0cy5DTEVBUl9NT0RFUyA9IENMRUFSX01PREVTO1xuZXhwb3J0cy5DT0xPUl9NQVNLX0JJVFMgPSBDT0xPUl9NQVNLX0JJVFM7XG5leHBvcnRzLkRSQVdfTU9ERVMgPSBEUkFXX01PREVTO1xuZXhwb3J0cy5FTlYgPSBFTlY7XG5leHBvcnRzLkZPUk1BVFMgPSBGT1JNQVRTO1xuZXhwb3J0cy5HQ19NT0RFUyA9IEdDX01PREVTO1xuZXhwb3J0cy5NQVNLX1RZUEVTID0gTUFTS19UWVBFUztcbmV4cG9ydHMuTUlQTUFQX01PREVTID0gTUlQTUFQX01PREVTO1xuZXhwb3J0cy5NU0FBX1FVQUxJVFkgPSBNU0FBX1FVQUxJVFk7XG5leHBvcnRzLlBSRUNJU0lPTiA9IFBSRUNJU0lPTjtcbmV4cG9ydHMuUkVOREVSRVJfVFlQRSA9IFJFTkRFUkVSX1RZUEU7XG5leHBvcnRzLlNBTVBMRVJfVFlQRVMgPSBTQU1QTEVSX1RZUEVTO1xuZXhwb3J0cy5TQ0FMRV9NT0RFUyA9IFNDQUxFX01PREVTO1xuZXhwb3J0cy5UQVJHRVRTID0gVEFSR0VUUztcbmV4cG9ydHMuVFlQRVMgPSBUWVBFUztcbmV4cG9ydHMuV1JBUF9NT0RFUyA9IFdSQVBfTU9ERVM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SVJlbmRlcmVyLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnQHBpeGkvY29uc3RhbnRzJyk7XG52YXIgZXh0ZW5zaW9ucyA9IHJlcXVpcmUoJ0BwaXhpL2V4dGVuc2lvbnMnKTtcbnZhciBtYXRoID0gcmVxdWlyZSgnQHBpeGkvbWF0aCcpO1xudmFyIHNldHRpbmdzID0gcmVxdWlyZSgnQHBpeGkvc2V0dGluZ3MnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BwaXhpL3V0aWxzJyk7XG52YXIgVW5pZm9ybUdyb3VwID0gcmVxdWlyZSgnLi9zaGFkZXIvVW5pZm9ybUdyb3VwLmpzJyk7XG52YXIgU3lzdGVtTWFuYWdlciA9IHJlcXVpcmUoJy4vc3lzdGVtL1N5c3RlbU1hbmFnZXIuanMnKTtcblxuY29uc3QgX1JlbmRlcmVyID0gY2xhc3MgZXh0ZW5kcyBTeXN0ZW1NYW5hZ2VyLlN5c3RlbU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnR5cGUgPSBjb25zdGFudHMuUkVOREVSRVJfVFlQRS5XRUJHTDtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgc2V0dGluZ3Muc2V0dGluZ3MuUkVOREVSX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgIHRoaXMuQ09OVEVYVF9VSUQgPSAwO1xuICAgIHRoaXMuZ2xvYmFsVW5pZm9ybXMgPSBuZXcgVW5pZm9ybUdyb3VwLlVuaWZvcm1Hcm91cCh7XG4gICAgICBwcm9qZWN0aW9uTWF0cml4OiBuZXcgbWF0aC5NYXRyaXgoKVxuICAgIH0sIHRydWUpO1xuICAgIGNvbnN0IHN5c3RlbUNvbmZpZyA9IHtcbiAgICAgIHJ1bm5lcnM6IFtcbiAgICAgICAgXCJpbml0XCIsXG4gICAgICAgIFwiZGVzdHJveVwiLFxuICAgICAgICBcImNvbnRleHRDaGFuZ2VcIixcbiAgICAgICAgXCJyZXNvbHV0aW9uQ2hhbmdlXCIsXG4gICAgICAgIFwicmVzZXRcIixcbiAgICAgICAgXCJ1cGRhdGVcIixcbiAgICAgICAgXCJwb3N0cmVuZGVyXCIsXG4gICAgICAgIFwicHJlcmVuZGVyXCIsXG4gICAgICAgIFwicmVzaXplXCJcbiAgICAgIF0sXG4gICAgICBzeXN0ZW1zOiBfUmVuZGVyZXIuX19zeXN0ZW1zLFxuICAgICAgcHJpb3JpdHk6IFtcbiAgICAgICAgXCJfdmlld1wiLFxuICAgICAgICBcInRleHR1cmVHZW5lcmF0b3JcIixcbiAgICAgICAgXCJiYWNrZ3JvdW5kXCIsXG4gICAgICAgIFwiX3BsdWdpblwiLFxuICAgICAgICBcInN0YXJ0dXBcIixcbiAgICAgICAgXCJjb250ZXh0XCIsXG4gICAgICAgIFwic3RhdGVcIixcbiAgICAgICAgXCJ0ZXh0dXJlXCIsXG4gICAgICAgIFwiYnVmZmVyXCIsXG4gICAgICAgIFwiZ2VvbWV0cnlcIixcbiAgICAgICAgXCJmcmFtZWJ1ZmZlclwiLFxuICAgICAgICBcInRyYW5zZm9ybUZlZWRiYWNrXCIsXG4gICAgICAgIFwibWFza1wiLFxuICAgICAgICBcInNjaXNzb3JcIixcbiAgICAgICAgXCJzdGVuY2lsXCIsXG4gICAgICAgIFwicHJvamVjdGlvblwiLFxuICAgICAgICBcInRleHR1cmVHQ1wiLFxuICAgICAgICBcImZpbHRlclwiLFxuICAgICAgICBcInJlbmRlclRleHR1cmVcIixcbiAgICAgICAgXCJiYXRjaFwiLFxuICAgICAgICBcIm9iamVjdFJlbmRlcmVyXCIsXG4gICAgICAgIFwiX211bHRpc2FtcGxlXCJcbiAgICAgIF1cbiAgICB9O1xuICAgIHRoaXMuc2V0dXAoc3lzdGVtQ29uZmlnKTtcbiAgICBpZiAoXCJ1c2VDb250ZXh0QWxwaGFcIiBpbiBvcHRpb25zKSB7XG4gICAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMC4wXCIsIFwib3B0aW9ucy51c2VDb250ZXh0QWxwaGEgaXMgZGVwcmVjYXRlZCwgdXNlIG9wdGlvbnMucHJlbXVsdGlwbGllZEFscGhhIGFuZCBvcHRpb25zLmJhY2tncm91bmRBbHBoYSBpbnN0ZWFkXCIpO1xuICAgICAgb3B0aW9ucy5wcmVtdWx0aXBsaWVkQWxwaGEgPSBvcHRpb25zLnVzZUNvbnRleHRBbHBoYSAmJiBvcHRpb25zLnVzZUNvbnRleHRBbHBoYSAhPT0gXCJub3RNdWx0aXBsaWVkXCI7XG4gICAgICBvcHRpb25zLmJhY2tncm91bmRBbHBoYSA9IG9wdGlvbnMudXNlQ29udGV4dEFscGhhID09PSBmYWxzZSA/IDEgOiBvcHRpb25zLmJhY2tncm91bmRBbHBoYTtcbiAgICB9XG4gICAgdGhpcy5fcGx1Z2luLnJlbmRlcmVyUGx1Z2lucyA9IF9SZW5kZXJlci5fX3BsdWdpbnM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnN0YXJ0dXAucnVuKHRoaXMub3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIHRlc3Qob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zPy5mb3JjZUNhbnZhcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuaXNXZWJHTFN1cHBvcnRlZCgpO1xuICB9XG4gIHJlbmRlcihkaXNwbGF5T2JqZWN0LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vYmplY3RSZW5kZXJlci5yZW5kZXIoZGlzcGxheU9iamVjdCwgb3B0aW9ucyk7XG4gIH1cbiAgcmVzaXplKGRlc2lyZWRTY3JlZW5XaWR0aCwgZGVzaXJlZFNjcmVlbkhlaWdodCkge1xuICAgIHRoaXMuX3ZpZXcucmVzaXplVmlldyhkZXNpcmVkU2NyZWVuV2lkdGgsIGRlc2lyZWRTY3JlZW5IZWlnaHQpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMucnVubmVycy5yZXNldC5lbWl0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5yZW5kZXJUZXh0dXJlLmJpbmQoKTtcbiAgICB0aGlzLnJlbmRlclRleHR1cmUuY2xlYXIoKTtcbiAgfVxuICBkZXN0cm95KHJlbW92ZVZpZXcgPSBmYWxzZSkge1xuICAgIHRoaXMucnVubmVycy5kZXN0cm95Lml0ZW1zLnJldmVyc2UoKTtcbiAgICB0aGlzLmVtaXRXaXRoQ3VzdG9tT3B0aW9ucyh0aGlzLnJ1bm5lcnMuZGVzdHJveSwge1xuICAgICAgX3ZpZXc6IHJlbW92ZVZpZXdcbiAgICB9KTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbiAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdWdpbi5wbHVnaW5zO1xuICB9XG4gIGdldCBtdWx0aXNhbXBsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbXVsdGlzYW1wbGUubXVsdGlzYW1wbGU7XG4gIH1cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3LmVsZW1lbnQud2lkdGg7XG4gIH1cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlldy5lbGVtZW50LmhlaWdodDtcbiAgfVxuICBnZXQgcmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlldy5yZXNvbHV0aW9uO1xuICB9XG4gIHNldCByZXNvbHV0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fdmlldy5yZXNvbHV0aW9uID0gdmFsdWU7XG4gICAgdGhpcy5ydW5uZXJzLnJlc29sdXRpb25DaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gIH1cbiAgZ2V0IGF1dG9EZW5zaXR5KCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3LmF1dG9EZW5zaXR5O1xuICB9XG4gIGdldCB2aWV3KCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3LmVsZW1lbnQ7XG4gIH1cbiAgZ2V0IHNjcmVlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlldy5zY3JlZW47XG4gIH1cbiAgZ2V0IGxhc3RPYmplY3RSZW5kZXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5vYmplY3RSZW5kZXJlci5sYXN0T2JqZWN0UmVuZGVyZWQ7XG4gIH1cbiAgZ2V0IHJlbmRlcmluZ1RvU2NyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLm9iamVjdFJlbmRlcmVyLnJlbmRlcmluZ1RvU2NyZWVuO1xuICB9XG4gIGdldCByZW5kZXJlckxvZ0lkKCkge1xuICAgIHJldHVybiBgV2ViR0wgJHt0aGlzLmNvbnRleHQud2ViR0xWZXJzaW9ufWA7XG4gIH1cbiAgZ2V0IGNsZWFyQmVmb3JlUmVuZGVyKCkge1xuICAgIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJyZW5kZXJlci5jbGVhckJlZm9yZVJlbmRlciBoYXMgYmVlbiBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHJlbmRlcmVyLmJhY2tncm91bmQuY2xlYXJCZWZvcmVSZW5kZXIgaW5zdGVhZC5cIik7XG4gICAgcmV0dXJuIHRoaXMuYmFja2dyb3VuZC5jbGVhckJlZm9yZVJlbmRlcjtcbiAgfVxuICBnZXQgdXNlQ29udGV4dEFscGhhKCkge1xuICAgIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJyZW5kZXJlci51c2VDb250ZXh0QWxwaGEgaGFzIGJlZW4gZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSByZW5kZXJlci5jb250ZXh0LnByZW11bHRpcGxpZWRBbHBoYSBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LnVzZUNvbnRleHRBbHBoYTtcbiAgfVxuICBnZXQgcHJlc2VydmVEcmF3aW5nQnVmZmVyKCkge1xuICAgIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJyZW5kZXJlci5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgaGFzIGJlZW4gZGVwcmVjYXRlZCwgd2UgY2Fubm90IHRydWx5IGtub3cgdGhpcyB1bmxlc3MgcGl4aSBjcmVhdGVkIHRoZSBjb250ZXh0XCIpO1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQucHJlc2VydmVEcmF3aW5nQnVmZmVyO1xuICB9XG4gIGdldCBiYWNrZ3JvdW5kQ29sb3IoKSB7XG4gICAgdXRpbHMuZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLmJhY2tncm91bmRDb2xvciBoYXMgYmVlbiBkZXByZWNhdGVkLCB1c2UgcmVuZGVyZXIuYmFja2dyb3VuZC5jb2xvciBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gdGhpcy5iYWNrZ3JvdW5kLmNvbG9yO1xuICB9XG4gIHNldCBiYWNrZ3JvdW5kQ29sb3IodmFsdWUpIHtcbiAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMC4wXCIsIFwicmVuZGVyZXIuYmFja2dyb3VuZENvbG9yIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHVzZSByZW5kZXJlci5iYWNrZ3JvdW5kLmNvbG9yIGluc3RlYWQuXCIpO1xuICAgIHRoaXMuYmFja2dyb3VuZC5jb2xvciA9IHZhbHVlO1xuICB9XG4gIGdldCBiYWNrZ3JvdW5kQWxwaGEoKSB7XG4gICAgdXRpbHMuZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLmJhY2tncm91bmRBbHBoYSBoYXMgYmVlbiBkZXByZWNhdGVkLCB1c2UgcmVuZGVyZXIuYmFja2dyb3VuZC5hbHBoYSBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gdGhpcy5iYWNrZ3JvdW5kLmFscGhhO1xuICB9XG4gIHNldCBiYWNrZ3JvdW5kQWxwaGEodmFsdWUpIHtcbiAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMC4wXCIsIFwicmVuZGVyZXIuYmFja2dyb3VuZEFscGhhIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHVzZSByZW5kZXJlci5iYWNrZ3JvdW5kLmFscGhhIGluc3RlYWQuXCIpO1xuICAgIHRoaXMuYmFja2dyb3VuZC5hbHBoYSA9IHZhbHVlO1xuICB9XG4gIGdldCBwb3dlclByZWZlcmVuY2UoKSB7XG4gICAgdXRpbHMuZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLnBvd2VyUHJlZmVyZW5jZSBoYXMgYmVlbiBkZXByZWNhdGVkLCB3ZSBjYW4gb25seSBrbm93IHRoaXMgaWYgcGl4aSBjcmVhdGVzIHRoZSBjb250ZXh0XCIpO1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQucG93ZXJQcmVmZXJlbmNlO1xuICB9XG4gIGdlbmVyYXRlVGV4dHVyZShkaXNwbGF5T2JqZWN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dHVyZUdlbmVyYXRvci5nZW5lcmF0ZVRleHR1cmUoZGlzcGxheU9iamVjdCwgb3B0aW9ucyk7XG4gIH1cbn07XG5sZXQgUmVuZGVyZXIgPSBfUmVuZGVyZXI7XG5SZW5kZXJlci5leHRlbnNpb24gPSB7XG4gIHR5cGU6IGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlcixcbiAgcHJpb3JpdHk6IDFcbn07XG5SZW5kZXJlci5fX3BsdWdpbnMgPSB7fTtcblJlbmRlcmVyLl9fc3lzdGVtcyA9IHt9O1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmhhbmRsZUJ5TWFwKGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclBsdWdpbiwgUmVuZGVyZXIuX19wbHVnaW5zKTtcbmV4dGVuc2lvbnMuZXh0ZW5zaW9ucy5oYW5kbGVCeU1hcChleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sIFJlbmRlcmVyLl9fc3lzdGVtcyk7XG5leHRlbnNpb25zLmV4dGVuc2lvbnMuYWRkKFJlbmRlcmVyKTtcblxuZXhwb3J0cy5SZW5kZXJlciA9IFJlbmRlcmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVuZGVyZXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBleHRlbnNpb25zID0gcmVxdWlyZSgnQHBpeGkvZXh0ZW5zaW9ucycpO1xuXG5jb25zdCByZW5kZXJlcnMgPSBbXTtcbmV4dGVuc2lvbnMuZXh0ZW5zaW9ucy5oYW5kbGVCeUxpc3QoZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLlJlbmRlcmVyLCByZW5kZXJlcnMpO1xuZnVuY3Rpb24gYXV0b0RldGVjdFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgZm9yIChjb25zdCBSZW5kZXJlclR5cGUgb2YgcmVuZGVyZXJzKSB7XG4gICAgaWYgKFJlbmRlcmVyVHlwZS50ZXN0KG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gbmV3IFJlbmRlcmVyVHlwZShvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGF1dG8tZGV0ZWN0IGEgc3VpdGFibGUgcmVuZGVyZXIuXCIpO1xufVxuXG5leHBvcnRzLmF1dG9EZXRlY3RSZW5kZXJlciA9IGF1dG9EZXRlY3RSZW5kZXJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dG9EZXRlY3RSZW5kZXJlci5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvbG9yID0gcmVxdWlyZSgnQHBpeGkvY29sb3InKTtcbnZhciBleHRlbnNpb25zID0gcmVxdWlyZSgnQHBpeGkvZXh0ZW5zaW9ucycpO1xuXG5jbGFzcyBCYWNrZ3JvdW5kU3lzdGVtIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jbGVhckJlZm9yZVJlbmRlciA9IHRydWU7XG4gICAgdGhpcy5fYmFja2dyb3VuZENvbG9yID0gbmV3IGNvbG9yLkNvbG9yKDApO1xuICAgIHRoaXMuYWxwaGEgPSAxO1xuICB9XG4gIGluaXQob3B0aW9ucykge1xuICAgIHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIgPSBvcHRpb25zLmNsZWFyQmVmb3JlUmVuZGVyO1xuICAgIGNvbnN0IHsgYmFja2dyb3VuZENvbG9yLCBiYWNrZ3JvdW5kLCBiYWNrZ3JvdW5kQWxwaGEgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY29sb3IgPSBiYWNrZ3JvdW5kID8/IGJhY2tncm91bmRDb2xvcjtcbiAgICBpZiAoY29sb3IgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgIH1cbiAgICB0aGlzLmFscGhhID0gYmFja2dyb3VuZEFscGhhO1xuICB9XG4gIGdldCBjb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFja2dyb3VuZENvbG9yLnZhbHVlO1xuICB9XG4gIHNldCBjb2xvcih2YWx1ZSkge1xuICAgIHRoaXMuX2JhY2tncm91bmRDb2xvci5zZXRWYWx1ZSh2YWx1ZSk7XG4gIH1cbiAgZ2V0IGFscGhhKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IuYWxwaGE7XG4gIH1cbiAgc2V0IGFscGhhKHZhbHVlKSB7XG4gICAgdGhpcy5fYmFja2dyb3VuZENvbG9yLnNldEFscGhhKHZhbHVlKTtcbiAgfVxuICBnZXQgYmFja2dyb3VuZENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3I7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgfVxufVxuQmFja2dyb3VuZFN5c3RlbS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgYmFja2dyb3VuZEFscGhhOiAxLFxuICBiYWNrZ3JvdW5kQ29sb3I6IDAsXG4gIGNsZWFyQmVmb3JlUmVuZGVyOiB0cnVlXG59O1xuQmFja2dyb3VuZFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gICAgZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLkNhbnZhc1JlbmRlcmVyU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwiYmFja2dyb3VuZFwiXG59O1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmFkZChCYWNrZ3JvdW5kU3lzdGVtKTtcblxuZXhwb3J0cy5CYWNrZ3JvdW5kU3lzdGVtID0gQmFja2dyb3VuZFN5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhY2tncm91bmRTeXN0ZW0uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCdAcGl4aS9jb25zdGFudHMnKTtcblxuY2xhc3MgQmF0Y2hEcmF3Q2FsbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudGV4QXJyYXkgPSBudWxsO1xuICAgIHRoaXMuYmxlbmQgPSAwO1xuICAgIHRoaXMudHlwZSA9IGNvbnN0YW50cy5EUkFXX01PREVTLlRSSUFOR0xFUztcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLnNpemUgPSAwO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0cy5CYXRjaERyYXdDYWxsID0gQmF0Y2hEcmF3Q2FsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhdGNoRHJhd0NhbGwuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCdAcGl4aS9jb25zdGFudHMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9CdWZmZXIuanMnKTtcbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L0dlb21ldHJ5LmpzJyk7XG5cbmNsYXNzIEJhdGNoR2VvbWV0cnkgZXh0ZW5kcyBHZW9tZXRyeS5HZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKF9zdGF0aWMgPSBmYWxzZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fYnVmZmVyID0gbmV3IEJ1ZmZlci5CdWZmZXIobnVsbCwgX3N0YXRpYywgZmFsc2UpO1xuICAgIHRoaXMuX2luZGV4QnVmZmVyID0gbmV3IEJ1ZmZlci5CdWZmZXIobnVsbCwgX3N0YXRpYywgdHJ1ZSk7XG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoXCJhVmVydGV4UG9zaXRpb25cIiwgdGhpcy5fYnVmZmVyLCAyLCBmYWxzZSwgY29uc3RhbnRzLlRZUEVTLkZMT0FUKS5hZGRBdHRyaWJ1dGUoXCJhVGV4dHVyZUNvb3JkXCIsIHRoaXMuX2J1ZmZlciwgMiwgZmFsc2UsIGNvbnN0YW50cy5UWVBFUy5GTE9BVCkuYWRkQXR0cmlidXRlKFwiYUNvbG9yXCIsIHRoaXMuX2J1ZmZlciwgNCwgdHJ1ZSwgY29uc3RhbnRzLlRZUEVTLlVOU0lHTkVEX0JZVEUpLmFkZEF0dHJpYnV0ZShcImFUZXh0dXJlSWRcIiwgdGhpcy5fYnVmZmVyLCAxLCB0cnVlLCBjb25zdGFudHMuVFlQRVMuRkxPQVQpLmFkZEluZGV4KHRoaXMuX2luZGV4QnVmZmVyKTtcbiAgfVxufVxuXG5leHBvcnRzLkJhdGNoR2VvbWV0cnkgPSBCYXRjaEdlb21ldHJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hHZW9tZXRyeS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvbG9yID0gcmVxdWlyZSgnQHBpeGkvY29sb3InKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCdAcGl4aS9jb25zdGFudHMnKTtcbnZhciBleHRlbnNpb25zID0gcmVxdWlyZSgnQHBpeGkvZXh0ZW5zaW9ucycpO1xudmFyIHNldHRpbmdzID0gcmVxdWlyZSgnQHBpeGkvc2V0dGluZ3MnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BwaXhpL3V0aWxzJyk7XG52YXIgVmlld2FibGVCdWZmZXIgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9WaWV3YWJsZUJ1ZmZlci5qcycpO1xudmFyIGNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIgPSByZXF1aXJlKCcuLi9zaGFkZXIvdXRpbHMvY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlci5qcycpO1xudmFyIFN0YXRlID0gcmVxdWlyZSgnLi4vc3RhdGUvU3RhdGUuanMnKTtcbnZhciBCYXNlVGV4dHVyZSA9IHJlcXVpcmUoJy4uL3RleHR1cmVzL0Jhc2VUZXh0dXJlLmpzJyk7XG52YXIgQmF0Y2hEcmF3Q2FsbCA9IHJlcXVpcmUoJy4vQmF0Y2hEcmF3Q2FsbC5qcycpO1xudmFyIEJhdGNoR2VvbWV0cnkgPSByZXF1aXJlKCcuL0JhdGNoR2VvbWV0cnkuanMnKTtcbnZhciBCYXRjaFNoYWRlckdlbmVyYXRvciA9IHJlcXVpcmUoJy4vQmF0Y2hTaGFkZXJHZW5lcmF0b3IuanMnKTtcbnZhciBCYXRjaFRleHR1cmVBcnJheSA9IHJlcXVpcmUoJy4vQmF0Y2hUZXh0dXJlQXJyYXkuanMnKTtcbnZhciBjYW5VcGxvYWRTYW1lQnVmZmVyID0gcmVxdWlyZSgnLi9jYW5VcGxvYWRTYW1lQnVmZmVyLmpzJyk7XG52YXIgbWF4UmVjb21tZW5kZWRUZXh0dXJlcyA9IHJlcXVpcmUoJy4vbWF4UmVjb21tZW5kZWRUZXh0dXJlcy5qcycpO1xudmFyIE9iamVjdFJlbmRlcmVyID0gcmVxdWlyZSgnLi9PYmplY3RSZW5kZXJlci5qcycpO1xudmFyIHRleHR1cmUkMSA9IHJlcXVpcmUoJy4vdGV4dHVyZS5qcycpO1xudmFyIHRleHR1cmUgPSByZXF1aXJlKCcuL3RleHR1cmUyLmpzJyk7XG5cbmNvbnN0IF9CYXRjaFJlbmRlcmVyID0gY2xhc3MgZXh0ZW5kcyBPYmplY3RSZW5kZXJlci5PYmplY3RSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgc3VwZXIocmVuZGVyZXIpO1xuICAgIHRoaXMuc2V0U2hhZGVyR2VuZXJhdG9yKCk7XG4gICAgdGhpcy5nZW9tZXRyeUNsYXNzID0gQmF0Y2hHZW9tZXRyeS5CYXRjaEdlb21ldHJ5O1xuICAgIHRoaXMudmVydGV4U2l6ZSA9IDY7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlN0YXRlLmZvcjJkKCk7XG4gICAgdGhpcy5zaXplID0gX0JhdGNoUmVuZGVyZXIuZGVmYXVsdEJhdGNoU2l6ZSAqIDQ7XG4gICAgdGhpcy5fdmVydGV4Q291bnQgPSAwO1xuICAgIHRoaXMuX2luZGV4Q291bnQgPSAwO1xuICAgIHRoaXMuX2J1ZmZlcmVkRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLl9idWZmZXJlZFRleHR1cmVzID0gW107XG4gICAgdGhpcy5fYnVmZmVyU2l6ZSA9IDA7XG4gICAgdGhpcy5fc2hhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9wYWNrZWRHZW9tZXRyaWVzID0gW107XG4gICAgdGhpcy5fcGFja2VkR2VvbWV0cnlQb29sU2l6ZSA9IDI7XG4gICAgdGhpcy5fZmx1c2hJZCA9IDA7XG4gICAgdGhpcy5fYUJ1ZmZlcnMgPSB7fTtcbiAgICB0aGlzLl9pQnVmZmVycyA9IHt9O1xuICAgIHRoaXMubWF4VGV4dHVyZXMgPSAxO1xuICAgIHRoaXMucmVuZGVyZXIub24oXCJwcmVyZW5kZXJcIiwgdGhpcy5vblByZXJlbmRlciwgdGhpcyk7XG4gICAgcmVuZGVyZXIucnVubmVycy5jb250ZXh0Q2hhbmdlLmFkZCh0aGlzKTtcbiAgICB0aGlzLl9kY0luZGV4ID0gMDtcbiAgICB0aGlzLl9hSW5kZXggPSAwO1xuICAgIHRoaXMuX2lJbmRleCA9IDA7XG4gICAgdGhpcy5fYXR0cmlidXRlQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLl9pbmRleEJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5fdGVtcEJvdW5kVGV4dHVyZXMgPSBbXTtcbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRNYXhUZXh0dXJlcygpIHtcbiAgICB0aGlzLl9kZWZhdWx0TWF4VGV4dHVyZXMgPSB0aGlzLl9kZWZhdWx0TWF4VGV4dHVyZXMgPz8gbWF4UmVjb21tZW5kZWRUZXh0dXJlcy5tYXhSZWNvbW1lbmRlZFRleHR1cmVzKDMyKTtcbiAgICByZXR1cm4gdGhpcy5fZGVmYXVsdE1heFRleHR1cmVzO1xuICB9XG4gIHN0YXRpYyBzZXQgZGVmYXVsdE1heFRleHR1cmVzKHZhbHVlKSB7XG4gICAgdGhpcy5fZGVmYXVsdE1heFRleHR1cmVzID0gdmFsdWU7XG4gIH1cbiAgc3RhdGljIGdldCBjYW5VcGxvYWRTYW1lQnVmZmVyKCkge1xuICAgIHRoaXMuX2NhblVwbG9hZFNhbWVCdWZmZXIgPSB0aGlzLl9jYW5VcGxvYWRTYW1lQnVmZmVyID8/IGNhblVwbG9hZFNhbWVCdWZmZXIuY2FuVXBsb2FkU2FtZUJ1ZmZlcigpO1xuICAgIHJldHVybiB0aGlzLl9jYW5VcGxvYWRTYW1lQnVmZmVyO1xuICB9XG4gIHN0YXRpYyBzZXQgY2FuVXBsb2FkU2FtZUJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMuX2NhblVwbG9hZFNhbWVCdWZmZXIgPSB2YWx1ZTtcbiAgfVxuICBnZXQgTUFYX1RFWFRVUkVTKCkge1xuICAgIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJCYXRjaFJlbmRlcmVyI01BWF9URVhUVVJFUyByZW5hbWVkIHRvIEJhdGNoUmVuZGVyZXIjbWF4VGV4dHVyZXNcIik7XG4gICAgcmV0dXJuIHRoaXMubWF4VGV4dHVyZXM7XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0VmVydGV4U3JjKCkge1xuICAgIHJldHVybiB0ZXh0dXJlW1wiZGVmYXVsdFwiXTtcbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRGcmFnbWVudFRlbXBsYXRlKCkge1xuICAgIHJldHVybiB0ZXh0dXJlJDFbXCJkZWZhdWx0XCJdO1xuICB9XG4gIHNldFNoYWRlckdlbmVyYXRvcih7XG4gICAgdmVydGV4ID0gX0JhdGNoUmVuZGVyZXIuZGVmYXVsdFZlcnRleFNyYyxcbiAgICBmcmFnbWVudCA9IF9CYXRjaFJlbmRlcmVyLmRlZmF1bHRGcmFnbWVudFRlbXBsYXRlXG4gIH0gPSB7fSkge1xuICAgIHRoaXMuc2hhZGVyR2VuZXJhdG9yID0gbmV3IEJhdGNoU2hhZGVyR2VuZXJhdG9yLkJhdGNoU2hhZGVyR2VuZXJhdG9yKHZlcnRleCwgZnJhZ21lbnQpO1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgIGlmIChzZXR0aW5ncy5zZXR0aW5ncy5QUkVGRVJfRU5WID09PSBjb25zdGFudHMuRU5WLldFQkdMX0xFR0FDWSkge1xuICAgICAgdGhpcy5tYXhUZXh0dXJlcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWF4VGV4dHVyZXMgPSBNYXRoLm1pbihnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpLCBfQmF0Y2hSZW5kZXJlci5kZWZhdWx0TWF4VGV4dHVyZXMpO1xuICAgICAgdGhpcy5tYXhUZXh0dXJlcyA9IGNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIuY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlcih0aGlzLm1heFRleHR1cmVzLCBnbCk7XG4gICAgfVxuICAgIHRoaXMuX3NoYWRlciA9IHRoaXMuc2hhZGVyR2VuZXJhdG9yLmdlbmVyYXRlU2hhZGVyKHRoaXMubWF4VGV4dHVyZXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcGFja2VkR2VvbWV0cnlQb29sU2l6ZTsgaSsrKSB7XG4gICAgICB0aGlzLl9wYWNrZWRHZW9tZXRyaWVzW2ldID0gbmV3IHRoaXMuZ2VvbWV0cnlDbGFzcygpO1xuICAgIH1cbiAgICB0aGlzLmluaXRGbHVzaEJ1ZmZlcnMoKTtcbiAgfVxuICBpbml0Rmx1c2hCdWZmZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIF9kcmF3Q2FsbFBvb2wsXG4gICAgICBfdGV4dHVyZUFycmF5UG9vbFxuICAgIH0gPSBfQmF0Y2hSZW5kZXJlcjtcbiAgICBjb25zdCBNQVhfU1BSSVRFUyA9IHRoaXMuc2l6ZSAvIDQ7XG4gICAgY29uc3QgTUFYX1RBID0gTWF0aC5mbG9vcihNQVhfU1BSSVRFUyAvIHRoaXMubWF4VGV4dHVyZXMpICsgMTtcbiAgICB3aGlsZSAoX2RyYXdDYWxsUG9vbC5sZW5ndGggPCBNQVhfU1BSSVRFUykge1xuICAgICAgX2RyYXdDYWxsUG9vbC5wdXNoKG5ldyBCYXRjaERyYXdDYWxsLkJhdGNoRHJhd0NhbGwoKSk7XG4gICAgfVxuICAgIHdoaWxlIChfdGV4dHVyZUFycmF5UG9vbC5sZW5ndGggPCBNQVhfVEEpIHtcbiAgICAgIF90ZXh0dXJlQXJyYXlQb29sLnB1c2gobmV3IEJhdGNoVGV4dHVyZUFycmF5LkJhdGNoVGV4dHVyZUFycmF5KCkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWF4VGV4dHVyZXM7IGkrKykge1xuICAgICAgdGhpcy5fdGVtcEJvdW5kVGV4dHVyZXNbaV0gPSBudWxsO1xuICAgIH1cbiAgfVxuICBvblByZXJlbmRlcigpIHtcbiAgICB0aGlzLl9mbHVzaElkID0gMDtcbiAgfVxuICByZW5kZXIoZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudC5fdGV4dHVyZS52YWxpZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdmVydGV4Q291bnQgKyBlbGVtZW50LnZlcnRleERhdGEubGVuZ3RoIC8gMiA+IHRoaXMuc2l6ZSkge1xuICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgICB0aGlzLl92ZXJ0ZXhDb3VudCArPSBlbGVtZW50LnZlcnRleERhdGEubGVuZ3RoIC8gMjtcbiAgICB0aGlzLl9pbmRleENvdW50ICs9IGVsZW1lbnQuaW5kaWNlcy5sZW5ndGg7XG4gICAgdGhpcy5fYnVmZmVyZWRUZXh0dXJlc1t0aGlzLl9idWZmZXJTaXplXSA9IGVsZW1lbnQuX3RleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgdGhpcy5fYnVmZmVyZWRFbGVtZW50c1t0aGlzLl9idWZmZXJTaXplKytdID0gZWxlbWVudDtcbiAgfVxuICBidWlsZFRleHR1cmVzQW5kRHJhd0NhbGxzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIF9idWZmZXJlZFRleHR1cmVzOiB0ZXh0dXJlcyxcbiAgICAgIG1heFRleHR1cmVzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgdGV4dHVyZUFycmF5cyA9IF9CYXRjaFJlbmRlcmVyLl90ZXh0dXJlQXJyYXlQb29sO1xuICAgIGNvbnN0IGJhdGNoID0gdGhpcy5yZW5kZXJlci5iYXRjaDtcbiAgICBjb25zdCBib3VuZFRleHR1cmVzID0gdGhpcy5fdGVtcEJvdW5kVGV4dHVyZXM7XG4gICAgY29uc3QgdG91Y2ggPSB0aGlzLnJlbmRlcmVyLnRleHR1cmVHQy5jb3VudDtcbiAgICBsZXQgVElDSyA9ICsrQmFzZVRleHR1cmUuQmFzZVRleHR1cmUuX2dsb2JhbEJhdGNoO1xuICAgIGxldCBjb3VudFRleEFycmF5cyA9IDA7XG4gICAgbGV0IHRleEFycmF5ID0gdGV4dHVyZUFycmF5c1swXTtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGJhdGNoLmNvcHlCb3VuZFRleHR1cmVzKGJvdW5kVGV4dHVyZXMsIG1heFRleHR1cmVzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2J1ZmZlclNpemU7ICsraSkge1xuICAgICAgY29uc3QgdGV4ID0gdGV4dHVyZXNbaV07XG4gICAgICB0ZXh0dXJlc1tpXSA9IG51bGw7XG4gICAgICBpZiAodGV4Ll9iYXRjaEVuYWJsZWQgPT09IFRJQ0spIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodGV4QXJyYXkuY291bnQgPj0gbWF4VGV4dHVyZXMpIHtcbiAgICAgICAgYmF0Y2guYm91bmRBcnJheSh0ZXhBcnJheSwgYm91bmRUZXh0dXJlcywgVElDSywgbWF4VGV4dHVyZXMpO1xuICAgICAgICB0aGlzLmJ1aWxkRHJhd0NhbGxzKHRleEFycmF5LCBzdGFydCwgaSk7XG4gICAgICAgIHN0YXJ0ID0gaTtcbiAgICAgICAgdGV4QXJyYXkgPSB0ZXh0dXJlQXJyYXlzWysrY291bnRUZXhBcnJheXNdO1xuICAgICAgICArK1RJQ0s7XG4gICAgICB9XG4gICAgICB0ZXguX2JhdGNoRW5hYmxlZCA9IFRJQ0s7XG4gICAgICB0ZXgudG91Y2hlZCA9IHRvdWNoO1xuICAgICAgdGV4QXJyYXkuZWxlbWVudHNbdGV4QXJyYXkuY291bnQrK10gPSB0ZXg7XG4gICAgfVxuICAgIGlmICh0ZXhBcnJheS5jb3VudCA+IDApIHtcbiAgICAgIGJhdGNoLmJvdW5kQXJyYXkodGV4QXJyYXksIGJvdW5kVGV4dHVyZXMsIFRJQ0ssIG1heFRleHR1cmVzKTtcbiAgICAgIHRoaXMuYnVpbGREcmF3Q2FsbHModGV4QXJyYXksIHN0YXJ0LCB0aGlzLl9idWZmZXJTaXplKTtcbiAgICAgICsrY291bnRUZXhBcnJheXM7XG4gICAgICArK1RJQ0s7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm91bmRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgYm91bmRUZXh0dXJlc1tpXSA9IG51bGw7XG4gICAgfVxuICAgIEJhc2VUZXh0dXJlLkJhc2VUZXh0dXJlLl9nbG9iYWxCYXRjaCA9IFRJQ0s7XG4gIH1cbiAgYnVpbGREcmF3Q2FsbHModGV4QXJyYXksIHN0YXJ0LCBmaW5pc2gpIHtcbiAgICBjb25zdCB7XG4gICAgICBfYnVmZmVyZWRFbGVtZW50czogZWxlbWVudHMsXG4gICAgICBfYXR0cmlidXRlQnVmZmVyLFxuICAgICAgX2luZGV4QnVmZmVyLFxuICAgICAgdmVydGV4U2l6ZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGRyYXdDYWxscyA9IF9CYXRjaFJlbmRlcmVyLl9kcmF3Q2FsbFBvb2w7XG4gICAgbGV0IGRjSW5kZXggPSB0aGlzLl9kY0luZGV4O1xuICAgIGxldCBhSW5kZXggPSB0aGlzLl9hSW5kZXg7XG4gICAgbGV0IGlJbmRleCA9IHRoaXMuX2lJbmRleDtcbiAgICBsZXQgZHJhd0NhbGwgPSBkcmF3Q2FsbHNbZGNJbmRleF07XG4gICAgZHJhd0NhbGwuc3RhcnQgPSB0aGlzLl9pSW5kZXg7XG4gICAgZHJhd0NhbGwudGV4QXJyYXkgPSB0ZXhBcnJheTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBmaW5pc2g7ICsraSkge1xuICAgICAgY29uc3Qgc3ByaXRlID0gZWxlbWVudHNbaV07XG4gICAgICBjb25zdCB0ZXggPSBzcHJpdGUuX3RleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICBjb25zdCBzcHJpdGVCbGVuZE1vZGUgPSB1dGlscy5wcmVtdWx0aXBseUJsZW5kTW9kZVt0ZXguYWxwaGFNb2RlID8gMSA6IDBdW3Nwcml0ZS5ibGVuZE1vZGVdO1xuICAgICAgZWxlbWVudHNbaV0gPSBudWxsO1xuICAgICAgaWYgKHN0YXJ0IDwgaSAmJiBkcmF3Q2FsbC5ibGVuZCAhPT0gc3ByaXRlQmxlbmRNb2RlKSB7XG4gICAgICAgIGRyYXdDYWxsLnNpemUgPSBpSW5kZXggLSBkcmF3Q2FsbC5zdGFydDtcbiAgICAgICAgc3RhcnQgPSBpO1xuICAgICAgICBkcmF3Q2FsbCA9IGRyYXdDYWxsc1srK2RjSW5kZXhdO1xuICAgICAgICBkcmF3Q2FsbC50ZXhBcnJheSA9IHRleEFycmF5O1xuICAgICAgICBkcmF3Q2FsbC5zdGFydCA9IGlJbmRleDtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFja0ludGVybGVhdmVkR2VvbWV0cnkoc3ByaXRlLCBfYXR0cmlidXRlQnVmZmVyLCBfaW5kZXhCdWZmZXIsIGFJbmRleCwgaUluZGV4KTtcbiAgICAgIGFJbmRleCArPSBzcHJpdGUudmVydGV4RGF0YS5sZW5ndGggLyAyICogdmVydGV4U2l6ZTtcbiAgICAgIGlJbmRleCArPSBzcHJpdGUuaW5kaWNlcy5sZW5ndGg7XG4gICAgICBkcmF3Q2FsbC5ibGVuZCA9IHNwcml0ZUJsZW5kTW9kZTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0IDwgZmluaXNoKSB7XG4gICAgICBkcmF3Q2FsbC5zaXplID0gaUluZGV4IC0gZHJhd0NhbGwuc3RhcnQ7XG4gICAgICArK2RjSW5kZXg7XG4gICAgfVxuICAgIHRoaXMuX2RjSW5kZXggPSBkY0luZGV4O1xuICAgIHRoaXMuX2FJbmRleCA9IGFJbmRleDtcbiAgICB0aGlzLl9pSW5kZXggPSBpSW5kZXg7XG4gIH1cbiAgYmluZEFuZENsZWFyVGV4QXJyYXkodGV4QXJyYXkpIHtcbiAgICBjb25zdCB0ZXh0dXJlU3lzdGVtID0gdGhpcy5yZW5kZXJlci50ZXh0dXJlO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGV4QXJyYXkuY291bnQ7IGorKykge1xuICAgICAgdGV4dHVyZVN5c3RlbS5iaW5kKHRleEFycmF5LmVsZW1lbnRzW2pdLCB0ZXhBcnJheS5pZHNbal0pO1xuICAgICAgdGV4QXJyYXkuZWxlbWVudHNbal0gPSBudWxsO1xuICAgIH1cbiAgICB0ZXhBcnJheS5jb3VudCA9IDA7XG4gIH1cbiAgdXBkYXRlR2VvbWV0cnkoKSB7XG4gICAgY29uc3Qge1xuICAgICAgX3BhY2tlZEdlb21ldHJpZXM6IHBhY2tlZEdlb21ldHJpZXMsXG4gICAgICBfYXR0cmlidXRlQnVmZmVyOiBhdHRyaWJ1dGVCdWZmZXIsXG4gICAgICBfaW5kZXhCdWZmZXI6IGluZGV4QnVmZmVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFfQmF0Y2hSZW5kZXJlci5jYW5VcGxvYWRTYW1lQnVmZmVyKSB7XG4gICAgICBpZiAodGhpcy5fcGFja2VkR2VvbWV0cnlQb29sU2l6ZSA8PSB0aGlzLl9mbHVzaElkKSB7XG4gICAgICAgIHRoaXMuX3BhY2tlZEdlb21ldHJ5UG9vbFNpemUrKztcbiAgICAgICAgcGFja2VkR2VvbWV0cmllc1t0aGlzLl9mbHVzaElkXSA9IG5ldyB0aGlzLmdlb21ldHJ5Q2xhc3MoKTtcbiAgICAgIH1cbiAgICAgIHBhY2tlZEdlb21ldHJpZXNbdGhpcy5fZmx1c2hJZF0uX2J1ZmZlci51cGRhdGUoYXR0cmlidXRlQnVmZmVyLnJhd0JpbmFyeURhdGEpO1xuICAgICAgcGFja2VkR2VvbWV0cmllc1t0aGlzLl9mbHVzaElkXS5faW5kZXhCdWZmZXIudXBkYXRlKGluZGV4QnVmZmVyKTtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2VvbWV0cnkuYmluZChwYWNrZWRHZW9tZXRyaWVzW3RoaXMuX2ZsdXNoSWRdKTtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2VvbWV0cnkudXBkYXRlQnVmZmVycygpO1xuICAgICAgdGhpcy5fZmx1c2hJZCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrZWRHZW9tZXRyaWVzW3RoaXMuX2ZsdXNoSWRdLl9idWZmZXIudXBkYXRlKGF0dHJpYnV0ZUJ1ZmZlci5yYXdCaW5hcnlEYXRhKTtcbiAgICAgIHBhY2tlZEdlb21ldHJpZXNbdGhpcy5fZmx1c2hJZF0uX2luZGV4QnVmZmVyLnVwZGF0ZShpbmRleEJ1ZmZlcik7XG4gICAgICB0aGlzLnJlbmRlcmVyLmdlb21ldHJ5LnVwZGF0ZUJ1ZmZlcnMoKTtcbiAgICB9XG4gIH1cbiAgZHJhd0JhdGNoZXMoKSB7XG4gICAgY29uc3QgZGNDb3VudCA9IHRoaXMuX2RjSW5kZXg7XG4gICAgY29uc3QgeyBnbCwgc3RhdGU6IHN0YXRlU3lzdGVtIH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIGNvbnN0IGRyYXdDYWxscyA9IF9CYXRjaFJlbmRlcmVyLl9kcmF3Q2FsbFBvb2w7XG4gICAgbGV0IGN1clRleEFycmF5ID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRjQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgeyB0ZXhBcnJheSwgdHlwZSwgc2l6ZSwgc3RhcnQsIGJsZW5kIH0gPSBkcmF3Q2FsbHNbaV07XG4gICAgICBpZiAoY3VyVGV4QXJyYXkgIT09IHRleEFycmF5KSB7XG4gICAgICAgIGN1clRleEFycmF5ID0gdGV4QXJyYXk7XG4gICAgICAgIHRoaXMuYmluZEFuZENsZWFyVGV4QXJyYXkodGV4QXJyYXkpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZS5ibGVuZE1vZGUgPSBibGVuZDtcbiAgICAgIHN0YXRlU3lzdGVtLnNldCh0aGlzLnN0YXRlKTtcbiAgICAgIGdsLmRyYXdFbGVtZW50cyh0eXBlLCBzaXplLCBnbC5VTlNJR05FRF9TSE9SVCwgc3RhcnQgKiAyKTtcbiAgICB9XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgaWYgKHRoaXMuX3ZlcnRleENvdW50ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2F0dHJpYnV0ZUJ1ZmZlciA9IHRoaXMuZ2V0QXR0cmlidXRlQnVmZmVyKHRoaXMuX3ZlcnRleENvdW50KTtcbiAgICB0aGlzLl9pbmRleEJ1ZmZlciA9IHRoaXMuZ2V0SW5kZXhCdWZmZXIodGhpcy5faW5kZXhDb3VudCk7XG4gICAgdGhpcy5fYUluZGV4ID0gMDtcbiAgICB0aGlzLl9pSW5kZXggPSAwO1xuICAgIHRoaXMuX2RjSW5kZXggPSAwO1xuICAgIHRoaXMuYnVpbGRUZXh0dXJlc0FuZERyYXdDYWxscygpO1xuICAgIHRoaXMudXBkYXRlR2VvbWV0cnkoKTtcbiAgICB0aGlzLmRyYXdCYXRjaGVzKCk7XG4gICAgdGhpcy5fYnVmZmVyU2l6ZSA9IDA7XG4gICAgdGhpcy5fdmVydGV4Q291bnQgPSAwO1xuICAgIHRoaXMuX2luZGV4Q291bnQgPSAwO1xuICB9XG4gIHN0YXJ0KCkge1xuICAgIHRoaXMucmVuZGVyZXIuc3RhdGUuc2V0KHRoaXMuc3RhdGUpO1xuICAgIHRoaXMucmVuZGVyZXIudGV4dHVyZS5lbnN1cmVTYW1wbGVyVHlwZSh0aGlzLm1heFRleHR1cmVzKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNoYWRlci5iaW5kKHRoaXMuX3NoYWRlcik7XG4gICAgaWYgKF9CYXRjaFJlbmRlcmVyLmNhblVwbG9hZFNhbWVCdWZmZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLl9wYWNrZWRHZW9tZXRyaWVzW3RoaXMuX2ZsdXNoSWRdKTtcbiAgICB9XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3BhY2tlZEdlb21ldHJ5UG9vbFNpemU7IGkrKykge1xuICAgICAgaWYgKHRoaXMuX3BhY2tlZEdlb21ldHJpZXNbaV0pIHtcbiAgICAgICAgdGhpcy5fcGFja2VkR2VvbWV0cmllc1tpXS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZXIub2ZmKFwicHJlcmVuZGVyXCIsIHRoaXMub25QcmVyZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMuX2FCdWZmZXJzID0gbnVsbDtcbiAgICB0aGlzLl9pQnVmZmVycyA9IG51bGw7XG4gICAgdGhpcy5fcGFja2VkR2VvbWV0cmllcyA9IG51bGw7XG4gICAgdGhpcy5fYXR0cmlidXRlQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLl9pbmRleEJ1ZmZlciA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3NoYWRlcikge1xuICAgICAgdGhpcy5fc2hhZGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX3NoYWRlciA9IG51bGw7XG4gICAgfVxuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuICBnZXRBdHRyaWJ1dGVCdWZmZXIoc2l6ZSkge1xuICAgIGNvbnN0IHJvdW5kZWRQMiA9IHV0aWxzLm5leHRQb3cyKE1hdGguY2VpbChzaXplIC8gOCkpO1xuICAgIGNvbnN0IHJvdW5kZWRTaXplSW5kZXggPSB1dGlscy5sb2cyKHJvdW5kZWRQMik7XG4gICAgY29uc3Qgcm91bmRlZFNpemUgPSByb3VuZGVkUDIgKiA4O1xuICAgIGlmICh0aGlzLl9hQnVmZmVycy5sZW5ndGggPD0gcm91bmRlZFNpemVJbmRleCkge1xuICAgICAgdGhpcy5faUJ1ZmZlcnMubGVuZ3RoID0gcm91bmRlZFNpemVJbmRleCArIDE7XG4gICAgfVxuICAgIGxldCBidWZmZXIgPSB0aGlzLl9hQnVmZmVyc1tyb3VuZGVkU2l6ZV07XG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIHRoaXMuX2FCdWZmZXJzW3JvdW5kZWRTaXplXSA9IGJ1ZmZlciA9IG5ldyBWaWV3YWJsZUJ1ZmZlci5WaWV3YWJsZUJ1ZmZlcihyb3VuZGVkU2l6ZSAqIHRoaXMudmVydGV4U2l6ZSAqIDQpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG4gIGdldEluZGV4QnVmZmVyKHNpemUpIHtcbiAgICBjb25zdCByb3VuZGVkUDIgPSB1dGlscy5uZXh0UG93MihNYXRoLmNlaWwoc2l6ZSAvIDEyKSk7XG4gICAgY29uc3Qgcm91bmRlZFNpemVJbmRleCA9IHV0aWxzLmxvZzIocm91bmRlZFAyKTtcbiAgICBjb25zdCByb3VuZGVkU2l6ZSA9IHJvdW5kZWRQMiAqIDEyO1xuICAgIGlmICh0aGlzLl9pQnVmZmVycy5sZW5ndGggPD0gcm91bmRlZFNpemVJbmRleCkge1xuICAgICAgdGhpcy5faUJ1ZmZlcnMubGVuZ3RoID0gcm91bmRlZFNpemVJbmRleCArIDE7XG4gICAgfVxuICAgIGxldCBidWZmZXIgPSB0aGlzLl9pQnVmZmVyc1tyb3VuZGVkU2l6ZUluZGV4XTtcbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgdGhpcy5faUJ1ZmZlcnNbcm91bmRlZFNpemVJbmRleF0gPSBidWZmZXIgPSBuZXcgVWludDE2QXJyYXkocm91bmRlZFNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG4gIHBhY2tJbnRlcmxlYXZlZEdlb21ldHJ5KGVsZW1lbnQsIGF0dHJpYnV0ZUJ1ZmZlciwgaW5kZXhCdWZmZXIsIGFJbmRleCwgaUluZGV4KSB7XG4gICAgY29uc3Qge1xuICAgICAgdWludDMyVmlldyxcbiAgICAgIGZsb2F0MzJWaWV3XG4gICAgfSA9IGF0dHJpYnV0ZUJ1ZmZlcjtcbiAgICBjb25zdCBwYWNrZWRWZXJ0aWNlcyA9IGFJbmRleCAvIHRoaXMudmVydGV4U2l6ZTtcbiAgICBjb25zdCB1dnMgPSBlbGVtZW50LnV2cztcbiAgICBjb25zdCBpbmRpY2llcyA9IGVsZW1lbnQuaW5kaWNlcztcbiAgICBjb25zdCB2ZXJ0ZXhEYXRhID0gZWxlbWVudC52ZXJ0ZXhEYXRhO1xuICAgIGNvbnN0IHRleHR1cmVJZCA9IGVsZW1lbnQuX3RleHR1cmUuYmFzZVRleHR1cmUuX2JhdGNoTG9jYXRpb247XG4gICAgY29uc3QgYWxwaGEgPSBNYXRoLm1pbihlbGVtZW50LndvcmxkQWxwaGEsIDEpO1xuICAgIGNvbnN0IGFyZ2IgPSBjb2xvci5Db2xvci5zaGFyZWQuc2V0VmFsdWUoZWxlbWVudC5fdGludFJHQikudG9QcmVtdWx0aXBsaWVkKGFscGhhLCBlbGVtZW50Ll90ZXh0dXJlLmJhc2VUZXh0dXJlLmFscGhhTW9kZSA+IDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGV4RGF0YS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgZmxvYXQzMlZpZXdbYUluZGV4KytdID0gdmVydGV4RGF0YVtpXTtcbiAgICAgIGZsb2F0MzJWaWV3W2FJbmRleCsrXSA9IHZlcnRleERhdGFbaSArIDFdO1xuICAgICAgZmxvYXQzMlZpZXdbYUluZGV4KytdID0gdXZzW2ldO1xuICAgICAgZmxvYXQzMlZpZXdbYUluZGV4KytdID0gdXZzW2kgKyAxXTtcbiAgICAgIHVpbnQzMlZpZXdbYUluZGV4KytdID0gYXJnYjtcbiAgICAgIGZsb2F0MzJWaWV3W2FJbmRleCsrXSA9IHRleHR1cmVJZDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgaW5kZXhCdWZmZXJbaUluZGV4KytdID0gcGFja2VkVmVydGljZXMgKyBpbmRpY2llc1tpXTtcbiAgICB9XG4gIH1cbn07XG5sZXQgQmF0Y2hSZW5kZXJlciA9IF9CYXRjaFJlbmRlcmVyO1xuQmF0Y2hSZW5kZXJlci5kZWZhdWx0QmF0Y2hTaXplID0gNDA5NjtcbkJhdGNoUmVuZGVyZXIuZXh0ZW5zaW9uID0ge1xuICBuYW1lOiBcImJhdGNoXCIsXG4gIHR5cGU6IGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclBsdWdpblxufTtcbkJhdGNoUmVuZGVyZXIuX2RyYXdDYWxsUG9vbCA9IFtdO1xuQmF0Y2hSZW5kZXJlci5fdGV4dHVyZUFycmF5UG9vbCA9IFtdO1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmFkZChCYXRjaFJlbmRlcmVyKTtcblxuZXhwb3J0cy5CYXRjaFJlbmRlcmVyID0gQmF0Y2hSZW5kZXJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhdGNoUmVuZGVyZXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBtYXRoID0gcmVxdWlyZSgnQHBpeGkvbWF0aCcpO1xudmFyIFByb2dyYW0gPSByZXF1aXJlKCcuLi9zaGFkZXIvUHJvZ3JhbS5qcycpO1xudmFyIFNoYWRlciA9IHJlcXVpcmUoJy4uL3NoYWRlci9TaGFkZXIuanMnKTtcbnZhciBVbmlmb3JtR3JvdXAgPSByZXF1aXJlKCcuLi9zaGFkZXIvVW5pZm9ybUdyb3VwLmpzJyk7XG5cbmNsYXNzIEJhdGNoU2hhZGVyR2VuZXJhdG9yIHtcbiAgY29uc3RydWN0b3IodmVydGV4U3JjLCBmcmFnVGVtcGxhdGUpIHtcbiAgICB0aGlzLnZlcnRleFNyYyA9IHZlcnRleFNyYztcbiAgICB0aGlzLmZyYWdUZW1wbGF0ZSA9IGZyYWdUZW1wbGF0ZTtcbiAgICB0aGlzLnByb2dyYW1DYWNoZSA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdEdyb3VwQ2FjaGUgPSB7fTtcbiAgICBpZiAoIWZyYWdUZW1wbGF0ZS5pbmNsdWRlcyhcIiVjb3VudCVcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRnJhZ21lbnQgdGVtcGxhdGUgbXVzdCBjb250YWluIFwiJWNvdW50JVwiLicpO1xuICAgIH1cbiAgICBpZiAoIWZyYWdUZW1wbGF0ZS5pbmNsdWRlcyhcIiVmb3Jsb29wJVwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcmFnbWVudCB0ZW1wbGF0ZSBtdXN0IGNvbnRhaW4gXCIlZm9ybG9vcCVcIi4nKTtcbiAgICB9XG4gIH1cbiAgZ2VuZXJhdGVTaGFkZXIobWF4VGV4dHVyZXMpIHtcbiAgICBpZiAoIXRoaXMucHJvZ3JhbUNhY2hlW21heFRleHR1cmVzXSkge1xuICAgICAgY29uc3Qgc2FtcGxlVmFsdWVzID0gbmV3IEludDMyQXJyYXkobWF4VGV4dHVyZXMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhUZXh0dXJlczsgaSsrKSB7XG4gICAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGk7XG4gICAgICB9XG4gICAgICB0aGlzLmRlZmF1bHRHcm91cENhY2hlW21heFRleHR1cmVzXSA9IFVuaWZvcm1Hcm91cC5Vbmlmb3JtR3JvdXAuZnJvbSh7IHVTYW1wbGVyczogc2FtcGxlVmFsdWVzIH0sIHRydWUpO1xuICAgICAgbGV0IGZyYWdtZW50U3JjID0gdGhpcy5mcmFnVGVtcGxhdGU7XG4gICAgICBmcmFnbWVudFNyYyA9IGZyYWdtZW50U3JjLnJlcGxhY2UoLyVjb3VudCUvZ2ksIGAke21heFRleHR1cmVzfWApO1xuICAgICAgZnJhZ21lbnRTcmMgPSBmcmFnbWVudFNyYy5yZXBsYWNlKC8lZm9ybG9vcCUvZ2ksIHRoaXMuZ2VuZXJhdGVTYW1wbGVTcmMobWF4VGV4dHVyZXMpKTtcbiAgICAgIHRoaXMucHJvZ3JhbUNhY2hlW21heFRleHR1cmVzXSA9IG5ldyBQcm9ncmFtLlByb2dyYW0odGhpcy52ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjKTtcbiAgICB9XG4gICAgY29uc3QgdW5pZm9ybXMgPSB7XG4gICAgICB0aW50OiBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxLCAxXSksXG4gICAgICB0cmFuc2xhdGlvbk1hdHJpeDogbmV3IG1hdGguTWF0cml4KCksXG4gICAgICBkZWZhdWx0OiB0aGlzLmRlZmF1bHRHcm91cENhY2hlW21heFRleHR1cmVzXVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBTaGFkZXIuU2hhZGVyKHRoaXMucHJvZ3JhbUNhY2hlW21heFRleHR1cmVzXSwgdW5pZm9ybXMpO1xuICB9XG4gIGdlbmVyYXRlU2FtcGxlU3JjKG1heFRleHR1cmVzKSB7XG4gICAgbGV0IHNyYyA9IFwiXCI7XG4gICAgc3JjICs9IFwiXFxuXCI7XG4gICAgc3JjICs9IFwiXFxuXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhUZXh0dXJlczsgaSsrKSB7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgc3JjICs9IFwiXFxuZWxzZSBcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpIDwgbWF4VGV4dHVyZXMgLSAxKSB7XG4gICAgICAgIHNyYyArPSBgaWYodlRleHR1cmVJZCA8ICR7aX0uNSlgO1xuICAgICAgfVxuICAgICAgc3JjICs9IFwiXFxue1wiO1xuICAgICAgc3JjICs9IGBcblx0Y29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXJzWyR7aX1dLCB2VGV4dHVyZUNvb3JkKTtgO1xuICAgICAgc3JjICs9IFwiXFxufVwiO1xuICAgIH1cbiAgICBzcmMgKz0gXCJcXG5cIjtcbiAgICBzcmMgKz0gXCJcXG5cIjtcbiAgICByZXR1cm4gc3JjO1xuICB9XG59XG5cbmV4cG9ydHMuQmF0Y2hTaGFkZXJHZW5lcmF0b3IgPSBCYXRjaFNoYWRlckdlbmVyYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhdGNoU2hhZGVyR2VuZXJhdG9yLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZXh0ZW5zaW9ucyA9IHJlcXVpcmUoJ0BwaXhpL2V4dGVuc2lvbnMnKTtcbnZhciBPYmplY3RSZW5kZXJlciA9IHJlcXVpcmUoJy4vT2JqZWN0UmVuZGVyZXIuanMnKTtcblxuY2xhc3MgQmF0Y2hTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLmVtcHR5UmVuZGVyZXIgPSBuZXcgT2JqZWN0UmVuZGVyZXIuT2JqZWN0UmVuZGVyZXIocmVuZGVyZXIpO1xuICAgIHRoaXMuY3VycmVudFJlbmRlcmVyID0gdGhpcy5lbXB0eVJlbmRlcmVyO1xuICB9XG4gIHNldE9iamVjdFJlbmRlcmVyKG9iamVjdFJlbmRlcmVyKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFJlbmRlcmVyID09PSBvYmplY3RSZW5kZXJlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRSZW5kZXJlci5zdG9wKCk7XG4gICAgdGhpcy5jdXJyZW50UmVuZGVyZXIgPSBvYmplY3RSZW5kZXJlcjtcbiAgICB0aGlzLmN1cnJlbnRSZW5kZXJlci5zdGFydCgpO1xuICB9XG4gIGZsdXNoKCkge1xuICAgIHRoaXMuc2V0T2JqZWN0UmVuZGVyZXIodGhpcy5lbXB0eVJlbmRlcmVyKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnNldE9iamVjdFJlbmRlcmVyKHRoaXMuZW1wdHlSZW5kZXJlcik7XG4gIH1cbiAgY29weUJvdW5kVGV4dHVyZXMoYXJyLCBtYXhUZXh0dXJlcykge1xuICAgIGNvbnN0IHsgYm91bmRUZXh0dXJlcyB9ID0gdGhpcy5yZW5kZXJlci50ZXh0dXJlO1xuICAgIGZvciAobGV0IGkgPSBtYXhUZXh0dXJlcyAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBhcnJbaV0gPSBib3VuZFRleHR1cmVzW2ldIHx8IG51bGw7XG4gICAgICBpZiAoYXJyW2ldKSB7XG4gICAgICAgIGFycltpXS5fYmF0Y2hMb2NhdGlvbiA9IGk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGJvdW5kQXJyYXkodGV4QXJyYXksIGJvdW5kVGV4dHVyZXMsIGJhdGNoSWQsIG1heFRleHR1cmVzKSB7XG4gICAgY29uc3QgeyBlbGVtZW50cywgaWRzLCBjb3VudCB9ID0gdGV4QXJyYXk7XG4gICAgbGV0IGogPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdGV4ID0gZWxlbWVudHNbaV07XG4gICAgICBjb25zdCBsb2MgPSB0ZXguX2JhdGNoTG9jYXRpb247XG4gICAgICBpZiAobG9jID49IDAgJiYgbG9jIDwgbWF4VGV4dHVyZXMgJiYgYm91bmRUZXh0dXJlc1tsb2NdID09PSB0ZXgpIHtcbiAgICAgICAgaWRzW2ldID0gbG9jO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChqIDwgbWF4VGV4dHVyZXMpIHtcbiAgICAgICAgY29uc3QgYm91bmQgPSBib3VuZFRleHR1cmVzW2pdO1xuICAgICAgICBpZiAoYm91bmQgJiYgYm91bmQuX2JhdGNoRW5hYmxlZCA9PT0gYmF0Y2hJZCAmJiBib3VuZC5fYmF0Y2hMb2NhdGlvbiA9PT0gaikge1xuICAgICAgICAgIGorKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZHNbaV0gPSBqO1xuICAgICAgICB0ZXguX2JhdGNoTG9jYXRpb24gPSBqO1xuICAgICAgICBib3VuZFRleHR1cmVzW2pdID0gdGV4O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuQmF0Y2hTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwiYmF0Y2hcIlxufTtcbmV4dGVuc2lvbnMuZXh0ZW5zaW9ucy5hZGQoQmF0Y2hTeXN0ZW0pO1xuXG5leHBvcnRzLkJhdGNoU3lzdGVtID0gQmF0Y2hTeXN0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXRjaFN5c3RlbS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY2xhc3MgQmF0Y2hUZXh0dXJlQXJyYXkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gW107XG4gICAgdGhpcy5pZHMgPSBbXTtcbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY291bnQ7IGkrKykge1xuICAgICAgdGhpcy5lbGVtZW50c1tpXSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY291bnQgPSAwO1xuICB9XG59XG5cbmV4cG9ydHMuQmF0Y2hUZXh0dXJlQXJyYXkgPSBCYXRjaFRleHR1cmVBcnJheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhdGNoVGV4dHVyZUFycmF5LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jbGFzcyBPYmplY3RSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIGZsdXNoKCkge1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbiAgc3RhcnQoKSB7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbiAgcmVuZGVyKF9vYmplY3QpIHtcbiAgfVxufVxuXG5leHBvcnRzLk9iamVjdFJlbmRlcmVyID0gT2JqZWN0UmVuZGVyZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYmplY3RSZW5kZXJlci5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHNldHRpbmdzID0gcmVxdWlyZSgnQHBpeGkvc2V0dGluZ3MnKTtcblxuZnVuY3Rpb24gY2FuVXBsb2FkU2FtZUJ1ZmZlcigpIHtcbiAgcmV0dXJuICFzZXR0aW5ncy5pc01vYmlsZS5hcHBsZS5kZXZpY2U7XG59XG5cbmV4cG9ydHMuY2FuVXBsb2FkU2FtZUJ1ZmZlciA9IGNhblVwbG9hZFNhbWVCdWZmZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYW5VcGxvYWRTYW1lQnVmZmVyLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgc2V0dGluZ3MgPSByZXF1aXJlKCdAcGl4aS9zZXR0aW5ncycpO1xuXG5mdW5jdGlvbiBtYXhSZWNvbW1lbmRlZFRleHR1cmVzKG1heCkge1xuICBsZXQgYWxsb3dNYXggPSB0cnVlO1xuICBjb25zdCBuYXZpZ2F0b3IgPSBzZXR0aW5ncy5zZXR0aW5ncy5BREFQVEVSLmdldE5hdmlnYXRvcigpO1xuICBpZiAoc2V0dGluZ3MuaXNNb2JpbGUudGFibGV0IHx8IHNldHRpbmdzLmlzTW9iaWxlLnBob25lKSB7XG4gICAgaWYgKHNldHRpbmdzLmlzTW9iaWxlLmFwcGxlLmRldmljZSkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9PUyAoXFxkKylfKFxcZCspPy8pO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IG1ham9yVmVyc2lvbiA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICAgIGlmIChtYWpvclZlcnNpb24gPCAxMSkge1xuICAgICAgICAgIGFsbG93TWF4ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNldHRpbmdzLmlzTW9iaWxlLmFuZHJvaWQuZGV2aWNlKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWRcXHMoWzAtOS5dKikvKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBjb25zdCBtYWpvclZlcnNpb24gPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICBpZiAobWFqb3JWZXJzaW9uIDwgNykge1xuICAgICAgICAgIGFsbG93TWF4ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFsbG93TWF4ID8gbWF4IDogNDtcbn1cblxuZXhwb3J0cy5tYXhSZWNvbW1lbmRlZFRleHR1cmVzID0gbWF4UmVjb21tZW5kZWRUZXh0dXJlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heFJlY29tbWVuZGVkVGV4dHVyZXMuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBkZWZhdWx0RnJhZ21lbnQgPSBcInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxudmFyeWluZyBmbG9hdCB2VGV4dHVyZUlkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyc1slY291bnQlXTtcXG5cXG52b2lkIG1haW4odm9pZCl7XFxuICAgIHZlYzQgY29sb3I7XFxuICAgICVmb3Jsb29wJVxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvciAqIHZDb2xvcjtcXG59XFxuXCI7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZGVmYXVsdEZyYWdtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dHVyZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGRlZmF1bHRWZXJ0ZXggPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5hdHRyaWJ1dGUgdmVjNCBhQ29sb3I7XFxuYXR0cmlidXRlIGZsb2F0IGFUZXh0dXJlSWQ7XFxuXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxudW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xcbnVuaWZvcm0gdmVjNCB0aW50O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxudmFyeWluZyBmbG9hdCB2VGV4dHVyZUlkO1xcblxcbnZvaWQgbWFpbih2b2lkKXtcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXG5cXG4gICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuICAgIHZUZXh0dXJlSWQgPSBhVGV4dHVyZUlkO1xcbiAgICB2Q29sb3IgPSBhQ29sb3IgKiB0aW50O1xcbn1cXG5cIjtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBkZWZhdWx0VmVydGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dHVyZTIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCdAcGl4aS9jb25zdGFudHMnKTtcbnZhciBleHRlbnNpb25zID0gcmVxdWlyZSgnQHBpeGkvZXh0ZW5zaW9ucycpO1xudmFyIHNldHRpbmdzID0gcmVxdWlyZSgnQHBpeGkvc2V0dGluZ3MnKTtcblxubGV0IENPTlRFWFRfVUlEX0NPVU5URVIgPSAwO1xuY2xhc3MgQ29udGV4dFN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMud2ViR0xWZXJzaW9uID0gMTtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLnN1cHBvcnRzID0ge1xuICAgICAgdWludDMySW5kaWNlczogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlQ29udGV4dExvc3QgPSB0aGlzLmhhbmRsZUNvbnRleHRMb3N0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVDb250ZXh0UmVzdG9yZWQgPSB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZC5iaW5kKHRoaXMpO1xuICB9XG4gIGdldCBpc0xvc3QoKSB7XG4gICAgcmV0dXJuICF0aGlzLmdsIHx8IHRoaXMuZ2wuaXNDb250ZXh0TG9zdCgpO1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoZ2wpIHtcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5yZW5kZXJlci5nbCA9IGdsO1xuICAgIHRoaXMucmVuZGVyZXIuQ09OVEVYVF9VSUQgPSBDT05URVhUX1VJRF9DT1VOVEVSKys7XG4gIH1cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuY29udGV4dCkge1xuICAgICAgdGhpcy5pbml0RnJvbUNvbnRleHQob3B0aW9ucy5jb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYWxwaGEgPSB0aGlzLnJlbmRlcmVyLmJhY2tncm91bmQuYWxwaGEgPCAxO1xuICAgICAgY29uc3QgcHJlbXVsdGlwbGllZEFscGhhID0gb3B0aW9ucy5wcmVtdWx0aXBsaWVkQWxwaGE7XG4gICAgICB0aGlzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IG9wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyO1xuICAgICAgdGhpcy51c2VDb250ZXh0QWxwaGEgPSBvcHRpb25zLnVzZUNvbnRleHRBbHBoYTtcbiAgICAgIHRoaXMucG93ZXJQcmVmZXJlbmNlID0gb3B0aW9ucy5wb3dlclByZWZlcmVuY2U7XG4gICAgICB0aGlzLmluaXRGcm9tT3B0aW9ucyh7XG4gICAgICAgIGFscGhhLFxuICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGEsXG4gICAgICAgIGFudGlhbGlhczogb3B0aW9ucy5hbnRpYWxpYXMsXG4gICAgICAgIHN0ZW5jaWw6IHRydWUsXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIsXG4gICAgICAgIHBvd2VyUHJlZmVyZW5jZTogb3B0aW9ucy5wb3dlclByZWZlcmVuY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpbml0RnJvbUNvbnRleHQoZ2wpIHtcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy52YWxpZGF0ZUNvbnRleHQoZ2wpO1xuICAgIHRoaXMucmVuZGVyZXIuZ2wgPSBnbDtcbiAgICB0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEID0gQ09OVEVYVF9VSURfQ09VTlRFUisrO1xuICAgIHRoaXMucmVuZGVyZXIucnVubmVycy5jb250ZXh0Q2hhbmdlLmVtaXQoZ2wpO1xuICAgIGNvbnN0IHZpZXcgPSB0aGlzLnJlbmRlcmVyLnZpZXc7XG4gICAgaWYgKHZpZXcuYWRkRXZlbnRMaXN0ZW5lciAhPT0gdm9pZCAwKSB7XG4gICAgICB2aWV3LmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsIHRoaXMuaGFuZGxlQ29udGV4dExvc3QsIGZhbHNlKTtcbiAgICAgIHZpZXcuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dHJlc3RvcmVkXCIsIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIGluaXRGcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmNyZWF0ZUNvbnRleHQodGhpcy5yZW5kZXJlci52aWV3LCBvcHRpb25zKTtcbiAgICB0aGlzLmluaXRGcm9tQ29udGV4dChnbCk7XG4gIH1cbiAgY3JlYXRlQ29udGV4dChjYW52YXMsIG9wdGlvbnMpIHtcbiAgICBsZXQgZ2w7XG4gICAgaWYgKHNldHRpbmdzLnNldHRpbmdzLlBSRUZFUl9FTlYgPj0gY29uc3RhbnRzLkVOVi5XRUJHTDIpIHtcbiAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbDJcIiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChnbCkge1xuICAgICAgdGhpcy53ZWJHTFZlcnNpb24gPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndlYkdMVmVyc2lvbiA9IDE7XG4gICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiwgb3B0aW9ucykgfHwgY2FudmFzLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIiwgb3B0aW9ucyk7XG4gICAgICBpZiAoIWdsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkdMLiBUcnkgdXNpbmcgdGhlIGNhbnZhcyByZW5kZXJlclwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMuZ2V0RXh0ZW5zaW9ucygpO1xuICAgIHJldHVybiB0aGlzLmdsO1xuICB9XG4gIGdldEV4dGVuc2lvbnMoKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcztcbiAgICBjb25zdCBjb21tb24gPSB7XG4gICAgICBsb3NlQ29udGV4dDogZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfbG9zZV9jb250ZXh0XCIpLFxuICAgICAgYW5pc290cm9waWNGaWx0ZXJpbmc6IGdsLmdldEV4dGVuc2lvbihcIkVYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpY1wiKSxcbiAgICAgIGZsb2F0VGV4dHVyZUxpbmVhcjogZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyXCIpLFxuICAgICAgczN0YzogZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIiksXG4gICAgICBzM3RjX3NSR0I6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjX3NyZ2JcIiksXG4gICAgICBldGM6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGNcIiksXG4gICAgICBldGMxOiBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMVwiKSxcbiAgICAgIHB2cnRjOiBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcIikgfHwgZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1wiKSxcbiAgICAgIGF0YzogZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2F0Y1wiKSxcbiAgICAgIGFzdGM6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hc3RjXCIpXG4gICAgfTtcbiAgICBpZiAodGhpcy53ZWJHTFZlcnNpb24gPT09IDEpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5leHRlbnNpb25zLCBjb21tb24sIHtcbiAgICAgICAgZHJhd0J1ZmZlcnM6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2RyYXdfYnVmZmVyc1wiKSxcbiAgICAgICAgZGVwdGhUZXh0dXJlOiBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9kZXB0aF90ZXh0dXJlXCIpLFxuICAgICAgICB2ZXJ0ZXhBcnJheU9iamVjdDogZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3ZlcnRleF9hcnJheV9vYmplY3RcIikgfHwgZ2wuZ2V0RXh0ZW5zaW9uKFwiTU9aX09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0XCIpIHx8IGdsLmdldEV4dGVuc2lvbihcIldFQktJVF9PRVNfdmVydGV4X2FycmF5X29iamVjdFwiKSxcbiAgICAgICAgdWludDMyRWxlbWVudEluZGV4OiBnbC5nZXRFeHRlbnNpb24oXCJPRVNfZWxlbWVudF9pbmRleF91aW50XCIpLFxuICAgICAgICBmbG9hdFRleHR1cmU6IGdsLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2Zsb2F0XCIpLFxuICAgICAgICBmbG9hdFRleHR1cmVMaW5lYXI6IGdsLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclwiKSxcbiAgICAgICAgdGV4dHVyZUhhbGZGbG9hdDogZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKSxcbiAgICAgICAgdGV4dHVyZUhhbGZGbG9hdExpbmVhcjogZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXJcIilcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy53ZWJHTFZlcnNpb24gPT09IDIpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5leHRlbnNpb25zLCBjb21tb24sIHtcbiAgICAgICAgY29sb3JCdWZmZXJGbG9hdDogZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGhhbmRsZUNvbnRleHRMb3N0KGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmdsLmlzQ29udGV4dExvc3QoKSAmJiB0aGlzLmV4dGVuc2lvbnMubG9zZUNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zLmxvc2VDb250ZXh0LnJlc3RvcmVDb250ZXh0KCk7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gIH1cbiAgaGFuZGxlQ29udGV4dFJlc3RvcmVkKCkge1xuICAgIHRoaXMucmVuZGVyZXIucnVubmVycy5jb250ZXh0Q2hhbmdlLmVtaXQodGhpcy5nbCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCB2aWV3ID0gdGhpcy5yZW5kZXJlci52aWV3O1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIGlmICh2aWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIgIT09IHZvaWQgMCkge1xuICAgICAgdmlldy5yZW1vdmVFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0bG9zdFwiLCB0aGlzLmhhbmRsZUNvbnRleHRMb3N0KTtcbiAgICAgIHZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dHJlc3RvcmVkXCIsIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkKTtcbiAgICB9XG4gICAgdGhpcy5nbC51c2VQcm9ncmFtKG51bGwpO1xuICAgIGlmICh0aGlzLmV4dGVuc2lvbnMubG9zZUNvbnRleHQpIHtcbiAgICAgIHRoaXMuZXh0ZW5zaW9ucy5sb3NlQ29udGV4dC5sb3NlQ29udGV4dCgpO1xuICAgIH1cbiAgfVxuICBwb3N0cmVuZGVyKCkge1xuICAgIGlmICh0aGlzLnJlbmRlcmVyLm9iamVjdFJlbmRlcmVyLnJlbmRlcmluZ1RvU2NyZWVuKSB7XG4gICAgICB0aGlzLmdsLmZsdXNoKCk7XG4gICAgfVxuICB9XG4gIHZhbGlkYXRlQ29udGV4dChnbCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBnbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuICAgIGNvbnN0IGlzV2ViR2wyID0gXCJXZWJHTDJSZW5kZXJpbmdDb250ZXh0XCIgaW4gZ2xvYmFsVGhpcyAmJiBnbCBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgICBpZiAoaXNXZWJHbDIpIHtcbiAgICAgIHRoaXMud2ViR0xWZXJzaW9uID0gMjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZXMgJiYgIWF0dHJpYnV0ZXMuc3RlbmNpbCkge1xuICAgICAgY29uc29sZS53YXJuKFwiUHJvdmlkZWQgV2ViR0wgY29udGV4dCBkb2VzIG5vdCBoYXZlIGEgc3RlbmNpbCBidWZmZXIsIG1hc2tzIG1heSBub3QgcmVuZGVyIGNvcnJlY3RseVwiKTtcbiAgICB9XG4gICAgY29uc3QgaGFzdWludDMyID0gaXNXZWJHbDIgfHwgISFnbC5nZXRFeHRlbnNpb24oXCJPRVNfZWxlbWVudF9pbmRleF91aW50XCIpO1xuICAgIHRoaXMuc3VwcG9ydHMudWludDMySW5kaWNlcyA9IGhhc3VpbnQzMjtcbiAgICBpZiAoIWhhc3VpbnQzMikge1xuICAgICAgY29uc29sZS53YXJuKFwiUHJvdmlkZWQgV2ViR0wgY29udGV4dCBkb2VzIG5vdCBzdXBwb3J0IDMyIGluZGV4IGJ1ZmZlciwgY29tcGxleCBncmFwaGljcyBtYXkgbm90IHJlbmRlciBjb3JyZWN0bHlcIik7XG4gICAgfVxuICB9XG59XG5Db250ZXh0U3lzdGVtLmRlZmF1bHRPcHRpb25zID0ge1xuICBjb250ZXh0OiBudWxsLFxuICBhbnRpYWxpYXM6IGZhbHNlLFxuICBwcmVtdWx0aXBsaWVkQWxwaGE6IHRydWUsXG4gIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gIHBvd2VyUHJlZmVyZW5jZTogXCJkZWZhdWx0XCJcbn07XG5Db250ZXh0U3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcImNvbnRleHRcIlxufTtcbmV4dGVuc2lvbnMuZXh0ZW5zaW9ucy5hZGQoQ29udGV4dFN5c3RlbSk7XG5cbmV4cG9ydHMuQ29udGV4dFN5c3RlbSA9IENvbnRleHRTeXN0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250ZXh0U3lzdGVtLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnQHBpeGkvY29uc3RhbnRzJyk7XG52YXIgUHJvZ3JhbSA9IHJlcXVpcmUoJy4uL3NoYWRlci9Qcm9ncmFtLmpzJyk7XG52YXIgU2hhZGVyID0gcmVxdWlyZSgnLi4vc2hhZGVyL1NoYWRlci5qcycpO1xudmFyIFN0YXRlID0gcmVxdWlyZSgnLi4vc3RhdGUvU3RhdGUuanMnKTtcbnZhciBkZWZhdWx0RmlsdGVyJDEgPSByZXF1aXJlKCcuL2RlZmF1bHRGaWx0ZXIuanMnKTtcbnZhciBkZWZhdWx0RmlsdGVyID0gcmVxdWlyZSgnLi9kZWZhdWx0RmlsdGVyMi5qcycpO1xuXG5jb25zdCBfRmlsdGVyID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXIuU2hhZGVyIHtcbiAgY29uc3RydWN0b3IodmVydGV4U3JjLCBmcmFnbWVudFNyYywgdW5pZm9ybXMpIHtcbiAgICBjb25zdCBwcm9ncmFtID0gUHJvZ3JhbS5Qcm9ncmFtLmZyb20odmVydGV4U3JjIHx8IF9GaWx0ZXIuZGVmYXVsdFZlcnRleFNyYywgZnJhZ21lbnRTcmMgfHwgX0ZpbHRlci5kZWZhdWx0RnJhZ21lbnRTcmMpO1xuICAgIHN1cGVyKHByb2dyYW0sIHVuaWZvcm1zKTtcbiAgICB0aGlzLnBhZGRpbmcgPSAwO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IF9GaWx0ZXIuZGVmYXVsdFJlc29sdXRpb247XG4gICAgdGhpcy5tdWx0aXNhbXBsZSA9IF9GaWx0ZXIuZGVmYXVsdE11bHRpc2FtcGxlO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5hdXRvRml0ID0gdHJ1ZTtcbiAgICB0aGlzLnN0YXRlID0gbmV3IFN0YXRlLlN0YXRlKCk7XG4gIH1cbiAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlLCBfY3VycmVudFN0YXRlKSB7XG4gICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpO1xuICB9XG4gIGdldCBibGVuZE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuYmxlbmRNb2RlO1xuICB9XG4gIHNldCBibGVuZE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IHZhbHVlO1xuICB9XG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9uO1xuICB9XG4gIHNldCByZXNvbHV0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fcmVzb2x1dGlvbiA9IHZhbHVlO1xuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFZlcnRleFNyYygpIHtcbiAgICByZXR1cm4gZGVmYXVsdEZpbHRlcltcImRlZmF1bHRcIl07XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0RnJhZ21lbnRTcmMoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRGaWx0ZXIkMVtcImRlZmF1bHRcIl07XG4gIH1cbn07XG5sZXQgRmlsdGVyID0gX0ZpbHRlcjtcbkZpbHRlci5kZWZhdWx0UmVzb2x1dGlvbiA9IDE7XG5GaWx0ZXIuZGVmYXVsdE11bHRpc2FtcGxlID0gY29uc3RhbnRzLk1TQUFfUVVBTElUWS5OT05FO1xuXG5leHBvcnRzLkZpbHRlciA9IEZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbHRlci5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ0BwaXhpL2NvbnN0YW50cycpO1xudmFyIG1hdGggPSByZXF1aXJlKCdAcGl4aS9tYXRoJyk7XG5cbmNsYXNzIEZpbHRlclN0YXRlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yZW5kZXJUZXh0dXJlID0gbnVsbDtcbiAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgdGhpcy5sZWdhY3kgPSBmYWxzZTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSAxO1xuICAgIHRoaXMubXVsdGlzYW1wbGUgPSBjb25zdGFudHMuTVNBQV9RVUFMSVRZLk5PTkU7XG4gICAgdGhpcy5zb3VyY2VGcmFtZSA9IG5ldyBtYXRoLlJlY3RhbmdsZSgpO1xuICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZSA9IG5ldyBtYXRoLlJlY3RhbmdsZSgpO1xuICAgIHRoaXMuYmluZGluZ1NvdXJjZUZyYW1lID0gbmV3IG1hdGguUmVjdGFuZ2xlKCk7XG4gICAgdGhpcy5iaW5kaW5nRGVzdGluYXRpb25GcmFtZSA9IG5ldyBtYXRoLlJlY3RhbmdsZSgpO1xuICAgIHRoaXMuZmlsdGVycyA9IFtdO1xuICAgIHRoaXMudHJhbnNmb3JtID0gbnVsbDtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgdGhpcy5maWx0ZXJzID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlclRleHR1cmUgPSBudWxsO1xuICB9XG59XG5cbmV4cG9ydHMuRmlsdGVyU3RhdGUgPSBGaWx0ZXJTdGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbHRlclN0YXRlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnQHBpeGkvY29uc3RhbnRzJyk7XG52YXIgZXh0ZW5zaW9ucyA9IHJlcXVpcmUoJ0BwaXhpL2V4dGVuc2lvbnMnKTtcbnZhciBtYXRoID0gcmVxdWlyZSgnQHBpeGkvbWF0aCcpO1xudmFyIFJlbmRlclRleHR1cmVQb29sID0gcmVxdWlyZSgnLi4vcmVuZGVyVGV4dHVyZS9SZW5kZXJUZXh0dXJlUG9vbC5qcycpO1xudmFyIFVuaWZvcm1Hcm91cCA9IHJlcXVpcmUoJy4uL3NoYWRlci9Vbmlmb3JtR3JvdXAuanMnKTtcbnZhciBRdWFkID0gcmVxdWlyZSgnLi4vdXRpbHMvUXVhZC5qcycpO1xudmFyIFF1YWRVdiA9IHJlcXVpcmUoJy4uL3V0aWxzL1F1YWRVdi5qcycpO1xudmFyIEZpbHRlclN0YXRlID0gcmVxdWlyZSgnLi9GaWx0ZXJTdGF0ZS5qcycpO1xuXG5jb25zdCB0ZW1wUG9pbnRzID0gW25ldyBtYXRoLlBvaW50KCksIG5ldyBtYXRoLlBvaW50KCksIG5ldyBtYXRoLlBvaW50KCksIG5ldyBtYXRoLlBvaW50KCldO1xuY29uc3QgdGVtcE1hdHJpeCA9IG5ldyBtYXRoLk1hdHJpeCgpO1xuY2xhc3MgRmlsdGVyU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5kZWZhdWx0RmlsdGVyU3RhY2sgPSBbe31dO1xuICAgIHRoaXMudGV4dHVyZVBvb2wgPSBuZXcgUmVuZGVyVGV4dHVyZVBvb2wuUmVuZGVyVGV4dHVyZVBvb2woKTtcbiAgICB0aGlzLnN0YXRlUG9vbCA9IFtdO1xuICAgIHRoaXMucXVhZCA9IG5ldyBRdWFkLlF1YWQoKTtcbiAgICB0aGlzLnF1YWRVdiA9IG5ldyBRdWFkVXYuUXVhZFV2KCk7XG4gICAgdGhpcy50ZW1wUmVjdCA9IG5ldyBtYXRoLlJlY3RhbmdsZSgpO1xuICAgIHRoaXMuYWN0aXZlU3RhdGUgPSB7fTtcbiAgICB0aGlzLmdsb2JhbFVuaWZvcm1zID0gbmV3IFVuaWZvcm1Hcm91cC5Vbmlmb3JtR3JvdXAoe1xuICAgICAgb3V0cHV0RnJhbWU6IG5ldyBtYXRoLlJlY3RhbmdsZSgpLFxuICAgICAgaW5wdXRTaXplOiBuZXcgRmxvYXQzMkFycmF5KDQpLFxuICAgICAgaW5wdXRQaXhlbDogbmV3IEZsb2F0MzJBcnJheSg0KSxcbiAgICAgIGlucHV0Q2xhbXA6IG5ldyBGbG9hdDMyQXJyYXkoNCksXG4gICAgICByZXNvbHV0aW9uOiAxLFxuICAgICAgZmlsdGVyQXJlYTogbmV3IEZsb2F0MzJBcnJheSg0KSxcbiAgICAgIGZpbHRlckNsYW1wOiBuZXcgRmxvYXQzMkFycmF5KDQpXG4gICAgfSwgdHJ1ZSk7XG4gICAgdGhpcy5mb3JjZUNsZWFyID0gZmFsc2U7XG4gICAgdGhpcy51c2VNYXhQYWRkaW5nID0gZmFsc2U7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICB0aGlzLnRleHR1cmVQb29sLnNldFNjcmVlblNpemUodGhpcy5yZW5kZXJlci52aWV3KTtcbiAgfVxuICBwdXNoKHRhcmdldCwgZmlsdGVycykge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBjb25zdCBmaWx0ZXJTdGFjayA9IHRoaXMuZGVmYXVsdEZpbHRlclN0YWNrO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZVBvb2wucG9wKCkgfHwgbmV3IEZpbHRlclN0YXRlLkZpbHRlclN0YXRlKCk7XG4gICAgY29uc3QgcmVuZGVyVGV4dHVyZVN5c3RlbSA9IHRoaXMucmVuZGVyZXIucmVuZGVyVGV4dHVyZTtcbiAgICBsZXQgcmVzb2x1dGlvbiA9IGZpbHRlcnNbMF0ucmVzb2x1dGlvbjtcbiAgICBsZXQgbXVsdGlzYW1wbGUgPSBmaWx0ZXJzWzBdLm11bHRpc2FtcGxlO1xuICAgIGxldCBwYWRkaW5nID0gZmlsdGVyc1swXS5wYWRkaW5nO1xuICAgIGxldCBhdXRvRml0ID0gZmlsdGVyc1swXS5hdXRvRml0O1xuICAgIGxldCBsZWdhY3kgPSBmaWx0ZXJzWzBdLmxlZ2FjeSA/PyB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZmlsdGVyID0gZmlsdGVyc1tpXTtcbiAgICAgIHJlc29sdXRpb24gPSBNYXRoLm1pbihyZXNvbHV0aW9uLCBmaWx0ZXIucmVzb2x1dGlvbik7XG4gICAgICBtdWx0aXNhbXBsZSA9IE1hdGgubWluKG11bHRpc2FtcGxlLCBmaWx0ZXIubXVsdGlzYW1wbGUpO1xuICAgICAgcGFkZGluZyA9IHRoaXMudXNlTWF4UGFkZGluZyA/IE1hdGgubWF4KHBhZGRpbmcsIGZpbHRlci5wYWRkaW5nKSA6IHBhZGRpbmcgKyBmaWx0ZXIucGFkZGluZztcbiAgICAgIGF1dG9GaXQgPSBhdXRvRml0ICYmIGZpbHRlci5hdXRvRml0O1xuICAgICAgbGVnYWN5ID0gbGVnYWN5IHx8IChmaWx0ZXIubGVnYWN5ID8/IHRydWUpO1xuICAgIH1cbiAgICBpZiAoZmlsdGVyU3RhY2subGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLmRlZmF1bHRGaWx0ZXJTdGFja1swXS5yZW5kZXJUZXh0dXJlID0gcmVuZGVyVGV4dHVyZVN5c3RlbS5jdXJyZW50O1xuICAgIH1cbiAgICBmaWx0ZXJTdGFjay5wdXNoKHN0YXRlKTtcbiAgICBzdGF0ZS5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICBzdGF0ZS5tdWx0aXNhbXBsZSA9IG11bHRpc2FtcGxlO1xuICAgIHN0YXRlLmxlZ2FjeSA9IGxlZ2FjeTtcbiAgICBzdGF0ZS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgc3RhdGUuc291cmNlRnJhbWUuY29weUZyb20odGFyZ2V0LmZpbHRlckFyZWEgfHwgdGFyZ2V0LmdldEJvdW5kcyh0cnVlKSk7XG4gICAgc3RhdGUuc291cmNlRnJhbWUucGFkKHBhZGRpbmcpO1xuICAgIGNvbnN0IHNvdXJjZUZyYW1lUHJvamVjdGVkID0gdGhpcy50ZW1wUmVjdC5jb3B5RnJvbShyZW5kZXJUZXh0dXJlU3lzdGVtLnNvdXJjZUZyYW1lKTtcbiAgICBpZiAocmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtQUFCQih0ZW1wTWF0cml4LmNvcHlGcm9tKHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtKS5pbnZlcnQoKSwgc291cmNlRnJhbWVQcm9qZWN0ZWQpO1xuICAgIH1cbiAgICBpZiAoYXV0b0ZpdCkge1xuICAgICAgc3RhdGUuc291cmNlRnJhbWUuZml0KHNvdXJjZUZyYW1lUHJvamVjdGVkKTtcbiAgICAgIGlmIChzdGF0ZS5zb3VyY2VGcmFtZS53aWR0aCA8PSAwIHx8IHN0YXRlLnNvdXJjZUZyYW1lLmhlaWdodCA8PSAwKSB7XG4gICAgICAgIHN0YXRlLnNvdXJjZUZyYW1lLndpZHRoID0gMDtcbiAgICAgICAgc3RhdGUuc291cmNlRnJhbWUuaGVpZ2h0ID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFzdGF0ZS5zb3VyY2VGcmFtZS5pbnRlcnNlY3RzKHNvdXJjZUZyYW1lUHJvamVjdGVkKSkge1xuICAgICAgc3RhdGUuc291cmNlRnJhbWUud2lkdGggPSAwO1xuICAgICAgc3RhdGUuc291cmNlRnJhbWUuaGVpZ2h0ID0gMDtcbiAgICB9XG4gICAgdGhpcy5yb3VuZEZyYW1lKHN0YXRlLnNvdXJjZUZyYW1lLCByZW5kZXJUZXh0dXJlU3lzdGVtLmN1cnJlbnQgPyByZW5kZXJUZXh0dXJlU3lzdGVtLmN1cnJlbnQucmVzb2x1dGlvbiA6IHJlbmRlcmVyLnJlc29sdXRpb24sIHJlbmRlclRleHR1cmVTeXN0ZW0uc291cmNlRnJhbWUsIHJlbmRlclRleHR1cmVTeXN0ZW0uZGVzdGluYXRpb25GcmFtZSwgcmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0pO1xuICAgIHN0YXRlLnJlbmRlclRleHR1cmUgPSB0aGlzLmdldE9wdGltYWxGaWx0ZXJUZXh0dXJlKHN0YXRlLnNvdXJjZUZyYW1lLndpZHRoLCBzdGF0ZS5zb3VyY2VGcmFtZS5oZWlnaHQsIHJlc29sdXRpb24sIG11bHRpc2FtcGxlKTtcbiAgICBzdGF0ZS5maWx0ZXJzID0gZmlsdGVycztcbiAgICBzdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLndpZHRoID0gc3RhdGUucmVuZGVyVGV4dHVyZS53aWR0aDtcbiAgICBzdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLmhlaWdodCA9IHN0YXRlLnJlbmRlclRleHR1cmUuaGVpZ2h0O1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uRnJhbWUgPSB0aGlzLnRlbXBSZWN0O1xuICAgIGRlc3RpbmF0aW9uRnJhbWUueCA9IDA7XG4gICAgZGVzdGluYXRpb25GcmFtZS55ID0gMDtcbiAgICBkZXN0aW5hdGlvbkZyYW1lLndpZHRoID0gc3RhdGUuc291cmNlRnJhbWUud2lkdGg7XG4gICAgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgPSBzdGF0ZS5zb3VyY2VGcmFtZS5oZWlnaHQ7XG4gICAgc3RhdGUucmVuZGVyVGV4dHVyZS5maWx0ZXJGcmFtZSA9IHN0YXRlLnNvdXJjZUZyYW1lO1xuICAgIHN0YXRlLmJpbmRpbmdTb3VyY2VGcmFtZS5jb3B5RnJvbShyZW5kZXJUZXh0dXJlU3lzdGVtLnNvdXJjZUZyYW1lKTtcbiAgICBzdGF0ZS5iaW5kaW5nRGVzdGluYXRpb25GcmFtZS5jb3B5RnJvbShyZW5kZXJUZXh0dXJlU3lzdGVtLmRlc3RpbmF0aW9uRnJhbWUpO1xuICAgIHN0YXRlLnRyYW5zZm9ybSA9IHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtO1xuICAgIHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtID0gbnVsbDtcbiAgICByZW5kZXJUZXh0dXJlU3lzdGVtLmJpbmQoc3RhdGUucmVuZGVyVGV4dHVyZSwgc3RhdGUuc291cmNlRnJhbWUsIGRlc3RpbmF0aW9uRnJhbWUpO1xuICAgIHJlbmRlcmVyLmZyYW1lYnVmZmVyLmNsZWFyKDAsIDAsIDAsIDApO1xuICB9XG4gIHBvcCgpIHtcbiAgICBjb25zdCBmaWx0ZXJTdGFjayA9IHRoaXMuZGVmYXVsdEZpbHRlclN0YWNrO1xuICAgIGNvbnN0IHN0YXRlID0gZmlsdGVyU3RhY2sucG9wKCk7XG4gICAgY29uc3QgZmlsdGVycyA9IHN0YXRlLmZpbHRlcnM7XG4gICAgdGhpcy5hY3RpdmVTdGF0ZSA9IHN0YXRlO1xuICAgIGNvbnN0IGdsb2JhbFVuaWZvcm1zID0gdGhpcy5nbG9iYWxVbmlmb3Jtcy51bmlmb3JtcztcbiAgICBnbG9iYWxVbmlmb3Jtcy5vdXRwdXRGcmFtZSA9IHN0YXRlLnNvdXJjZUZyYW1lO1xuICAgIGdsb2JhbFVuaWZvcm1zLnJlc29sdXRpb24gPSBzdGF0ZS5yZXNvbHV0aW9uO1xuICAgIGNvbnN0IGlucHV0U2l6ZSA9IGdsb2JhbFVuaWZvcm1zLmlucHV0U2l6ZTtcbiAgICBjb25zdCBpbnB1dFBpeGVsID0gZ2xvYmFsVW5pZm9ybXMuaW5wdXRQaXhlbDtcbiAgICBjb25zdCBpbnB1dENsYW1wID0gZ2xvYmFsVW5pZm9ybXMuaW5wdXRDbGFtcDtcbiAgICBpbnB1dFNpemVbMF0gPSBzdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLndpZHRoO1xuICAgIGlucHV0U2l6ZVsxXSA9IHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0O1xuICAgIGlucHV0U2l6ZVsyXSA9IDEgLyBpbnB1dFNpemVbMF07XG4gICAgaW5wdXRTaXplWzNdID0gMSAvIGlucHV0U2l6ZVsxXTtcbiAgICBpbnB1dFBpeGVsWzBdID0gTWF0aC5yb3VuZChpbnB1dFNpemVbMF0gKiBzdGF0ZS5yZXNvbHV0aW9uKTtcbiAgICBpbnB1dFBpeGVsWzFdID0gTWF0aC5yb3VuZChpbnB1dFNpemVbMV0gKiBzdGF0ZS5yZXNvbHV0aW9uKTtcbiAgICBpbnB1dFBpeGVsWzJdID0gMSAvIGlucHV0UGl4ZWxbMF07XG4gICAgaW5wdXRQaXhlbFszXSA9IDEgLyBpbnB1dFBpeGVsWzFdO1xuICAgIGlucHV0Q2xhbXBbMF0gPSAwLjUgKiBpbnB1dFBpeGVsWzJdO1xuICAgIGlucHV0Q2xhbXBbMV0gPSAwLjUgKiBpbnB1dFBpeGVsWzNdO1xuICAgIGlucHV0Q2xhbXBbMl0gPSBzdGF0ZS5zb3VyY2VGcmFtZS53aWR0aCAqIGlucHV0U2l6ZVsyXSAtIDAuNSAqIGlucHV0UGl4ZWxbMl07XG4gICAgaW5wdXRDbGFtcFszXSA9IHN0YXRlLnNvdXJjZUZyYW1lLmhlaWdodCAqIGlucHV0U2l6ZVszXSAtIDAuNSAqIGlucHV0UGl4ZWxbM107XG4gICAgaWYgKHN0YXRlLmxlZ2FjeSkge1xuICAgICAgY29uc3QgZmlsdGVyQXJlYSA9IGdsb2JhbFVuaWZvcm1zLmZpbHRlckFyZWE7XG4gICAgICBmaWx0ZXJBcmVhWzBdID0gc3RhdGUuZGVzdGluYXRpb25GcmFtZS53aWR0aDtcbiAgICAgIGZpbHRlckFyZWFbMV0gPSBzdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLmhlaWdodDtcbiAgICAgIGZpbHRlckFyZWFbMl0gPSBzdGF0ZS5zb3VyY2VGcmFtZS54O1xuICAgICAgZmlsdGVyQXJlYVszXSA9IHN0YXRlLnNvdXJjZUZyYW1lLnk7XG4gICAgICBnbG9iYWxVbmlmb3Jtcy5maWx0ZXJDbGFtcCA9IGdsb2JhbFVuaWZvcm1zLmlucHV0Q2xhbXA7XG4gICAgfVxuICAgIHRoaXMuZ2xvYmFsVW5pZm9ybXMudXBkYXRlKCk7XG4gICAgY29uc3QgbGFzdFN0YXRlID0gZmlsdGVyU3RhY2tbZmlsdGVyU3RhY2subGVuZ3RoIC0gMV07XG4gICAgdGhpcy5yZW5kZXJlci5mcmFtZWJ1ZmZlci5ibGl0KCk7XG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICBmaWx0ZXJzWzBdLmFwcGx5KHRoaXMsIHN0YXRlLnJlbmRlclRleHR1cmUsIGxhc3RTdGF0ZS5yZW5kZXJUZXh0dXJlLCBjb25zdGFudHMuQ0xFQVJfTU9ERVMuQkxFTkQsIHN0YXRlKTtcbiAgICAgIHRoaXMucmV0dXJuRmlsdGVyVGV4dHVyZShzdGF0ZS5yZW5kZXJUZXh0dXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGZsaXAgPSBzdGF0ZS5yZW5kZXJUZXh0dXJlO1xuICAgICAgbGV0IGZsb3AgPSB0aGlzLmdldE9wdGltYWxGaWx0ZXJUZXh0dXJlKGZsaXAud2lkdGgsIGZsaXAuaGVpZ2h0LCBzdGF0ZS5yZXNvbHV0aW9uKTtcbiAgICAgIGZsb3AuZmlsdGVyRnJhbWUgPSBmbGlwLmZpbHRlckZyYW1lO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIGlmIChpID09PSAxICYmIHN0YXRlLm11bHRpc2FtcGxlID4gMSkge1xuICAgICAgICAgIGZsb3AgPSB0aGlzLmdldE9wdGltYWxGaWx0ZXJUZXh0dXJlKGZsaXAud2lkdGgsIGZsaXAuaGVpZ2h0LCBzdGF0ZS5yZXNvbHV0aW9uKTtcbiAgICAgICAgICBmbG9wLmZpbHRlckZyYW1lID0gZmxpcC5maWx0ZXJGcmFtZTtcbiAgICAgICAgfVxuICAgICAgICBmaWx0ZXJzW2ldLmFwcGx5KHRoaXMsIGZsaXAsIGZsb3AsIGNvbnN0YW50cy5DTEVBUl9NT0RFUy5DTEVBUiwgc3RhdGUpO1xuICAgICAgICBjb25zdCB0ID0gZmxpcDtcbiAgICAgICAgZmxpcCA9IGZsb3A7XG4gICAgICAgIGZsb3AgPSB0O1xuICAgICAgfVxuICAgICAgZmlsdGVyc1tpXS5hcHBseSh0aGlzLCBmbGlwLCBsYXN0U3RhdGUucmVuZGVyVGV4dHVyZSwgY29uc3RhbnRzLkNMRUFSX01PREVTLkJMRU5ELCBzdGF0ZSk7XG4gICAgICBpZiAoaSA+IDEgJiYgc3RhdGUubXVsdGlzYW1wbGUgPiAxKSB7XG4gICAgICAgIHRoaXMucmV0dXJuRmlsdGVyVGV4dHVyZShzdGF0ZS5yZW5kZXJUZXh0dXJlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmV0dXJuRmlsdGVyVGV4dHVyZShmbGlwKTtcbiAgICAgIHRoaXMucmV0dXJuRmlsdGVyVGV4dHVyZShmbG9wKTtcbiAgICB9XG4gICAgc3RhdGUuY2xlYXIoKTtcbiAgICB0aGlzLnN0YXRlUG9vbC5wdXNoKHN0YXRlKTtcbiAgfVxuICBiaW5kQW5kQ2xlYXIoZmlsdGVyVGV4dHVyZSwgY2xlYXJNb2RlID0gY29uc3RhbnRzLkNMRUFSX01PREVTLkNMRUFSKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyVGV4dHVyZTogcmVuZGVyVGV4dHVyZVN5c3RlbSxcbiAgICAgIHN0YXRlOiBzdGF0ZVN5c3RlbVxuICAgIH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIGlmIChmaWx0ZXJUZXh0dXJlID09PSB0aGlzLmRlZmF1bHRGaWx0ZXJTdGFja1t0aGlzLmRlZmF1bHRGaWx0ZXJTdGFjay5sZW5ndGggLSAxXS5yZW5kZXJUZXh0dXJlKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtID0gdGhpcy5hY3RpdmVTdGF0ZS50cmFuc2Zvcm07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZmlsdGVyVGV4dHVyZT8uZmlsdGVyRnJhbWUpIHtcbiAgICAgIGNvbnN0IGRlc3RpbmF0aW9uRnJhbWUgPSB0aGlzLnRlbXBSZWN0O1xuICAgICAgZGVzdGluYXRpb25GcmFtZS54ID0gMDtcbiAgICAgIGRlc3RpbmF0aW9uRnJhbWUueSA9IDA7XG4gICAgICBkZXN0aW5hdGlvbkZyYW1lLndpZHRoID0gZmlsdGVyVGV4dHVyZS5maWx0ZXJGcmFtZS53aWR0aDtcbiAgICAgIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0ID0gZmlsdGVyVGV4dHVyZS5maWx0ZXJGcmFtZS5oZWlnaHQ7XG4gICAgICByZW5kZXJUZXh0dXJlU3lzdGVtLmJpbmQoZmlsdGVyVGV4dHVyZSwgZmlsdGVyVGV4dHVyZS5maWx0ZXJGcmFtZSwgZGVzdGluYXRpb25GcmFtZSk7XG4gICAgfSBlbHNlIGlmIChmaWx0ZXJUZXh0dXJlICE9PSB0aGlzLmRlZmF1bHRGaWx0ZXJTdGFja1t0aGlzLmRlZmF1bHRGaWx0ZXJTdGFjay5sZW5ndGggLSAxXS5yZW5kZXJUZXh0dXJlKSB7XG4gICAgICByZW5kZXJUZXh0dXJlU3lzdGVtLmJpbmQoZmlsdGVyVGV4dHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKGZpbHRlclRleHR1cmUsIHRoaXMuYWN0aXZlU3RhdGUuYmluZGluZ1NvdXJjZUZyYW1lLCB0aGlzLmFjdGl2ZVN0YXRlLmJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lKTtcbiAgICB9XG4gICAgY29uc3QgYXV0b0NsZWFyID0gc3RhdGVTeXN0ZW0uc3RhdGVJZCAmIDEgfHwgdGhpcy5mb3JjZUNsZWFyO1xuICAgIGlmIChjbGVhck1vZGUgPT09IGNvbnN0YW50cy5DTEVBUl9NT0RFUy5DTEVBUiB8fCBjbGVhck1vZGUgPT09IGNvbnN0YW50cy5DTEVBUl9NT0RFUy5CTElUICYmIGF1dG9DbGVhcikge1xuICAgICAgdGhpcy5yZW5kZXJlci5mcmFtZWJ1ZmZlci5jbGVhcigwLCAwLCAwLCAwKTtcbiAgICB9XG4gIH1cbiAgYXBwbHlGaWx0ZXIoZmlsdGVyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgcmVuZGVyZXIuc3RhdGUuc2V0KGZpbHRlci5zdGF0ZSk7XG4gICAgdGhpcy5iaW5kQW5kQ2xlYXIob3V0cHV0LCBjbGVhck1vZGUpO1xuICAgIGZpbHRlci51bmlmb3Jtcy51U2FtcGxlciA9IGlucHV0O1xuICAgIGZpbHRlci51bmlmb3Jtcy5maWx0ZXJHbG9iYWxzID0gdGhpcy5nbG9iYWxVbmlmb3JtcztcbiAgICByZW5kZXJlci5zaGFkZXIuYmluZChmaWx0ZXIpO1xuICAgIGZpbHRlci5sZWdhY3kgPSAhIWZpbHRlci5wcm9ncmFtLmF0dHJpYnV0ZURhdGEuYVRleHR1cmVDb29yZDtcbiAgICBpZiAoZmlsdGVyLmxlZ2FjeSkge1xuICAgICAgdGhpcy5xdWFkVXYubWFwKGlucHV0Ll9mcmFtZSwgaW5wdXQuZmlsdGVyRnJhbWUpO1xuICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLnF1YWRVdik7XG4gICAgICByZW5kZXJlci5nZW9tZXRyeS5kcmF3KGNvbnN0YW50cy5EUkFXX01PREVTLlRSSUFOR0xFUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVyLmdlb21ldHJ5LmJpbmQodGhpcy5xdWFkKTtcbiAgICAgIHJlbmRlcmVyLmdlb21ldHJ5LmRyYXcoY29uc3RhbnRzLkRSQVdfTU9ERVMuVFJJQU5HTEVfU1RSSVApO1xuICAgIH1cbiAgfVxuICBjYWxjdWxhdGVTcHJpdGVNYXRyaXgob3V0cHV0TWF0cml4LCBzcHJpdGUpIHtcbiAgICBjb25zdCB7IHNvdXJjZUZyYW1lLCBkZXN0aW5hdGlvbkZyYW1lIH0gPSB0aGlzLmFjdGl2ZVN0YXRlO1xuICAgIGNvbnN0IHsgb3JpZyB9ID0gc3ByaXRlLl90ZXh0dXJlO1xuICAgIGNvbnN0IG1hcHBlZE1hdHJpeCA9IG91dHB1dE1hdHJpeC5zZXQoZGVzdGluYXRpb25GcmFtZS53aWR0aCwgMCwgMCwgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQsIHNvdXJjZUZyYW1lLngsIHNvdXJjZUZyYW1lLnkpO1xuICAgIGNvbnN0IHdvcmxkVHJhbnNmb3JtID0gc3ByaXRlLndvcmxkVHJhbnNmb3JtLmNvcHlUbyhtYXRoLk1hdHJpeC5URU1QX01BVFJJWCk7XG4gICAgd29ybGRUcmFuc2Zvcm0uaW52ZXJ0KCk7XG4gICAgbWFwcGVkTWF0cml4LnByZXBlbmQod29ybGRUcmFuc2Zvcm0pO1xuICAgIG1hcHBlZE1hdHJpeC5zY2FsZSgxIC8gb3JpZy53aWR0aCwgMSAvIG9yaWcuaGVpZ2h0KTtcbiAgICBtYXBwZWRNYXRyaXgudHJhbnNsYXRlKHNwcml0ZS5hbmNob3IueCwgc3ByaXRlLmFuY2hvci55KTtcbiAgICByZXR1cm4gbWFwcGVkTWF0cml4O1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy50ZXh0dXJlUG9vbC5jbGVhcihmYWxzZSk7XG4gIH1cbiAgZ2V0T3B0aW1hbEZpbHRlclRleHR1cmUobWluV2lkdGgsIG1pbkhlaWdodCwgcmVzb2x1dGlvbiA9IDEsIG11bHRpc2FtcGxlID0gY29uc3RhbnRzLk1TQUFfUVVBTElUWS5OT05FKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dHVyZVBvb2wuZ2V0T3B0aW1hbFRleHR1cmUobWluV2lkdGgsIG1pbkhlaWdodCwgcmVzb2x1dGlvbiwgbXVsdGlzYW1wbGUpO1xuICB9XG4gIGdldEZpbHRlclRleHR1cmUoaW5wdXQsIHJlc29sdXRpb24sIG11bHRpc2FtcGxlKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3Qgc3dhcCA9IGlucHV0O1xuICAgICAgaW5wdXQgPSByZXNvbHV0aW9uO1xuICAgICAgcmVzb2x1dGlvbiA9IHN3YXA7XG4gICAgfVxuICAgIGlucHV0ID0gaW5wdXQgfHwgdGhpcy5hY3RpdmVTdGF0ZS5yZW5kZXJUZXh0dXJlO1xuICAgIGNvbnN0IGZpbHRlclRleHR1cmUgPSB0aGlzLnRleHR1cmVQb29sLmdldE9wdGltYWxUZXh0dXJlKGlucHV0LndpZHRoLCBpbnB1dC5oZWlnaHQsIHJlc29sdXRpb24gfHwgaW5wdXQucmVzb2x1dGlvbiwgbXVsdGlzYW1wbGUgfHwgY29uc3RhbnRzLk1TQUFfUVVBTElUWS5OT05FKTtcbiAgICBmaWx0ZXJUZXh0dXJlLmZpbHRlckZyYW1lID0gaW5wdXQuZmlsdGVyRnJhbWU7XG4gICAgcmV0dXJuIGZpbHRlclRleHR1cmU7XG4gIH1cbiAgcmV0dXJuRmlsdGVyVGV4dHVyZShyZW5kZXJUZXh0dXJlKSB7XG4gICAgdGhpcy50ZXh0dXJlUG9vbC5yZXR1cm5UZXh0dXJlKHJlbmRlclRleHR1cmUpO1xuICB9XG4gIGVtcHR5UG9vbCgpIHtcbiAgICB0aGlzLnRleHR1cmVQb29sLmNsZWFyKHRydWUpO1xuICB9XG4gIHJlc2l6ZSgpIHtcbiAgICB0aGlzLnRleHR1cmVQb29sLnNldFNjcmVlblNpemUodGhpcy5yZW5kZXJlci52aWV3KTtcbiAgfVxuICB0cmFuc2Zvcm1BQUJCKG1hdHJpeCwgcmVjdCkge1xuICAgIGNvbnN0IGx0ID0gdGVtcFBvaW50c1swXTtcbiAgICBjb25zdCBsYiA9IHRlbXBQb2ludHNbMV07XG4gICAgY29uc3QgcnQgPSB0ZW1wUG9pbnRzWzJdO1xuICAgIGNvbnN0IHJiID0gdGVtcFBvaW50c1szXTtcbiAgICBsdC5zZXQocmVjdC5sZWZ0LCByZWN0LnRvcCk7XG4gICAgbGIuc2V0KHJlY3QubGVmdCwgcmVjdC5ib3R0b20pO1xuICAgIHJ0LnNldChyZWN0LnJpZ2h0LCByZWN0LnRvcCk7XG4gICAgcmIuc2V0KHJlY3QucmlnaHQsIHJlY3QuYm90dG9tKTtcbiAgICBtYXRyaXguYXBwbHkobHQsIGx0KTtcbiAgICBtYXRyaXguYXBwbHkobGIsIGxiKTtcbiAgICBtYXRyaXguYXBwbHkocnQsIHJ0KTtcbiAgICBtYXRyaXguYXBwbHkocmIsIHJiKTtcbiAgICBjb25zdCB4MCA9IE1hdGgubWluKGx0LngsIGxiLngsIHJ0LngsIHJiLngpO1xuICAgIGNvbnN0IHkwID0gTWF0aC5taW4obHQueSwgbGIueSwgcnQueSwgcmIueSk7XG4gICAgY29uc3QgeDEgPSBNYXRoLm1heChsdC54LCBsYi54LCBydC54LCByYi54KTtcbiAgICBjb25zdCB5MSA9IE1hdGgubWF4KGx0LnksIGxiLnksIHJ0LnksIHJiLnkpO1xuICAgIHJlY3QueCA9IHgwO1xuICAgIHJlY3QueSA9IHkwO1xuICAgIHJlY3Qud2lkdGggPSB4MSAtIHgwO1xuICAgIHJlY3QuaGVpZ2h0ID0geTEgLSB5MDtcbiAgfVxuICByb3VuZEZyYW1lKGZyYW1lLCByZXNvbHV0aW9uLCBiaW5kaW5nU291cmNlRnJhbWUsIGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLCB0cmFuc2Zvcm0pIHtcbiAgICBpZiAoZnJhbWUud2lkdGggPD0gMCB8fCBmcmFtZS5oZWlnaHQgPD0gMCB8fCBiaW5kaW5nU291cmNlRnJhbWUud2lkdGggPD0gMCB8fCBiaW5kaW5nU291cmNlRnJhbWUuaGVpZ2h0IDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgY29uc3QgeyBhLCBiLCBjLCBkIH0gPSB0cmFuc2Zvcm07XG4gICAgICBpZiAoKE1hdGguYWJzKGIpID4gMWUtNCB8fCBNYXRoLmFicyhjKSA+IDFlLTQpICYmIChNYXRoLmFicyhhKSA+IDFlLTQgfHwgTWF0aC5hYnMoZCkgPiAxZS00KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybSA/IHRlbXBNYXRyaXguY29weUZyb20odHJhbnNmb3JtKSA6IHRlbXBNYXRyaXguaWRlbnRpdHkoKTtcbiAgICB0cmFuc2Zvcm0udHJhbnNsYXRlKC1iaW5kaW5nU291cmNlRnJhbWUueCwgLWJpbmRpbmdTb3VyY2VGcmFtZS55KS5zY2FsZShiaW5kaW5nRGVzdGluYXRpb25GcmFtZS53aWR0aCAvIGJpbmRpbmdTb3VyY2VGcmFtZS53aWR0aCwgYmluZGluZ0Rlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0IC8gYmluZGluZ1NvdXJjZUZyYW1lLmhlaWdodCkudHJhbnNsYXRlKGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLngsIGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLnkpO1xuICAgIHRoaXMudHJhbnNmb3JtQUFCQih0cmFuc2Zvcm0sIGZyYW1lKTtcbiAgICBmcmFtZS5jZWlsKHJlc29sdXRpb24pO1xuICAgIHRoaXMudHJhbnNmb3JtQUFCQih0cmFuc2Zvcm0uaW52ZXJ0KCksIGZyYW1lKTtcbiAgfVxufVxuRmlsdGVyU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcImZpbHRlclwiXG59O1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmFkZChGaWx0ZXJTeXN0ZW0pO1xuXG5leHBvcnRzLkZpbHRlclN5c3RlbSA9IEZpbHRlclN5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbHRlclN5c3RlbS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SUZpbHRlclRhcmdldC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGRlZmF1bHRGcmFnbWVudCA9IFwidmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxuXFxudm9pZCBtYWluKHZvaWQpe1xcbiAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxufVxcblwiO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGRlZmF1bHRGcmFnbWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRGaWx0ZXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBkZWZhdWx0VmVydGV4ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSB2ZWM0IGlucHV0U2l6ZTtcXG51bmlmb3JtIHZlYzQgb3V0cHV0RnJhbWU7XFxuXFxudmVjNCBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbiggdm9pZCApXFxue1xcbiAgICB2ZWMyIHBvc2l0aW9uID0gYVZlcnRleFBvc2l0aW9uICogbWF4KG91dHB1dEZyYW1lLnp3LCB2ZWMyKDAuKSkgKyBvdXRwdXRGcmFtZS54eTtcXG5cXG4gICAgcmV0dXJuIHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcbn1cXG5cXG52ZWMyIGZpbHRlclRleHR1cmVDb29yZCggdm9pZCApXFxue1xcbiAgICByZXR1cm4gYVZlcnRleFBvc2l0aW9uICogKG91dHB1dEZyYW1lLnp3ICogaW5wdXRTaXplLnp3KTtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9Qb3NpdGlvbiA9IGZpbHRlclZlcnRleFBvc2l0aW9uKCk7XFxuICAgIHZUZXh0dXJlQ29vcmQgPSBmaWx0ZXJUZXh0dXJlQ29vcmQoKTtcXG59XFxuXCI7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZGVmYXVsdFZlcnRleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRGaWx0ZXIyLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbWF0aCA9IHJlcXVpcmUoJ0BwaXhpL21hdGgnKTtcbnZhciBUZXh0dXJlTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vdGV4dHVyZXMvVGV4dHVyZU1hdHJpeC5qcycpO1xudmFyIEZpbHRlciA9IHJlcXVpcmUoJy4uL0ZpbHRlci5qcycpO1xudmFyIHNwcml0ZU1hc2tGaWx0ZXIkMSA9IHJlcXVpcmUoJy4vc3ByaXRlTWFza0ZpbHRlcjIuanMnKTtcbnZhciBzcHJpdGVNYXNrRmlsdGVyID0gcmVxdWlyZSgnLi9zcHJpdGVNYXNrRmlsdGVyMy5qcycpO1xuXG5jbGFzcyBTcHJpdGVNYXNrRmlsdGVyIGV4dGVuZHMgRmlsdGVyLkZpbHRlciB7XG4gIGNvbnN0cnVjdG9yKHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIHVuaWZvcm1zKSB7XG4gICAgbGV0IHNwcml0ZSA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiB2ZXJ0ZXhTcmMgIT09IFwic3RyaW5nXCIgJiYgZnJhZ21lbnRTcmMgPT09IHZvaWQgMCAmJiB1bmlmb3JtcyA9PT0gdm9pZCAwKSB7XG4gICAgICBzcHJpdGUgPSB2ZXJ0ZXhTcmM7XG4gICAgICB2ZXJ0ZXhTcmMgPSB2b2lkIDA7XG4gICAgICBmcmFnbWVudFNyYyA9IHZvaWQgMDtcbiAgICAgIHVuaWZvcm1zID0gdm9pZCAwO1xuICAgIH1cbiAgICBzdXBlcih2ZXJ0ZXhTcmMgfHwgc3ByaXRlTWFza0ZpbHRlcltcImRlZmF1bHRcIl0sIGZyYWdtZW50U3JjIHx8IHNwcml0ZU1hc2tGaWx0ZXIkMVtcImRlZmF1bHRcIl0sIHVuaWZvcm1zKTtcbiAgICB0aGlzLm1hc2tTcHJpdGUgPSBzcHJpdGU7XG4gICAgdGhpcy5tYXNrTWF0cml4ID0gbmV3IG1hdGguTWF0cml4KCk7XG4gIH1cbiAgZ2V0IG1hc2tTcHJpdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hc2tTcHJpdGU7XG4gIH1cbiAgc2V0IG1hc2tTcHJpdGUodmFsdWUpIHtcbiAgICB0aGlzLl9tYXNrU3ByaXRlID0gdmFsdWU7XG4gICAgaWYgKHRoaXMuX21hc2tTcHJpdGUpIHtcbiAgICAgIHRoaXMuX21hc2tTcHJpdGUucmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICBjb25zdCBtYXNrU3ByaXRlID0gdGhpcy5fbWFza1Nwcml0ZTtcbiAgICBjb25zdCB0ZXggPSBtYXNrU3ByaXRlLl90ZXh0dXJlO1xuICAgIGlmICghdGV4LnZhbGlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGV4LnV2TWF0cml4KSB7XG4gICAgICB0ZXgudXZNYXRyaXggPSBuZXcgVGV4dHVyZU1hdHJpeC5UZXh0dXJlTWF0cml4KHRleCwgMCk7XG4gICAgfVxuICAgIHRleC51dk1hdHJpeC51cGRhdGUoKTtcbiAgICB0aGlzLnVuaWZvcm1zLm5wbUFscGhhID0gdGV4LmJhc2VUZXh0dXJlLmFscGhhTW9kZSA/IDAgOiAxO1xuICAgIHRoaXMudW5pZm9ybXMubWFzayA9IHRleDtcbiAgICB0aGlzLnVuaWZvcm1zLm90aGVyTWF0cml4ID0gZmlsdGVyTWFuYWdlci5jYWxjdWxhdGVTcHJpdGVNYXRyaXgodGhpcy5tYXNrTWF0cml4LCBtYXNrU3ByaXRlKS5wcmVwZW5kKHRleC51dk1hdHJpeC5tYXBDb29yZCk7XG4gICAgdGhpcy51bmlmb3Jtcy5hbHBoYSA9IG1hc2tTcHJpdGUud29ybGRBbHBoYTtcbiAgICB0aGlzLnVuaWZvcm1zLm1hc2tDbGFtcCA9IHRleC51dk1hdHJpeC51Q2xhbXBGcmFtZTtcbiAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSk7XG4gIH1cbn1cblxuZXhwb3J0cy5TcHJpdGVNYXNrRmlsdGVyID0gU3ByaXRlTWFza0ZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNwcml0ZU1hc2tGaWx0ZXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBmcmFnbWVudCA9IFwidmFyeWluZyB2ZWMyIHZNYXNrQ29vcmQ7XFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSBzYW1wbGVyMkQgbWFzaztcXG51bmlmb3JtIGZsb2F0IGFscGhhO1xcbnVuaWZvcm0gZmxvYXQgbnBtQWxwaGE7XFxudW5pZm9ybSB2ZWM0IG1hc2tDbGFtcDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGZsb2F0IGNsaXAgPSBzdGVwKDMuNSxcXG4gICAgICAgIHN0ZXAobWFza0NsYW1wLngsIHZNYXNrQ29vcmQueCkgK1xcbiAgICAgICAgc3RlcChtYXNrQ2xhbXAueSwgdk1hc2tDb29yZC55KSArXFxuICAgICAgICBzdGVwKHZNYXNrQ29vcmQueCwgbWFza0NsYW1wLnopICtcXG4gICAgICAgIHN0ZXAodk1hc2tDb29yZC55LCBtYXNrQ2xhbXAudykpO1xcblxcbiAgICB2ZWM0IG9yaWdpbmFsID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXG4gICAgdmVjNCBtYXNreSA9IHRleHR1cmUyRChtYXNrLCB2TWFza0Nvb3JkKTtcXG4gICAgZmxvYXQgYWxwaGFNdWwgPSAxLjAgLSBucG1BbHBoYSAqICgxLjAgLSBtYXNreS5hKTtcXG5cXG4gICAgb3JpZ2luYWwgKj0gKGFscGhhTXVsICogbWFza3kuciAqIGFscGhhICogY2xpcCk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IG9yaWdpbmFsO1xcbn1cXG5cIjtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmcmFnbWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZU1hc2tGaWx0ZXIyLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgdmVydGV4ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDMgb3RoZXJNYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZNYXNrQ29vcmQ7XFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXG5cXG4gICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuICAgIHZNYXNrQ29vcmQgPSAoIG90aGVyTWF0cml4ICogdmVjMyggYVRleHR1cmVDb29yZCwgMS4wKSAgKS54eTtcXG59XFxuXCI7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdmVydGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ByaXRlTWFza0ZpbHRlcjMuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciAkZGVmYXVsdFZlcnRleCA9IFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXG4gICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxufVwiO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9ICRkZWZhdWx0VmVydGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyICRkZWZhdWx0RmlsdGVyVmVydGV4ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSB2ZWM0IGlucHV0U2l6ZTtcXG51bmlmb3JtIHZlYzQgb3V0cHV0RnJhbWU7XFxuXFxudmVjNCBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbiggdm9pZCApXFxue1xcbiAgICB2ZWMyIHBvc2l0aW9uID0gYVZlcnRleFBvc2l0aW9uICogbWF4KG91dHB1dEZyYW1lLnp3LCB2ZWMyKDAuKSkgKyBvdXRwdXRGcmFtZS54eTtcXG5cXG4gICAgcmV0dXJuIHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcbn1cXG5cXG52ZWMyIGZpbHRlclRleHR1cmVDb29yZCggdm9pZCApXFxue1xcbiAgICByZXR1cm4gYVZlcnRleFBvc2l0aW9uICogKG91dHB1dEZyYW1lLnp3ICogaW5wdXRTaXplLnp3KTtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9Qb3NpdGlvbiA9IGZpbHRlclZlcnRleFBvc2l0aW9uKCk7XFxuICAgIHZUZXh0dXJlQ29vcmQgPSBmaWx0ZXJUZXh0dXJlQ29vcmQoKTtcXG59XFxuXCI7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gJGRlZmF1bHRGaWx0ZXJWZXJ0ZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0RmlsdGVyLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgX2RlZmF1bHQgPSByZXF1aXJlKCcuL2RlZmF1bHQuanMnKTtcbnZhciBkZWZhdWx0RmlsdGVyID0gcmVxdWlyZSgnLi9kZWZhdWx0RmlsdGVyLmpzJyk7XG5cbmNvbnN0IGRlZmF1bHRWZXJ0ZXggPSBfZGVmYXVsdFtcImRlZmF1bHRcIl07XG5jb25zdCBkZWZhdWx0RmlsdGVyVmVydGV4ID0gZGVmYXVsdEZpbHRlcltcImRlZmF1bHRcIl07XG5cbmV4cG9ydHMuZGVmYXVsdEZpbHRlclZlcnRleCA9IGRlZmF1bHRGaWx0ZXJWZXJ0ZXg7XG5leHBvcnRzLmRlZmF1bHRWZXJ0ZXggPSBkZWZhdWx0VmVydGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCdAcGl4aS9jb25zdGFudHMnKTtcbnZhciBydW5uZXIgPSByZXF1aXJlKCdAcGl4aS9ydW5uZXInKTtcbnZhciBCYXNlVGV4dHVyZSA9IHJlcXVpcmUoJy4uL3RleHR1cmVzL0Jhc2VUZXh0dXJlLmpzJyk7XG52YXIgRGVwdGhSZXNvdXJjZSA9IHJlcXVpcmUoJy4uL3RleHR1cmVzL3Jlc291cmNlcy9EZXB0aFJlc291cmNlLmpzJyk7XG5cbmNsYXNzIEZyYW1lYnVmZmVyIHtcbiAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMud2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoIHx8IDEwMCk7XG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCB8fCAxMDApO1xuICAgIHRoaXMuc3RlbmNpbCA9IGZhbHNlO1xuICAgIHRoaXMuZGVwdGggPSBmYWxzZTtcbiAgICB0aGlzLmRpcnR5SWQgPSAwO1xuICAgIHRoaXMuZGlydHlGb3JtYXQgPSAwO1xuICAgIHRoaXMuZGlydHlTaXplID0gMDtcbiAgICB0aGlzLmRlcHRoVGV4dHVyZSA9IG51bGw7XG4gICAgdGhpcy5jb2xvclRleHR1cmVzID0gW107XG4gICAgdGhpcy5nbEZyYW1lYnVmZmVycyA9IHt9O1xuICAgIHRoaXMuZGlzcG9zZVJ1bm5lciA9IG5ldyBydW5uZXIuUnVubmVyKFwiZGlzcG9zZUZyYW1lYnVmZmVyXCIpO1xuICAgIHRoaXMubXVsdGlzYW1wbGUgPSBjb25zdGFudHMuTVNBQV9RVUFMSVRZLk5PTkU7XG4gIH1cbiAgZ2V0IGNvbG9yVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvclRleHR1cmVzWzBdO1xuICB9XG4gIGFkZENvbG9yVGV4dHVyZShpbmRleCA9IDAsIHRleHR1cmUpIHtcbiAgICB0aGlzLmNvbG9yVGV4dHVyZXNbaW5kZXhdID0gdGV4dHVyZSB8fCBuZXcgQmFzZVRleHR1cmUuQmFzZVRleHR1cmUobnVsbCwge1xuICAgICAgc2NhbGVNb2RlOiBjb25zdGFudHMuU0NBTEVfTU9ERVMuTkVBUkVTVCxcbiAgICAgIHJlc29sdXRpb246IDEsXG4gICAgICBtaXBtYXA6IGNvbnN0YW50cy5NSVBNQVBfTU9ERVMuT0ZGLFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfSk7XG4gICAgdGhpcy5kaXJ0eUlkKys7XG4gICAgdGhpcy5kaXJ0eUZvcm1hdCsrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZERlcHRoVGV4dHVyZSh0ZXh0dXJlKSB7XG4gICAgdGhpcy5kZXB0aFRleHR1cmUgPSB0ZXh0dXJlIHx8IG5ldyBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZShuZXcgRGVwdGhSZXNvdXJjZS5EZXB0aFJlc291cmNlKG51bGwsIHsgd2lkdGg6IHRoaXMud2lkdGgsIGhlaWdodDogdGhpcy5oZWlnaHQgfSksIHtcbiAgICAgIHNjYWxlTW9kZTogY29uc3RhbnRzLlNDQUxFX01PREVTLk5FQVJFU1QsXG4gICAgICByZXNvbHV0aW9uOiAxLFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgbWlwbWFwOiBjb25zdGFudHMuTUlQTUFQX01PREVTLk9GRixcbiAgICAgIGZvcm1hdDogY29uc3RhbnRzLkZPUk1BVFMuREVQVEhfQ09NUE9ORU5ULFxuICAgICAgdHlwZTogY29uc3RhbnRzLlRZUEVTLlVOU0lHTkVEX1NIT1JUXG4gICAgfSk7XG4gICAgdGhpcy5kaXJ0eUlkKys7XG4gICAgdGhpcy5kaXJ0eUZvcm1hdCsrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGVuYWJsZURlcHRoKCkge1xuICAgIHRoaXMuZGVwdGggPSB0cnVlO1xuICAgIHRoaXMuZGlydHlJZCsrO1xuICAgIHRoaXMuZGlydHlGb3JtYXQrKztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBlbmFibGVTdGVuY2lsKCkge1xuICAgIHRoaXMuc3RlbmNpbCA9IHRydWU7XG4gICAgdGhpcy5kaXJ0eUlkKys7XG4gICAgdGhpcy5kaXJ0eUZvcm1hdCsrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgd2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoKTtcbiAgICBoZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCk7XG4gICAgaWYgKHdpZHRoID09PSB0aGlzLndpZHRoICYmIGhlaWdodCA9PT0gdGhpcy5oZWlnaHQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuZGlydHlJZCsrO1xuICAgIHRoaXMuZGlydHlTaXplKys7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbG9yVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmNvbG9yVGV4dHVyZXNbaV07XG4gICAgICBjb25zdCByZXNvbHV0aW9uID0gdGV4dHVyZS5yZXNvbHV0aW9uO1xuICAgICAgdGV4dHVyZS5zZXRTaXplKHdpZHRoIC8gcmVzb2x1dGlvbiwgaGVpZ2h0IC8gcmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlcHRoVGV4dHVyZSkge1xuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZGVwdGhUZXh0dXJlLnJlc29sdXRpb247XG4gICAgICB0aGlzLmRlcHRoVGV4dHVyZS5zZXRTaXplKHdpZHRoIC8gcmVzb2x1dGlvbiwgaGVpZ2h0IC8gcmVzb2x1dGlvbik7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5kaXNwb3NlUnVubmVyLmVtaXQodGhpcywgZmFsc2UpO1xuICB9XG4gIGRlc3Ryb3lEZXB0aFRleHR1cmUoKSB7XG4gICAgaWYgKHRoaXMuZGVwdGhUZXh0dXJlKSB7XG4gICAgICB0aGlzLmRlcHRoVGV4dHVyZS5kZXN0cm95KCk7XG4gICAgICB0aGlzLmRlcHRoVGV4dHVyZSA9IG51bGw7XG4gICAgICArK3RoaXMuZGlydHlJZDtcbiAgICAgICsrdGhpcy5kaXJ0eUZvcm1hdDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5GcmFtZWJ1ZmZlciA9IEZyYW1lYnVmZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnJhbWVidWZmZXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCdAcGl4aS9jb25zdGFudHMnKTtcbnZhciBleHRlbnNpb25zID0gcmVxdWlyZSgnQHBpeGkvZXh0ZW5zaW9ucycpO1xudmFyIG1hdGggPSByZXF1aXJlKCdAcGl4aS9tYXRoJyk7XG52YXIgc2V0dGluZ3MgPSByZXF1aXJlKCdAcGl4aS9zZXR0aW5ncycpO1xudmFyIEZyYW1lYnVmZmVyID0gcmVxdWlyZSgnLi9GcmFtZWJ1ZmZlci5qcycpO1xudmFyIEdMRnJhbWVidWZmZXIgPSByZXF1aXJlKCcuL0dMRnJhbWVidWZmZXIuanMnKTtcblxuY29uc3QgdGVtcFJlY3RhbmdsZSA9IG5ldyBtYXRoLlJlY3RhbmdsZSgpO1xuY2xhc3MgRnJhbWVidWZmZXJTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLm1hbmFnZWRGcmFtZWJ1ZmZlcnMgPSBbXTtcbiAgICB0aGlzLnVua25vd25GcmFtZWJ1ZmZlciA9IG5ldyBGcmFtZWJ1ZmZlci5GcmFtZWJ1ZmZlcigxMCwgMTApO1xuICAgIHRoaXMubXNhYVNhbXBsZXMgPSBudWxsO1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoKSB7XG4gICAgdGhpcy5kaXNwb3NlQWxsKHRydWUpO1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgdGhpcy5DT05URVhUX1VJRCA9IHRoaXMucmVuZGVyZXIuQ09OVEVYVF9VSUQ7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy51bmtub3duRnJhbWVidWZmZXI7XG4gICAgdGhpcy52aWV3cG9ydCA9IG5ldyBtYXRoLlJlY3RhbmdsZSgpO1xuICAgIHRoaXMuaGFzTVJUID0gdHJ1ZTtcbiAgICB0aGlzLndyaXRlRGVwdGhUZXh0dXJlID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5yZW5kZXJlci5jb250ZXh0LndlYkdMVmVyc2lvbiA9PT0gMSkge1xuICAgICAgbGV0IG5hdGl2ZURyYXdCdWZmZXJzRXh0ZW5zaW9uID0gdGhpcy5yZW5kZXJlci5jb250ZXh0LmV4dGVuc2lvbnMuZHJhd0J1ZmZlcnM7XG4gICAgICBsZXQgbmF0aXZlRGVwdGhUZXh0dXJlRXh0ZW5zaW9uID0gdGhpcy5yZW5kZXJlci5jb250ZXh0LmV4dGVuc2lvbnMuZGVwdGhUZXh0dXJlO1xuICAgICAgaWYgKHNldHRpbmdzLnNldHRpbmdzLlBSRUZFUl9FTlYgPT09IGNvbnN0YW50cy5FTlYuV0VCR0xfTEVHQUNZKSB7XG4gICAgICAgIG5hdGl2ZURyYXdCdWZmZXJzRXh0ZW5zaW9uID0gbnVsbDtcbiAgICAgICAgbmF0aXZlRGVwdGhUZXh0dXJlRXh0ZW5zaW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChuYXRpdmVEcmF3QnVmZmVyc0V4dGVuc2lvbikge1xuICAgICAgICBnbC5kcmF3QnVmZmVycyA9IChhY3RpdmVUZXh0dXJlcykgPT4gbmF0aXZlRHJhd0J1ZmZlcnNFeHRlbnNpb24uZHJhd0J1ZmZlcnNXRUJHTChhY3RpdmVUZXh0dXJlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhc01SVCA9IGZhbHNlO1xuICAgICAgICBnbC5kcmF3QnVmZmVycyA9ICgpID0+IHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICghbmF0aXZlRGVwdGhUZXh0dXJlRXh0ZW5zaW9uKSB7XG4gICAgICAgIHRoaXMud3JpdGVEZXB0aFRleHR1cmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tc2FhU2FtcGxlcyA9IGdsLmdldEludGVybmFsZm9ybWF0UGFyYW1ldGVyKGdsLlJFTkRFUkJVRkZFUiwgZ2wuUkdCQTgsIGdsLlNBTVBMRVMpO1xuICAgIH1cbiAgfVxuICBiaW5kKGZyYW1lYnVmZmVyLCBmcmFtZSwgbWlwTGV2ZWwgPSAwKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcztcbiAgICBpZiAoZnJhbWVidWZmZXIpIHtcbiAgICAgIGNvbnN0IGZibyA9IGZyYW1lYnVmZmVyLmdsRnJhbWVidWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdIHx8IHRoaXMuaW5pdEZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKTtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnQgIT09IGZyYW1lYnVmZmVyKSB7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IGZyYW1lYnVmZmVyO1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZiby5mcmFtZWJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBpZiAoZmJvLm1pcExldmVsICE9PSBtaXBMZXZlbCkge1xuICAgICAgICBmcmFtZWJ1ZmZlci5kaXJ0eUlkKys7XG4gICAgICAgIGZyYW1lYnVmZmVyLmRpcnR5Rm9ybWF0Kys7XG4gICAgICAgIGZiby5taXBMZXZlbCA9IG1pcExldmVsO1xuICAgICAgfVxuICAgICAgaWYgKGZiby5kaXJ0eUlkICE9PSBmcmFtZWJ1ZmZlci5kaXJ0eUlkKSB7XG4gICAgICAgIGZiby5kaXJ0eUlkID0gZnJhbWVidWZmZXIuZGlydHlJZDtcbiAgICAgICAgaWYgKGZiby5kaXJ0eUZvcm1hdCAhPT0gZnJhbWVidWZmZXIuZGlydHlGb3JtYXQpIHtcbiAgICAgICAgICBmYm8uZGlydHlGb3JtYXQgPSBmcmFtZWJ1ZmZlci5kaXJ0eUZvcm1hdDtcbiAgICAgICAgICBmYm8uZGlydHlTaXplID0gZnJhbWVidWZmZXIuZGlydHlTaXplO1xuICAgICAgICAgIHRoaXMudXBkYXRlRnJhbWVidWZmZXIoZnJhbWVidWZmZXIsIG1pcExldmVsKTtcbiAgICAgICAgfSBlbHNlIGlmIChmYm8uZGlydHlTaXplICE9PSBmcmFtZWJ1ZmZlci5kaXJ0eVNpemUpIHtcbiAgICAgICAgICBmYm8uZGlydHlTaXplID0gZnJhbWVidWZmZXIuZGlydHlTaXplO1xuICAgICAgICAgIHRoaXMucmVzaXplRnJhbWVidWZmZXIoZnJhbWVidWZmZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lYnVmZmVyLmNvbG9yVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdGV4ID0gZnJhbWVidWZmZXIuY29sb3JUZXh0dXJlc1tpXTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLnVuYmluZCh0ZXgucGFyZW50VGV4dHVyZUFycmF5IHx8IHRleCk7XG4gICAgICB9XG4gICAgICBpZiAoZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudGV4dHVyZS51bmJpbmQoZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICBjb25zdCBtaXBXaWR0aCA9IGZyYW1lLndpZHRoID4+IG1pcExldmVsO1xuICAgICAgICBjb25zdCBtaXBIZWlnaHQgPSBmcmFtZS5oZWlnaHQgPj4gbWlwTGV2ZWw7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gbWlwV2lkdGggLyBmcmFtZS53aWR0aDtcbiAgICAgICAgdGhpcy5zZXRWaWV3cG9ydChmcmFtZS54ICogc2NhbGUsIGZyYW1lLnkgKiBzY2FsZSwgbWlwV2lkdGgsIG1pcEhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtaXBXaWR0aCA9IGZyYW1lYnVmZmVyLndpZHRoID4+IG1pcExldmVsO1xuICAgICAgICBjb25zdCBtaXBIZWlnaHQgPSBmcmFtZWJ1ZmZlci5oZWlnaHQgPj4gbWlwTGV2ZWw7XG4gICAgICAgIHRoaXMuc2V0Vmlld3BvcnQoMCwgMCwgbWlwV2lkdGgsIG1pcEhlaWdodCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICB0aGlzLnNldFZpZXdwb3J0KGZyYW1lLngsIGZyYW1lLnksIGZyYW1lLndpZHRoLCBmcmFtZS5oZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRWaWV3cG9ydCgwLCAwLCB0aGlzLnJlbmRlcmVyLndpZHRoLCB0aGlzLnJlbmRlcmVyLmhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNldFZpZXdwb3J0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB2ID0gdGhpcy52aWV3cG9ydDtcbiAgICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICB3aWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xuICAgIGhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0KTtcbiAgICBpZiAodi53aWR0aCAhPT0gd2lkdGggfHwgdi5oZWlnaHQgIT09IGhlaWdodCB8fCB2LnggIT09IHggfHwgdi55ICE9PSB5KSB7XG4gICAgICB2LnggPSB4O1xuICAgICAgdi55ID0geTtcbiAgICAgIHYud2lkdGggPSB3aWR0aDtcbiAgICAgIHYuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdGhpcy5nbC52aWV3cG9ydCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudCkge1xuICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCwgd2lkdGg6IHRoaXMuY3VycmVudC53aWR0aCwgaGVpZ2h0OiB0aGlzLmN1cnJlbnQuaGVpZ2h0IH07XG4gICAgfVxuICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHdpZHRoOiB0aGlzLnJlbmRlcmVyLndpZHRoLCBoZWlnaHQ6IHRoaXMucmVuZGVyZXIuaGVpZ2h0IH07XG4gIH1cbiAgY2xlYXIociwgZywgYiwgYSwgbWFzayA9IGNvbnN0YW50cy5CVUZGRVJfQklUUy5DT0xPUiB8IGNvbnN0YW50cy5CVUZGRVJfQklUUy5ERVBUSCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgZ2wuY2xlYXJDb2xvcihyLCBnLCBiLCBhKTtcbiAgICBnbC5jbGVhcihtYXNrKTtcbiAgfVxuICBpbml0RnJhbWVidWZmZXIoZnJhbWVidWZmZXIpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzO1xuICAgIGNvbnN0IGZibyA9IG5ldyBHTEZyYW1lYnVmZmVyLkdMRnJhbWVidWZmZXIoZ2wuY3JlYXRlRnJhbWVidWZmZXIoKSk7XG4gICAgZmJvLm11bHRpc2FtcGxlID0gdGhpcy5kZXRlY3RTYW1wbGVzKGZyYW1lYnVmZmVyLm11bHRpc2FtcGxlKTtcbiAgICBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXSA9IGZibztcbiAgICB0aGlzLm1hbmFnZWRGcmFtZWJ1ZmZlcnMucHVzaChmcmFtZWJ1ZmZlcik7XG4gICAgZnJhbWVidWZmZXIuZGlzcG9zZVJ1bm5lci5hZGQodGhpcyk7XG4gICAgcmV0dXJuIGZibztcbiAgfVxuICByZXNpemVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcikge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgY29uc3QgZmJvID0gZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgaWYgKGZiby5zdGVuY2lsKSB7XG4gICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgZmJvLnN0ZW5jaWwpO1xuICAgICAgaWYgKGZiby5tc2FhQnVmZmVyKSB7XG4gICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZShnbC5SRU5ERVJCVUZGRVIsIGZiby5tdWx0aXNhbXBsZSwgZ2wuREVQVEgyNF9TVEVOQ0lMOCwgZnJhbWVidWZmZXIud2lkdGgsIGZyYW1lYnVmZmVyLmhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTCwgZnJhbWVidWZmZXIud2lkdGgsIGZyYW1lYnVmZmVyLmhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yVGV4dHVyZXMgPSBmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzO1xuICAgIGxldCBjb3VudCA9IGNvbG9yVGV4dHVyZXMubGVuZ3RoO1xuICAgIGlmICghZ2wuZHJhd0J1ZmZlcnMpIHtcbiAgICAgIGNvdW50ID0gTWF0aC5taW4oY291bnQsIDEpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBjb2xvclRleHR1cmVzW2ldO1xuICAgICAgY29uc3QgcGFyZW50VGV4dHVyZSA9IHRleHR1cmUucGFyZW50VGV4dHVyZUFycmF5IHx8IHRleHR1cmU7XG4gICAgICB0aGlzLnJlbmRlcmVyLnRleHR1cmUuYmluZChwYXJlbnRUZXh0dXJlLCAwKTtcbiAgICAgIGlmIChpID09PSAwICYmIGZiby5tc2FhQnVmZmVyKSB7XG4gICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBmYm8ubXNhYUJ1ZmZlcik7XG4gICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZShnbC5SRU5ERVJCVUZGRVIsIGZiby5tdWx0aXNhbXBsZSwgcGFyZW50VGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXS5pbnRlcm5hbEZvcm1hdCwgZnJhbWVidWZmZXIud2lkdGgsIGZyYW1lYnVmZmVyLmhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmUgJiYgdGhpcy53cml0ZURlcHRoVGV4dHVyZSkge1xuICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLmJpbmQoZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlLCAwKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlRnJhbWVidWZmZXIoZnJhbWVidWZmZXIsIG1pcExldmVsKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcztcbiAgICBjb25zdCBmYm8gPSBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICBjb25zdCBjb2xvclRleHR1cmVzID0gZnJhbWVidWZmZXIuY29sb3JUZXh0dXJlcztcbiAgICBsZXQgY291bnQgPSBjb2xvclRleHR1cmVzLmxlbmd0aDtcbiAgICBpZiAoIWdsLmRyYXdCdWZmZXJzKSB7XG4gICAgICBjb3VudCA9IE1hdGgubWluKGNvdW50LCAxKTtcbiAgICB9XG4gICAgaWYgKGZiby5tdWx0aXNhbXBsZSA+IDEgJiYgdGhpcy5jYW5NdWx0aXNhbXBsZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKSkge1xuICAgICAgZmJvLm1zYWFCdWZmZXIgPSBmYm8ubXNhYUJ1ZmZlciB8fCBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICB9IGVsc2UgaWYgKGZiby5tc2FhQnVmZmVyKSB7XG4gICAgICBnbC5kZWxldGVSZW5kZXJidWZmZXIoZmJvLm1zYWFCdWZmZXIpO1xuICAgICAgZmJvLm1zYWFCdWZmZXIgPSBudWxsO1xuICAgICAgaWYgKGZiby5ibGl0RnJhbWVidWZmZXIpIHtcbiAgICAgICAgZmJvLmJsaXRGcmFtZWJ1ZmZlci5kaXNwb3NlKCk7XG4gICAgICAgIGZiby5ibGl0RnJhbWVidWZmZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhY3RpdmVUZXh0dXJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdGV4dHVyZSA9IGNvbG9yVGV4dHVyZXNbaV07XG4gICAgICBjb25zdCBwYXJlbnRUZXh0dXJlID0gdGV4dHVyZS5wYXJlbnRUZXh0dXJlQXJyYXkgfHwgdGV4dHVyZTtcbiAgICAgIHRoaXMucmVuZGVyZXIudGV4dHVyZS5iaW5kKHBhcmVudFRleHR1cmUsIDApO1xuICAgICAgaWYgKGkgPT09IDAgJiYgZmJvLm1zYWFCdWZmZXIpIHtcbiAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIGZiby5tc2FhQnVmZmVyKTtcbiAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKGdsLlJFTkRFUkJVRkZFUiwgZmJvLm11bHRpc2FtcGxlLCBwYXJlbnRUZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdLmludGVybmFsRm9ybWF0LCBmcmFtZWJ1ZmZlci53aWR0aCwgZnJhbWVidWZmZXIuaGVpZ2h0KTtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5SRU5ERVJCVUZGRVIsIGZiby5tc2FhQnVmZmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksIHRleHR1cmUudGFyZ2V0LCBwYXJlbnRUZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdLnRleHR1cmUsIG1pcExldmVsKTtcbiAgICAgICAgYWN0aXZlVGV4dHVyZXMucHVzaChnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWN0aXZlVGV4dHVyZXMubGVuZ3RoID4gMSkge1xuICAgICAgZ2wuZHJhd0J1ZmZlcnMoYWN0aXZlVGV4dHVyZXMpO1xuICAgIH1cbiAgICBpZiAoZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlKSB7XG4gICAgICBjb25zdCB3cml0ZURlcHRoVGV4dHVyZSA9IHRoaXMud3JpdGVEZXB0aFRleHR1cmU7XG4gICAgICBpZiAod3JpdGVEZXB0aFRleHR1cmUpIHtcbiAgICAgICAgY29uc3QgZGVwdGhUZXh0dXJlID0gZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnRleHR1cmUuYmluZChkZXB0aFRleHR1cmUsIDApO1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuVEVYVFVSRV8yRCwgZGVwdGhUZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdLnRleHR1cmUsIG1pcExldmVsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKChmcmFtZWJ1ZmZlci5zdGVuY2lsIHx8IGZyYW1lYnVmZmVyLmRlcHRoKSAmJiAhKGZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZSAmJiB0aGlzLndyaXRlRGVwdGhUZXh0dXJlKSkge1xuICAgICAgZmJvLnN0ZW5jaWwgPSBmYm8uc3RlbmNpbCB8fCBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBmYm8uc3RlbmNpbCk7XG4gICAgICBpZiAoZmJvLm1zYWFCdWZmZXIpIHtcbiAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKGdsLlJFTkRFUkJVRkZFUiwgZmJvLm11bHRpc2FtcGxlLCBnbC5ERVBUSDI0X1NURU5DSUw4LCBmcmFtZWJ1ZmZlci53aWR0aCwgZnJhbWVidWZmZXIuaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMLCBmcmFtZWJ1ZmZlci53aWR0aCwgZnJhbWVidWZmZXIuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgZmJvLnN0ZW5jaWwpO1xuICAgIH0gZWxzZSBpZiAoZmJvLnN0ZW5jaWwpIHtcbiAgICAgIGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihmYm8uc3RlbmNpbCk7XG4gICAgICBmYm8uc3RlbmNpbCA9IG51bGw7XG4gICAgfVxuICB9XG4gIGNhbk11bHRpc2FtcGxlRnJhbWVidWZmZXIoZnJhbWVidWZmZXIpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5jb250ZXh0LndlYkdMVmVyc2lvbiAhPT0gMSAmJiBmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzLmxlbmd0aCA8PSAxICYmICFmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmU7XG4gIH1cbiAgZGV0ZWN0U2FtcGxlcyhzYW1wbGVzKSB7XG4gICAgY29uc3QgeyBtc2FhU2FtcGxlcyB9ID0gdGhpcztcbiAgICBsZXQgcmVzID0gY29uc3RhbnRzLk1TQUFfUVVBTElUWS5OT05FO1xuICAgIGlmIChzYW1wbGVzIDw9IDEgfHwgbXNhYVNhbXBsZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXNhYVNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChtc2FhU2FtcGxlc1tpXSA8PSBzYW1wbGVzKSB7XG4gICAgICAgIHJlcyA9IG1zYWFTYW1wbGVzW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlcyA9PT0gMSkge1xuICAgICAgcmVzID0gY29uc3RhbnRzLk1TQUFfUVVBTElUWS5OT05FO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGJsaXQoZnJhbWVidWZmZXIsIHNvdXJjZVBpeGVscywgZGVzdFBpeGVscykge1xuICAgIGNvbnN0IHsgY3VycmVudCwgcmVuZGVyZXIsIGdsLCBDT05URVhUX1VJRCB9ID0gdGhpcztcbiAgICBpZiAocmVuZGVyZXIuY29udGV4dC53ZWJHTFZlcnNpb24gIT09IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZibyA9IGN1cnJlbnQuZ2xGcmFtZWJ1ZmZlcnNbQ09OVEVYVF9VSURdO1xuICAgIGlmICghZmJvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZnJhbWVidWZmZXIpIHtcbiAgICAgIGlmICghZmJvLm1zYWFCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sb3JUZXh0dXJlID0gY3VycmVudC5jb2xvclRleHR1cmVzWzBdO1xuICAgICAgaWYgKCFjb2xvclRleHR1cmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFmYm8uYmxpdEZyYW1lYnVmZmVyKSB7XG4gICAgICAgIGZiby5ibGl0RnJhbWVidWZmZXIgPSBuZXcgRnJhbWVidWZmZXIuRnJhbWVidWZmZXIoY3VycmVudC53aWR0aCwgY3VycmVudC5oZWlnaHQpO1xuICAgICAgICBmYm8uYmxpdEZyYW1lYnVmZmVyLmFkZENvbG9yVGV4dHVyZSgwLCBjb2xvclRleHR1cmUpO1xuICAgICAgfVxuICAgICAgZnJhbWVidWZmZXIgPSBmYm8uYmxpdEZyYW1lYnVmZmVyO1xuICAgICAgaWYgKGZyYW1lYnVmZmVyLmNvbG9yVGV4dHVyZXNbMF0gIT09IGNvbG9yVGV4dHVyZSkge1xuICAgICAgICBmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzWzBdID0gY29sb3JUZXh0dXJlO1xuICAgICAgICBmcmFtZWJ1ZmZlci5kaXJ0eUlkKys7XG4gICAgICAgIGZyYW1lYnVmZmVyLmRpcnR5Rm9ybWF0Kys7XG4gICAgICB9XG4gICAgICBpZiAoZnJhbWVidWZmZXIud2lkdGggIT09IGN1cnJlbnQud2lkdGggfHwgZnJhbWVidWZmZXIuaGVpZ2h0ICE9PSBjdXJyZW50LmhlaWdodCkge1xuICAgICAgICBmcmFtZWJ1ZmZlci53aWR0aCA9IGN1cnJlbnQud2lkdGg7XG4gICAgICAgIGZyYW1lYnVmZmVyLmhlaWdodCA9IGN1cnJlbnQuaGVpZ2h0O1xuICAgICAgICBmcmFtZWJ1ZmZlci5kaXJ0eUlkKys7XG4gICAgICAgIGZyYW1lYnVmZmVyLmRpcnR5U2l6ZSsrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXNvdXJjZVBpeGVscykge1xuICAgICAgc291cmNlUGl4ZWxzID0gdGVtcFJlY3RhbmdsZTtcbiAgICAgIHNvdXJjZVBpeGVscy53aWR0aCA9IGN1cnJlbnQud2lkdGg7XG4gICAgICBzb3VyY2VQaXhlbHMuaGVpZ2h0ID0gY3VycmVudC5oZWlnaHQ7XG4gICAgfVxuICAgIGlmICghZGVzdFBpeGVscykge1xuICAgICAgZGVzdFBpeGVscyA9IHNvdXJjZVBpeGVscztcbiAgICB9XG4gICAgY29uc3Qgc2FtZVNpemUgPSBzb3VyY2VQaXhlbHMud2lkdGggPT09IGRlc3RQaXhlbHMud2lkdGggJiYgc291cmNlUGl4ZWxzLmhlaWdodCA9PT0gZGVzdFBpeGVscy5oZWlnaHQ7XG4gICAgdGhpcy5iaW5kKGZyYW1lYnVmZmVyKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuUkVBRF9GUkFNRUJVRkZFUiwgZmJvLmZyYW1lYnVmZmVyKTtcbiAgICBnbC5ibGl0RnJhbWVidWZmZXIoc291cmNlUGl4ZWxzLmxlZnQsIHNvdXJjZVBpeGVscy50b3AsIHNvdXJjZVBpeGVscy5yaWdodCwgc291cmNlUGl4ZWxzLmJvdHRvbSwgZGVzdFBpeGVscy5sZWZ0LCBkZXN0UGl4ZWxzLnRvcCwgZGVzdFBpeGVscy5yaWdodCwgZGVzdFBpeGVscy5ib3R0b20sIGdsLkNPTE9SX0JVRkZFUl9CSVQsIHNhbWVTaXplID8gZ2wuTkVBUkVTVCA6IGdsLkxJTkVBUik7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLlJFQURfRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyLmdsRnJhbWVidWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdLmZyYW1lYnVmZmVyKTtcbiAgfVxuICBkaXNwb3NlRnJhbWVidWZmZXIoZnJhbWVidWZmZXIsIGNvbnRleHRMb3N0KSB7XG4gICAgY29uc3QgZmJvID0gZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGlmICghZmJvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMubWFuYWdlZEZyYW1lYnVmZmVycy5pbmRleE9mKGZyYW1lYnVmZmVyKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5tYW5hZ2VkRnJhbWVidWZmZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIGZyYW1lYnVmZmVyLmRpc3Bvc2VSdW5uZXIucmVtb3ZlKHRoaXMpO1xuICAgIGlmICghY29udGV4dExvc3QpIHtcbiAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZiby5mcmFtZWJ1ZmZlcik7XG4gICAgICBpZiAoZmJvLm1zYWFCdWZmZXIpIHtcbiAgICAgICAgZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKGZiby5tc2FhQnVmZmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChmYm8uc3RlbmNpbCkge1xuICAgICAgICBnbC5kZWxldGVSZW5kZXJidWZmZXIoZmJvLnN0ZW5jaWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmJvLmJsaXRGcmFtZWJ1ZmZlcikge1xuICAgICAgdGhpcy5kaXNwb3NlRnJhbWVidWZmZXIoZmJvLmJsaXRGcmFtZWJ1ZmZlciwgY29udGV4dExvc3QpO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlQWxsKGNvbnRleHRMb3N0KSB7XG4gICAgY29uc3QgbGlzdCA9IHRoaXMubWFuYWdlZEZyYW1lYnVmZmVycztcbiAgICB0aGlzLm1hbmFnZWRGcmFtZWJ1ZmZlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuZGlzcG9zZUZyYW1lYnVmZmVyKGxpc3RbaV0sIGNvbnRleHRMb3N0KTtcbiAgICB9XG4gIH1cbiAgZm9yY2VTdGVuY2lsKCkge1xuICAgIGNvbnN0IGZyYW1lYnVmZmVyID0gdGhpcy5jdXJyZW50O1xuICAgIGlmICghZnJhbWVidWZmZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZmJvID0gZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgaWYgKCFmYm8gfHwgZmJvLnN0ZW5jaWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnJhbWVidWZmZXIuc3RlbmNpbCA9IHRydWU7XG4gICAgY29uc3QgdyA9IGZyYW1lYnVmZmVyLndpZHRoO1xuICAgIGNvbnN0IGggPSBmcmFtZWJ1ZmZlci5oZWlnaHQ7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGNvbnN0IHN0ZW5jaWwgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgc3RlbmNpbCk7XG4gICAgaWYgKGZiby5tc2FhQnVmZmVyKSB7XG4gICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoZ2wuUkVOREVSQlVGRkVSLCBmYm8ubXVsdGlzYW1wbGUsIGdsLkRFUFRIMjRfU1RFTkNJTDgsIHcsIGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTCwgdywgaCk7XG4gICAgfVxuICAgIGZiby5zdGVuY2lsID0gc3RlbmNpbDtcbiAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIHN0ZW5jaWwpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMudW5rbm93bkZyYW1lYnVmZmVyO1xuICAgIHRoaXMudmlld3BvcnQgPSBuZXcgbWF0aC5SZWN0YW5nbGUoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG5GcmFtZWJ1ZmZlclN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJmcmFtZWJ1ZmZlclwiXG59O1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmFkZChGcmFtZWJ1ZmZlclN5c3RlbSk7XG5cbmV4cG9ydHMuRnJhbWVidWZmZXJTeXN0ZW0gPSBGcmFtZWJ1ZmZlclN5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZyYW1lYnVmZmVyU3lzdGVtLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnQHBpeGkvY29uc3RhbnRzJyk7XG5cbmNsYXNzIEdMRnJhbWVidWZmZXIge1xuICBjb25zdHJ1Y3RvcihmcmFtZWJ1ZmZlcikge1xuICAgIHRoaXMuZnJhbWVidWZmZXIgPSBmcmFtZWJ1ZmZlcjtcbiAgICB0aGlzLnN0ZW5jaWwgPSBudWxsO1xuICAgIHRoaXMuZGlydHlJZCA9IC0xO1xuICAgIHRoaXMuZGlydHlGb3JtYXQgPSAtMTtcbiAgICB0aGlzLmRpcnR5U2l6ZSA9IC0xO1xuICAgIHRoaXMubXVsdGlzYW1wbGUgPSBjb25zdGFudHMuTVNBQV9RVUFMSVRZLk5PTkU7XG4gICAgdGhpcy5tc2FhQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmJsaXRGcmFtZWJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5taXBMZXZlbCA9IDA7XG4gIH1cbn1cblxuZXhwb3J0cy5HTEZyYW1lYnVmZmVyID0gR0xGcmFtZWJ1ZmZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdMRnJhbWVidWZmZXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCdAcGl4aS9jb25zdGFudHMnKTtcbnZhciBleHRlbnNpb25zID0gcmVxdWlyZSgnQHBpeGkvZXh0ZW5zaW9ucycpO1xuXG5jbGFzcyBNdWx0aXNhbXBsZVN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoZ2wpIHtcbiAgICBsZXQgc2FtcGxlcztcbiAgICBpZiAodGhpcy5yZW5kZXJlci5jb250ZXh0LndlYkdMVmVyc2lvbiA9PT0gMSkge1xuICAgICAgY29uc3QgZnJhbWVidWZmZXIgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuRlJBTUVCVUZGRVJfQklORElORyk7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgc2FtcGxlcyA9IGdsLmdldFBhcmFtZXRlcihnbC5TQU1QTEVTKTtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmcmFtZWJ1ZmZlciA9IGdsLmdldFBhcmFtZXRlcihnbC5EUkFXX0ZSQU1FQlVGRkVSX0JJTkRJTkcpO1xuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkRSQVdfRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgc2FtcGxlcyA9IGdsLmdldFBhcmFtZXRlcihnbC5TQU1QTEVTKTtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5EUkFXX0ZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG4gICAgfVxuICAgIGlmIChzYW1wbGVzID49IGNvbnN0YW50cy5NU0FBX1FVQUxJVFkuSElHSCkge1xuICAgICAgdGhpcy5tdWx0aXNhbXBsZSA9IGNvbnN0YW50cy5NU0FBX1FVQUxJVFkuSElHSDtcbiAgICB9IGVsc2UgaWYgKHNhbXBsZXMgPj0gY29uc3RhbnRzLk1TQUFfUVVBTElUWS5NRURJVU0pIHtcbiAgICAgIHRoaXMubXVsdGlzYW1wbGUgPSBjb25zdGFudHMuTVNBQV9RVUFMSVRZLk1FRElVTTtcbiAgICB9IGVsc2UgaWYgKHNhbXBsZXMgPj0gY29uc3RhbnRzLk1TQUFfUVVBTElUWS5MT1cpIHtcbiAgICAgIHRoaXMubXVsdGlzYW1wbGUgPSBjb25zdGFudHMuTVNBQV9RVUFMSVRZLkxPVztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tdWx0aXNhbXBsZSA9IGNvbnN0YW50cy5NU0FBX1FVQUxJVFkuTk9ORTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgfVxufVxuTXVsdGlzYW1wbGVTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwiX211bHRpc2FtcGxlXCJcbn07XG5leHRlbnNpb25zLmV4dGVuc2lvbnMuYWRkKE11bHRpc2FtcGxlU3lzdGVtKTtcblxuZXhwb3J0cy5NdWx0aXNhbXBsZVN5c3RlbSA9IE11bHRpc2FtcGxlU3lzdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TXVsdGlzYW1wbGVTeXN0ZW0uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCdAcGl4aS9jb25zdGFudHMnKTtcblxuY2xhc3MgQXR0cmlidXRlIHtcbiAgY29uc3RydWN0b3IoYnVmZmVyLCBzaXplID0gMCwgbm9ybWFsaXplZCA9IGZhbHNlLCB0eXBlID0gY29uc3RhbnRzLlRZUEVTLkZMT0FULCBzdHJpZGUsIHN0YXJ0LCBpbnN0YW5jZSwgZGl2aXNvciA9IDEpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnN0cmlkZSA9IHN0cmlkZTtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIHRoaXMuZGl2aXNvciA9IGRpdmlzb3I7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gIH1cbiAgc3RhdGljIGZyb20oYnVmZmVyLCBzaXplLCBub3JtYWxpemVkLCB0eXBlLCBzdHJpZGUpIHtcbiAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZShidWZmZXIsIHNpemUsIG5vcm1hbGl6ZWQsIHR5cGUsIHN0cmlkZSk7XG4gIH1cbn1cblxuZXhwb3J0cy5BdHRyaWJ1dGUgPSBBdHRyaWJ1dGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdHRyaWJ1dGUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCdAcGl4aS9jb25zdGFudHMnKTtcbnZhciBydW5uZXIgPSByZXF1aXJlKCdAcGl4aS9ydW5uZXInKTtcblxubGV0IFVJRCA9IDA7XG5jbGFzcyBCdWZmZXIge1xuICBjb25zdHJ1Y3RvcihkYXRhLCBfc3RhdGljID0gdHJ1ZSwgaW5kZXggPSBmYWxzZSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwgbmV3IEZsb2F0MzJBcnJheSgxKTtcbiAgICB0aGlzLl9nbEJ1ZmZlcnMgPSB7fTtcbiAgICB0aGlzLl91cGRhdGVJRCA9IDA7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuc3RhdGljID0gX3N0YXRpYztcbiAgICB0aGlzLmlkID0gVUlEKys7XG4gICAgdGhpcy5kaXNwb3NlUnVubmVyID0gbmV3IHJ1bm5lci5SdW5uZXIoXCJkaXNwb3NlQnVmZmVyXCIpO1xuICB9XG4gIHVwZGF0ZShkYXRhKSB7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XG4gICAgfVxuICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwgdGhpcy5kYXRhO1xuICAgIHRoaXMuX3VwZGF0ZUlEKys7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmRpc3Bvc2VSdW5uZXIuZW1pdCh0aGlzLCBmYWxzZSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICB9XG4gIHNldCBpbmRleCh2YWx1ZSkge1xuICAgIHRoaXMudHlwZSA9IHZhbHVlID8gY29uc3RhbnRzLkJVRkZFUl9UWVBFLkVMRU1FTlRfQVJSQVlfQlVGRkVSIDogY29uc3RhbnRzLkJVRkZFUl9UWVBFLkFSUkFZX0JVRkZFUjtcbiAgfVxuICBnZXQgaW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gY29uc3RhbnRzLkJVRkZFUl9UWVBFLkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xuICB9XG4gIHN0YXRpYyBmcm9tKGRhdGEpIHtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoZGF0YSk7XG4gIH1cbn1cblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdWZmZXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBleHRlbnNpb25zID0gcmVxdWlyZSgnQHBpeGkvZXh0ZW5zaW9ucycpO1xudmFyIEdMQnVmZmVyID0gcmVxdWlyZSgnLi9HTEJ1ZmZlci5qcycpO1xuXG5jbGFzcyBCdWZmZXJTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLm1hbmFnZWRCdWZmZXJzID0ge307XG4gICAgdGhpcy5ib3VuZEJ1ZmZlckJhc2VzID0ge307XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKCkge1xuICAgIHRoaXMuZGlzcG9zZUFsbCh0cnVlKTtcbiAgICB0aGlzLmdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICB0aGlzLkNPTlRFWFRfVUlEID0gdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRDtcbiAgfVxuICBiaW5kKGJ1ZmZlcikge1xuICAgIGNvbnN0IHsgZ2wsIENPTlRFWFRfVUlEIH0gPSB0aGlzO1xuICAgIGNvbnN0IGdsQnVmZmVyID0gYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdIHx8IHRoaXMuY3JlYXRlR0xCdWZmZXIoYnVmZmVyKTtcbiAgICBnbC5iaW5kQnVmZmVyKGJ1ZmZlci50eXBlLCBnbEJ1ZmZlci5idWZmZXIpO1xuICB9XG4gIHVuYmluZCh0eXBlKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcztcbiAgICBnbC5iaW5kQnVmZmVyKHR5cGUsIG51bGwpO1xuICB9XG4gIGJpbmRCdWZmZXJCYXNlKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICBjb25zdCB7IGdsLCBDT05URVhUX1VJRCB9ID0gdGhpcztcbiAgICBpZiAodGhpcy5ib3VuZEJ1ZmZlckJhc2VzW2luZGV4XSAhPT0gYnVmZmVyKSB7XG4gICAgICBjb25zdCBnbEJ1ZmZlciA9IGJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXSB8fCB0aGlzLmNyZWF0ZUdMQnVmZmVyKGJ1ZmZlcik7XG4gICAgICB0aGlzLmJvdW5kQnVmZmVyQmFzZXNbaW5kZXhdID0gYnVmZmVyO1xuICAgICAgZ2wuYmluZEJ1ZmZlckJhc2UoZ2wuVU5JRk9STV9CVUZGRVIsIGluZGV4LCBnbEJ1ZmZlci5idWZmZXIpO1xuICAgIH1cbiAgfVxuICBiaW5kQnVmZmVyUmFuZ2UoYnVmZmVyLCBpbmRleCwgb2Zmc2V0KSB7XG4gICAgY29uc3QgeyBnbCwgQ09OVEVYVF9VSUQgfSA9IHRoaXM7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgY29uc3QgZ2xCdWZmZXIgPSBidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF0gfHwgdGhpcy5jcmVhdGVHTEJ1ZmZlcihidWZmZXIpO1xuICAgIGdsLmJpbmRCdWZmZXJSYW5nZShnbC5VTklGT1JNX0JVRkZFUiwgaW5kZXggfHwgMCwgZ2xCdWZmZXIuYnVmZmVyLCBvZmZzZXQgKiAyNTYsIDI1Nik7XG4gIH1cbiAgdXBkYXRlKGJ1ZmZlcikge1xuICAgIGNvbnN0IHsgZ2wsIENPTlRFWFRfVUlEIH0gPSB0aGlzO1xuICAgIGNvbnN0IGdsQnVmZmVyID0gYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdIHx8IHRoaXMuY3JlYXRlR0xCdWZmZXIoYnVmZmVyKTtcbiAgICBpZiAoYnVmZmVyLl91cGRhdGVJRCA9PT0gZ2xCdWZmZXIudXBkYXRlSUQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZ2xCdWZmZXIudXBkYXRlSUQgPSBidWZmZXIuX3VwZGF0ZUlEO1xuICAgIGdsLmJpbmRCdWZmZXIoYnVmZmVyLnR5cGUsIGdsQnVmZmVyLmJ1ZmZlcik7XG4gICAgaWYgKGdsQnVmZmVyLmJ5dGVMZW5ndGggPj0gYnVmZmVyLmRhdGEuYnl0ZUxlbmd0aCkge1xuICAgICAgZ2wuYnVmZmVyU3ViRGF0YShidWZmZXIudHlwZSwgMCwgYnVmZmVyLmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkcmF3VHlwZSA9IGJ1ZmZlci5zdGF0aWMgPyBnbC5TVEFUSUNfRFJBVyA6IGdsLkRZTkFNSUNfRFJBVztcbiAgICAgIGdsQnVmZmVyLmJ5dGVMZW5ndGggPSBidWZmZXIuZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgZ2wuYnVmZmVyRGF0YShidWZmZXIudHlwZSwgYnVmZmVyLmRhdGEsIGRyYXdUeXBlKTtcbiAgICB9XG4gIH1cbiAgZGlzcG9zZShidWZmZXIsIGNvbnRleHRMb3N0KSB7XG4gICAgaWYgKCF0aGlzLm1hbmFnZWRCdWZmZXJzW2J1ZmZlci5pZF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMubWFuYWdlZEJ1ZmZlcnNbYnVmZmVyLmlkXTtcbiAgICBjb25zdCBnbEJ1ZmZlciA9IGJ1ZmZlci5fZ2xCdWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBidWZmZXIuZGlzcG9zZVJ1bm5lci5yZW1vdmUodGhpcyk7XG4gICAgaWYgKCFnbEJ1ZmZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNvbnRleHRMb3N0KSB7XG4gICAgICBnbC5kZWxldGVCdWZmZXIoZ2xCdWZmZXIuYnVmZmVyKTtcbiAgICB9XG4gICAgZGVsZXRlIGJ1ZmZlci5fZ2xCdWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdO1xuICB9XG4gIGRpc3Bvc2VBbGwoY29udGV4dExvc3QpIHtcbiAgICBjb25zdCBhbGwgPSBPYmplY3Qua2V5cyh0aGlzLm1hbmFnZWRCdWZmZXJzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5kaXNwb3NlKHRoaXMubWFuYWdlZEJ1ZmZlcnNbYWxsW2ldXSwgY29udGV4dExvc3QpO1xuICAgIH1cbiAgfVxuICBjcmVhdGVHTEJ1ZmZlcihidWZmZXIpIHtcbiAgICBjb25zdCB7IENPTlRFWFRfVUlELCBnbCB9ID0gdGhpcztcbiAgICBidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF0gPSBuZXcgR0xCdWZmZXIuR0xCdWZmZXIoZ2wuY3JlYXRlQnVmZmVyKCkpO1xuICAgIHRoaXMubWFuYWdlZEJ1ZmZlcnNbYnVmZmVyLmlkXSA9IGJ1ZmZlcjtcbiAgICBidWZmZXIuZGlzcG9zZVJ1bm5lci5hZGQodGhpcyk7XG4gICAgcmV0dXJuIGJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXTtcbiAgfVxufVxuQnVmZmVyU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcImJ1ZmZlclwiXG59O1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmFkZChCdWZmZXJTeXN0ZW0pO1xuXG5leHBvcnRzLkJ1ZmZlclN5c3RlbSA9IEJ1ZmZlclN5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1ZmZlclN5c3RlbS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY2xhc3MgR0xCdWZmZXIge1xuICBjb25zdHJ1Y3RvcihidWZmZXIpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlciB8fCBudWxsO1xuICAgIHRoaXMudXBkYXRlSUQgPSAtMTtcbiAgICB0aGlzLmJ5dGVMZW5ndGggPSAtMTtcbiAgICB0aGlzLnJlZkNvdW50ID0gMDtcbiAgfVxufVxuXG5leHBvcnRzLkdMQnVmZmVyID0gR0xCdWZmZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HTEJ1ZmZlci5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ0BwaXhpL2NvbnN0YW50cycpO1xudmFyIHJ1bm5lciA9IHJlcXVpcmUoJ0BwaXhpL3J1bm5lcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQHBpeGkvdXRpbHMnKTtcbnZhciBBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL0F0dHJpYnV0ZS5qcycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4vQnVmZmVyLmpzJyk7XG52YXIgaW50ZXJsZWF2ZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnLi91dGlscy9pbnRlcmxlYXZlVHlwZWRBcnJheXMuanMnKTtcblxuY29uc3QgYnl0ZVNpemVNYXAgPSB7IDUxMjY6IDQsIDUxMjM6IDIsIDUxMjE6IDEgfTtcbmxldCBVSUQgPSAwO1xuY29uc3QgbWFwID0ge1xuICBGbG9hdDMyQXJyYXksXG4gIFVpbnQzMkFycmF5LFxuICBJbnQzMkFycmF5LFxuICBVaW50OEFycmF5LFxuICBVaW50MTZBcnJheVxufTtcbmNsYXNzIEdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoYnVmZmVycyA9IFtdLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBidWZmZXJzO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgdGhpcy5nbFZlcnRleEFycmF5T2JqZWN0cyA9IHt9O1xuICAgIHRoaXMuaWQgPSBVSUQrKztcbiAgICB0aGlzLmluc3RhbmNlZCA9IGZhbHNlO1xuICAgIHRoaXMuaW5zdGFuY2VDb3VudCA9IDE7XG4gICAgdGhpcy5kaXNwb3NlUnVubmVyID0gbmV3IHJ1bm5lci5SdW5uZXIoXCJkaXNwb3NlR2VvbWV0cnlcIik7XG4gICAgdGhpcy5yZWZDb3VudCA9IDA7XG4gIH1cbiAgYWRkQXR0cmlidXRlKGlkLCBidWZmZXIsIHNpemUgPSAwLCBub3JtYWxpemVkID0gZmFsc2UsIHR5cGUsIHN0cmlkZSwgc3RhcnQsIGluc3RhbmNlID0gZmFsc2UpIHtcbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcGFzcyBhIGJ1ZmZlciB3aGVuIGNyZWF0aW5nIGFuIGF0dHJpYnV0ZVwiKTtcbiAgICB9XG4gICAgaWYgKCEoYnVmZmVyIGluc3RhbmNlb2YgQnVmZmVyLkJ1ZmZlcikpIHtcbiAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBidWZmZXIgPSBuZXcgQnVmZmVyLkJ1ZmZlcihidWZmZXIpO1xuICAgIH1cbiAgICBjb25zdCBpZHMgPSBpZC5zcGxpdChcInxcIik7XG4gICAgaWYgKGlkcy5sZW5ndGggPiAxKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShpZHNbaV0sIGJ1ZmZlciwgc2l6ZSwgbm9ybWFsaXplZCwgdHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbGV0IGJ1ZmZlckluZGV4ID0gdGhpcy5idWZmZXJzLmluZGV4T2YoYnVmZmVyKTtcbiAgICBpZiAoYnVmZmVySW5kZXggPT09IC0xKSB7XG4gICAgICB0aGlzLmJ1ZmZlcnMucHVzaChidWZmZXIpO1xuICAgICAgYnVmZmVySW5kZXggPSB0aGlzLmJ1ZmZlcnMubGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgdGhpcy5hdHRyaWJ1dGVzW2lkXSA9IG5ldyBBdHRyaWJ1dGUuQXR0cmlidXRlKGJ1ZmZlckluZGV4LCBzaXplLCBub3JtYWxpemVkLCB0eXBlLCBzdHJpZGUsIHN0YXJ0LCBpbnN0YW5jZSk7XG4gICAgdGhpcy5pbnN0YW5jZWQgPSB0aGlzLmluc3RhbmNlZCB8fCBpbnN0YW5jZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXRBdHRyaWJ1dGUoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2lkXTtcbiAgfVxuICBnZXRCdWZmZXIoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXJzW3RoaXMuZ2V0QXR0cmlidXRlKGlkKS5idWZmZXJdO1xuICB9XG4gIGFkZEluZGV4KGJ1ZmZlcikge1xuICAgIGlmICghKGJ1ZmZlciBpbnN0YW5jZW9mIEJ1ZmZlci5CdWZmZXIpKSB7XG4gICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBidWZmZXIgPSBuZXcgQnVmZmVyLkJ1ZmZlcihidWZmZXIpO1xuICAgIH1cbiAgICBidWZmZXIudHlwZSA9IGNvbnN0YW50cy5CVUZGRVJfVFlQRS5FTEVNRU5UX0FSUkFZX0JVRkZFUjtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gYnVmZmVyO1xuICAgIGlmICghdGhpcy5idWZmZXJzLmluY2x1ZGVzKGJ1ZmZlcikpIHtcbiAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4QnVmZmVyO1xuICB9XG4gIGludGVybGVhdmUoKSB7XG4gICAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT09IDEgfHwgdGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gMiAmJiB0aGlzLmluZGV4QnVmZmVyKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgYXJyYXlzID0gW107XG4gICAgY29uc3Qgc2l6ZXMgPSBbXTtcbiAgICBjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlciA9IG5ldyBCdWZmZXIuQnVmZmVyKCk7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzW2ldO1xuICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXJzW2F0dHJpYnV0ZS5idWZmZXJdO1xuICAgICAgYXJyYXlzLnB1c2goYnVmZmVyLmRhdGEpO1xuICAgICAgc2l6ZXMucHVzaChhdHRyaWJ1dGUuc2l6ZSAqIGJ5dGVTaXplTWFwW2F0dHJpYnV0ZS50eXBlXSAvIDQpO1xuICAgICAgYXR0cmlidXRlLmJ1ZmZlciA9IDA7XG4gICAgfVxuICAgIGludGVybGVhdmVkQnVmZmVyLmRhdGEgPSBpbnRlcmxlYXZlVHlwZWRBcnJheXMuaW50ZXJsZWF2ZVR5cGVkQXJyYXlzKGFycmF5cywgc2l6ZXMpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmJ1ZmZlcnNbaV0gIT09IHRoaXMuaW5kZXhCdWZmZXIpIHtcbiAgICAgICAgdGhpcy5idWZmZXJzW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5idWZmZXJzID0gW2ludGVybGVhdmVkQnVmZmVyXTtcbiAgICBpZiAodGhpcy5pbmRleEJ1ZmZlcikge1xuICAgICAgdGhpcy5idWZmZXJzLnB1c2godGhpcy5pbmRleEJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldFNpemUoKSB7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzW2ldO1xuICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXJzW2F0dHJpYnV0ZS5idWZmZXJdO1xuICAgICAgcmV0dXJuIGJ1ZmZlci5kYXRhLmxlbmd0aCAvIChhdHRyaWJ1dGUuc3RyaWRlIC8gNCB8fCBhdHRyaWJ1dGUuc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5kaXNwb3NlUnVubmVyLmVtaXQodGhpcywgZmFsc2UpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgdGhpcy5idWZmZXJzID0gbnVsbDtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBudWxsO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGdlb21ldHJ5LmJ1ZmZlcnNbaV0gPSBuZXcgQnVmZmVyLkJ1ZmZlcih0aGlzLmJ1ZmZlcnNbaV0uZGF0YS5zbGljZSgwKSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYiA9IHRoaXMuYXR0cmlidXRlc1tpXTtcbiAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXNbaV0gPSBuZXcgQXR0cmlidXRlLkF0dHJpYnV0ZShhdHRyaWIuYnVmZmVyLCBhdHRyaWIuc2l6ZSwgYXR0cmliLm5vcm1hbGl6ZWQsIGF0dHJpYi50eXBlLCBhdHRyaWIuc3RyaWRlLCBhdHRyaWIuc3RhcnQsIGF0dHJpYi5pbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmluZGV4QnVmZmVyKSB7XG4gICAgICBnZW9tZXRyeS5pbmRleEJ1ZmZlciA9IGdlb21ldHJ5LmJ1ZmZlcnNbdGhpcy5idWZmZXJzLmluZGV4T2YodGhpcy5pbmRleEJ1ZmZlcildO1xuICAgICAgZ2VvbWV0cnkuaW5kZXhCdWZmZXIudHlwZSA9IGNvbnN0YW50cy5CVUZGRVJfVFlQRS5FTEVNRU5UX0FSUkFZX0JVRkZFUjtcbiAgICB9XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG4gIHN0YXRpYyBtZXJnZShnZW9tZXRyaWVzKSB7XG4gICAgY29uc3QgZ2VvbWV0cnlPdXQgPSBuZXcgR2VvbWV0cnkoKTtcbiAgICBjb25zdCBhcnJheXMgPSBbXTtcbiAgICBjb25zdCBzaXplcyA9IFtdO1xuICAgIGNvbnN0IG9mZnNldHMgPSBbXTtcbiAgICBsZXQgZ2VvbWV0cnk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBnZW9tZXRyeSA9IGdlb21ldHJpZXNbaV07XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc2l6ZXNbal0gPSBzaXplc1tqXSB8fCAwO1xuICAgICAgICBzaXplc1tqXSArPSBnZW9tZXRyeS5idWZmZXJzW2pdLmRhdGEubGVuZ3RoO1xuICAgICAgICBvZmZzZXRzW2pdID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tZXRyeS5idWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnJheXNbaV0gPSBuZXcgbWFwW3V0aWxzLmdldEJ1ZmZlclR5cGUoZ2VvbWV0cnkuYnVmZmVyc1tpXS5kYXRhKV0oc2l6ZXNbaV0pO1xuICAgICAgZ2VvbWV0cnlPdXQuYnVmZmVyc1tpXSA9IG5ldyBCdWZmZXIuQnVmZmVyKGFycmF5c1tpXSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzW2ldO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBnZW9tZXRyeS5idWZmZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGFycmF5c1tqXS5zZXQoZ2VvbWV0cnkuYnVmZmVyc1tqXS5kYXRhLCBvZmZzZXRzW2pdKTtcbiAgICAgICAgb2Zmc2V0c1tqXSArPSBnZW9tZXRyeS5idWZmZXJzW2pdLmRhdGEubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW9tZXRyeU91dC5hdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICBpZiAoZ2VvbWV0cnkuaW5kZXhCdWZmZXIpIHtcbiAgICAgIGdlb21ldHJ5T3V0LmluZGV4QnVmZmVyID0gZ2VvbWV0cnlPdXQuYnVmZmVyc1tnZW9tZXRyeS5idWZmZXJzLmluZGV4T2YoZ2VvbWV0cnkuaW5kZXhCdWZmZXIpXTtcbiAgICAgIGdlb21ldHJ5T3V0LmluZGV4QnVmZmVyLnR5cGUgPSBjb25zdGFudHMuQlVGRkVSX1RZUEUuRUxFTUVOVF9BUlJBWV9CVUZGRVI7XG4gICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgIGxldCBzdHJpZGUgPSAwO1xuICAgICAgbGV0IG9mZnNldDIgPSAwO1xuICAgICAgbGV0IGJ1ZmZlckluZGV4VG9Db3VudCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGdlb21ldHJ5LmJ1ZmZlcnNbaV0gIT09IGdlb21ldHJ5LmluZGV4QnVmZmVyKSB7XG4gICAgICAgICAgYnVmZmVySW5kZXhUb0NvdW50ID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBpIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlc1tpXTtcbiAgICAgICAgaWYgKChhdHRyaWJ1dGUuYnVmZmVyIHwgMCkgPT09IGJ1ZmZlckluZGV4VG9Db3VudCkge1xuICAgICAgICAgIHN0cmlkZSArPSBhdHRyaWJ1dGUuc2l6ZSAqIGJ5dGVTaXplTWFwW2F0dHJpYnV0ZS50eXBlXSAvIDQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpbmRleEJ1ZmZlckRhdGEgPSBnZW9tZXRyaWVzW2ldLmluZGV4QnVmZmVyLmRhdGE7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5kZXhCdWZmZXJEYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZ2VvbWV0cnlPdXQuaW5kZXhCdWZmZXIuZGF0YVtqICsgb2Zmc2V0Ml0gKz0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBnZW9tZXRyaWVzW2ldLmJ1ZmZlcnNbYnVmZmVySW5kZXhUb0NvdW50XS5kYXRhLmxlbmd0aCAvIHN0cmlkZTtcbiAgICAgICAgb2Zmc2V0MiArPSBpbmRleEJ1ZmZlckRhdGEubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VvbWV0cnlPdXQ7XG4gIH1cbn1cblxuZXhwb3J0cy5HZW9tZXRyeSA9IEdlb21ldHJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2VvbWV0cnkuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCdAcGl4aS9jb25zdGFudHMnKTtcbnZhciBleHRlbnNpb25zID0gcmVxdWlyZSgnQHBpeGkvZXh0ZW5zaW9ucycpO1xudmFyIHNldHRpbmdzID0gcmVxdWlyZSgnQHBpeGkvc2V0dGluZ3MnKTtcblxuY29uc3QgYnl0ZVNpemVNYXAgPSB7IDUxMjY6IDQsIDUxMjM6IDIsIDUxMjE6IDEgfTtcbmNsYXNzIEdlb21ldHJ5U3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5fYWN0aXZlR2VvbWV0cnkgPSBudWxsO1xuICAgIHRoaXMuX2FjdGl2ZVZhbyA9IG51bGw7XG4gICAgdGhpcy5oYXNWYW8gPSB0cnVlO1xuICAgIHRoaXMuaGFzSW5zdGFuY2UgPSB0cnVlO1xuICAgIHRoaXMuY2FuVXNlVUludDMyRWxlbWVudEluZGV4ID0gZmFsc2U7XG4gICAgdGhpcy5tYW5hZ2VkR2VvbWV0cmllcyA9IHt9O1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoKSB7XG4gICAgdGhpcy5kaXNwb3NlQWxsKHRydWUpO1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMucmVuZGVyZXIuY29udGV4dDtcbiAgICB0aGlzLkNPTlRFWFRfVUlEID0gdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRDtcbiAgICBpZiAoY29udGV4dC53ZWJHTFZlcnNpb24gIT09IDIpIHtcbiAgICAgIGxldCBuYXRpdmVWYW9FeHRlbnNpb24gPSB0aGlzLnJlbmRlcmVyLmNvbnRleHQuZXh0ZW5zaW9ucy52ZXJ0ZXhBcnJheU9iamVjdDtcbiAgICAgIGlmIChzZXR0aW5ncy5zZXR0aW5ncy5QUkVGRVJfRU5WID09PSBjb25zdGFudHMuRU5WLldFQkdMX0xFR0FDWSkge1xuICAgICAgICBuYXRpdmVWYW9FeHRlbnNpb24gPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKG5hdGl2ZVZhb0V4dGVuc2lvbikge1xuICAgICAgICBnbC5jcmVhdGVWZXJ0ZXhBcnJheSA9ICgpID0+IG5hdGl2ZVZhb0V4dGVuc2lvbi5jcmVhdGVWZXJ0ZXhBcnJheU9FUygpO1xuICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkgPSAodmFvKSA9PiBuYXRpdmVWYW9FeHRlbnNpb24uYmluZFZlcnRleEFycmF5T0VTKHZhbyk7XG4gICAgICAgIGdsLmRlbGV0ZVZlcnRleEFycmF5ID0gKHZhbykgPT4gbmF0aXZlVmFvRXh0ZW5zaW9uLmRlbGV0ZVZlcnRleEFycmF5T0VTKHZhbyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhc1ZhbyA9IGZhbHNlO1xuICAgICAgICBnbC5jcmVhdGVWZXJ0ZXhBcnJheSA9ICgpID0+IG51bGw7XG4gICAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSA9ICgpID0+IG51bGw7XG4gICAgICAgIGdsLmRlbGV0ZVZlcnRleEFycmF5ID0gKCkgPT4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRleHQud2ViR0xWZXJzaW9uICE9PSAyKSB7XG4gICAgICBjb25zdCBpbnN0YW5jZUV4dCA9IGdsLmdldEV4dGVuc2lvbihcIkFOR0xFX2luc3RhbmNlZF9hcnJheXNcIik7XG4gICAgICBpZiAoaW5zdGFuY2VFeHQpIHtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvciA9IChhLCBiKSA9PiBpbnN0YW5jZUV4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoYSwgYik7XG4gICAgICAgIGdsLmRyYXdFbGVtZW50c0luc3RhbmNlZCA9IChhLCBiLCBjLCBkLCBlKSA9PiBpbnN0YW5jZUV4dC5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRShhLCBiLCBjLCBkLCBlKTtcbiAgICAgICAgZ2wuZHJhd0FycmF5c0luc3RhbmNlZCA9IChhLCBiLCBjLCBkKSA9PiBpbnN0YW5jZUV4dC5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoYSwgYiwgYywgZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhc0luc3RhbmNlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2FuVXNlVUludDMyRWxlbWVudEluZGV4ID0gY29udGV4dC53ZWJHTFZlcnNpb24gPT09IDIgfHwgISFjb250ZXh0LmV4dGVuc2lvbnMudWludDMyRWxlbWVudEluZGV4O1xuICB9XG4gIGJpbmQoZ2VvbWV0cnksIHNoYWRlcikge1xuICAgIHNoYWRlciA9IHNoYWRlciB8fCB0aGlzLnJlbmRlcmVyLnNoYWRlci5zaGFkZXI7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcztcbiAgICBsZXQgdmFvcyA9IGdlb21ldHJ5LmdsVmVydGV4QXJyYXlPYmplY3RzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgIGxldCBpbmNSZWZDb3VudCA9IGZhbHNlO1xuICAgIGlmICghdmFvcykge1xuICAgICAgdGhpcy5tYW5hZ2VkR2VvbWV0cmllc1tnZW9tZXRyeS5pZF0gPSBnZW9tZXRyeTtcbiAgICAgIGdlb21ldHJ5LmRpc3Bvc2VSdW5uZXIuYWRkKHRoaXMpO1xuICAgICAgZ2VvbWV0cnkuZ2xWZXJ0ZXhBcnJheU9iamVjdHNbdGhpcy5DT05URVhUX1VJRF0gPSB2YW9zID0ge307XG4gICAgICBpbmNSZWZDb3VudCA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbyA9IHZhb3Nbc2hhZGVyLnByb2dyYW0uaWRdIHx8IHRoaXMuaW5pdEdlb21ldHJ5VmFvKGdlb21ldHJ5LCBzaGFkZXIsIGluY1JlZkNvdW50KTtcbiAgICB0aGlzLl9hY3RpdmVHZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgIGlmICh0aGlzLl9hY3RpdmVWYW8gIT09IHZhbykge1xuICAgICAgdGhpcy5fYWN0aXZlVmFvID0gdmFvO1xuICAgICAgaWYgKHRoaXMuaGFzVmFvKSB7XG4gICAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSh2YW8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZVZhbyhnZW9tZXRyeSwgc2hhZGVyLnByb2dyYW0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUJ1ZmZlcnMoKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnVuYmluZCgpO1xuICB9XG4gIHVwZGF0ZUJ1ZmZlcnMoKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLl9hY3RpdmVHZW9tZXRyeTtcbiAgICBjb25zdCBidWZmZXJTeXN0ZW0gPSB0aGlzLnJlbmRlcmVyLmJ1ZmZlcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGdlb21ldHJ5LmJ1ZmZlcnNbaV07XG4gICAgICBidWZmZXJTeXN0ZW0udXBkYXRlKGJ1ZmZlcik7XG4gICAgfVxuICB9XG4gIGNoZWNrQ29tcGF0aWJpbGl0eShnZW9tZXRyeSwgcHJvZ3JhbSkge1xuICAgIGNvbnN0IGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgY29uc3Qgc2hhZGVyQXR0cmlidXRlcyA9IHByb2dyYW0uYXR0cmlidXRlRGF0YTtcbiAgICBmb3IgKGNvbnN0IGogaW4gc2hhZGVyQXR0cmlidXRlcykge1xuICAgICAgaWYgKCFnZW9tZXRyeUF0dHJpYnV0ZXNbal0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaGFkZXIgYW5kIGdlb21ldHJ5IGluY29tcGF0aWJsZSwgZ2VvbWV0cnkgbWlzc2luZyB0aGUgXCIke2p9XCIgYXR0cmlidXRlYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldFNpZ25hdHVyZShnZW9tZXRyeSwgcHJvZ3JhbSkge1xuICAgIGNvbnN0IGF0dHJpYnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IHNoYWRlckF0dHJpYnV0ZXMgPSBwcm9ncmFtLmF0dHJpYnV0ZURhdGE7XG4gICAgY29uc3Qgc3RyaW5ncyA9IFtcImdcIiwgZ2VvbWV0cnkuaWRdO1xuICAgIGZvciAoY29uc3QgaSBpbiBhdHRyaWJzKSB7XG4gICAgICBpZiAoc2hhZGVyQXR0cmlidXRlc1tpXSkge1xuICAgICAgICBzdHJpbmdzLnB1c2goaSwgc2hhZGVyQXR0cmlidXRlc1tpXS5sb2NhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdzLmpvaW4oXCItXCIpO1xuICB9XG4gIGluaXRHZW9tZXRyeVZhbyhnZW9tZXRyeSwgc2hhZGVyLCBpbmNSZWZDb3VudCA9IHRydWUpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgY29uc3QgQ09OVEVYVF9VSUQgPSB0aGlzLkNPTlRFWFRfVUlEO1xuICAgIGNvbnN0IGJ1ZmZlclN5c3RlbSA9IHRoaXMucmVuZGVyZXIuYnVmZmVyO1xuICAgIGNvbnN0IHByb2dyYW0gPSBzaGFkZXIucHJvZ3JhbTtcbiAgICBpZiAoIXByb2dyYW0uZ2xQcm9ncmFtc1tDT05URVhUX1VJRF0pIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuc2hhZGVyLmdlbmVyYXRlUHJvZ3JhbShzaGFkZXIpO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrQ29tcGF0aWJpbGl0eShnZW9tZXRyeSwgcHJvZ3JhbSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gdGhpcy5nZXRTaWduYXR1cmUoZ2VvbWV0cnksIHByb2dyYW0pO1xuICAgIGNvbnN0IHZhb09iamVjdEhhc2ggPSBnZW9tZXRyeS5nbFZlcnRleEFycmF5T2JqZWN0c1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICBsZXQgdmFvID0gdmFvT2JqZWN0SGFzaFtzaWduYXR1cmVdO1xuICAgIGlmICh2YW8pIHtcbiAgICAgIHZhb09iamVjdEhhc2hbcHJvZ3JhbS5pZF0gPSB2YW87XG4gICAgICByZXR1cm4gdmFvO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJzID0gZ2VvbWV0cnkuYnVmZmVycztcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICBjb25zdCB0ZW1wU3RyaWRlID0ge307XG4gICAgY29uc3QgdGVtcFN0YXJ0ID0ge307XG4gICAgZm9yIChjb25zdCBqIGluIGJ1ZmZlcnMpIHtcbiAgICAgIHRlbXBTdHJpZGVbal0gPSAwO1xuICAgICAgdGVtcFN0YXJ0W2pdID0gMDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBqIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICghYXR0cmlidXRlc1tqXS5zaXplICYmIHByb2dyYW0uYXR0cmlidXRlRGF0YVtqXSkge1xuICAgICAgICBhdHRyaWJ1dGVzW2pdLnNpemUgPSBwcm9ncmFtLmF0dHJpYnV0ZURhdGFbal0uc2l6ZTtcbiAgICAgIH0gZWxzZSBpZiAoIWF0dHJpYnV0ZXNbal0uc2l6ZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFBJWEkgR2VvbWV0cnkgYXR0cmlidXRlICcke2p9JyBzaXplIGNhbm5vdCBiZSBkZXRlcm1pbmVkIChsaWtlbHkgdGhlIGJvdW5kIHNoYWRlciBkb2VzIG5vdCBoYXZlIHRoZSBhdHRyaWJ1dGUpYCk7XG4gICAgICB9XG4gICAgICB0ZW1wU3RyaWRlW2F0dHJpYnV0ZXNbal0uYnVmZmVyXSArPSBhdHRyaWJ1dGVzW2pdLnNpemUgKiBieXRlU2l6ZU1hcFthdHRyaWJ1dGVzW2pdLnR5cGVdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGogaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tqXTtcbiAgICAgIGNvbnN0IGF0dHJpYlNpemUgPSBhdHRyaWJ1dGUuc2l6ZTtcbiAgICAgIGlmIChhdHRyaWJ1dGUuc3RyaWRlID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHRlbXBTdHJpZGVbYXR0cmlidXRlLmJ1ZmZlcl0gPT09IGF0dHJpYlNpemUgKiBieXRlU2l6ZU1hcFthdHRyaWJ1dGUudHlwZV0pIHtcbiAgICAgICAgICBhdHRyaWJ1dGUuc3RyaWRlID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRyaWJ1dGUuc3RyaWRlID0gdGVtcFN0cmlkZVthdHRyaWJ1dGUuYnVmZmVyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZS5zdGFydCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGF0dHJpYnV0ZS5zdGFydCA9IHRlbXBTdGFydFthdHRyaWJ1dGUuYnVmZmVyXTtcbiAgICAgICAgdGVtcFN0YXJ0W2F0dHJpYnV0ZS5idWZmZXJdICs9IGF0dHJpYlNpemUgKiBieXRlU2l6ZU1hcFthdHRyaWJ1dGUudHlwZV07XG4gICAgICB9XG4gICAgfVxuICAgIHZhbyA9IGdsLmNyZWF0ZVZlcnRleEFycmF5KCk7XG4gICAgZ2wuYmluZFZlcnRleEFycmF5KHZhbyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJzW2ldO1xuICAgICAgYnVmZmVyU3lzdGVtLmJpbmQoYnVmZmVyKTtcbiAgICAgIGlmIChpbmNSZWZDb3VudCkge1xuICAgICAgICBidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF0ucmVmQ291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hY3RpdmF0ZVZhbyhnZW9tZXRyeSwgcHJvZ3JhbSk7XG4gICAgdmFvT2JqZWN0SGFzaFtwcm9ncmFtLmlkXSA9IHZhbztcbiAgICB2YW9PYmplY3RIYXNoW3NpZ25hdHVyZV0gPSB2YW87XG4gICAgZ2wuYmluZFZlcnRleEFycmF5KG51bGwpO1xuICAgIGJ1ZmZlclN5c3RlbS51bmJpbmQoY29uc3RhbnRzLkJVRkZFUl9UWVBFLkFSUkFZX0JVRkZFUik7XG4gICAgcmV0dXJuIHZhbztcbiAgfVxuICBkaXNwb3NlR2VvbWV0cnkoZ2VvbWV0cnksIGNvbnRleHRMb3N0KSB7XG4gICAgaWYgKCF0aGlzLm1hbmFnZWRHZW9tZXRyaWVzW2dlb21ldHJ5LmlkXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5tYW5hZ2VkR2VvbWV0cmllc1tnZW9tZXRyeS5pZF07XG4gICAgY29uc3QgdmFvcyA9IGdlb21ldHJ5LmdsVmVydGV4QXJyYXlPYmplY3RzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBjb25zdCBidWZmZXJzID0gZ2VvbWV0cnkuYnVmZmVycztcbiAgICBjb25zdCBidWZmZXJTeXN0ZW0gPSB0aGlzLnJlbmRlcmVyPy5idWZmZXI7XG4gICAgZ2VvbWV0cnkuZGlzcG9zZVJ1bm5lci5yZW1vdmUodGhpcyk7XG4gICAgaWYgKCF2YW9zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChidWZmZXJTeXN0ZW0pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBidWYgPSBidWZmZXJzW2ldLl9nbEJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgICAgIGlmIChidWYpIHtcbiAgICAgICAgICBidWYucmVmQ291bnQtLTtcbiAgICAgICAgICBpZiAoYnVmLnJlZkNvdW50ID09PSAwICYmICFjb250ZXh0TG9zdCkge1xuICAgICAgICAgICAgYnVmZmVyU3lzdGVtLmRpc3Bvc2UoYnVmZmVyc1tpXSwgY29udGV4dExvc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNvbnRleHRMb3N0KSB7XG4gICAgICBmb3IgKGNvbnN0IHZhb0lkIGluIHZhb3MpIHtcbiAgICAgICAgaWYgKHZhb0lkWzBdID09PSBcImdcIikge1xuICAgICAgICAgIGNvbnN0IHZhbyA9IHZhb3NbdmFvSWRdO1xuICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmVWYW8gPT09IHZhbykge1xuICAgICAgICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ2wuZGVsZXRlVmVydGV4QXJyYXkodmFvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUgZ2VvbWV0cnkuZ2xWZXJ0ZXhBcnJheU9iamVjdHNbdGhpcy5DT05URVhUX1VJRF07XG4gIH1cbiAgZGlzcG9zZUFsbChjb250ZXh0TG9zdCkge1xuICAgIGNvbnN0IGFsbCA9IE9iamVjdC5rZXlzKHRoaXMubWFuYWdlZEdlb21ldHJpZXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmRpc3Bvc2VHZW9tZXRyeSh0aGlzLm1hbmFnZWRHZW9tZXRyaWVzW2FsbFtpXV0sIGNvbnRleHRMb3N0KTtcbiAgICB9XG4gIH1cbiAgYWN0aXZhdGVWYW8oZ2VvbWV0cnksIHByb2dyYW0pIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgY29uc3QgQ09OVEVYVF9VSUQgPSB0aGlzLkNPTlRFWFRfVUlEO1xuICAgIGNvbnN0IGJ1ZmZlclN5c3RlbSA9IHRoaXMucmVuZGVyZXIuYnVmZmVyO1xuICAgIGNvbnN0IGJ1ZmZlcnMgPSBnZW9tZXRyeS5idWZmZXJzO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuICAgIGlmIChnZW9tZXRyeS5pbmRleEJ1ZmZlcikge1xuICAgICAgYnVmZmVyU3lzdGVtLmJpbmQoZ2VvbWV0cnkuaW5kZXhCdWZmZXIpO1xuICAgIH1cbiAgICBsZXQgbGFzdEJ1ZmZlciA9IG51bGw7XG4gICAgZm9yIChjb25zdCBqIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbal07XG4gICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJzW2F0dHJpYnV0ZS5idWZmZXJdO1xuICAgICAgY29uc3QgZ2xCdWZmZXIgPSBidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF07XG4gICAgICBpZiAocHJvZ3JhbS5hdHRyaWJ1dGVEYXRhW2pdKSB7XG4gICAgICAgIGlmIChsYXN0QnVmZmVyICE9PSBnbEJ1ZmZlcikge1xuICAgICAgICAgIGJ1ZmZlclN5c3RlbS5iaW5kKGJ1ZmZlcik7XG4gICAgICAgICAgbGFzdEJ1ZmZlciA9IGdsQnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhW2pdLmxvY2F0aW9uO1xuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbik7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobG9jYXRpb24sIGF0dHJpYnV0ZS5zaXplLCBhdHRyaWJ1dGUudHlwZSB8fCBnbC5GTE9BVCwgYXR0cmlidXRlLm5vcm1hbGl6ZWQsIGF0dHJpYnV0ZS5zdHJpZGUsIGF0dHJpYnV0ZS5zdGFydCk7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUuaW5zdGFuY2UpIHtcbiAgICAgICAgICBpZiAodGhpcy5oYXNJbnN0YW5jZSkge1xuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihsb2NhdGlvbiwgYXR0cmlidXRlLmRpdmlzb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZW9tZXRyeSBlcnJvciwgR1BVIEluc3RhbmNpbmcgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJhdyh0eXBlLCBzaXplLCBzdGFydCwgaW5zdGFuY2VDb3VudCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLl9hY3RpdmVHZW9tZXRyeTtcbiAgICBpZiAoZ2VvbWV0cnkuaW5kZXhCdWZmZXIpIHtcbiAgICAgIGNvbnN0IGJ5dGVTaXplID0gZ2VvbWV0cnkuaW5kZXhCdWZmZXIuZGF0YS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgIGNvbnN0IGdsVHlwZSA9IGJ5dGVTaXplID09PSAyID8gZ2wuVU5TSUdORURfU0hPUlQgOiBnbC5VTlNJR05FRF9JTlQ7XG4gICAgICBpZiAoYnl0ZVNpemUgPT09IDIgfHwgYnl0ZVNpemUgPT09IDQgJiYgdGhpcy5jYW5Vc2VVSW50MzJFbGVtZW50SW5kZXgpIHtcbiAgICAgICAgaWYgKGdlb21ldHJ5Lmluc3RhbmNlZCkge1xuICAgICAgICAgIGdsLmRyYXdFbGVtZW50c0luc3RhbmNlZCh0eXBlLCBzaXplIHx8IGdlb21ldHJ5LmluZGV4QnVmZmVyLmRhdGEubGVuZ3RoLCBnbFR5cGUsIChzdGFydCB8fCAwKSAqIGJ5dGVTaXplLCBpbnN0YW5jZUNvdW50IHx8IDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyh0eXBlLCBzaXplIHx8IGdlb21ldHJ5LmluZGV4QnVmZmVyLmRhdGEubGVuZ3RoLCBnbFR5cGUsIChzdGFydCB8fCAwKSAqIGJ5dGVTaXplKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwidW5zdXBwb3J0ZWQgaW5kZXggYnVmZmVyIHR5cGU6IHVpbnQzMlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdlb21ldHJ5Lmluc3RhbmNlZCkge1xuICAgICAgZ2wuZHJhd0FycmF5c0luc3RhbmNlZCh0eXBlLCBzdGFydCwgc2l6ZSB8fCBnZW9tZXRyeS5nZXRTaXplKCksIGluc3RhbmNlQ291bnQgfHwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmRyYXdBcnJheXModHlwZSwgc3RhcnQsIHNpemUgfHwgZ2VvbWV0cnkuZ2V0U2l6ZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdW5iaW5kKCkge1xuICAgIHRoaXMuZ2wuYmluZFZlcnRleEFycmF5KG51bGwpO1xuICAgIHRoaXMuX2FjdGl2ZVZhbyA9IG51bGw7XG4gICAgdGhpcy5fYWN0aXZlR2VvbWV0cnkgPSBudWxsO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbkdlb21ldHJ5U3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcImdlb21ldHJ5XCJcbn07XG5leHRlbnNpb25zLmV4dGVuc2lvbnMuYWRkKEdlb21ldHJ5U3lzdGVtKTtcblxuZXhwb3J0cy5HZW9tZXRyeVN5c3RlbSA9IEdlb21ldHJ5U3lzdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2VvbWV0cnlTeXN0ZW0uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNsYXNzIFZpZXdhYmxlQnVmZmVyIHtcbiAgY29uc3RydWN0b3Ioc2l6ZU9yQnVmZmVyKSB7XG4gICAgaWYgKHR5cGVvZiBzaXplT3JCdWZmZXIgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRoaXMucmF3QmluYXJ5RGF0YSA9IG5ldyBBcnJheUJ1ZmZlcihzaXplT3JCdWZmZXIpO1xuICAgIH0gZWxzZSBpZiAoc2l6ZU9yQnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgdGhpcy5yYXdCaW5hcnlEYXRhID0gc2l6ZU9yQnVmZmVyLmJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yYXdCaW5hcnlEYXRhID0gc2l6ZU9yQnVmZmVyO1xuICAgIH1cbiAgICB0aGlzLnVpbnQzMlZpZXcgPSBuZXcgVWludDMyQXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKTtcbiAgICB0aGlzLmZsb2F0MzJWaWV3ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnJhd0JpbmFyeURhdGEpO1xuICB9XG4gIGdldCBpbnQ4VmlldygpIHtcbiAgICBpZiAoIXRoaXMuX2ludDhWaWV3KSB7XG4gICAgICB0aGlzLl9pbnQ4VmlldyA9IG5ldyBJbnQ4QXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ludDhWaWV3O1xuICB9XG4gIGdldCB1aW50OFZpZXcoKSB7XG4gICAgaWYgKCF0aGlzLl91aW50OFZpZXcpIHtcbiAgICAgIHRoaXMuX3VpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl91aW50OFZpZXc7XG4gIH1cbiAgZ2V0IGludDE2VmlldygpIHtcbiAgICBpZiAoIXRoaXMuX2ludDE2Vmlldykge1xuICAgICAgdGhpcy5faW50MTZWaWV3ID0gbmV3IEludDE2QXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ludDE2VmlldztcbiAgfVxuICBnZXQgdWludDE2VmlldygpIHtcbiAgICBpZiAoIXRoaXMuX3VpbnQxNlZpZXcpIHtcbiAgICAgIHRoaXMuX3VpbnQxNlZpZXcgPSBuZXcgVWludDE2QXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3VpbnQxNlZpZXc7XG4gIH1cbiAgZ2V0IGludDMyVmlldygpIHtcbiAgICBpZiAoIXRoaXMuX2ludDMyVmlldykge1xuICAgICAgdGhpcy5faW50MzJWaWV3ID0gbmV3IEludDMyQXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ludDMyVmlldztcbiAgfVxuICB2aWV3KHR5cGUpIHtcbiAgICByZXR1cm4gdGhpc1tgJHt0eXBlfVZpZXdgXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmF3QmluYXJ5RGF0YSA9IG51bGw7XG4gICAgdGhpcy5faW50OFZpZXcgPSBudWxsO1xuICAgIHRoaXMuX3VpbnQ4VmlldyA9IG51bGw7XG4gICAgdGhpcy5faW50MTZWaWV3ID0gbnVsbDtcbiAgICB0aGlzLl91aW50MTZWaWV3ID0gbnVsbDtcbiAgICB0aGlzLl9pbnQzMlZpZXcgPSBudWxsO1xuICAgIHRoaXMudWludDMyVmlldyA9IG51bGw7XG4gICAgdGhpcy5mbG9hdDMyVmlldyA9IG51bGw7XG4gIH1cbiAgc3RhdGljIHNpemVPZih0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiaW50OFwiOlxuICAgICAgY2FzZSBcInVpbnQ4XCI6XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgY2FzZSBcImludDE2XCI6XG4gICAgICBjYXNlIFwidWludDE2XCI6XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgY2FzZSBcImludDMyXCI6XG4gICAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICBjYXNlIFwiZmxvYXQzMlwiOlxuICAgICAgICByZXR1cm4gNDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0eXBlfSBpc24ndCBhIHZhbGlkIHZpZXcgdHlwZWApO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLlZpZXdhYmxlQnVmZmVyID0gVmlld2FibGVCdWZmZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaWV3YWJsZUJ1ZmZlci5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnQHBpeGkvdXRpbHMnKTtcblxuY29uc3QgbWFwID0ge1xuICBGbG9hdDMyQXJyYXksXG4gIFVpbnQzMkFycmF5LFxuICBJbnQzMkFycmF5LFxuICBVaW50OEFycmF5XG59O1xuZnVuY3Rpb24gaW50ZXJsZWF2ZVR5cGVkQXJyYXlzKGFycmF5cywgc2l6ZXMpIHtcbiAgbGV0IG91dFNpemUgPSAwO1xuICBsZXQgc3RyaWRlID0gMDtcbiAgY29uc3Qgdmlld3MgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICBzdHJpZGUgKz0gc2l6ZXNbaV07XG4gICAgb3V0U2l6ZSArPSBhcnJheXNbaV0ubGVuZ3RoO1xuICB9XG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihvdXRTaXplICogNCk7XG4gIGxldCBvdXQgPSBudWxsO1xuICBsZXQgbGl0dGxlT2Zmc2V0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzaXplID0gc2l6ZXNbaV07XG4gICAgY29uc3QgYXJyYXkgPSBhcnJheXNbaV07XG4gICAgY29uc3QgdHlwZSA9IHV0aWxzLmdldEJ1ZmZlclR5cGUoYXJyYXkpO1xuICAgIGlmICghdmlld3NbdHlwZV0pIHtcbiAgICAgIHZpZXdzW3R5cGVdID0gbmV3IG1hcFt0eXBlXShidWZmZXIpO1xuICAgIH1cbiAgICBvdXQgPSB2aWV3c1t0eXBlXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBpbmRleFN0YXJ0ID0gKGogLyBzaXplIHwgMCkgKiBzdHJpZGUgKyBsaXR0bGVPZmZzZXQ7XG4gICAgICBjb25zdCBpbmRleCA9IGogJSBzaXplO1xuICAgICAgb3V0W2luZGV4U3RhcnQgKyBpbmRleF0gPSBhcnJheVtqXTtcbiAgICB9XG4gICAgbGl0dGxlT2Zmc2V0ICs9IHNpemU7XG4gIH1cbiAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcbn1cblxuZXhwb3J0cy5pbnRlcmxlYXZlVHlwZWRBcnJheXMgPSBpbnRlcmxlYXZlVHlwZWRBcnJheXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmxlYXZlVHlwZWRBcnJheXMuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnJlcXVpcmUoJy4vc2V0dGluZ3MuanMnKTtcbnZhciBjb2xvciA9IHJlcXVpcmUoJ0BwaXhpL2NvbG9yJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnQHBpeGkvY29uc3RhbnRzJyk7XG52YXIgZXh0ZW5zaW9ucyA9IHJlcXVpcmUoJ0BwaXhpL2V4dGVuc2lvbnMnKTtcbnZhciBtYXRoID0gcmVxdWlyZSgnQHBpeGkvbWF0aCcpO1xudmFyIHJ1bm5lciA9IHJlcXVpcmUoJ0BwaXhpL3J1bm5lcicpO1xudmFyIHNldHRpbmdzID0gcmVxdWlyZSgnQHBpeGkvc2V0dGluZ3MnKTtcbnZhciB0aWNrZXIgPSByZXF1aXJlKCdAcGl4aS90aWNrZXInKTtcbnZhciB1dGlscyQxID0gcmVxdWlyZSgnQHBpeGkvdXRpbHMnKTtcbnZhciBhdXRvRGV0ZWN0UmVuZGVyZXIgPSByZXF1aXJlKCcuL2F1dG9EZXRlY3RSZW5kZXJlci5qcycpO1xudmFyIEJhY2tncm91bmRTeXN0ZW0gPSByZXF1aXJlKCcuL2JhY2tncm91bmQvQmFja2dyb3VuZFN5c3RlbS5qcycpO1xudmFyIEJhdGNoRHJhd0NhbGwgPSByZXF1aXJlKCcuL2JhdGNoL0JhdGNoRHJhd0NhbGwuanMnKTtcbnZhciBCYXRjaEdlb21ldHJ5ID0gcmVxdWlyZSgnLi9iYXRjaC9CYXRjaEdlb21ldHJ5LmpzJyk7XG52YXIgQmF0Y2hSZW5kZXJlciA9IHJlcXVpcmUoJy4vYmF0Y2gvQmF0Y2hSZW5kZXJlci5qcycpO1xudmFyIEJhdGNoU2hhZGVyR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9iYXRjaC9CYXRjaFNoYWRlckdlbmVyYXRvci5qcycpO1xudmFyIEJhdGNoU3lzdGVtID0gcmVxdWlyZSgnLi9iYXRjaC9CYXRjaFN5c3RlbS5qcycpO1xudmFyIEJhdGNoVGV4dHVyZUFycmF5ID0gcmVxdWlyZSgnLi9iYXRjaC9CYXRjaFRleHR1cmVBcnJheS5qcycpO1xudmFyIE9iamVjdFJlbmRlcmVyID0gcmVxdWlyZSgnLi9iYXRjaC9PYmplY3RSZW5kZXJlci5qcycpO1xudmFyIENvbnRleHRTeXN0ZW0gPSByZXF1aXJlKCcuL2NvbnRleHQvQ29udGV4dFN5c3RlbS5qcycpO1xudmFyIEZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVycy9GaWx0ZXIuanMnKTtcbnZhciBGaWx0ZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZmlsdGVycy9GaWx0ZXJTdGF0ZS5qcycpO1xudmFyIEZpbHRlclN5c3RlbSA9IHJlcXVpcmUoJy4vZmlsdGVycy9GaWx0ZXJTeXN0ZW0uanMnKTtcbnJlcXVpcmUoJy4vZmlsdGVycy9JRmlsdGVyVGFyZ2V0LmpzJyk7XG52YXIgU3ByaXRlTWFza0ZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVycy9zcHJpdGVNYXNrL1Nwcml0ZU1hc2tGaWx0ZXIuanMnKTtcbnZhciBpbmRleCA9IHJlcXVpcmUoJy4vZnJhZ21lbnRzL2luZGV4LmpzJyk7XG52YXIgRnJhbWVidWZmZXIgPSByZXF1aXJlKCcuL2ZyYW1lYnVmZmVyL0ZyYW1lYnVmZmVyLmpzJyk7XG52YXIgRnJhbWVidWZmZXJTeXN0ZW0gPSByZXF1aXJlKCcuL2ZyYW1lYnVmZmVyL0ZyYW1lYnVmZmVyU3lzdGVtLmpzJyk7XG52YXIgR0xGcmFtZWJ1ZmZlciA9IHJlcXVpcmUoJy4vZnJhbWVidWZmZXIvR0xGcmFtZWJ1ZmZlci5qcycpO1xudmFyIE11bHRpc2FtcGxlU3lzdGVtID0gcmVxdWlyZSgnLi9mcmFtZWJ1ZmZlci9NdWx0aXNhbXBsZVN5c3RlbS5qcycpO1xudmFyIEF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vZ2VvbWV0cnkvQXR0cmlidXRlLmpzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9nZW9tZXRyeS9CdWZmZXIuanMnKTtcbnZhciBCdWZmZXJTeXN0ZW0gPSByZXF1aXJlKCcuL2dlb21ldHJ5L0J1ZmZlclN5c3RlbS5qcycpO1xudmFyIEdlb21ldHJ5ID0gcmVxdWlyZSgnLi9nZW9tZXRyeS9HZW9tZXRyeS5qcycpO1xudmFyIEdlb21ldHJ5U3lzdGVtID0gcmVxdWlyZSgnLi9nZW9tZXRyeS9HZW9tZXRyeVN5c3RlbS5qcycpO1xudmFyIFZpZXdhYmxlQnVmZmVyID0gcmVxdWlyZSgnLi9nZW9tZXRyeS9WaWV3YWJsZUJ1ZmZlci5qcycpO1xucmVxdWlyZSgnLi9JUmVuZGVyZXIuanMnKTtcbnZhciBNYXNrRGF0YSA9IHJlcXVpcmUoJy4vbWFzay9NYXNrRGF0YS5qcycpO1xudmFyIE1hc2tTeXN0ZW0gPSByZXF1aXJlKCcuL21hc2svTWFza1N5c3RlbS5qcycpO1xudmFyIFNjaXNzb3JTeXN0ZW0gPSByZXF1aXJlKCcuL21hc2svU2Npc3NvclN5c3RlbS5qcycpO1xudmFyIFN0ZW5jaWxTeXN0ZW0gPSByZXF1aXJlKCcuL21hc2svU3RlbmNpbFN5c3RlbS5qcycpO1xudmFyIFBsdWdpblN5c3RlbSA9IHJlcXVpcmUoJy4vcGx1Z2luL1BsdWdpblN5c3RlbS5qcycpO1xudmFyIFByb2plY3Rpb25TeXN0ZW0gPSByZXF1aXJlKCcuL3Byb2plY3Rpb24vUHJvamVjdGlvblN5c3RlbS5qcycpO1xudmFyIE9iamVjdFJlbmRlcmVyU3lzdGVtID0gcmVxdWlyZSgnLi9yZW5kZXIvT2JqZWN0UmVuZGVyZXJTeXN0ZW0uanMnKTtcbnZhciBSZW5kZXJlciA9IHJlcXVpcmUoJy4vUmVuZGVyZXIuanMnKTtcbnZhciBCYXNlUmVuZGVyVGV4dHVyZSA9IHJlcXVpcmUoJy4vcmVuZGVyVGV4dHVyZS9CYXNlUmVuZGVyVGV4dHVyZS5qcycpO1xudmFyIEdlbmVyYXRlVGV4dHVyZVN5c3RlbSA9IHJlcXVpcmUoJy4vcmVuZGVyVGV4dHVyZS9HZW5lcmF0ZVRleHR1cmVTeXN0ZW0uanMnKTtcbnZhciBSZW5kZXJUZXh0dXJlID0gcmVxdWlyZSgnLi9yZW5kZXJUZXh0dXJlL1JlbmRlclRleHR1cmUuanMnKTtcbnZhciBSZW5kZXJUZXh0dXJlUG9vbCA9IHJlcXVpcmUoJy4vcmVuZGVyVGV4dHVyZS9SZW5kZXJUZXh0dXJlUG9vbC5qcycpO1xudmFyIFJlbmRlclRleHR1cmVTeXN0ZW0gPSByZXF1aXJlKCcuL3JlbmRlclRleHR1cmUvUmVuZGVyVGV4dHVyZVN5c3RlbS5qcycpO1xudmFyIEdMUHJvZ3JhbSA9IHJlcXVpcmUoJy4vc2hhZGVyL0dMUHJvZ3JhbS5qcycpO1xudmFyIFByb2dyYW0gPSByZXF1aXJlKCcuL3NoYWRlci9Qcm9ncmFtLmpzJyk7XG52YXIgU2hhZGVyID0gcmVxdWlyZSgnLi9zaGFkZXIvU2hhZGVyLmpzJyk7XG52YXIgU2hhZGVyU3lzdGVtID0gcmVxdWlyZSgnLi9zaGFkZXIvU2hhZGVyU3lzdGVtLmpzJyk7XG52YXIgVW5pZm9ybUdyb3VwID0gcmVxdWlyZSgnLi9zaGFkZXIvVW5pZm9ybUdyb3VwLmpzJyk7XG52YXIgY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlciA9IHJlcXVpcmUoJy4vc2hhZGVyL3V0aWxzL2NoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIuanMnKTtcbnZhciBnZW5lcmF0ZVByb2dyYW0gPSByZXF1aXJlKCcuL3NoYWRlci91dGlscy9nZW5lcmF0ZVByb2dyYW0uanMnKTtcbnZhciBnZW5lcmF0ZVVuaWZvcm1CdWZmZXJTeW5jID0gcmVxdWlyZSgnLi9zaGFkZXIvdXRpbHMvZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYy5qcycpO1xudmFyIGdldFRlc3RDb250ZXh0ID0gcmVxdWlyZSgnLi9zaGFkZXIvdXRpbHMvZ2V0VGVzdENvbnRleHQuanMnKTtcbnZhciB1bmlmb3JtUGFyc2VycyA9IHJlcXVpcmUoJy4vc2hhZGVyL3V0aWxzL3VuaWZvcm1QYXJzZXJzLmpzJyk7XG52YXIgdW5zYWZlRXZhbFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vc2hhZGVyL3V0aWxzL3Vuc2FmZUV2YWxTdXBwb3J0ZWQuanMnKTtcbnZhciBTdGFydHVwU3lzdGVtID0gcmVxdWlyZSgnLi9zdGFydHVwL1N0YXJ0dXBTeXN0ZW0uanMnKTtcbnZhciBTdGF0ZSA9IHJlcXVpcmUoJy4vc3RhdGUvU3RhdGUuanMnKTtcbnZhciBTdGF0ZVN5c3RlbSA9IHJlcXVpcmUoJy4vc3RhdGUvU3RhdGVTeXN0ZW0uanMnKTtcbnJlcXVpcmUoJy4vc3lzdGVtL0lTeXN0ZW0uanMnKTtcbnJlcXVpcmUoJy4vc3lzdGVtcy5qcycpO1xudmFyIEJhc2VUZXh0dXJlID0gcmVxdWlyZSgnLi90ZXh0dXJlcy9CYXNlVGV4dHVyZS5qcycpO1xudmFyIEdMVGV4dHVyZSA9IHJlcXVpcmUoJy4vdGV4dHVyZXMvR0xUZXh0dXJlLmpzJyk7XG5yZXF1aXJlKCcuL3RleHR1cmVzL3Jlc291cmNlcy9pbmRleC5qcycpO1xudmFyIFRleHR1cmUgPSByZXF1aXJlKCcuL3RleHR1cmVzL1RleHR1cmUuanMnKTtcbnZhciBUZXh0dXJlR0NTeXN0ZW0gPSByZXF1aXJlKCcuL3RleHR1cmVzL1RleHR1cmVHQ1N5c3RlbS5qcycpO1xudmFyIFRleHR1cmVNYXRyaXggPSByZXF1aXJlKCcuL3RleHR1cmVzL1RleHR1cmVNYXRyaXguanMnKTtcbnZhciBUZXh0dXJlU3lzdGVtID0gcmVxdWlyZSgnLi90ZXh0dXJlcy9UZXh0dXJlU3lzdGVtLmpzJyk7XG52YXIgVGV4dHVyZVV2cyA9IHJlcXVpcmUoJy4vdGV4dHVyZXMvVGV4dHVyZVV2cy5qcycpO1xudmFyIFRyYW5zZm9ybUZlZWRiYWNrID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1GZWVkYmFjay9UcmFuc2Zvcm1GZWVkYmFjay5qcycpO1xudmFyIFRyYW5zZm9ybUZlZWRiYWNrU3lzdGVtID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1GZWVkYmFjay9UcmFuc2Zvcm1GZWVkYmFja1N5c3RlbS5qcycpO1xudmFyIFF1YWQgPSByZXF1aXJlKCcuL3V0aWxzL1F1YWQuanMnKTtcbnZhciBRdWFkVXYgPSByZXF1aXJlKCcuL3V0aWxzL1F1YWRVdi5qcycpO1xudmFyIFZpZXdTeXN0ZW0gPSByZXF1aXJlKCcuL3ZpZXcvVmlld1N5c3RlbS5qcycpO1xudmFyIFN5c3RlbU1hbmFnZXIgPSByZXF1aXJlKCcuL3N5c3RlbS9TeXN0ZW1NYW5hZ2VyLmpzJyk7XG52YXIgQmFzZUltYWdlUmVzb3VyY2UgPSByZXF1aXJlKCcuL3RleHR1cmVzL3Jlc291cmNlcy9CYXNlSW1hZ2VSZXNvdXJjZS5qcycpO1xudmFyIFJlc291cmNlID0gcmVxdWlyZSgnLi90ZXh0dXJlcy9yZXNvdXJjZXMvUmVzb3VyY2UuanMnKTtcbnZhciBBYnN0cmFjdE11bHRpUmVzb3VyY2UgPSByZXF1aXJlKCcuL3RleHR1cmVzL3Jlc291cmNlcy9BYnN0cmFjdE11bHRpUmVzb3VyY2UuanMnKTtcbnZhciBBcnJheVJlc291cmNlID0gcmVxdWlyZSgnLi90ZXh0dXJlcy9yZXNvdXJjZXMvQXJyYXlSZXNvdXJjZS5qcycpO1xudmFyIGF1dG9EZXRlY3RSZXNvdXJjZSA9IHJlcXVpcmUoJy4vdGV4dHVyZXMvcmVzb3VyY2VzL2F1dG9EZXRlY3RSZXNvdXJjZS5qcycpO1xudmFyIEJ1ZmZlclJlc291cmNlID0gcmVxdWlyZSgnLi90ZXh0dXJlcy9yZXNvdXJjZXMvQnVmZmVyUmVzb3VyY2UuanMnKTtcbnZhciBDYW52YXNSZXNvdXJjZSA9IHJlcXVpcmUoJy4vdGV4dHVyZXMvcmVzb3VyY2VzL0NhbnZhc1Jlc291cmNlLmpzJyk7XG52YXIgQ3ViZVJlc291cmNlID0gcmVxdWlyZSgnLi90ZXh0dXJlcy9yZXNvdXJjZXMvQ3ViZVJlc291cmNlLmpzJyk7XG52YXIgSW1hZ2VCaXRtYXBSZXNvdXJjZSA9IHJlcXVpcmUoJy4vdGV4dHVyZXMvcmVzb3VyY2VzL0ltYWdlQml0bWFwUmVzb3VyY2UuanMnKTtcbnZhciBJbWFnZVJlc291cmNlID0gcmVxdWlyZSgnLi90ZXh0dXJlcy9yZXNvdXJjZXMvSW1hZ2VSZXNvdXJjZS5qcycpO1xudmFyIFNWR1Jlc291cmNlID0gcmVxdWlyZSgnLi90ZXh0dXJlcy9yZXNvdXJjZXMvU1ZHUmVzb3VyY2UuanMnKTtcbnZhciBWaWRlb1Jlc291cmNlID0gcmVxdWlyZSgnLi90ZXh0dXJlcy9yZXNvdXJjZXMvVmlkZW9SZXNvdXJjZS5qcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG5cdGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG5cdHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0aWYgKGUpIHtcblx0XHRPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdFx0XHRpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG5cdFx0XHRcdHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXHRuW1wiZGVmYXVsdFwiXSA9IGU7XG5cdHJldHVybiBuO1xufVxuXG52YXIgdXRpbHNfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZSh1dGlscyQxKTtcblxuY29uc3QgVkVSU0lPTiA9IFwiNy4yLjRcIjtcblxuZXhwb3J0cy51dGlscyA9IHV0aWxzX19uYW1lc3BhY2U7XG5leHBvcnRzLmF1dG9EZXRlY3RSZW5kZXJlciA9IGF1dG9EZXRlY3RSZW5kZXJlci5hdXRvRGV0ZWN0UmVuZGVyZXI7XG5leHBvcnRzLkJhY2tncm91bmRTeXN0ZW0gPSBCYWNrZ3JvdW5kU3lzdGVtLkJhY2tncm91bmRTeXN0ZW07XG5leHBvcnRzLkJhdGNoRHJhd0NhbGwgPSBCYXRjaERyYXdDYWxsLkJhdGNoRHJhd0NhbGw7XG5leHBvcnRzLkJhdGNoR2VvbWV0cnkgPSBCYXRjaEdlb21ldHJ5LkJhdGNoR2VvbWV0cnk7XG5leHBvcnRzLkJhdGNoUmVuZGVyZXIgPSBCYXRjaFJlbmRlcmVyLkJhdGNoUmVuZGVyZXI7XG5leHBvcnRzLkJhdGNoU2hhZGVyR2VuZXJhdG9yID0gQmF0Y2hTaGFkZXJHZW5lcmF0b3IuQmF0Y2hTaGFkZXJHZW5lcmF0b3I7XG5leHBvcnRzLkJhdGNoU3lzdGVtID0gQmF0Y2hTeXN0ZW0uQmF0Y2hTeXN0ZW07XG5leHBvcnRzLkJhdGNoVGV4dHVyZUFycmF5ID0gQmF0Y2hUZXh0dXJlQXJyYXkuQmF0Y2hUZXh0dXJlQXJyYXk7XG5leHBvcnRzLk9iamVjdFJlbmRlcmVyID0gT2JqZWN0UmVuZGVyZXIuT2JqZWN0UmVuZGVyZXI7XG5leHBvcnRzLkNvbnRleHRTeXN0ZW0gPSBDb250ZXh0U3lzdGVtLkNvbnRleHRTeXN0ZW07XG5leHBvcnRzLkZpbHRlciA9IEZpbHRlci5GaWx0ZXI7XG5leHBvcnRzLkZpbHRlclN0YXRlID0gRmlsdGVyU3RhdGUuRmlsdGVyU3RhdGU7XG5leHBvcnRzLkZpbHRlclN5c3RlbSA9IEZpbHRlclN5c3RlbS5GaWx0ZXJTeXN0ZW07XG5leHBvcnRzLlNwcml0ZU1hc2tGaWx0ZXIgPSBTcHJpdGVNYXNrRmlsdGVyLlNwcml0ZU1hc2tGaWx0ZXI7XG5leHBvcnRzLmRlZmF1bHRGaWx0ZXJWZXJ0ZXggPSBpbmRleC5kZWZhdWx0RmlsdGVyVmVydGV4O1xuZXhwb3J0cy5kZWZhdWx0VmVydGV4ID0gaW5kZXguZGVmYXVsdFZlcnRleDtcbmV4cG9ydHMuRnJhbWVidWZmZXIgPSBGcmFtZWJ1ZmZlci5GcmFtZWJ1ZmZlcjtcbmV4cG9ydHMuRnJhbWVidWZmZXJTeXN0ZW0gPSBGcmFtZWJ1ZmZlclN5c3RlbS5GcmFtZWJ1ZmZlclN5c3RlbTtcbmV4cG9ydHMuR0xGcmFtZWJ1ZmZlciA9IEdMRnJhbWVidWZmZXIuR0xGcmFtZWJ1ZmZlcjtcbmV4cG9ydHMuTXVsdGlzYW1wbGVTeXN0ZW0gPSBNdWx0aXNhbXBsZVN5c3RlbS5NdWx0aXNhbXBsZVN5c3RlbTtcbmV4cG9ydHMuQXR0cmlidXRlID0gQXR0cmlidXRlLkF0dHJpYnV0ZTtcbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyLkJ1ZmZlcjtcbmV4cG9ydHMuQnVmZmVyU3lzdGVtID0gQnVmZmVyU3lzdGVtLkJ1ZmZlclN5c3RlbTtcbmV4cG9ydHMuR2VvbWV0cnkgPSBHZW9tZXRyeS5HZW9tZXRyeTtcbmV4cG9ydHMuR2VvbWV0cnlTeXN0ZW0gPSBHZW9tZXRyeVN5c3RlbS5HZW9tZXRyeVN5c3RlbTtcbmV4cG9ydHMuVmlld2FibGVCdWZmZXIgPSBWaWV3YWJsZUJ1ZmZlci5WaWV3YWJsZUJ1ZmZlcjtcbmV4cG9ydHMuTWFza0RhdGEgPSBNYXNrRGF0YS5NYXNrRGF0YTtcbmV4cG9ydHMuTWFza1N5c3RlbSA9IE1hc2tTeXN0ZW0uTWFza1N5c3RlbTtcbmV4cG9ydHMuU2Npc3NvclN5c3RlbSA9IFNjaXNzb3JTeXN0ZW0uU2Npc3NvclN5c3RlbTtcbmV4cG9ydHMuU3RlbmNpbFN5c3RlbSA9IFN0ZW5jaWxTeXN0ZW0uU3RlbmNpbFN5c3RlbTtcbmV4cG9ydHMuUGx1Z2luU3lzdGVtID0gUGx1Z2luU3lzdGVtLlBsdWdpblN5c3RlbTtcbmV4cG9ydHMuUHJvamVjdGlvblN5c3RlbSA9IFByb2plY3Rpb25TeXN0ZW0uUHJvamVjdGlvblN5c3RlbTtcbmV4cG9ydHMuT2JqZWN0UmVuZGVyZXJTeXN0ZW0gPSBPYmplY3RSZW5kZXJlclN5c3RlbS5PYmplY3RSZW5kZXJlclN5c3RlbTtcbmV4cG9ydHMuUmVuZGVyZXIgPSBSZW5kZXJlci5SZW5kZXJlcjtcbmV4cG9ydHMuQmFzZVJlbmRlclRleHR1cmUgPSBCYXNlUmVuZGVyVGV4dHVyZS5CYXNlUmVuZGVyVGV4dHVyZTtcbmV4cG9ydHMuR2VuZXJhdGVUZXh0dXJlU3lzdGVtID0gR2VuZXJhdGVUZXh0dXJlU3lzdGVtLkdlbmVyYXRlVGV4dHVyZVN5c3RlbTtcbmV4cG9ydHMuUmVuZGVyVGV4dHVyZSA9IFJlbmRlclRleHR1cmUuUmVuZGVyVGV4dHVyZTtcbmV4cG9ydHMuUmVuZGVyVGV4dHVyZVBvb2wgPSBSZW5kZXJUZXh0dXJlUG9vbC5SZW5kZXJUZXh0dXJlUG9vbDtcbmV4cG9ydHMuUmVuZGVyVGV4dHVyZVN5c3RlbSA9IFJlbmRlclRleHR1cmVTeXN0ZW0uUmVuZGVyVGV4dHVyZVN5c3RlbTtcbmV4cG9ydHMuR0xQcm9ncmFtID0gR0xQcm9ncmFtLkdMUHJvZ3JhbTtcbmV4cG9ydHMuSUdMVW5pZm9ybURhdGEgPSBHTFByb2dyYW0uSUdMVW5pZm9ybURhdGE7XG5leHBvcnRzLlByb2dyYW0gPSBQcm9ncmFtLlByb2dyYW07XG5leHBvcnRzLlNoYWRlciA9IFNoYWRlci5TaGFkZXI7XG5leHBvcnRzLlNoYWRlclN5c3RlbSA9IFNoYWRlclN5c3RlbS5TaGFkZXJTeXN0ZW07XG5leHBvcnRzLlVuaWZvcm1Hcm91cCA9IFVuaWZvcm1Hcm91cC5Vbmlmb3JtR3JvdXA7XG5leHBvcnRzLmNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIgPSBjaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyLmNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXI7XG5leHBvcnRzLmdlbmVyYXRlUHJvZ3JhbSA9IGdlbmVyYXRlUHJvZ3JhbS5nZW5lcmF0ZVByb2dyYW07XG5leHBvcnRzLmNyZWF0ZVVCT0VsZW1lbnRzID0gZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYy5jcmVhdGVVQk9FbGVtZW50cztcbmV4cG9ydHMuZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYyA9IGdlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMuZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYztcbmV4cG9ydHMuZ2V0VUJPRGF0YSA9IGdlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMuZ2V0VUJPRGF0YTtcbmV4cG9ydHMuZ2V0VGVzdENvbnRleHQgPSBnZXRUZXN0Q29udGV4dC5nZXRUZXN0Q29udGV4dDtcbmV4cG9ydHMudW5pZm9ybVBhcnNlcnMgPSB1bmlmb3JtUGFyc2Vycy51bmlmb3JtUGFyc2VycztcbmV4cG9ydHMudW5zYWZlRXZhbFN1cHBvcnRlZCA9IHVuc2FmZUV2YWxTdXBwb3J0ZWQudW5zYWZlRXZhbFN1cHBvcnRlZDtcbmV4cG9ydHMuU3RhcnR1cFN5c3RlbSA9IFN0YXJ0dXBTeXN0ZW0uU3RhcnR1cFN5c3RlbTtcbmV4cG9ydHMuU3RhdGUgPSBTdGF0ZS5TdGF0ZTtcbmV4cG9ydHMuU3RhdGVTeXN0ZW0gPSBTdGF0ZVN5c3RlbS5TdGF0ZVN5c3RlbTtcbmV4cG9ydHMuQmFzZVRleHR1cmUgPSBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZTtcbmV4cG9ydHMuR0xUZXh0dXJlID0gR0xUZXh0dXJlLkdMVGV4dHVyZTtcbmV4cG9ydHMuVGV4dHVyZSA9IFRleHR1cmUuVGV4dHVyZTtcbmV4cG9ydHMuVGV4dHVyZUdDU3lzdGVtID0gVGV4dHVyZUdDU3lzdGVtLlRleHR1cmVHQ1N5c3RlbTtcbmV4cG9ydHMuVGV4dHVyZU1hdHJpeCA9IFRleHR1cmVNYXRyaXguVGV4dHVyZU1hdHJpeDtcbmV4cG9ydHMuVGV4dHVyZVN5c3RlbSA9IFRleHR1cmVTeXN0ZW0uVGV4dHVyZVN5c3RlbTtcbmV4cG9ydHMuVGV4dHVyZVV2cyA9IFRleHR1cmVVdnMuVGV4dHVyZVV2cztcbmV4cG9ydHMuVHJhbnNmb3JtRmVlZGJhY2sgPSBUcmFuc2Zvcm1GZWVkYmFjay5UcmFuc2Zvcm1GZWVkYmFjaztcbmV4cG9ydHMuVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0gPSBUcmFuc2Zvcm1GZWVkYmFja1N5c3RlbS5UcmFuc2Zvcm1GZWVkYmFja1N5c3RlbTtcbmV4cG9ydHMuUXVhZCA9IFF1YWQuUXVhZDtcbmV4cG9ydHMuUXVhZFV2ID0gUXVhZFV2LlF1YWRVdjtcbmV4cG9ydHMuVmlld1N5c3RlbSA9IFZpZXdTeXN0ZW0uVmlld1N5c3RlbTtcbmV4cG9ydHMuU3lzdGVtTWFuYWdlciA9IFN5c3RlbU1hbmFnZXIuU3lzdGVtTWFuYWdlcjtcbmV4cG9ydHMuQmFzZUltYWdlUmVzb3VyY2UgPSBCYXNlSW1hZ2VSZXNvdXJjZS5CYXNlSW1hZ2VSZXNvdXJjZTtcbmV4cG9ydHMuUmVzb3VyY2UgPSBSZXNvdXJjZS5SZXNvdXJjZTtcbmV4cG9ydHMuQWJzdHJhY3RNdWx0aVJlc291cmNlID0gQWJzdHJhY3RNdWx0aVJlc291cmNlLkFic3RyYWN0TXVsdGlSZXNvdXJjZTtcbmV4cG9ydHMuQXJyYXlSZXNvdXJjZSA9IEFycmF5UmVzb3VyY2UuQXJyYXlSZXNvdXJjZTtcbmV4cG9ydHMuSU5TVEFMTEVEID0gYXV0b0RldGVjdFJlc291cmNlLklOU1RBTExFRDtcbmV4cG9ydHMuYXV0b0RldGVjdFJlc291cmNlID0gYXV0b0RldGVjdFJlc291cmNlLmF1dG9EZXRlY3RSZXNvdXJjZTtcbmV4cG9ydHMuQnVmZmVyUmVzb3VyY2UgPSBCdWZmZXJSZXNvdXJjZS5CdWZmZXJSZXNvdXJjZTtcbmV4cG9ydHMuQ2FudmFzUmVzb3VyY2UgPSBDYW52YXNSZXNvdXJjZS5DYW52YXNSZXNvdXJjZTtcbmV4cG9ydHMuQ3ViZVJlc291cmNlID0gQ3ViZVJlc291cmNlLkN1YmVSZXNvdXJjZTtcbmV4cG9ydHMuSW1hZ2VCaXRtYXBSZXNvdXJjZSA9IEltYWdlQml0bWFwUmVzb3VyY2UuSW1hZ2VCaXRtYXBSZXNvdXJjZTtcbmV4cG9ydHMuSW1hZ2VSZXNvdXJjZSA9IEltYWdlUmVzb3VyY2UuSW1hZ2VSZXNvdXJjZTtcbmV4cG9ydHMuU1ZHUmVzb3VyY2UgPSBTVkdSZXNvdXJjZS5TVkdSZXNvdXJjZTtcbmV4cG9ydHMuVmlkZW9SZXNvdXJjZSA9IFZpZGVvUmVzb3VyY2UuVmlkZW9SZXNvdXJjZTtcbmV4cG9ydHMuVkVSU0lPTiA9IFZFUlNJT047XG5PYmplY3Qua2V5cyhjb2xvcikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2xvcltrXTsgfVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoY29uc3RhbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkoaykpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c1trXTsgfVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZXh0ZW5zaW9ucykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleHRlbnNpb25zW2tdOyB9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhtYXRoKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkoaykpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhba107IH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKHJ1bm5lcikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBydW5uZXJba107IH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKHNldHRpbmdzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkoaykpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldHRpbmdzW2tdOyB9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyh0aWNrZXIpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShrKSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGlja2VyW2tdOyB9XG5cdH0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY2xhc3MgQWJzdHJhY3RNYXNrU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5tYXNrU3RhY2sgPSBbXTtcbiAgICB0aGlzLmdsQ29uc3QgPSAwO1xuICB9XG4gIGdldFN0YWNrTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLm1hc2tTdGFjay5sZW5ndGg7XG4gIH1cbiAgc2V0TWFza1N0YWNrKG1hc2tTdGFjaykge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3QgY3VyU3RhY2tMZW4gPSB0aGlzLmdldFN0YWNrTGVuZ3RoKCk7XG4gICAgdGhpcy5tYXNrU3RhY2sgPSBtYXNrU3RhY2s7XG4gICAgY29uc3QgbmV3U3RhY2tMZW4gPSB0aGlzLmdldFN0YWNrTGVuZ3RoKCk7XG4gICAgaWYgKG5ld1N0YWNrTGVuICE9PSBjdXJTdGFja0xlbikge1xuICAgICAgaWYgKG5ld1N0YWNrTGVuID09PSAwKSB7XG4gICAgICAgIGdsLmRpc2FibGUodGhpcy5nbENvbnN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLmVuYWJsZSh0aGlzLmdsQ29uc3QpO1xuICAgICAgICB0aGlzLl91c2VDdXJyZW50KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF91c2VDdXJyZW50KCkge1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5tYXNrU3RhY2sgPSBudWxsO1xuICB9XG59XG5cbmV4cG9ydHMuQWJzdHJhY3RNYXNrU3lzdGVtID0gQWJzdHJhY3RNYXNrU3lzdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJzdHJhY3RNYXNrU3lzdGVtLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnQHBpeGkvY29uc3RhbnRzJyk7XG52YXIgRmlsdGVyID0gcmVxdWlyZSgnLi4vZmlsdGVycy9GaWx0ZXIuanMnKTtcblxuY2xhc3MgTWFza0RhdGEge1xuICBjb25zdHJ1Y3RvcihtYXNrT2JqZWN0ID0gbnVsbCkge1xuICAgIHRoaXMudHlwZSA9IGNvbnN0YW50cy5NQVNLX1RZUEVTLk5PTkU7XG4gICAgdGhpcy5hdXRvRGV0ZWN0ID0gdHJ1ZTtcbiAgICB0aGlzLm1hc2tPYmplY3QgPSBtYXNrT2JqZWN0IHx8IG51bGw7XG4gICAgdGhpcy5wb29sZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzTWFza0RhdGEgPSB0cnVlO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IG51bGw7XG4gICAgdGhpcy5tdWx0aXNhbXBsZSA9IEZpbHRlci5GaWx0ZXIuZGVmYXVsdE11bHRpc2FtcGxlO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5jb2xvck1hc2sgPSAxNTtcbiAgICB0aGlzLl9maWx0ZXJzID0gbnVsbDtcbiAgICB0aGlzLl9zdGVuY2lsQ291bnRlciA9IDA7XG4gICAgdGhpcy5fc2Npc3NvckNvdW50ZXIgPSAwO1xuICAgIHRoaXMuX3NjaXNzb3JSZWN0ID0gbnVsbDtcbiAgICB0aGlzLl9zY2lzc29yUmVjdExvY2FsID0gbnVsbDtcbiAgICB0aGlzLl9jb2xvck1hc2sgPSAxNTtcbiAgICB0aGlzLl90YXJnZXQgPSBudWxsO1xuICB9XG4gIGdldCBmaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbHRlcnMgPyB0aGlzLl9maWx0ZXJzWzBdIDogbnVsbDtcbiAgfVxuICBzZXQgZmlsdGVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fZmlsdGVycykge1xuICAgICAgICB0aGlzLl9maWx0ZXJzWzBdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9maWx0ZXJzID0gW3ZhbHVlXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZmlsdGVycyA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLnBvb2xlZCkge1xuICAgICAgdGhpcy5tYXNrT2JqZWN0ID0gbnVsbDtcbiAgICAgIHRoaXMudHlwZSA9IGNvbnN0YW50cy5NQVNLX1RZUEVTLk5PTkU7XG4gICAgICB0aGlzLmF1dG9EZXRlY3QgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl90YXJnZXQgPSBudWxsO1xuICAgIHRoaXMuX3NjaXNzb3JSZWN0TG9jYWwgPSBudWxsO1xuICB9XG4gIGNvcHlDb3VudGVyc09yUmVzZXQobWFza0Fib3ZlKSB7XG4gICAgaWYgKG1hc2tBYm92ZSkge1xuICAgICAgdGhpcy5fc3RlbmNpbENvdW50ZXIgPSBtYXNrQWJvdmUuX3N0ZW5jaWxDb3VudGVyO1xuICAgICAgdGhpcy5fc2Npc3NvckNvdW50ZXIgPSBtYXNrQWJvdmUuX3NjaXNzb3JDb3VudGVyO1xuICAgICAgdGhpcy5fc2Npc3NvclJlY3QgPSBtYXNrQWJvdmUuX3NjaXNzb3JSZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdGVuY2lsQ291bnRlciA9IDA7XG4gICAgICB0aGlzLl9zY2lzc29yQ291bnRlciA9IDA7XG4gICAgICB0aGlzLl9zY2lzc29yUmVjdCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuTWFza0RhdGEgPSBNYXNrRGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hc2tEYXRhLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnQHBpeGkvY29uc3RhbnRzJyk7XG52YXIgZXh0ZW5zaW9ucyA9IHJlcXVpcmUoJ0BwaXhpL2V4dGVuc2lvbnMnKTtcbnZhciBTcHJpdGVNYXNrRmlsdGVyID0gcmVxdWlyZSgnLi4vZmlsdGVycy9zcHJpdGVNYXNrL1Nwcml0ZU1hc2tGaWx0ZXIuanMnKTtcbnZhciBNYXNrRGF0YSA9IHJlcXVpcmUoJy4vTWFza0RhdGEuanMnKTtcblxuY2xhc3MgTWFza1N5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMuZW5hYmxlU2Npc3NvciA9IHRydWU7XG4gICAgdGhpcy5hbHBoYU1hc2tQb29sID0gW107XG4gICAgdGhpcy5tYXNrRGF0YVBvb2wgPSBbXTtcbiAgICB0aGlzLm1hc2tTdGFjayA9IFtdO1xuICAgIHRoaXMuYWxwaGFNYXNrSW5kZXggPSAwO1xuICB9XG4gIHNldE1hc2tTdGFjayhtYXNrU3RhY2spIHtcbiAgICB0aGlzLm1hc2tTdGFjayA9IG1hc2tTdGFjaztcbiAgICB0aGlzLnJlbmRlcmVyLnNjaXNzb3Iuc2V0TWFza1N0YWNrKG1hc2tTdGFjayk7XG4gICAgdGhpcy5yZW5kZXJlci5zdGVuY2lsLnNldE1hc2tTdGFjayhtYXNrU3RhY2spO1xuICB9XG4gIHB1c2godGFyZ2V0LCBtYXNrRGF0YU9yVGFyZ2V0KSB7XG4gICAgbGV0IG1hc2tEYXRhID0gbWFza0RhdGFPclRhcmdldDtcbiAgICBpZiAoIW1hc2tEYXRhLmlzTWFza0RhdGEpIHtcbiAgICAgIGNvbnN0IGQgPSB0aGlzLm1hc2tEYXRhUG9vbC5wb3AoKSB8fCBuZXcgTWFza0RhdGEuTWFza0RhdGEoKTtcbiAgICAgIGQucG9vbGVkID0gdHJ1ZTtcbiAgICAgIGQubWFza09iamVjdCA9IG1hc2tEYXRhT3JUYXJnZXQ7XG4gICAgICBtYXNrRGF0YSA9IGQ7XG4gICAgfVxuICAgIGNvbnN0IG1hc2tBYm92ZSA9IHRoaXMubWFza1N0YWNrLmxlbmd0aCAhPT0gMCA/IHRoaXMubWFza1N0YWNrW3RoaXMubWFza1N0YWNrLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICBtYXNrRGF0YS5jb3B5Q291bnRlcnNPclJlc2V0KG1hc2tBYm92ZSk7XG4gICAgbWFza0RhdGEuX2NvbG9yTWFzayA9IG1hc2tBYm92ZSA/IG1hc2tBYm92ZS5fY29sb3JNYXNrIDogMTU7XG4gICAgaWYgKG1hc2tEYXRhLmF1dG9EZXRlY3QpIHtcbiAgICAgIHRoaXMuZGV0ZWN0KG1hc2tEYXRhKTtcbiAgICB9XG4gICAgbWFza0RhdGEuX3RhcmdldCA9IHRhcmdldDtcbiAgICBpZiAobWFza0RhdGEudHlwZSAhPT0gY29uc3RhbnRzLk1BU0tfVFlQRVMuU1BSSVRFKSB7XG4gICAgICB0aGlzLm1hc2tTdGFjay5wdXNoKG1hc2tEYXRhKTtcbiAgICB9XG4gICAgaWYgKG1hc2tEYXRhLmVuYWJsZWQpIHtcbiAgICAgIHN3aXRjaCAobWFza0RhdGEudHlwZSkge1xuICAgICAgICBjYXNlIGNvbnN0YW50cy5NQVNLX1RZUEVTLlNDSVNTT1I6XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5zY2lzc29yLnB1c2gobWFza0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGNvbnN0YW50cy5NQVNLX1RZUEVTLlNURU5DSUw6XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5zdGVuY2lsLnB1c2gobWFza0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGNvbnN0YW50cy5NQVNLX1RZUEVTLlNQUklURTpcbiAgICAgICAgICBtYXNrRGF0YS5jb3B5Q291bnRlcnNPclJlc2V0KG51bGwpO1xuICAgICAgICAgIHRoaXMucHVzaFNwcml0ZU1hc2sobWFza0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGNvbnN0YW50cy5NQVNLX1RZUEVTLkNPTE9SOlxuICAgICAgICAgIHRoaXMucHVzaENvbG9yTWFzayhtYXNrRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXNrRGF0YS50eXBlID09PSBjb25zdGFudHMuTUFTS19UWVBFUy5TUFJJVEUpIHtcbiAgICAgIHRoaXMubWFza1N0YWNrLnB1c2gobWFza0RhdGEpO1xuICAgIH1cbiAgfVxuICBwb3AodGFyZ2V0KSB7XG4gICAgY29uc3QgbWFza0RhdGEgPSB0aGlzLm1hc2tTdGFjay5wb3AoKTtcbiAgICBpZiAoIW1hc2tEYXRhIHx8IG1hc2tEYXRhLl90YXJnZXQgIT09IHRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWFza0RhdGEuZW5hYmxlZCkge1xuICAgICAgc3dpdGNoIChtYXNrRGF0YS50eXBlKSB7XG4gICAgICAgIGNhc2UgY29uc3RhbnRzLk1BU0tfVFlQRVMuU0NJU1NPUjpcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNjaXNzb3IucG9wKG1hc2tEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBjb25zdGFudHMuTUFTS19UWVBFUy5TVEVOQ0lMOlxuICAgICAgICAgIHRoaXMucmVuZGVyZXIuc3RlbmNpbC5wb3AobWFza0RhdGEubWFza09iamVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgY29uc3RhbnRzLk1BU0tfVFlQRVMuU1BSSVRFOlxuICAgICAgICAgIHRoaXMucG9wU3ByaXRlTWFzayhtYXNrRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgY29uc3RhbnRzLk1BU0tfVFlQRVMuQ09MT1I6XG4gICAgICAgICAgdGhpcy5wb3BDb2xvck1hc2sobWFza0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXNrRGF0YS5yZXNldCgpO1xuICAgIGlmIChtYXNrRGF0YS5wb29sZWQpIHtcbiAgICAgIHRoaXMubWFza0RhdGFQb29sLnB1c2gobWFza0RhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXNrU3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCBtYXNrQ3VycmVudCA9IHRoaXMubWFza1N0YWNrW3RoaXMubWFza1N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKG1hc2tDdXJyZW50LnR5cGUgPT09IGNvbnN0YW50cy5NQVNLX1RZUEVTLlNQUklURSAmJiBtYXNrQ3VycmVudC5fZmlsdGVycykge1xuICAgICAgICBtYXNrQ3VycmVudC5fZmlsdGVyc1swXS5tYXNrU3ByaXRlID0gbWFza0N1cnJlbnQubWFza09iamVjdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGV0ZWN0KG1hc2tEYXRhKSB7XG4gICAgY29uc3QgbWFza09iamVjdCA9IG1hc2tEYXRhLm1hc2tPYmplY3Q7XG4gICAgaWYgKCFtYXNrT2JqZWN0KSB7XG4gICAgICBtYXNrRGF0YS50eXBlID0gY29uc3RhbnRzLk1BU0tfVFlQRVMuQ09MT1I7XG4gICAgfSBlbHNlIGlmIChtYXNrT2JqZWN0LmlzU3ByaXRlKSB7XG4gICAgICBtYXNrRGF0YS50eXBlID0gY29uc3RhbnRzLk1BU0tfVFlQRVMuU1BSSVRFO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lbmFibGVTY2lzc29yICYmIHRoaXMucmVuZGVyZXIuc2Npc3Nvci50ZXN0U2Npc3NvcihtYXNrRGF0YSkpIHtcbiAgICAgIG1hc2tEYXRhLnR5cGUgPSBjb25zdGFudHMuTUFTS19UWVBFUy5TQ0lTU09SO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXNrRGF0YS50eXBlID0gY29uc3RhbnRzLk1BU0tfVFlQRVMuU1RFTkNJTDtcbiAgICB9XG4gIH1cbiAgcHVzaFNwcml0ZU1hc2sobWFza0RhdGEpIHtcbiAgICBjb25zdCB7IG1hc2tPYmplY3QgfSA9IG1hc2tEYXRhO1xuICAgIGNvbnN0IHRhcmdldCA9IG1hc2tEYXRhLl90YXJnZXQ7XG4gICAgbGV0IGFscGhhTWFza0ZpbHRlciA9IG1hc2tEYXRhLl9maWx0ZXJzO1xuICAgIGlmICghYWxwaGFNYXNrRmlsdGVyKSB7XG4gICAgICBhbHBoYU1hc2tGaWx0ZXIgPSB0aGlzLmFscGhhTWFza1Bvb2xbdGhpcy5hbHBoYU1hc2tJbmRleF07XG4gICAgICBpZiAoIWFscGhhTWFza0ZpbHRlcikge1xuICAgICAgICBhbHBoYU1hc2tGaWx0ZXIgPSB0aGlzLmFscGhhTWFza1Bvb2xbdGhpcy5hbHBoYU1hc2tJbmRleF0gPSBbbmV3IFNwcml0ZU1hc2tGaWx0ZXIuU3ByaXRlTWFza0ZpbHRlcigpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIGNvbnN0IHJlbmRlclRleHR1cmVTeXN0ZW0gPSByZW5kZXJlci5yZW5kZXJUZXh0dXJlO1xuICAgIGxldCByZXNvbHV0aW9uO1xuICAgIGxldCBtdWx0aXNhbXBsZTtcbiAgICBpZiAocmVuZGVyVGV4dHVyZVN5c3RlbS5jdXJyZW50KSB7XG4gICAgICBjb25zdCByZW5kZXJUZXh0dXJlID0gcmVuZGVyVGV4dHVyZVN5c3RlbS5jdXJyZW50O1xuICAgICAgcmVzb2x1dGlvbiA9IG1hc2tEYXRhLnJlc29sdXRpb24gfHwgcmVuZGVyVGV4dHVyZS5yZXNvbHV0aW9uO1xuICAgICAgbXVsdGlzYW1wbGUgPSBtYXNrRGF0YS5tdWx0aXNhbXBsZSA/PyByZW5kZXJUZXh0dXJlLm11bHRpc2FtcGxlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHV0aW9uID0gbWFza0RhdGEucmVzb2x1dGlvbiB8fCByZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgICAgbXVsdGlzYW1wbGUgPSBtYXNrRGF0YS5tdWx0aXNhbXBsZSA/PyByZW5kZXJlci5tdWx0aXNhbXBsZTtcbiAgICB9XG4gICAgYWxwaGFNYXNrRmlsdGVyWzBdLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgIGFscGhhTWFza0ZpbHRlclswXS5tdWx0aXNhbXBsZSA9IG11bHRpc2FtcGxlO1xuICAgIGFscGhhTWFza0ZpbHRlclswXS5tYXNrU3ByaXRlID0gbWFza09iamVjdDtcbiAgICBjb25zdCBzdGFzaEZpbHRlckFyZWEgPSB0YXJnZXQuZmlsdGVyQXJlYTtcbiAgICB0YXJnZXQuZmlsdGVyQXJlYSA9IG1hc2tPYmplY3QuZ2V0Qm91bmRzKHRydWUpO1xuICAgIHJlbmRlcmVyLmZpbHRlci5wdXNoKHRhcmdldCwgYWxwaGFNYXNrRmlsdGVyKTtcbiAgICB0YXJnZXQuZmlsdGVyQXJlYSA9IHN0YXNoRmlsdGVyQXJlYTtcbiAgICBpZiAoIW1hc2tEYXRhLl9maWx0ZXJzKSB7XG4gICAgICB0aGlzLmFscGhhTWFza0luZGV4Kys7XG4gICAgfVxuICB9XG4gIHBvcFNwcml0ZU1hc2sobWFza0RhdGEpIHtcbiAgICB0aGlzLnJlbmRlcmVyLmZpbHRlci5wb3AoKTtcbiAgICBpZiAobWFza0RhdGEuX2ZpbHRlcnMpIHtcbiAgICAgIG1hc2tEYXRhLl9maWx0ZXJzWzBdLm1hc2tTcHJpdGUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFscGhhTWFza0luZGV4LS07XG4gICAgICB0aGlzLmFscGhhTWFza1Bvb2xbdGhpcy5hbHBoYU1hc2tJbmRleF1bMF0ubWFza1Nwcml0ZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIHB1c2hDb2xvck1hc2sobWFza0RhdGEpIHtcbiAgICBjb25zdCBjdXJyQ29sb3JNYXNrID0gbWFza0RhdGEuX2NvbG9yTWFzaztcbiAgICBjb25zdCBuZXh0Q29sb3JNYXNrID0gbWFza0RhdGEuX2NvbG9yTWFzayA9IGN1cnJDb2xvck1hc2sgJiBtYXNrRGF0YS5jb2xvck1hc2s7XG4gICAgaWYgKG5leHRDb2xvck1hc2sgIT09IGN1cnJDb2xvck1hc2spIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2wuY29sb3JNYXNrKChuZXh0Q29sb3JNYXNrICYgMSkgIT09IDAsIChuZXh0Q29sb3JNYXNrICYgMikgIT09IDAsIChuZXh0Q29sb3JNYXNrICYgNCkgIT09IDAsIChuZXh0Q29sb3JNYXNrICYgOCkgIT09IDApO1xuICAgIH1cbiAgfVxuICBwb3BDb2xvck1hc2sobWFza0RhdGEpIHtcbiAgICBjb25zdCBjdXJyQ29sb3JNYXNrID0gbWFza0RhdGEuX2NvbG9yTWFzaztcbiAgICBjb25zdCBuZXh0Q29sb3JNYXNrID0gdGhpcy5tYXNrU3RhY2subGVuZ3RoID4gMCA/IHRoaXMubWFza1N0YWNrW3RoaXMubWFza1N0YWNrLmxlbmd0aCAtIDFdLl9jb2xvck1hc2sgOiAxNTtcbiAgICBpZiAobmV4dENvbG9yTWFzayAhPT0gY3VyckNvbG9yTWFzaykge1xuICAgICAgdGhpcy5yZW5kZXJlci5nbC5jb2xvck1hc2soKG5leHRDb2xvck1hc2sgJiAxKSAhPT0gMCwgKG5leHRDb2xvck1hc2sgJiAyKSAhPT0gMCwgKG5leHRDb2xvck1hc2sgJiA0KSAhPT0gMCwgKG5leHRDb2xvck1hc2sgJiA4KSAhPT0gMCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbk1hc2tTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwibWFza1wiXG59O1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmFkZChNYXNrU3lzdGVtKTtcblxuZXhwb3J0cy5NYXNrU3lzdGVtID0gTWFza1N5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hc2tTeXN0ZW0uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBleHRlbnNpb25zID0gcmVxdWlyZSgnQHBpeGkvZXh0ZW5zaW9ucycpO1xudmFyIG1hdGggPSByZXF1aXJlKCdAcGl4aS9tYXRoJyk7XG52YXIgc2V0dGluZ3MgPSByZXF1aXJlKCdAcGl4aS9zZXR0aW5ncycpO1xudmFyIEFic3RyYWN0TWFza1N5c3RlbSA9IHJlcXVpcmUoJy4vQWJzdHJhY3RNYXNrU3lzdGVtLmpzJyk7XG5cbmNvbnN0IHRlbXBNYXRyaXggPSBuZXcgbWF0aC5NYXRyaXgoKTtcbmNvbnN0IHJlY3RQb29sID0gW107XG5jb25zdCBfU2Npc3NvclN5c3RlbSA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RNYXNrU3lzdGVtLkFic3RyYWN0TWFza1N5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgc3VwZXIocmVuZGVyZXIpO1xuICAgIHRoaXMuZ2xDb25zdCA9IHNldHRpbmdzLnNldHRpbmdzLkFEQVBURVIuZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KCkuU0NJU1NPUl9URVNUO1xuICB9XG4gIGdldFN0YWNrTGVuZ3RoKCkge1xuICAgIGNvbnN0IG1hc2tEYXRhID0gdGhpcy5tYXNrU3RhY2tbdGhpcy5tYXNrU3RhY2subGVuZ3RoIC0gMV07XG4gICAgaWYgKG1hc2tEYXRhKSB7XG4gICAgICByZXR1cm4gbWFza0RhdGEuX3NjaXNzb3JDb3VudGVyO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBjYWxjU2Npc3NvclJlY3QobWFza0RhdGEpIHtcbiAgICBpZiAobWFza0RhdGEuX3NjaXNzb3JSZWN0TG9jYWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHJldkRhdGEgPSBtYXNrRGF0YS5fc2Npc3NvclJlY3Q7XG4gICAgY29uc3QgeyBtYXNrT2JqZWN0IH0gPSBtYXNrRGF0YTtcbiAgICBjb25zdCB7IHJlbmRlcmVyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJlbmRlclRleHR1cmVTeXN0ZW0gPSByZW5kZXJlci5yZW5kZXJUZXh0dXJlO1xuICAgIGNvbnN0IHJlY3QgPSBtYXNrT2JqZWN0LmdldEJvdW5kcyh0cnVlLCByZWN0UG9vbC5wb3AoKSA/PyBuZXcgbWF0aC5SZWN0YW5nbGUoKSk7XG4gICAgdGhpcy5yb3VuZEZyYW1lVG9QaXhlbHMocmVjdCwgcmVuZGVyVGV4dHVyZVN5c3RlbS5jdXJyZW50ID8gcmVuZGVyVGV4dHVyZVN5c3RlbS5jdXJyZW50LnJlc29sdXRpb24gOiByZW5kZXJlci5yZXNvbHV0aW9uLCByZW5kZXJUZXh0dXJlU3lzdGVtLnNvdXJjZUZyYW1lLCByZW5kZXJUZXh0dXJlU3lzdGVtLmRlc3RpbmF0aW9uRnJhbWUsIHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtKTtcbiAgICBpZiAocHJldkRhdGEpIHtcbiAgICAgIHJlY3QuZml0KHByZXZEYXRhKTtcbiAgICB9XG4gICAgbWFza0RhdGEuX3NjaXNzb3JSZWN0TG9jYWwgPSByZWN0O1xuICB9XG4gIHN0YXRpYyBpc01hdHJpeFJvdGF0ZWQobWF0cml4KSB7XG4gICAgaWYgKCFtYXRyaXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBhLCBiLCBjLCBkIH0gPSBtYXRyaXg7XG4gICAgcmV0dXJuIChNYXRoLmFicyhiKSA+IDFlLTQgfHwgTWF0aC5hYnMoYykgPiAxZS00KSAmJiAoTWF0aC5hYnMoYSkgPiAxZS00IHx8IE1hdGguYWJzKGQpID4gMWUtNCk7XG4gIH1cbiAgdGVzdFNjaXNzb3IobWFza0RhdGEpIHtcbiAgICBjb25zdCB7IG1hc2tPYmplY3QgfSA9IG1hc2tEYXRhO1xuICAgIGlmICghbWFza09iamVjdC5pc0Zhc3RSZWN0IHx8ICFtYXNrT2JqZWN0LmlzRmFzdFJlY3QoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoX1NjaXNzb3JTeXN0ZW0uaXNNYXRyaXhSb3RhdGVkKG1hc2tPYmplY3Qud29ybGRUcmFuc2Zvcm0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChfU2Npc3NvclN5c3RlbS5pc01hdHJpeFJvdGF0ZWQodGhpcy5yZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5jYWxjU2Npc3NvclJlY3QobWFza0RhdGEpO1xuICAgIGNvbnN0IHJlY3QgPSBtYXNrRGF0YS5fc2Npc3NvclJlY3RMb2NhbDtcbiAgICByZXR1cm4gcmVjdC53aWR0aCA+IDAgJiYgcmVjdC5oZWlnaHQgPiAwO1xuICB9XG4gIHJvdW5kRnJhbWVUb1BpeGVscyhmcmFtZSwgcmVzb2x1dGlvbiwgYmluZGluZ1NvdXJjZUZyYW1lLCBiaW5kaW5nRGVzdGluYXRpb25GcmFtZSwgdHJhbnNmb3JtKSB7XG4gICAgaWYgKF9TY2lzc29yU3lzdGVtLmlzTWF0cml4Um90YXRlZCh0cmFuc2Zvcm0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybSA/IHRlbXBNYXRyaXguY29weUZyb20odHJhbnNmb3JtKSA6IHRlbXBNYXRyaXguaWRlbnRpdHkoKTtcbiAgICB0cmFuc2Zvcm0udHJhbnNsYXRlKC1iaW5kaW5nU291cmNlRnJhbWUueCwgLWJpbmRpbmdTb3VyY2VGcmFtZS55KS5zY2FsZShiaW5kaW5nRGVzdGluYXRpb25GcmFtZS53aWR0aCAvIGJpbmRpbmdTb3VyY2VGcmFtZS53aWR0aCwgYmluZGluZ0Rlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0IC8gYmluZGluZ1NvdXJjZUZyYW1lLmhlaWdodCkudHJhbnNsYXRlKGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLngsIGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLnkpO1xuICAgIHRoaXMucmVuZGVyZXIuZmlsdGVyLnRyYW5zZm9ybUFBQkIodHJhbnNmb3JtLCBmcmFtZSk7XG4gICAgZnJhbWUuZml0KGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lKTtcbiAgICBmcmFtZS54ID0gTWF0aC5yb3VuZChmcmFtZS54ICogcmVzb2x1dGlvbik7XG4gICAgZnJhbWUueSA9IE1hdGgucm91bmQoZnJhbWUueSAqIHJlc29sdXRpb24pO1xuICAgIGZyYW1lLndpZHRoID0gTWF0aC5yb3VuZChmcmFtZS53aWR0aCAqIHJlc29sdXRpb24pO1xuICAgIGZyYW1lLmhlaWdodCA9IE1hdGgucm91bmQoZnJhbWUuaGVpZ2h0ICogcmVzb2x1dGlvbik7XG4gIH1cbiAgcHVzaChtYXNrRGF0YSkge1xuICAgIGlmICghbWFza0RhdGEuX3NjaXNzb3JSZWN0TG9jYWwpIHtcbiAgICAgIHRoaXMuY2FsY1NjaXNzb3JSZWN0KG1hc2tEYXRhKTtcbiAgICB9XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcy5yZW5kZXJlcjtcbiAgICBpZiAoIW1hc2tEYXRhLl9zY2lzc29yUmVjdCkge1xuICAgICAgZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgfVxuICAgIG1hc2tEYXRhLl9zY2lzc29yQ291bnRlcisrO1xuICAgIG1hc2tEYXRhLl9zY2lzc29yUmVjdCA9IG1hc2tEYXRhLl9zY2lzc29yUmVjdExvY2FsO1xuICAgIHRoaXMuX3VzZUN1cnJlbnQoKTtcbiAgfVxuICBwb3AobWFza0RhdGEpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIGlmIChtYXNrRGF0YSkge1xuICAgICAgcmVjdFBvb2wucHVzaChtYXNrRGF0YS5fc2Npc3NvclJlY3RMb2NhbCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmdldFN0YWNrTGVuZ3RoKCkgPiAwKSB7XG4gICAgICB0aGlzLl91c2VDdXJyZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmRpc2FibGUoZ2wuU0NJU1NPUl9URVNUKTtcbiAgICB9XG4gIH1cbiAgX3VzZUN1cnJlbnQoKSB7XG4gICAgY29uc3QgcmVjdCA9IHRoaXMubWFza1N0YWNrW3RoaXMubWFza1N0YWNrLmxlbmd0aCAtIDFdLl9zY2lzc29yUmVjdDtcbiAgICBsZXQgeTtcbiAgICBpZiAodGhpcy5yZW5kZXJlci5yZW5kZXJUZXh0dXJlLmN1cnJlbnQpIHtcbiAgICAgIHkgPSByZWN0Lnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgPSB0aGlzLnJlbmRlcmVyLmhlaWdodCAtIHJlY3QuaGVpZ2h0IC0gcmVjdC55O1xuICAgIH1cbiAgICB0aGlzLnJlbmRlcmVyLmdsLnNjaXNzb3IocmVjdC54LCB5LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gIH1cbn07XG5sZXQgU2Npc3NvclN5c3RlbSA9IF9TY2lzc29yU3lzdGVtO1xuU2Npc3NvclN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJzY2lzc29yXCJcbn07XG5leHRlbnNpb25zLmV4dGVuc2lvbnMuYWRkKFNjaXNzb3JTeXN0ZW0pO1xuXG5leHBvcnRzLlNjaXNzb3JTeXN0ZW0gPSBTY2lzc29yU3lzdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2Npc3NvclN5c3RlbS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGV4dGVuc2lvbnMgPSByZXF1aXJlKCdAcGl4aS9leHRlbnNpb25zJyk7XG52YXIgc2V0dGluZ3MgPSByZXF1aXJlKCdAcGl4aS9zZXR0aW5ncycpO1xudmFyIEFic3RyYWN0TWFza1N5c3RlbSA9IHJlcXVpcmUoJy4vQWJzdHJhY3RNYXNrU3lzdGVtLmpzJyk7XG5cbmNsYXNzIFN0ZW5jaWxTeXN0ZW0gZXh0ZW5kcyBBYnN0cmFjdE1hc2tTeXN0ZW0uQWJzdHJhY3RNYXNrU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICBzdXBlcihyZW5kZXJlcik7XG4gICAgdGhpcy5nbENvbnN0ID0gc2V0dGluZ3Muc2V0dGluZ3MuQURBUFRFUi5nZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQoKS5TVEVOQ0lMX1RFU1Q7XG4gIH1cbiAgZ2V0U3RhY2tMZW5ndGgoKSB7XG4gICAgY29uc3QgbWFza0RhdGEgPSB0aGlzLm1hc2tTdGFja1t0aGlzLm1hc2tTdGFjay5sZW5ndGggLSAxXTtcbiAgICBpZiAobWFza0RhdGEpIHtcbiAgICAgIHJldHVybiBtYXNrRGF0YS5fc3RlbmNpbENvdW50ZXI7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIHB1c2gobWFza0RhdGEpIHtcbiAgICBjb25zdCBtYXNrT2JqZWN0ID0gbWFza0RhdGEubWFza09iamVjdDtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIGNvbnN0IHByZXZNYXNrQ291bnQgPSBtYXNrRGF0YS5fc3RlbmNpbENvdW50ZXI7XG4gICAgaWYgKHByZXZNYXNrQ291bnQgPT09IDApIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuZnJhbWVidWZmZXIuZm9yY2VTdGVuY2lsKCk7XG4gICAgICBnbC5jbGVhclN0ZW5jaWwoMCk7XG4gICAgICBnbC5jbGVhcihnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xuICAgICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgfVxuICAgIG1hc2tEYXRhLl9zdGVuY2lsQ291bnRlcisrO1xuICAgIGNvbnN0IGNvbG9yTWFzayA9IG1hc2tEYXRhLl9jb2xvck1hc2s7XG4gICAgaWYgKGNvbG9yTWFzayAhPT0gMCkge1xuICAgICAgbWFza0RhdGEuX2NvbG9yTWFzayA9IDA7XG4gICAgICBnbC5jb2xvck1hc2soZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgIH1cbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgcHJldk1hc2tDb3VudCwgNDI5NDk2NzI5NSk7XG4gICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsIGdsLktFRVAsIGdsLklOQ1IpO1xuICAgIG1hc2tPYmplY3QucmVuZGVyYWJsZSA9IHRydWU7XG4gICAgbWFza09iamVjdC5yZW5kZXIodGhpcy5yZW5kZXJlcik7XG4gICAgdGhpcy5yZW5kZXJlci5iYXRjaC5mbHVzaCgpO1xuICAgIG1hc2tPYmplY3QucmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgIGlmIChjb2xvck1hc2sgIT09IDApIHtcbiAgICAgIG1hc2tEYXRhLl9jb2xvck1hc2sgPSBjb2xvck1hc2s7XG4gICAgICBnbC5jb2xvck1hc2soKGNvbG9yTWFzayAmIDEpICE9PSAwLCAoY29sb3JNYXNrICYgMikgIT09IDAsIChjb2xvck1hc2sgJiA0KSAhPT0gMCwgKGNvbG9yTWFzayAmIDgpICE9PSAwKTtcbiAgICB9XG4gICAgdGhpcy5fdXNlQ3VycmVudCgpO1xuICB9XG4gIHBvcChtYXNrT2JqZWN0KSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgIGlmICh0aGlzLmdldFN0YWNrTGVuZ3RoKCkgPT09IDApIHtcbiAgICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWFza0RhdGEgPSB0aGlzLm1hc2tTdGFjay5sZW5ndGggIT09IDAgPyB0aGlzLm1hc2tTdGFja1t0aGlzLm1hc2tTdGFjay5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICBjb25zdCBjb2xvck1hc2sgPSBtYXNrRGF0YSA/IG1hc2tEYXRhLl9jb2xvck1hc2sgOiAxNTtcbiAgICAgIGlmIChjb2xvck1hc2sgIT09IDApIHtcbiAgICAgICAgbWFza0RhdGEuX2NvbG9yTWFzayA9IDA7XG4gICAgICAgIGdsLmNvbG9yTWFzayhmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuREVDUik7XG4gICAgICBtYXNrT2JqZWN0LnJlbmRlcmFibGUgPSB0cnVlO1xuICAgICAgbWFza09iamVjdC5yZW5kZXIodGhpcy5yZW5kZXJlcik7XG4gICAgICB0aGlzLnJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XG4gICAgICBtYXNrT2JqZWN0LnJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgIGlmIChjb2xvck1hc2sgIT09IDApIHtcbiAgICAgICAgbWFza0RhdGEuX2NvbG9yTWFzayA9IGNvbG9yTWFzaztcbiAgICAgICAgZ2wuY29sb3JNYXNrKChjb2xvck1hc2sgJiAxKSAhPT0gMCwgKGNvbG9yTWFzayAmIDIpICE9PSAwLCAoY29sb3JNYXNrICYgNCkgIT09IDAsIChjb2xvck1hc2sgJiA4KSAhPT0gMCk7XG4gICAgICB9XG4gICAgICB0aGlzLl91c2VDdXJyZW50KCk7XG4gICAgfVxuICB9XG4gIF91c2VDdXJyZW50KCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgdGhpcy5nZXRTdGFja0xlbmd0aCgpLCA0Mjk0OTY3Mjk1KTtcbiAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuS0VFUCk7XG4gIH1cbn1cblN0ZW5jaWxTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwic3RlbmNpbFwiXG59O1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmFkZChTdGVuY2lsU3lzdGVtKTtcblxuZXhwb3J0cy5TdGVuY2lsU3lzdGVtID0gU3RlbmNpbFN5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0ZW5jaWxTeXN0ZW0uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBleHRlbnNpb25zID0gcmVxdWlyZSgnQHBpeGkvZXh0ZW5zaW9ucycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQHBpeGkvdXRpbHMnKTtcblxuY2xhc3MgUGx1Z2luU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5wbHVnaW5zID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcy5wbHVnaW5zLCB7XG4gICAgICBleHRyYWN0OiB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgdXRpbHMuZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLnBsdWdpbnMuZXh0cmFjdCBoYXMgbW92ZWQgdG8gcmVuZGVyZXIuZXh0cmFjdFwiKTtcbiAgICAgICAgICByZXR1cm4gcmVuZGVyZXIuZXh0cmFjdDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByZXBhcmU6IHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMC4wXCIsIFwicmVuZGVyZXIucGx1Z2lucy5wcmVwYXJlIGhhcyBtb3ZlZCB0byByZW5kZXJlci5wcmVwYXJlXCIpO1xuICAgICAgICAgIHJldHVybiByZW5kZXJlci5wcmVwYXJlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaW50ZXJhY3Rpb246IHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMC4wXCIsIFwicmVuZGVyZXIucGx1Z2lucy5pbnRlcmFjdGlvbiBoYXMgYmVlbiBkZXByZWNhdGVkLCB1c2UgcmVuZGVyZXIuZXZlbnRzXCIpO1xuICAgICAgICAgIHJldHVybiByZW5kZXJlci5ldmVudHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpbml0KCkge1xuICAgIGNvbnN0IHN0YXRpY01hcCA9IHRoaXMucmVuZGVyZXJQbHVnaW5zO1xuICAgIGZvciAoY29uc3QgbyBpbiBzdGF0aWNNYXApIHtcbiAgICAgIHRoaXMucGx1Z2luc1tvXSA9IG5ldyBzdGF0aWNNYXBbb10odGhpcy5yZW5kZXJlcik7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBvIGluIHRoaXMucGx1Z2lucykge1xuICAgICAgdGhpcy5wbHVnaW5zW29dLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMucGx1Z2luc1tvXSA9IG51bGw7XG4gICAgfVxuICB9XG59XG5QbHVnaW5TeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICAgIGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5DYW52YXNSZW5kZXJlclN5c3RlbVxuICBdLFxuICBuYW1lOiBcIl9wbHVnaW5cIlxufTtcbmV4dGVuc2lvbnMuZXh0ZW5zaW9ucy5hZGQoUGx1Z2luU3lzdGVtKTtcblxuZXhwb3J0cy5QbHVnaW5TeXN0ZW0gPSBQbHVnaW5TeXN0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QbHVnaW5TeXN0ZW0uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBleHRlbnNpb25zID0gcmVxdWlyZSgnQHBpeGkvZXh0ZW5zaW9ucycpO1xudmFyIG1hdGggPSByZXF1aXJlKCdAcGl4aS9tYXRoJyk7XG5cbmNsYXNzIFByb2plY3Rpb25TeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgPSBudWxsO1xuICAgIHRoaXMuc291cmNlRnJhbWUgPSBudWxsO1xuICAgIHRoaXMuZGVmYXVsdEZyYW1lID0gbnVsbDtcbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBuZXcgbWF0aC5NYXRyaXgoKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG51bGw7XG4gIH1cbiAgdXBkYXRlKGRlc3RpbmF0aW9uRnJhbWUsIHNvdXJjZUZyYW1lLCByZXNvbHV0aW9uLCByb290KSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lID0gZGVzdGluYXRpb25GcmFtZSB8fCB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgfHwgdGhpcy5kZWZhdWx0RnJhbWU7XG4gICAgdGhpcy5zb3VyY2VGcmFtZSA9IHNvdXJjZUZyYW1lIHx8IHRoaXMuc291cmNlRnJhbWUgfHwgZGVzdGluYXRpb25GcmFtZTtcbiAgICB0aGlzLmNhbGN1bGF0ZVByb2plY3Rpb24odGhpcy5kZXN0aW5hdGlvbkZyYW1lLCB0aGlzLnNvdXJjZUZyYW1lLCByZXNvbHV0aW9uLCByb290KTtcbiAgICBpZiAodGhpcy50cmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5hcHBlbmQodGhpcy50cmFuc2Zvcm0pO1xuICAgIH1cbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCA9IHRoaXMucHJvamVjdGlvbk1hdHJpeDtcbiAgICByZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy51cGRhdGUoKTtcbiAgICBpZiAocmVuZGVyZXIuc2hhZGVyLnNoYWRlcikge1xuICAgICAgcmVuZGVyZXIuc2hhZGVyLnN5bmNVbmlmb3JtR3JvdXAocmVuZGVyZXIuc2hhZGVyLnNoYWRlci51bmlmb3Jtcy5nbG9iYWxzKTtcbiAgICB9XG4gIH1cbiAgY2FsY3VsYXRlUHJvamVjdGlvbihfZGVzdGluYXRpb25GcmFtZSwgc291cmNlRnJhbWUsIF9yZXNvbHV0aW9uLCByb290KSB7XG4gICAgY29uc3QgcG0gPSB0aGlzLnByb2plY3Rpb25NYXRyaXg7XG4gICAgY29uc3Qgc2lnbiA9ICFyb290ID8gMSA6IC0xO1xuICAgIHBtLmlkZW50aXR5KCk7XG4gICAgcG0uYSA9IDEgLyBzb3VyY2VGcmFtZS53aWR0aCAqIDI7XG4gICAgcG0uZCA9IHNpZ24gKiAoMSAvIHNvdXJjZUZyYW1lLmhlaWdodCAqIDIpO1xuICAgIHBtLnR4ID0gLTEgLSBzb3VyY2VGcmFtZS54ICogcG0uYTtcbiAgICBwbS50eSA9IC1zaWduIC0gc291cmNlRnJhbWUueSAqIHBtLmQ7XG4gIH1cbiAgc2V0VHJhbnNmb3JtKF9tYXRyaXgpIHtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG5Qcm9qZWN0aW9uU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcInByb2plY3Rpb25cIlxufTtcbmV4dGVuc2lvbnMuZXh0ZW5zaW9ucy5hZGQoUHJvamVjdGlvblN5c3RlbSk7XG5cbmV4cG9ydHMuUHJvamVjdGlvblN5c3RlbSA9IFByb2plY3Rpb25TeXN0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcm9qZWN0aW9uU3lzdGVtLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29sb3IgPSByZXF1aXJlKCdAcGl4aS9jb2xvcicpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ0BwaXhpL2NvbnN0YW50cycpO1xudmFyIEZyYW1lYnVmZmVyID0gcmVxdWlyZSgnLi4vZnJhbWVidWZmZXIvRnJhbWVidWZmZXIuanMnKTtcbnZhciBCYXNlVGV4dHVyZSA9IHJlcXVpcmUoJy4uL3RleHR1cmVzL0Jhc2VUZXh0dXJlLmpzJyk7XG5cbmNsYXNzIEJhc2VSZW5kZXJUZXh0dXJlIGV4dGVuZHMgQmFzZVRleHR1cmUuQmFzZVRleHR1cmUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgY29uc3Qgc2NhbGVNb2RlID0gYXJndW1lbnRzWzJdO1xuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IGFyZ3VtZW50c1szXTtcbiAgICAgIG9wdGlvbnMgPSB7IHdpZHRoLCBoZWlnaHQsIHNjYWxlTW9kZSwgcmVzb2x1dGlvbiB9O1xuICAgIH1cbiAgICBvcHRpb25zLndpZHRoID0gb3B0aW9ucy53aWR0aCB8fCAxMDA7XG4gICAgb3B0aW9ucy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCAxMDA7XG4gICAgb3B0aW9ucy5tdWx0aXNhbXBsZSA/PyAob3B0aW9ucy5tdWx0aXNhbXBsZSA9IGNvbnN0YW50cy5NU0FBX1FVQUxJVFkuTk9ORSk7XG4gICAgc3VwZXIobnVsbCwgb3B0aW9ucyk7XG4gICAgdGhpcy5taXBtYXAgPSBjb25zdGFudHMuTUlQTUFQX01PREVTLk9GRjtcbiAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcbiAgICB0aGlzLl9jbGVhciA9IG5ldyBjb2xvci5Db2xvcihbMCwgMCwgMCwgMF0pO1xuICAgIHRoaXMuZnJhbWVidWZmZXIgPSBuZXcgRnJhbWVidWZmZXIuRnJhbWVidWZmZXIodGhpcy5yZWFsV2lkdGgsIHRoaXMucmVhbEhlaWdodCkuYWRkQ29sb3JUZXh0dXJlKDAsIHRoaXMpO1xuICAgIHRoaXMuZnJhbWVidWZmZXIubXVsdGlzYW1wbGUgPSBvcHRpb25zLm11bHRpc2FtcGxlO1xuICAgIHRoaXMubWFza1N0YWNrID0gW107XG4gICAgdGhpcy5maWx0ZXJTdGFjayA9IFt7fV07XG4gIH1cbiAgc2V0IGNsZWFyQ29sb3IodmFsdWUpIHtcbiAgICB0aGlzLl9jbGVhci5zZXRWYWx1ZSh2YWx1ZSk7XG4gIH1cbiAgZ2V0IGNsZWFyQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsZWFyLnZhbHVlO1xuICB9XG4gIGdldCBjbGVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xlYXI7XG4gIH1cbiAgcmVzaXplKGRlc2lyZWRXaWR0aCwgZGVzaXJlZEhlaWdodCkge1xuICAgIHRoaXMuZnJhbWVidWZmZXIucmVzaXplKGRlc2lyZWRXaWR0aCAqIHRoaXMucmVzb2x1dGlvbiwgZGVzaXJlZEhlaWdodCAqIHRoaXMucmVzb2x1dGlvbik7XG4gICAgdGhpcy5zZXRSZWFsU2l6ZSh0aGlzLmZyYW1lYnVmZmVyLndpZHRoLCB0aGlzLmZyYW1lYnVmZmVyLmhlaWdodCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmZyYW1lYnVmZmVyLmRpc3Bvc2UoKTtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlci5kZXN0cm95RGVwdGhUZXh0dXJlKCk7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlciA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0cy5CYXNlUmVuZGVyVGV4dHVyZSA9IEJhc2VSZW5kZXJUZXh0dXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZVJlbmRlclRleHR1cmUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBleHRlbnNpb25zID0gcmVxdWlyZSgnQHBpeGkvZXh0ZW5zaW9ucycpO1xudmFyIG1hdGggPSByZXF1aXJlKCdAcGl4aS9tYXRoJyk7XG52YXIgUmVuZGVyVGV4dHVyZSA9IHJlcXVpcmUoJy4vUmVuZGVyVGV4dHVyZS5qcycpO1xuXG5jb25zdCB0ZW1wVHJhbnNmb3JtID0gbmV3IG1hdGguVHJhbnNmb3JtKCk7XG5jbGFzcyBHZW5lcmF0ZVRleHR1cmVTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLl90ZW1wTWF0cml4ID0gbmV3IG1hdGguTWF0cml4KCk7XG4gIH1cbiAgZ2VuZXJhdGVUZXh0dXJlKGRpc3BsYXlPYmplY3QsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHJlZ2lvbjogbWFudWFsUmVnaW9uLCAuLi50ZXh0dXJlT3B0aW9ucyB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCByZWdpb24gPSBtYW51YWxSZWdpb24gfHwgZGlzcGxheU9iamVjdC5nZXRMb2NhbEJvdW5kcyhudWxsLCB0cnVlKTtcbiAgICBpZiAocmVnaW9uLndpZHRoID09PSAwKVxuICAgICAgcmVnaW9uLndpZHRoID0gMTtcbiAgICBpZiAocmVnaW9uLmhlaWdodCA9PT0gMClcbiAgICAgIHJlZ2lvbi5oZWlnaHQgPSAxO1xuICAgIGNvbnN0IHJlbmRlclRleHR1cmUgPSBSZW5kZXJUZXh0dXJlLlJlbmRlclRleHR1cmUuY3JlYXRlKHtcbiAgICAgIHdpZHRoOiByZWdpb24ud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlZ2lvbi5oZWlnaHQsXG4gICAgICAuLi50ZXh0dXJlT3B0aW9uc1xuICAgIH0pO1xuICAgIHRoaXMuX3RlbXBNYXRyaXgudHggPSAtcmVnaW9uLng7XG4gICAgdGhpcy5fdGVtcE1hdHJpeC50eSA9IC1yZWdpb24ueTtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBkaXNwbGF5T2JqZWN0LnRyYW5zZm9ybTtcbiAgICBkaXNwbGF5T2JqZWN0LnRyYW5zZm9ybSA9IHRlbXBUcmFuc2Zvcm07XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIoZGlzcGxheU9iamVjdCwge1xuICAgICAgcmVuZGVyVGV4dHVyZSxcbiAgICAgIHRyYW5zZm9ybTogdGhpcy5fdGVtcE1hdHJpeCxcbiAgICAgIHNraXBVcGRhdGVUcmFuc2Zvcm06ICEhZGlzcGxheU9iamVjdC5wYXJlbnQsXG4gICAgICBibGl0OiB0cnVlXG4gICAgfSk7XG4gICAgZGlzcGxheU9iamVjdC50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgcmV0dXJuIHJlbmRlclRleHR1cmU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgfVxufVxuR2VuZXJhdGVUZXh0dXJlU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgICBleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuQ2FudmFzUmVuZGVyZXJTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJ0ZXh0dXJlR2VuZXJhdG9yXCJcbn07XG5leHRlbnNpb25zLmV4dGVuc2lvbnMuYWRkKEdlbmVyYXRlVGV4dHVyZVN5c3RlbSk7XG5cbmV4cG9ydHMuR2VuZXJhdGVUZXh0dXJlU3lzdGVtID0gR2VuZXJhdGVUZXh0dXJlU3lzdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2VuZXJhdGVUZXh0dXJlU3lzdGVtLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgVGV4dHVyZSA9IHJlcXVpcmUoJy4uL3RleHR1cmVzL1RleHR1cmUuanMnKTtcbnZhciBCYXNlUmVuZGVyVGV4dHVyZSA9IHJlcXVpcmUoJy4vQmFzZVJlbmRlclRleHR1cmUuanMnKTtcblxuY2xhc3MgUmVuZGVyVGV4dHVyZSBleHRlbmRzIFRleHR1cmUuVGV4dHVyZSB7XG4gIGNvbnN0cnVjdG9yKGJhc2VSZW5kZXJUZXh0dXJlLCBmcmFtZSkge1xuICAgIHN1cGVyKGJhc2VSZW5kZXJUZXh0dXJlLCBmcmFtZSk7XG4gICAgdGhpcy52YWxpZCA9IHRydWU7XG4gICAgdGhpcy5maWx0ZXJGcmFtZSA9IG51bGw7XG4gICAgdGhpcy5maWx0ZXJQb29sS2V5ID0gbnVsbDtcbiAgICB0aGlzLnVwZGF0ZVV2cygpO1xuICB9XG4gIGdldCBmcmFtZWJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlVGV4dHVyZS5mcmFtZWJ1ZmZlcjtcbiAgfVxuICBnZXQgbXVsdGlzYW1wbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhbWVidWZmZXIubXVsdGlzYW1wbGU7XG4gIH1cbiAgc2V0IG11bHRpc2FtcGxlKHZhbHVlKSB7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlci5tdWx0aXNhbXBsZSA9IHZhbHVlO1xuICB9XG4gIHJlc2l6ZShkZXNpcmVkV2lkdGgsIGRlc2lyZWRIZWlnaHQsIHJlc2l6ZUJhc2VUZXh0dXJlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmJhc2VUZXh0dXJlLnJlc29sdXRpb247XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKGRlc2lyZWRXaWR0aCAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLnJvdW5kKGRlc2lyZWRIZWlnaHQgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG4gICAgdGhpcy52YWxpZCA9IHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwO1xuICAgIHRoaXMuX2ZyYW1lLndpZHRoID0gdGhpcy5vcmlnLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5fZnJhbWUuaGVpZ2h0ID0gdGhpcy5vcmlnLmhlaWdodCA9IGhlaWdodDtcbiAgICBpZiAocmVzaXplQmFzZVRleHR1cmUpIHtcbiAgICAgIHRoaXMuYmFzZVRleHR1cmUucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVV2cygpO1xuICB9XG4gIHNldFJlc29sdXRpb24ocmVzb2x1dGlvbikge1xuICAgIGNvbnN0IHsgYmFzZVRleHR1cmUgfSA9IHRoaXM7XG4gICAgaWYgKGJhc2VUZXh0dXJlLnJlc29sdXRpb24gPT09IHJlc29sdXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYmFzZVRleHR1cmUuc2V0UmVzb2x1dGlvbihyZXNvbHV0aW9uKTtcbiAgICB0aGlzLnJlc2l6ZShiYXNlVGV4dHVyZS53aWR0aCwgYmFzZVRleHR1cmUuaGVpZ2h0LCBmYWxzZSk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSZW5kZXJUZXh0dXJlKG5ldyBCYXNlUmVuZGVyVGV4dHVyZS5CYXNlUmVuZGVyVGV4dHVyZShvcHRpb25zKSk7XG4gIH1cbn1cblxuZXhwb3J0cy5SZW5kZXJUZXh0dXJlID0gUmVuZGVyVGV4dHVyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlbmRlclRleHR1cmUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCdAcGl4aS9jb25zdGFudHMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BwaXhpL3V0aWxzJyk7XG52YXIgQmFzZVJlbmRlclRleHR1cmUgPSByZXF1aXJlKCcuL0Jhc2VSZW5kZXJUZXh0dXJlLmpzJyk7XG52YXIgUmVuZGVyVGV4dHVyZSA9IHJlcXVpcmUoJy4vUmVuZGVyVGV4dHVyZS5qcycpO1xuXG5jbGFzcyBSZW5kZXJUZXh0dXJlUG9vbCB7XG4gIGNvbnN0cnVjdG9yKHRleHR1cmVPcHRpb25zKSB7XG4gICAgdGhpcy50ZXh0dXJlUG9vbCA9IHt9O1xuICAgIHRoaXMudGV4dHVyZU9wdGlvbnMgPSB0ZXh0dXJlT3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLmVuYWJsZUZ1bGxTY3JlZW4gPSBmYWxzZTtcbiAgICB0aGlzLl9waXhlbHNXaWR0aCA9IDA7XG4gICAgdGhpcy5fcGl4ZWxzSGVpZ2h0ID0gMDtcbiAgfVxuICBjcmVhdGVUZXh0dXJlKHJlYWxXaWR0aCwgcmVhbEhlaWdodCwgbXVsdGlzYW1wbGUgPSBjb25zdGFudHMuTVNBQV9RVUFMSVRZLk5PTkUpIHtcbiAgICBjb25zdCBiYXNlUmVuZGVyVGV4dHVyZSA9IG5ldyBCYXNlUmVuZGVyVGV4dHVyZS5CYXNlUmVuZGVyVGV4dHVyZShPYmplY3QuYXNzaWduKHtcbiAgICAgIHdpZHRoOiByZWFsV2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlYWxIZWlnaHQsXG4gICAgICByZXNvbHV0aW9uOiAxLFxuICAgICAgbXVsdGlzYW1wbGVcbiAgICB9LCB0aGlzLnRleHR1cmVPcHRpb25zKSk7XG4gICAgcmV0dXJuIG5ldyBSZW5kZXJUZXh0dXJlLlJlbmRlclRleHR1cmUoYmFzZVJlbmRlclRleHR1cmUpO1xuICB9XG4gIGdldE9wdGltYWxUZXh0dXJlKG1pbldpZHRoLCBtaW5IZWlnaHQsIHJlc29sdXRpb24gPSAxLCBtdWx0aXNhbXBsZSA9IGNvbnN0YW50cy5NU0FBX1FVQUxJVFkuTk9ORSkge1xuICAgIGxldCBrZXk7XG4gICAgbWluV2lkdGggPSBNYXRoLmNlaWwobWluV2lkdGggKiByZXNvbHV0aW9uIC0gMWUtNik7XG4gICAgbWluSGVpZ2h0ID0gTWF0aC5jZWlsKG1pbkhlaWdodCAqIHJlc29sdXRpb24gLSAxZS02KTtcbiAgICBpZiAoIXRoaXMuZW5hYmxlRnVsbFNjcmVlbiB8fCBtaW5XaWR0aCAhPT0gdGhpcy5fcGl4ZWxzV2lkdGggfHwgbWluSGVpZ2h0ICE9PSB0aGlzLl9waXhlbHNIZWlnaHQpIHtcbiAgICAgIG1pbldpZHRoID0gdXRpbHMubmV4dFBvdzIobWluV2lkdGgpO1xuICAgICAgbWluSGVpZ2h0ID0gdXRpbHMubmV4dFBvdzIobWluSGVpZ2h0KTtcbiAgICAgIGtleSA9ICgobWluV2lkdGggJiA2NTUzNSkgPDwgMTYgfCBtaW5IZWlnaHQgJiA2NTUzNSkgPj4+IDA7XG4gICAgICBpZiAobXVsdGlzYW1wbGUgPiAxKSB7XG4gICAgICAgIGtleSArPSBtdWx0aXNhbXBsZSAqIDQyOTQ5NjcyOTY7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IG11bHRpc2FtcGxlID4gMSA/IC1tdWx0aXNhbXBsZSA6IC0xO1xuICAgIH1cbiAgICBpZiAoIXRoaXMudGV4dHVyZVBvb2xba2V5XSkge1xuICAgICAgdGhpcy50ZXh0dXJlUG9vbFtrZXldID0gW107XG4gICAgfVxuICAgIGxldCByZW5kZXJUZXh0dXJlID0gdGhpcy50ZXh0dXJlUG9vbFtrZXldLnBvcCgpO1xuICAgIGlmICghcmVuZGVyVGV4dHVyZSkge1xuICAgICAgcmVuZGVyVGV4dHVyZSA9IHRoaXMuY3JlYXRlVGV4dHVyZShtaW5XaWR0aCwgbWluSGVpZ2h0LCBtdWx0aXNhbXBsZSk7XG4gICAgfVxuICAgIHJlbmRlclRleHR1cmUuZmlsdGVyUG9vbEtleSA9IGtleTtcbiAgICByZW5kZXJUZXh0dXJlLnNldFJlc29sdXRpb24ocmVzb2x1dGlvbik7XG4gICAgcmV0dXJuIHJlbmRlclRleHR1cmU7XG4gIH1cbiAgZ2V0RmlsdGVyVGV4dHVyZShpbnB1dCwgcmVzb2x1dGlvbiwgbXVsdGlzYW1wbGUpIHtcbiAgICBjb25zdCBmaWx0ZXJUZXh0dXJlID0gdGhpcy5nZXRPcHRpbWFsVGV4dHVyZShpbnB1dC53aWR0aCwgaW5wdXQuaGVpZ2h0LCByZXNvbHV0aW9uIHx8IGlucHV0LnJlc29sdXRpb24sIG11bHRpc2FtcGxlIHx8IGNvbnN0YW50cy5NU0FBX1FVQUxJVFkuTk9ORSk7XG4gICAgZmlsdGVyVGV4dHVyZS5maWx0ZXJGcmFtZSA9IGlucHV0LmZpbHRlckZyYW1lO1xuICAgIHJldHVybiBmaWx0ZXJUZXh0dXJlO1xuICB9XG4gIHJldHVyblRleHR1cmUocmVuZGVyVGV4dHVyZSkge1xuICAgIGNvbnN0IGtleSA9IHJlbmRlclRleHR1cmUuZmlsdGVyUG9vbEtleTtcbiAgICByZW5kZXJUZXh0dXJlLmZpbHRlckZyYW1lID0gbnVsbDtcbiAgICB0aGlzLnRleHR1cmVQb29sW2tleV0ucHVzaChyZW5kZXJUZXh0dXJlKTtcbiAgfVxuICByZXR1cm5GaWx0ZXJUZXh0dXJlKHJlbmRlclRleHR1cmUpIHtcbiAgICB0aGlzLnJldHVyblRleHR1cmUocmVuZGVyVGV4dHVyZSk7XG4gIH1cbiAgY2xlYXIoZGVzdHJveVRleHR1cmVzKSB7XG4gICAgZGVzdHJveVRleHR1cmVzID0gZGVzdHJveVRleHR1cmVzICE9PSBmYWxzZTtcbiAgICBpZiAoZGVzdHJveVRleHR1cmVzKSB7XG4gICAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy50ZXh0dXJlUG9vbCkge1xuICAgICAgICBjb25zdCB0ZXh0dXJlcyA9IHRoaXMudGV4dHVyZVBvb2xbaV07XG4gICAgICAgIGlmICh0ZXh0dXJlcykge1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGV4dHVyZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHRleHR1cmVzW2pdLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudGV4dHVyZVBvb2wgPSB7fTtcbiAgfVxuICBzZXRTY3JlZW5TaXplKHNpemUpIHtcbiAgICBpZiAoc2l6ZS53aWR0aCA9PT0gdGhpcy5fcGl4ZWxzV2lkdGggJiYgc2l6ZS5oZWlnaHQgPT09IHRoaXMuX3BpeGVsc0hlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVuYWJsZUZ1bGxTY3JlZW4gPSBzaXplLndpZHRoID4gMCAmJiBzaXplLmhlaWdodCA+IDA7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMudGV4dHVyZVBvb2wpIHtcbiAgICAgIGlmICghKE51bWJlcihpKSA8IDApKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dHVyZXMgPSB0aGlzLnRleHR1cmVQb29sW2ldO1xuICAgICAgaWYgKHRleHR1cmVzKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGV4dHVyZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB0ZXh0dXJlc1tqXS5kZXN0cm95KHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnRleHR1cmVQb29sW2ldID0gW107XG4gICAgfVxuICAgIHRoaXMuX3BpeGVsc1dpZHRoID0gc2l6ZS53aWR0aDtcbiAgICB0aGlzLl9waXhlbHNIZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgfVxufVxuUmVuZGVyVGV4dHVyZVBvb2wuU0NSRUVOX0tFWSA9IC0xO1xuXG5leHBvcnRzLlJlbmRlclRleHR1cmVQb29sID0gUmVuZGVyVGV4dHVyZVBvb2w7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW5kZXJUZXh0dXJlUG9vbC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvbG9yID0gcmVxdWlyZSgnQHBpeGkvY29sb3InKTtcbnZhciBleHRlbnNpb25zID0gcmVxdWlyZSgnQHBpeGkvZXh0ZW5zaW9ucycpO1xudmFyIG1hdGggPSByZXF1aXJlKCdAcGl4aS9tYXRoJyk7XG5cbmNvbnN0IHRlbXBSZWN0ID0gbmV3IG1hdGguUmVjdGFuZ2xlKCk7XG5jb25zdCB0ZW1wUmVjdDIgPSBuZXcgbWF0aC5SZWN0YW5nbGUoKTtcbmNsYXNzIFJlbmRlclRleHR1cmVTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLmRlZmF1bHRNYXNrU3RhY2sgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuc291cmNlRnJhbWUgPSBuZXcgbWF0aC5SZWN0YW5nbGUoKTtcbiAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgPSBuZXcgbWF0aC5SZWN0YW5nbGUoKTtcbiAgICB0aGlzLnZpZXdwb3J0RnJhbWUgPSBuZXcgbWF0aC5SZWN0YW5nbGUoKTtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLnJlbmRlcmVyPy5nbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuICAgIHRoaXMuX3JlbmRlcmVyUHJlbXVsdGlwbGllZEFscGhhID0gISEoYXR0cmlidXRlcyAmJiBhdHRyaWJ1dGVzLmFscGhhICYmIGF0dHJpYnV0ZXMucHJlbXVsdGlwbGllZEFscGhhKTtcbiAgfVxuICBiaW5kKHJlbmRlclRleHR1cmUgPSBudWxsLCBzb3VyY2VGcmFtZSwgZGVzdGluYXRpb25GcmFtZSkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICB0aGlzLmN1cnJlbnQgPSByZW5kZXJUZXh0dXJlO1xuICAgIGxldCBiYXNlVGV4dHVyZTtcbiAgICBsZXQgZnJhbWVidWZmZXI7XG4gICAgbGV0IHJlc29sdXRpb247XG4gICAgaWYgKHJlbmRlclRleHR1cmUpIHtcbiAgICAgIGJhc2VUZXh0dXJlID0gcmVuZGVyVGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgIHJlc29sdXRpb24gPSBiYXNlVGV4dHVyZS5yZXNvbHV0aW9uO1xuICAgICAgaWYgKCFzb3VyY2VGcmFtZSkge1xuICAgICAgICB0ZW1wUmVjdC53aWR0aCA9IHJlbmRlclRleHR1cmUuZnJhbWUud2lkdGg7XG4gICAgICAgIHRlbXBSZWN0LmhlaWdodCA9IHJlbmRlclRleHR1cmUuZnJhbWUuaGVpZ2h0O1xuICAgICAgICBzb3VyY2VGcmFtZSA9IHRlbXBSZWN0O1xuICAgICAgfVxuICAgICAgaWYgKCFkZXN0aW5hdGlvbkZyYW1lKSB7XG4gICAgICAgIHRlbXBSZWN0Mi54ID0gcmVuZGVyVGV4dHVyZS5mcmFtZS54O1xuICAgICAgICB0ZW1wUmVjdDIueSA9IHJlbmRlclRleHR1cmUuZnJhbWUueTtcbiAgICAgICAgdGVtcFJlY3QyLndpZHRoID0gc291cmNlRnJhbWUud2lkdGg7XG4gICAgICAgIHRlbXBSZWN0Mi5oZWlnaHQgPSBzb3VyY2VGcmFtZS5oZWlnaHQ7XG4gICAgICAgIGRlc3RpbmF0aW9uRnJhbWUgPSB0ZW1wUmVjdDI7XG4gICAgICB9XG4gICAgICBmcmFtZWJ1ZmZlciA9IGJhc2VUZXh0dXJlLmZyYW1lYnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHV0aW9uID0gcmVuZGVyZXIucmVzb2x1dGlvbjtcbiAgICAgIGlmICghc291cmNlRnJhbWUpIHtcbiAgICAgICAgdGVtcFJlY3Qud2lkdGggPSByZW5kZXJlci5fdmlldy5zY3JlZW4ud2lkdGg7XG4gICAgICAgIHRlbXBSZWN0LmhlaWdodCA9IHJlbmRlcmVyLl92aWV3LnNjcmVlbi5oZWlnaHQ7XG4gICAgICAgIHNvdXJjZUZyYW1lID0gdGVtcFJlY3Q7XG4gICAgICB9XG4gICAgICBpZiAoIWRlc3RpbmF0aW9uRnJhbWUpIHtcbiAgICAgICAgZGVzdGluYXRpb25GcmFtZSA9IHRlbXBSZWN0O1xuICAgICAgICBkZXN0aW5hdGlvbkZyYW1lLndpZHRoID0gc291cmNlRnJhbWUud2lkdGg7XG4gICAgICAgIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0ID0gc291cmNlRnJhbWUuaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2aWV3cG9ydEZyYW1lID0gdGhpcy52aWV3cG9ydEZyYW1lO1xuICAgIHZpZXdwb3J0RnJhbWUueCA9IGRlc3RpbmF0aW9uRnJhbWUueCAqIHJlc29sdXRpb247XG4gICAgdmlld3BvcnRGcmFtZS55ID0gZGVzdGluYXRpb25GcmFtZS55ICogcmVzb2x1dGlvbjtcbiAgICB2aWV3cG9ydEZyYW1lLndpZHRoID0gZGVzdGluYXRpb25GcmFtZS53aWR0aCAqIHJlc29sdXRpb247XG4gICAgdmlld3BvcnRGcmFtZS5oZWlnaHQgPSBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAqIHJlc29sdXRpb247XG4gICAgaWYgKCFyZW5kZXJUZXh0dXJlKSB7XG4gICAgICB2aWV3cG9ydEZyYW1lLnkgPSByZW5kZXJlci52aWV3LmhlaWdodCAtICh2aWV3cG9ydEZyYW1lLnkgKyB2aWV3cG9ydEZyYW1lLmhlaWdodCk7XG4gICAgfVxuICAgIHZpZXdwb3J0RnJhbWUuY2VpbCgpO1xuICAgIHRoaXMucmVuZGVyZXIuZnJhbWVidWZmZXIuYmluZChmcmFtZWJ1ZmZlciwgdmlld3BvcnRGcmFtZSk7XG4gICAgdGhpcy5yZW5kZXJlci5wcm9qZWN0aW9uLnVwZGF0ZShkZXN0aW5hdGlvbkZyYW1lLCBzb3VyY2VGcmFtZSwgcmVzb2x1dGlvbiwgIWZyYW1lYnVmZmVyKTtcbiAgICBpZiAocmVuZGVyVGV4dHVyZSkge1xuICAgICAgdGhpcy5yZW5kZXJlci5tYXNrLnNldE1hc2tTdGFjayhiYXNlVGV4dHVyZS5tYXNrU3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLm1hc2suc2V0TWFza1N0YWNrKHRoaXMuZGVmYXVsdE1hc2tTdGFjayk7XG4gICAgfVxuICAgIHRoaXMuc291cmNlRnJhbWUuY29weUZyb20oc291cmNlRnJhbWUpO1xuICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZS5jb3B5RnJvbShkZXN0aW5hdGlvbkZyYW1lKTtcbiAgfVxuICBjbGVhcihjbGVhckNvbG9yLCBtYXNrKSB7XG4gICAgY29uc3QgZmFsbGJhY2tDb2xvciA9IHRoaXMuY3VycmVudCA/IHRoaXMuY3VycmVudC5iYXNlVGV4dHVyZS5jbGVhciA6IHRoaXMucmVuZGVyZXIuYmFja2dyb3VuZC5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgY29uc3QgY29sb3IkMSA9IGNvbG9yLkNvbG9yLnNoYXJlZC5zZXRWYWx1ZShjbGVhckNvbG9yID8gY2xlYXJDb2xvciA6IGZhbGxiYWNrQ29sb3IpO1xuICAgIGlmICh0aGlzLmN1cnJlbnQgJiYgdGhpcy5jdXJyZW50LmJhc2VUZXh0dXJlLmFscGhhTW9kZSA+IDAgfHwgIXRoaXMuY3VycmVudCAmJiB0aGlzLl9yZW5kZXJlclByZW11bHRpcGxpZWRBbHBoYSkge1xuICAgICAgY29sb3IkMS5wcmVtdWx0aXBseShjb2xvciQxLmFscGhhKTtcbiAgICB9XG4gICAgY29uc3QgZGVzdGluYXRpb25GcmFtZSA9IHRoaXMuZGVzdGluYXRpb25GcmFtZTtcbiAgICBjb25zdCBiYXNlRnJhbWUgPSB0aGlzLmN1cnJlbnQgPyB0aGlzLmN1cnJlbnQuYmFzZVRleHR1cmUgOiB0aGlzLnJlbmRlcmVyLl92aWV3LnNjcmVlbjtcbiAgICBjb25zdCBjbGVhck1hc2sgPSBkZXN0aW5hdGlvbkZyYW1lLndpZHRoICE9PSBiYXNlRnJhbWUud2lkdGggfHwgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgIT09IGJhc2VGcmFtZS5oZWlnaHQ7XG4gICAgaWYgKGNsZWFyTWFzaykge1xuICAgICAgbGV0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy52aWV3cG9ydEZyYW1lO1xuICAgICAgeCA9IE1hdGgucm91bmQoeCk7XG4gICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICAgIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCk7XG4gICAgICBoZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCk7XG4gICAgICB0aGlzLnJlbmRlcmVyLmdsLmVuYWJsZSh0aGlzLnJlbmRlcmVyLmdsLlNDSVNTT1JfVEVTVCk7XG4gICAgICB0aGlzLnJlbmRlcmVyLmdsLnNjaXNzb3IoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZXIuZnJhbWVidWZmZXIuY2xlYXIoY29sb3IkMS5yZWQsIGNvbG9yJDEuZ3JlZW4sIGNvbG9yJDEuYmx1ZSwgY29sb3IkMS5hbHBoYSwgbWFzayk7XG4gICAgaWYgKGNsZWFyTWFzaykge1xuICAgICAgdGhpcy5yZW5kZXJlci5zY2lzc29yLnBvcCgpO1xuICAgIH1cbiAgfVxuICByZXNpemUoKSB7XG4gICAgdGhpcy5iaW5kKG51bGwpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuYmluZChudWxsKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG5SZW5kZXJUZXh0dXJlU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcInJlbmRlclRleHR1cmVcIlxufTtcbmV4dGVuc2lvbnMuZXh0ZW5zaW9ucy5hZGQoUmVuZGVyVGV4dHVyZVN5c3RlbSk7XG5cbmV4cG9ydHMuUmVuZGVyVGV4dHVyZVN5c3RlbSA9IFJlbmRlclRleHR1cmVTeXN0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW5kZXJUZXh0dXJlU3lzdGVtLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZXh0ZW5zaW9ucyA9IHJlcXVpcmUoJ0BwaXhpL2V4dGVuc2lvbnMnKTtcblxuY2xhc3MgT2JqZWN0UmVuZGVyZXJTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICByZW5kZXIoZGlzcGxheU9iamVjdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBsZXQgcmVuZGVyVGV4dHVyZTtcbiAgICBsZXQgY2xlYXI7XG4gICAgbGV0IHRyYW5zZm9ybTtcbiAgICBsZXQgc2tpcFVwZGF0ZVRyYW5zZm9ybTtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgcmVuZGVyVGV4dHVyZSA9IG9wdGlvbnMucmVuZGVyVGV4dHVyZTtcbiAgICAgIGNsZWFyID0gb3B0aW9ucy5jbGVhcjtcbiAgICAgIHRyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuICAgICAgc2tpcFVwZGF0ZVRyYW5zZm9ybSA9IG9wdGlvbnMuc2tpcFVwZGF0ZVRyYW5zZm9ybTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJpbmdUb1NjcmVlbiA9ICFyZW5kZXJUZXh0dXJlO1xuICAgIHJlbmRlcmVyLnJ1bm5lcnMucHJlcmVuZGVyLmVtaXQoKTtcbiAgICByZW5kZXJlci5lbWl0KFwicHJlcmVuZGVyXCIpO1xuICAgIHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGlmIChyZW5kZXJlci5jb250ZXh0LmlzTG9zdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXJlbmRlclRleHR1cmUpIHtcbiAgICAgIHRoaXMubGFzdE9iamVjdFJlbmRlcmVkID0gZGlzcGxheU9iamVjdDtcbiAgICB9XG4gICAgaWYgKCFza2lwVXBkYXRlVHJhbnNmb3JtKSB7XG4gICAgICBjb25zdCBjYWNoZVBhcmVudCA9IGRpc3BsYXlPYmplY3QuZW5hYmxlVGVtcFBhcmVudCgpO1xuICAgICAgZGlzcGxheU9iamVjdC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgIGRpc3BsYXlPYmplY3QuZGlzYWJsZVRlbXBQYXJlbnQoY2FjaGVQYXJlbnQpO1xuICAgIH1cbiAgICByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQocmVuZGVyVGV4dHVyZSk7XG4gICAgcmVuZGVyZXIuYmF0Y2guY3VycmVudFJlbmRlcmVyLnN0YXJ0KCk7XG4gICAgaWYgKGNsZWFyID8/IHJlbmRlcmVyLmJhY2tncm91bmQuY2xlYXJCZWZvcmVSZW5kZXIpIHtcbiAgICAgIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuY2xlYXIoKTtcbiAgICB9XG4gICAgZGlzcGxheU9iamVjdC5yZW5kZXIocmVuZGVyZXIpO1xuICAgIHJlbmRlcmVyLmJhdGNoLmN1cnJlbnRSZW5kZXJlci5mbHVzaCgpO1xuICAgIGlmIChyZW5kZXJUZXh0dXJlKSB7XG4gICAgICBpZiAob3B0aW9ucy5ibGl0KSB7XG4gICAgICAgIHJlbmRlcmVyLmZyYW1lYnVmZmVyLmJsaXQoKTtcbiAgICAgIH1cbiAgICAgIHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUudXBkYXRlKCk7XG4gICAgfVxuICAgIHJlbmRlcmVyLnJ1bm5lcnMucG9zdHJlbmRlci5lbWl0KCk7XG4gICAgcmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0gPSBudWxsO1xuICAgIHJlbmRlcmVyLmVtaXQoXCJwb3N0cmVuZGVyXCIpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5sYXN0T2JqZWN0UmVuZGVyZWQgPSBudWxsO1xuICB9XG59XG5PYmplY3RSZW5kZXJlclN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJvYmplY3RSZW5kZXJlclwiXG59O1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmFkZChPYmplY3RSZW5kZXJlclN5c3RlbSk7XG5cbmV4cG9ydHMuT2JqZWN0UmVuZGVyZXJTeXN0ZW0gPSBPYmplY3RSZW5kZXJlclN5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdFJlbmRlcmVyU3lzdGVtLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnQHBpeGkvY29uc3RhbnRzJyk7XG52YXIgc2V0dGluZ3MgPSByZXF1aXJlKCdAcGl4aS9zZXR0aW5ncycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQHBpeGkvdXRpbHMnKTtcbnZhciBCYXRjaFJlbmRlcmVyID0gcmVxdWlyZSgnLi9iYXRjaC9CYXRjaFJlbmRlcmVyLmpzJyk7XG52YXIgRmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXJzL0ZpbHRlci5qcycpO1xudmFyIFByb2dyYW0gPSByZXF1aXJlKCcuL3NoYWRlci9Qcm9ncmFtLmpzJyk7XG5yZXF1aXJlKCcuL3N5c3RlbXMuanMnKTtcbnZhciBCYXNlVGV4dHVyZSA9IHJlcXVpcmUoJy4vdGV4dHVyZXMvQmFzZVRleHR1cmUuanMnKTtcbnZhciBDb250ZXh0U3lzdGVtID0gcmVxdWlyZSgnLi9jb250ZXh0L0NvbnRleHRTeXN0ZW0uanMnKTtcbnZhciBCYWNrZ3JvdW5kU3lzdGVtID0gcmVxdWlyZSgnLi9iYWNrZ3JvdW5kL0JhY2tncm91bmRTeXN0ZW0uanMnKTtcbnZhciBWaWV3U3lzdGVtID0gcmVxdWlyZSgnLi92aWV3L1ZpZXdTeXN0ZW0uanMnKTtcbnZhciBTdGFydHVwU3lzdGVtID0gcmVxdWlyZSgnLi9zdGFydHVwL1N0YXJ0dXBTeXN0ZW0uanMnKTtcbnZhciBUZXh0dXJlR0NTeXN0ZW0gPSByZXF1aXJlKCcuL3RleHR1cmVzL1RleHR1cmVHQ1N5c3RlbS5qcycpO1xuXG5zZXR0aW5ncy5zZXR0aW5ncy5QUkVGRVJfRU5WID0gY29uc3RhbnRzLkVOVi5XRUJHTDI7XG5zZXR0aW5ncy5zZXR0aW5ncy5TVFJJQ1RfVEVYVFVSRV9DQUNIRSA9IGZhbHNlO1xuc2V0dGluZ3Muc2V0dGluZ3MuUkVOREVSX09QVElPTlMgPSB7XG4gIC4uLkNvbnRleHRTeXN0ZW0uQ29udGV4dFN5c3RlbS5kZWZhdWx0T3B0aW9ucyxcbiAgLi4uQmFja2dyb3VuZFN5c3RlbS5CYWNrZ3JvdW5kU3lzdGVtLmRlZmF1bHRPcHRpb25zLFxuICAuLi5WaWV3U3lzdGVtLlZpZXdTeXN0ZW0uZGVmYXVsdE9wdGlvbnMsXG4gIC4uLlN0YXJ0dXBTeXN0ZW0uU3RhcnR1cFN5c3RlbS5kZWZhdWx0T3B0aW9uc1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNldHRpbmdzLnNldHRpbmdzLCB7XG4gIFdSQVBfTU9ERToge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy53cmFwTW9kZTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgdXRpbHMuZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLldSQVBfTU9ERSBpcyBkZXByZWNhdGVkLCB1c2UgQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMud3JhcE1vZGVcIik7XG4gICAgICBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy53cmFwTW9kZSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgU0NBTEVfTU9ERToge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5zY2FsZU1vZGU7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5TQ0FMRV9NT0RFIGlzIGRlcHJlY2F0ZWQsIHVzZSBCYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5zY2FsZU1vZGVcIik7XG4gICAgICBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5zY2FsZU1vZGUgPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIE1JUE1BUF9URVhUVVJFUzoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5taXBtYXA7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5NSVBNQVBfVEVYVFVSRVMgaXMgZGVwcmVjYXRlZCwgdXNlIEJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zLm1pcG1hcFwiKTtcbiAgICAgIEJhc2VUZXh0dXJlLkJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zLm1pcG1hcCA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgQU5JU09UUk9QSUNfTEVWRUw6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gQmFzZVRleHR1cmUuQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMuYW5pc290cm9waWNMZXZlbDtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgdXRpbHMuZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLkFOSVNPVFJPUElDX0xFVkVMIGlzIGRlcHJlY2F0ZWQsIHVzZSBCYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5hbmlzb3Ryb3BpY0xldmVsXCIpO1xuICAgICAgQmFzZVRleHR1cmUuQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMuYW5pc290cm9waWNMZXZlbCA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgRklMVEVSX1JFU09MVVRJT046IHtcbiAgICBnZXQoKSB7XG4gICAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuRklMVEVSX1JFU09MVVRJT04gaXMgZGVwcmVjYXRlZCwgdXNlIEZpbHRlci5kZWZhdWx0UmVzb2x1dGlvblwiKTtcbiAgICAgIHJldHVybiBGaWx0ZXIuRmlsdGVyLmRlZmF1bHRSZXNvbHV0aW9uO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBGaWx0ZXIuRmlsdGVyLmRlZmF1bHRSZXNvbHV0aW9uID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICBGSUxURVJfTVVMVElTQU1QTEU6IHtcbiAgICBnZXQoKSB7XG4gICAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuRklMVEVSX01VTFRJU0FNUExFIGlzIGRlcHJlY2F0ZWQsIHVzZSBGaWx0ZXIuZGVmYXVsdE11bHRpc2FtcGxlXCIpO1xuICAgICAgcmV0dXJuIEZpbHRlci5GaWx0ZXIuZGVmYXVsdE11bHRpc2FtcGxlO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBGaWx0ZXIuRmlsdGVyLmRlZmF1bHRNdWx0aXNhbXBsZSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgU1BSSVRFX01BWF9URVhUVVJFUzoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBCYXRjaFJlbmRlcmVyLkJhdGNoUmVuZGVyZXIuZGVmYXVsdE1heFRleHR1cmVzO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuU1BSSVRFX01BWF9URVhUVVJFUyBpcyBkZXByZWNhdGVkLCB1c2UgQmF0Y2hSZW5kZXJlci5kZWZhdWx0TWF4VGV4dHVyZXNcIik7XG4gICAgICBCYXRjaFJlbmRlcmVyLkJhdGNoUmVuZGVyZXIuZGVmYXVsdE1heFRleHR1cmVzID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICBTUFJJVEVfQkFUQ0hfU0laRToge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBCYXRjaFJlbmRlcmVyLkJhdGNoUmVuZGVyZXIuZGVmYXVsdEJhdGNoU2l6ZTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgdXRpbHMuZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLlNQUklURV9CQVRDSF9TSVpFIGlzIGRlcHJlY2F0ZWQsIHVzZSBCYXRjaFJlbmRlcmVyLmRlZmF1bHRCYXRjaFNpemVcIik7XG4gICAgICBCYXRjaFJlbmRlcmVyLkJhdGNoUmVuZGVyZXIuZGVmYXVsdEJhdGNoU2l6ZSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgQ0FOX1VQTE9BRF9TQU1FX0JVRkZFUjoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBCYXRjaFJlbmRlcmVyLkJhdGNoUmVuZGVyZXIuY2FuVXBsb2FkU2FtZUJ1ZmZlcjtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgdXRpbHMuZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLkNBTl9VUExPQURfU0FNRV9CVUZGRVIgaXMgZGVwcmVjYXRlZCwgdXNlIEJhdGNoUmVuZGVyZXIuY2FuVXBsb2FkU2FtZUJ1ZmZlclwiKTtcbiAgICAgIEJhdGNoUmVuZGVyZXIuQmF0Y2hSZW5kZXJlci5jYW5VcGxvYWRTYW1lQnVmZmVyID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICBHQ19NT0RFOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIFRleHR1cmVHQ1N5c3RlbS5UZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdE1vZGU7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5HQ19NT0RFIGlzIGRlcHJlY2F0ZWQsIHVzZSBUZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdE1vZGVcIik7XG4gICAgICBUZXh0dXJlR0NTeXN0ZW0uVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRNb2RlID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICBHQ19NQVhfSURMRToge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBUZXh0dXJlR0NTeXN0ZW0uVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRNYXhJZGxlO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuR0NfTUFYX0lETEUgaXMgZGVwcmVjYXRlZCwgdXNlIFRleHR1cmVHQ1N5c3RlbS5kZWZhdWx0TWF4SWRsZVwiKTtcbiAgICAgIFRleHR1cmVHQ1N5c3RlbS5UZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdE1heElkbGUgPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIEdDX01BWF9DSEVDS19DT1VOVDoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBUZXh0dXJlR0NTeXN0ZW0uVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRDaGVja0NvdW50TWF4O1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuR0NfTUFYX0NIRUNLX0NPVU5UIGlzIGRlcHJlY2F0ZWQsIHVzZSBUZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdENoZWNrQ291bnRNYXhcIik7XG4gICAgICBUZXh0dXJlR0NTeXN0ZW0uVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRDaGVja0NvdW50TWF4ID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICBQUkVDSVNJT05fVkVSVEVYOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIFByb2dyYW0uUHJvZ3JhbS5kZWZhdWx0VmVydGV4UHJlY2lzaW9uO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuUFJFQ0lTSU9OX1ZFUlRFWCBpcyBkZXByZWNhdGVkLCB1c2UgUHJvZ3JhbS5kZWZhdWx0VmVydGV4UHJlY2lzaW9uXCIpO1xuICAgICAgUHJvZ3JhbS5Qcm9ncmFtLmRlZmF1bHRWZXJ0ZXhQcmVjaXNpb24gPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIFBSRUNJU0lPTl9GUkFHTUVOVDoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBQcm9ncmFtLlByb2dyYW0uZGVmYXVsdEZyYWdtZW50UHJlY2lzaW9uO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuUFJFQ0lTSU9OX0ZSQUdNRU5UIGlzIGRlcHJlY2F0ZWQsIHVzZSBQcm9ncmFtLmRlZmF1bHRGcmFnbWVudFByZWNpc2lvblwiKTtcbiAgICAgIFByb2dyYW0uUHJvZ3JhbS5kZWZhdWx0RnJhZ21lbnRQcmVjaXNpb24gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0dGluZ3MuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNsYXNzIElHTFVuaWZvcm1EYXRhIHtcbn1cbmNsYXNzIEdMUHJvZ3JhbSB7XG4gIGNvbnN0cnVjdG9yKHByb2dyYW0sIHVuaWZvcm1EYXRhKSB7XG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICB0aGlzLnVuaWZvcm1EYXRhID0gdW5pZm9ybURhdGE7XG4gICAgdGhpcy51bmlmb3JtR3JvdXBzID0ge307XG4gICAgdGhpcy51bmlmb3JtRGlydHlHcm91cHMgPSB7fTtcbiAgICB0aGlzLnVuaWZvcm1CdWZmZXJCaW5kaW5ncyA9IHt9O1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bmlmb3JtRGF0YSA9IG51bGw7XG4gICAgdGhpcy51bmlmb3JtR3JvdXBzID0gbnVsbDtcbiAgICB0aGlzLnVuaWZvcm1EaXJ0eUdyb3VwcyA9IG51bGw7XG4gICAgdGhpcy51bmlmb3JtQnVmZmVyQmluZGluZ3MgPSBudWxsO1xuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0cy5HTFByb2dyYW0gPSBHTFByb2dyYW07XG5leHBvcnRzLklHTFVuaWZvcm1EYXRhID0gSUdMVW5pZm9ybURhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HTFByb2dyYW0uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCdAcGl4aS9jb25zdGFudHMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BwaXhpL3V0aWxzJyk7XG52YXIgZGVmYXVsdFByb2dyYW0kMSA9IHJlcXVpcmUoJy4vZGVmYXVsdFByb2dyYW0uanMnKTtcbnZhciBkZWZhdWx0UHJvZ3JhbSA9IHJlcXVpcmUoJy4vZGVmYXVsdFByb2dyYW0yLmpzJyk7XG5yZXF1aXJlKCcuL3V0aWxzL2luZGV4LmpzJyk7XG52YXIgc2V0UHJlY2lzaW9uID0gcmVxdWlyZSgnLi91dGlscy9zZXRQcmVjaXNpb24uanMnKTtcbnZhciBnZXRNYXhGcmFnbWVudFByZWNpc2lvbiA9IHJlcXVpcmUoJy4vdXRpbHMvZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24uanMnKTtcblxubGV0IFVJRCA9IDA7XG5jb25zdCBuYW1lQ2FjaGUgPSB7fTtcbmNvbnN0IF9Qcm9ncmFtID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBuYW1lID0gXCJwaXhpLXNoYWRlclwiLCBleHRyYSA9IHt9KSB7XG4gICAgdGhpcy5leHRyYSA9IHt9O1xuICAgIHRoaXMuaWQgPSBVSUQrKztcbiAgICB0aGlzLnZlcnRleFNyYyA9IHZlcnRleFNyYyB8fCBfUHJvZ3JhbS5kZWZhdWx0VmVydGV4U3JjO1xuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBmcmFnbWVudFNyYyB8fCBfUHJvZ3JhbS5kZWZhdWx0RnJhZ21lbnRTcmM7XG4gICAgdGhpcy52ZXJ0ZXhTcmMgPSB0aGlzLnZlcnRleFNyYy50cmltKCk7XG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IHRoaXMuZnJhZ21lbnRTcmMudHJpbSgpO1xuICAgIHRoaXMuZXh0cmEgPSBleHRyYTtcbiAgICBpZiAodGhpcy52ZXJ0ZXhTcmMuc3Vic3RyaW5nKDAsIDgpICE9PSBcIiN2ZXJzaW9uXCIpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1xccysvZywgXCItXCIpO1xuICAgICAgaWYgKG5hbWVDYWNoZVtuYW1lXSkge1xuICAgICAgICBuYW1lQ2FjaGVbbmFtZV0rKztcbiAgICAgICAgbmFtZSArPSBgLSR7bmFtZUNhY2hlW25hbWVdfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lQ2FjaGVbbmFtZV0gPSAxO1xuICAgICAgfVxuICAgICAgdGhpcy52ZXJ0ZXhTcmMgPSBgI2RlZmluZSBTSEFERVJfTkFNRSAke25hbWV9XG4ke3RoaXMudmVydGV4U3JjfWA7XG4gICAgICB0aGlzLmZyYWdtZW50U3JjID0gYCNkZWZpbmUgU0hBREVSX05BTUUgJHtuYW1lfVxuJHt0aGlzLmZyYWdtZW50U3JjfWA7XG4gICAgICB0aGlzLnZlcnRleFNyYyA9IHNldFByZWNpc2lvbi5zZXRQcmVjaXNpb24odGhpcy52ZXJ0ZXhTcmMsIF9Qcm9ncmFtLmRlZmF1bHRWZXJ0ZXhQcmVjaXNpb24sIGNvbnN0YW50cy5QUkVDSVNJT04uSElHSCk7XG4gICAgICB0aGlzLmZyYWdtZW50U3JjID0gc2V0UHJlY2lzaW9uLnNldFByZWNpc2lvbih0aGlzLmZyYWdtZW50U3JjLCBfUHJvZ3JhbS5kZWZhdWx0RnJhZ21lbnRQcmVjaXNpb24sIGdldE1heEZyYWdtZW50UHJlY2lzaW9uLmdldE1heEZyYWdtZW50UHJlY2lzaW9uKCkpO1xuICAgIH1cbiAgICB0aGlzLmdsUHJvZ3JhbXMgPSB7fTtcbiAgICB0aGlzLnN5bmNVbmlmb3JtcyA9IG51bGw7XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0VmVydGV4U3JjKCkge1xuICAgIHJldHVybiBkZWZhdWx0UHJvZ3JhbVtcImRlZmF1bHRcIl07XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0RnJhZ21lbnRTcmMoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRQcm9ncmFtJDFbXCJkZWZhdWx0XCJdO1xuICB9XG4gIHN0YXRpYyBmcm9tKHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIG5hbWUpIHtcbiAgICBjb25zdCBrZXkgPSB2ZXJ0ZXhTcmMgKyBmcmFnbWVudFNyYztcbiAgICBsZXQgcHJvZ3JhbSA9IHV0aWxzLlByb2dyYW1DYWNoZVtrZXldO1xuICAgIGlmICghcHJvZ3JhbSkge1xuICAgICAgdXRpbHMuUHJvZ3JhbUNhY2hlW2tleV0gPSBwcm9ncmFtID0gbmV3IF9Qcm9ncmFtKHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvZ3JhbTtcbiAgfVxufTtcbmxldCBQcm9ncmFtID0gX1Byb2dyYW07XG5Qcm9ncmFtLmRlZmF1bHRWZXJ0ZXhQcmVjaXNpb24gPSBjb25zdGFudHMuUFJFQ0lTSU9OLkhJR0g7XG5Qcm9ncmFtLmRlZmF1bHRGcmFnbWVudFByZWNpc2lvbiA9IHV0aWxzLmlzTW9iaWxlLmFwcGxlLmRldmljZSA/IGNvbnN0YW50cy5QUkVDSVNJT04uSElHSCA6IGNvbnN0YW50cy5QUkVDSVNJT04uTUVESVVNO1xuXG5leHBvcnRzLlByb2dyYW0gPSBQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJvZ3JhbS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHJ1bm5lciA9IHJlcXVpcmUoJ0BwaXhpL3J1bm5lcicpO1xudmFyIFByb2dyYW0gPSByZXF1aXJlKCcuL1Byb2dyYW0uanMnKTtcbnZhciBVbmlmb3JtR3JvdXAgPSByZXF1aXJlKCcuL1VuaWZvcm1Hcm91cC5qcycpO1xuXG5jbGFzcyBTaGFkZXIge1xuICBjb25zdHJ1Y3Rvcihwcm9ncmFtLCB1bmlmb3Jtcykge1xuICAgIHRoaXMudW5pZm9ybUJpbmRDb3VudCA9IDA7XG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICBpZiAodW5pZm9ybXMpIHtcbiAgICAgIGlmICh1bmlmb3JtcyBpbnN0YW5jZW9mIFVuaWZvcm1Hcm91cC5Vbmlmb3JtR3JvdXApIHtcbiAgICAgICAgdGhpcy51bmlmb3JtR3JvdXAgPSB1bmlmb3JtcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudW5pZm9ybUdyb3VwID0gbmV3IFVuaWZvcm1Hcm91cC5Vbmlmb3JtR3JvdXAodW5pZm9ybXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuaWZvcm1Hcm91cCA9IG5ldyBVbmlmb3JtR3JvdXAuVW5pZm9ybUdyb3VwKHt9KTtcbiAgICB9XG4gICAgdGhpcy5kaXNwb3NlUnVubmVyID0gbmV3IHJ1bm5lci5SdW5uZXIoXCJkaXNwb3NlU2hhZGVyXCIpO1xuICB9XG4gIGNoZWNrVW5pZm9ybUV4aXN0cyhuYW1lLCBncm91cCkge1xuICAgIGlmIChncm91cC51bmlmb3Jtc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaSBpbiBncm91cC51bmlmb3Jtcykge1xuICAgICAgY29uc3QgdW5pZm9ybSA9IGdyb3VwLnVuaWZvcm1zW2ldO1xuICAgICAgaWYgKHVuaWZvcm0uZ3JvdXApIHtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tVbmlmb3JtRXhpc3RzKG5hbWUsIHVuaWZvcm0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bmlmb3JtR3JvdXAgPSBudWxsO1xuICAgIHRoaXMuZGlzcG9zZVJ1bm5lci5lbWl0KHRoaXMpO1xuICAgIHRoaXMuZGlzcG9zZVJ1bm5lci5kZXN0cm95KCk7XG4gIH1cbiAgZ2V0IHVuaWZvcm1zKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1Hcm91cC51bmlmb3JtcztcbiAgfVxuICBzdGF0aWMgZnJvbSh2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCB1bmlmb3Jtcykge1xuICAgIGNvbnN0IHByb2dyYW0gPSBQcm9ncmFtLlByb2dyYW0uZnJvbSh2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjKTtcbiAgICByZXR1cm4gbmV3IFNoYWRlcihwcm9ncmFtLCB1bmlmb3Jtcyk7XG4gIH1cbn1cblxuZXhwb3J0cy5TaGFkZXIgPSBTaGFkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaGFkZXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBleHRlbnNpb25zID0gcmVxdWlyZSgnQHBpeGkvZXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi91dGlscy9pbmRleC5qcycpO1xudmFyIGdlbmVyYXRlUHJvZ3JhbSA9IHJlcXVpcmUoJy4vdXRpbHMvZ2VuZXJhdGVQcm9ncmFtLmpzJyk7XG52YXIgZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYyA9IHJlcXVpcmUoJy4vdXRpbHMvZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYy5qcycpO1xudmFyIHVuc2FmZUV2YWxTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL3V0aWxzL3Vuc2FmZUV2YWxTdXBwb3J0ZWQuanMnKTtcbnZhciBnZW5lcmF0ZVVuaWZvcm1zU3luYyA9IHJlcXVpcmUoJy4vdXRpbHMvZ2VuZXJhdGVVbmlmb3Jtc1N5bmMuanMnKTtcblxubGV0IFVJRCA9IDA7XG5jb25zdCBkZWZhdWx0U3luY0RhdGEgPSB7IHRleHR1cmVDb3VudDogMCwgdWJvQ291bnQ6IDAgfTtcbmNsYXNzIFNoYWRlclN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5zeXN0ZW1DaGVjaygpO1xuICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICB0aGlzLl91Ym9DYWNoZSA9IHt9O1xuICAgIHRoaXMuaWQgPSBVSUQrKztcbiAgfVxuICBzeXN0ZW1DaGVjaygpIHtcbiAgICBpZiAoIXVuc2FmZUV2YWxTdXBwb3J0ZWQudW5zYWZlRXZhbFN1cHBvcnRlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IGFsbG93IHVuc2FmZS1ldmFsLCBwbGVhc2UgdXNlIEBwaXhpL3Vuc2FmZS1ldmFsIG1vZHVsZSB0byBlbmFibGUgc3VwcG9ydC5cIik7XG4gICAgfVxuICB9XG4gIGNvbnRleHRDaGFuZ2UoZ2wpIHtcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG4gIGJpbmQoc2hhZGVyLCBkb250U3luYykge1xuICAgIHNoYWRlci5kaXNwb3NlUnVubmVyLmFkZCh0aGlzKTtcbiAgICBzaGFkZXIudW5pZm9ybXMuZ2xvYmFscyA9IHRoaXMucmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXM7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHNoYWRlci5wcm9ncmFtO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IHByb2dyYW0uZ2xQcm9ncmFtc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXSB8fCB0aGlzLmdlbmVyYXRlUHJvZ3JhbShzaGFkZXIpO1xuICAgIHRoaXMuc2hhZGVyID0gc2hhZGVyO1xuICAgIGlmICh0aGlzLnByb2dyYW0gIT09IHByb2dyYW0pIHtcbiAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICB0aGlzLmdsLnVzZVByb2dyYW0oZ2xQcm9ncmFtLnByb2dyYW0pO1xuICAgIH1cbiAgICBpZiAoIWRvbnRTeW5jKSB7XG4gICAgICBkZWZhdWx0U3luY0RhdGEudGV4dHVyZUNvdW50ID0gMDtcbiAgICAgIGRlZmF1bHRTeW5jRGF0YS51Ym9Db3VudCA9IDA7XG4gICAgICB0aGlzLnN5bmNVbmlmb3JtR3JvdXAoc2hhZGVyLnVuaWZvcm1Hcm91cCwgZGVmYXVsdFN5bmNEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGdsUHJvZ3JhbTtcbiAgfVxuICBzZXRVbmlmb3Jtcyh1bmlmb3Jtcykge1xuICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuc2hhZGVyLnByb2dyYW07XG4gICAgY29uc3QgZ2xQcm9ncmFtID0gc2hhZGVyLmdsUHJvZ3JhbXNbdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRF07XG4gICAgc2hhZGVyLnN5bmNVbmlmb3JtcyhnbFByb2dyYW0udW5pZm9ybURhdGEsIHVuaWZvcm1zLCB0aGlzLnJlbmRlcmVyKTtcbiAgfVxuICBzeW5jVW5pZm9ybUdyb3VwKGdyb3VwLCBzeW5jRGF0YSkge1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IHRoaXMuZ2V0R2xQcm9ncmFtKCk7XG4gICAgaWYgKCFncm91cC5zdGF0aWMgfHwgZ3JvdXAuZGlydHlJZCAhPT0gZ2xQcm9ncmFtLnVuaWZvcm1EaXJ0eUdyb3Vwc1tncm91cC5pZF0pIHtcbiAgICAgIGdsUHJvZ3JhbS51bmlmb3JtRGlydHlHcm91cHNbZ3JvdXAuaWRdID0gZ3JvdXAuZGlydHlJZDtcbiAgICAgIHRoaXMuc3luY1VuaWZvcm1zKGdyb3VwLCBnbFByb2dyYW0sIHN5bmNEYXRhKTtcbiAgICB9XG4gIH1cbiAgc3luY1VuaWZvcm1zKGdyb3VwLCBnbFByb2dyYW0sIHN5bmNEYXRhKSB7XG4gICAgY29uc3Qgc3luY0Z1bmMgPSBncm91cC5zeW5jVW5pZm9ybXNbdGhpcy5zaGFkZXIucHJvZ3JhbS5pZF0gfHwgdGhpcy5jcmVhdGVTeW5jR3JvdXBzKGdyb3VwKTtcbiAgICBzeW5jRnVuYyhnbFByb2dyYW0udW5pZm9ybURhdGEsIGdyb3VwLnVuaWZvcm1zLCB0aGlzLnJlbmRlcmVyLCBzeW5jRGF0YSk7XG4gIH1cbiAgY3JlYXRlU3luY0dyb3Vwcyhncm91cCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXRTaWduYXR1cmUoZ3JvdXAsIHRoaXMuc2hhZGVyLnByb2dyYW0udW5pZm9ybURhdGEsIFwidVwiKTtcbiAgICBpZiAoIXRoaXMuY2FjaGVbaWRdKSB7XG4gICAgICB0aGlzLmNhY2hlW2lkXSA9IGdlbmVyYXRlVW5pZm9ybXNTeW5jLmdlbmVyYXRlVW5pZm9ybXNTeW5jKGdyb3VwLCB0aGlzLnNoYWRlci5wcm9ncmFtLnVuaWZvcm1EYXRhKTtcbiAgICB9XG4gICAgZ3JvdXAuc3luY1VuaWZvcm1zW3RoaXMuc2hhZGVyLnByb2dyYW0uaWRdID0gdGhpcy5jYWNoZVtpZF07XG4gICAgcmV0dXJuIGdyb3VwLnN5bmNVbmlmb3Jtc1t0aGlzLnNoYWRlci5wcm9ncmFtLmlkXTtcbiAgfVxuICBzeW5jVW5pZm9ybUJ1ZmZlckdyb3VwKGdyb3VwLCBuYW1lKSB7XG4gICAgY29uc3QgZ2xQcm9ncmFtID0gdGhpcy5nZXRHbFByb2dyYW0oKTtcbiAgICBpZiAoIWdyb3VwLnN0YXRpYyB8fCBncm91cC5kaXJ0eUlkICE9PSAwIHx8ICFnbFByb2dyYW0udW5pZm9ybUdyb3Vwc1tncm91cC5pZF0pIHtcbiAgICAgIGdyb3VwLmRpcnR5SWQgPSAwO1xuICAgICAgY29uc3Qgc3luY0Z1bmMgPSBnbFByb2dyYW0udW5pZm9ybUdyb3Vwc1tncm91cC5pZF0gfHwgdGhpcy5jcmVhdGVTeW5jQnVmZmVyR3JvdXAoZ3JvdXAsIGdsUHJvZ3JhbSwgbmFtZSk7XG4gICAgICBncm91cC5idWZmZXIudXBkYXRlKCk7XG4gICAgICBzeW5jRnVuYyhnbFByb2dyYW0udW5pZm9ybURhdGEsIGdyb3VwLnVuaWZvcm1zLCB0aGlzLnJlbmRlcmVyLCBkZWZhdWx0U3luY0RhdGEsIGdyb3VwLmJ1ZmZlcik7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZXIuYnVmZmVyLmJpbmRCdWZmZXJCYXNlKGdyb3VwLmJ1ZmZlciwgZ2xQcm9ncmFtLnVuaWZvcm1CdWZmZXJCaW5kaW5nc1tuYW1lXSk7XG4gIH1cbiAgY3JlYXRlU3luY0J1ZmZlckdyb3VwKGdyb3VwLCBnbFByb2dyYW0sIG5hbWUpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIHRoaXMucmVuZGVyZXIuYnVmZmVyLmJpbmQoZ3JvdXAuYnVmZmVyKTtcbiAgICBjb25zdCB1bmlmb3JtQmxvY2tJbmRleCA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUJsb2NrSW5kZXgoZ2xQcm9ncmFtLnByb2dyYW0sIG5hbWUpO1xuICAgIGdsUHJvZ3JhbS51bmlmb3JtQnVmZmVyQmluZGluZ3NbbmFtZV0gPSB0aGlzLnNoYWRlci51bmlmb3JtQmluZENvdW50O1xuICAgIGdsLnVuaWZvcm1CbG9ja0JpbmRpbmcoZ2xQcm9ncmFtLnByb2dyYW0sIHVuaWZvcm1CbG9ja0luZGV4LCB0aGlzLnNoYWRlci51bmlmb3JtQmluZENvdW50KTtcbiAgICB0aGlzLnNoYWRlci51bmlmb3JtQmluZENvdW50Kys7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldFNpZ25hdHVyZShncm91cCwgdGhpcy5zaGFkZXIucHJvZ3JhbS51bmlmb3JtRGF0YSwgXCJ1Ym9cIik7XG4gICAgbGV0IHVib0RhdGEgPSB0aGlzLl91Ym9DYWNoZVtpZF07XG4gICAgaWYgKCF1Ym9EYXRhKSB7XG4gICAgICB1Ym9EYXRhID0gdGhpcy5fdWJvQ2FjaGVbaWRdID0gZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYy5nZW5lcmF0ZVVuaWZvcm1CdWZmZXJTeW5jKGdyb3VwLCB0aGlzLnNoYWRlci5wcm9ncmFtLnVuaWZvcm1EYXRhKTtcbiAgICB9XG4gICAgaWYgKGdyb3VwLmF1dG9NYW5hZ2UpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHVib0RhdGEuc2l6ZSAvIDQpO1xuICAgICAgZ3JvdXAuYnVmZmVyLnVwZGF0ZShkYXRhKTtcbiAgICB9XG4gICAgZ2xQcm9ncmFtLnVuaWZvcm1Hcm91cHNbZ3JvdXAuaWRdID0gdWJvRGF0YS5zeW5jRnVuYztcbiAgICByZXR1cm4gZ2xQcm9ncmFtLnVuaWZvcm1Hcm91cHNbZ3JvdXAuaWRdO1xuICB9XG4gIGdldFNpZ25hdHVyZShncm91cCwgdW5pZm9ybURhdGEsIHByZUZpeCkge1xuICAgIGNvbnN0IHVuaWZvcm1zID0gZ3JvdXAudW5pZm9ybXM7XG4gICAgY29uc3Qgc3RyaW5ncyA9IFtgJHtwcmVGaXh9LWBdO1xuICAgIGZvciAoY29uc3QgaSBpbiB1bmlmb3Jtcykge1xuICAgICAgc3RyaW5ncy5wdXNoKGkpO1xuICAgICAgaWYgKHVuaWZvcm1EYXRhW2ldKSB7XG4gICAgICAgIHN0cmluZ3MucHVzaCh1bmlmb3JtRGF0YVtpXS50eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ3Muam9pbihcIi1cIik7XG4gIH1cbiAgZ2V0R2xQcm9ncmFtKCkge1xuICAgIGlmICh0aGlzLnNoYWRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuc2hhZGVyLnByb2dyYW0uZ2xQcm9ncmFtc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2VuZXJhdGVQcm9ncmFtKHNoYWRlcikge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBjb25zdCBwcm9ncmFtID0gc2hhZGVyLnByb2dyYW07XG4gICAgY29uc3QgZ2xQcm9ncmFtID0gZ2VuZXJhdGVQcm9ncmFtLmdlbmVyYXRlUHJvZ3JhbShnbCwgcHJvZ3JhbSk7XG4gICAgcHJvZ3JhbS5nbFByb2dyYW1zW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdID0gZ2xQcm9ncmFtO1xuICAgIHJldHVybiBnbFByb2dyYW07XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gIH1cbiAgZGlzcG9zZVNoYWRlcihzaGFkZXIpIHtcbiAgICBpZiAodGhpcy5zaGFkZXIgPT09IHNoYWRlcikge1xuICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxufVxuU2hhZGVyU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcInNoYWRlclwiXG59O1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmFkZChTaGFkZXJTeXN0ZW0pO1xuXG5leHBvcnRzLlNoYWRlclN5c3RlbSA9IFNoYWRlclN5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNoYWRlclN5c3RlbS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ0BwaXhpL2NvbnN0YW50cycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L0J1ZmZlci5qcycpO1xuXG5sZXQgVUlEID0gMDtcbmNsYXNzIFVuaWZvcm1Hcm91cCB7XG4gIGNvbnN0cnVjdG9yKHVuaWZvcm1zLCBpc1N0YXRpYywgaXNVYm8pIHtcbiAgICB0aGlzLmdyb3VwID0gdHJ1ZTtcbiAgICB0aGlzLnN5bmNVbmlmb3JtcyA9IHt9O1xuICAgIHRoaXMuZGlydHlJZCA9IDA7XG4gICAgdGhpcy5pZCA9IFVJRCsrO1xuICAgIHRoaXMuc3RhdGljID0gISFpc1N0YXRpYztcbiAgICB0aGlzLnVibyA9ICEhaXNVYm87XG4gICAgaWYgKHVuaWZvcm1zIGluc3RhbmNlb2YgQnVmZmVyLkJ1ZmZlcikge1xuICAgICAgdGhpcy5idWZmZXIgPSB1bmlmb3JtcztcbiAgICAgIHRoaXMuYnVmZmVyLnR5cGUgPSBjb25zdGFudHMuQlVGRkVSX1RZUEUuVU5JRk9STV9CVUZGRVI7XG4gICAgICB0aGlzLmF1dG9NYW5hZ2UgPSBmYWxzZTtcbiAgICAgIHRoaXMudWJvID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmlmb3JtcyA9IHVuaWZvcm1zO1xuICAgICAgaWYgKHRoaXMudWJvKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlci5CdWZmZXIobmV3IEZsb2F0MzJBcnJheSgxKSk7XG4gICAgICAgIHRoaXMuYnVmZmVyLnR5cGUgPSBjb25zdGFudHMuQlVGRkVSX1RZUEUuVU5JRk9STV9CVUZGRVI7XG4gICAgICAgIHRoaXMuYXV0b01hbmFnZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLmRpcnR5SWQrKztcbiAgICBpZiAoIXRoaXMuYXV0b01hbmFnZSAmJiB0aGlzLmJ1ZmZlcikge1xuICAgICAgdGhpcy5idWZmZXIudXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIGFkZChuYW1lLCB1bmlmb3JtcywgX3N0YXRpYykge1xuICAgIGlmICghdGhpcy51Ym8pIHtcbiAgICAgIHRoaXMudW5pZm9ybXNbbmFtZV0gPSBuZXcgVW5pZm9ybUdyb3VwKHVuaWZvcm1zLCBfc3RhdGljKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1VuaWZvcm1Hcm91cF0gdW5pZm9ybSBncm91cHMgaW4gdWJvIG1vZGUgY2Fubm90IGJlIG1vZGlmaWVkLCBvciBoYXZlIHVuaWZvcm0gZ3JvdXBzIG5lc3RlZCBpbiB0aGVtXCIpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbSh1bmlmb3JtcywgX3N0YXRpYywgX3Vibykge1xuICAgIHJldHVybiBuZXcgVW5pZm9ybUdyb3VwKHVuaWZvcm1zLCBfc3RhdGljLCBfdWJvKTtcbiAgfVxuICBzdGF0aWMgdWJvRnJvbSh1bmlmb3JtcywgX3N0YXRpYykge1xuICAgIHJldHVybiBuZXcgVW5pZm9ybUdyb3VwKHVuaWZvcm1zLCBfc3RhdGljID8/IHRydWUsIHRydWUpO1xuICB9XG59XG5cbmV4cG9ydHMuVW5pZm9ybUdyb3VwID0gVW5pZm9ybUdyb3VwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VW5pZm9ybUdyb3VwLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZGVmYXVsdEZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG5cXG52b2lkIG1haW4odm9pZCl7XFxuICAgZ2xfRnJhZ0NvbG9yICo9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxufVwiO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGRlZmF1bHRGcmFnbWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRQcm9ncmFtLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZGVmYXVsdFZlcnRleCA9IFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudm9pZCBtYWluKHZvaWQpe1xcbiAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcbiAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcbn1cXG5cIjtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBkZWZhdWx0VmVydGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdFByb2dyYW0yLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jb25zdCBmcmFnVGVtcGxhdGUgPSBbXG4gIFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XCIsXG4gIFwidm9pZCBtYWluKHZvaWQpe1wiLFxuICBcImZsb2F0IHRlc3QgPSAwLjE7XCIsXG4gIFwiJWZvcmxvb3AlXCIsXG4gIFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjApO1wiLFxuICBcIn1cIlxuXS5qb2luKFwiXFxuXCIpO1xuZnVuY3Rpb24gZ2VuZXJhdGVJZlRlc3RTcmMobWF4SWZzKSB7XG4gIGxldCBzcmMgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1heElmczsgKytpKSB7XG4gICAgaWYgKGkgPiAwKSB7XG4gICAgICBzcmMgKz0gXCJcXG5lbHNlIFwiO1xuICAgIH1cbiAgICBpZiAoaSA8IG1heElmcyAtIDEpIHtcbiAgICAgIHNyYyArPSBgaWYodGVzdCA9PSAke2l9LjApe31gO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3JjO1xufVxuZnVuY3Rpb24gY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlcihtYXhJZnMsIGdsKSB7XG4gIGlmIChtYXhJZnMgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIG9mIGAwYCBwYXNzZWQgdG8gYGNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXJgXCIpO1xuICB9XG4gIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IGZyYWdtZW50U3JjID0gZnJhZ1RlbXBsYXRlLnJlcGxhY2UoLyVmb3Jsb29wJS9naSwgZ2VuZXJhdGVJZlRlc3RTcmMobWF4SWZzKSk7XG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgZnJhZ21lbnRTcmMpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgbWF4SWZzID0gbWF4SWZzIC8gMiB8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF4SWZzO1xufVxuXG5leHBvcnRzLmNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIgPSBjaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlci5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gY29tcGlsZVNoYWRlcihnbCwgdHlwZSwgc3JjKSB7XG4gIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc3JjKTtcbiAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICByZXR1cm4gc2hhZGVyO1xufVxuXG5leHBvcnRzLmNvbXBpbGVTaGFkZXIgPSBjb21waWxlU2hhZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGlsZVNoYWRlci5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gYm9vbGVhbkFycmF5KHNpemUpIHtcbiAgY29uc3QgYXJyYXkgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJheVtpXSA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRWYWx1ZSh0eXBlLCBzaXplKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJmbG9hdFwiOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSBcInZlYzJcIjpcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KDIgKiBzaXplKTtcbiAgICBjYXNlIFwidmVjM1wiOlxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoMyAqIHNpemUpO1xuICAgIGNhc2UgXCJ2ZWM0XCI6XG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSg0ICogc2l6ZSk7XG4gICAgY2FzZSBcImludFwiOlxuICAgIGNhc2UgXCJ1aW50XCI6XG4gICAgY2FzZSBcInNhbXBsZXIyRFwiOlxuICAgIGNhc2UgXCJzYW1wbGVyMkRBcnJheVwiOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSBcIml2ZWMyXCI6XG4gICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoMiAqIHNpemUpO1xuICAgIGNhc2UgXCJpdmVjM1wiOlxuICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KDMgKiBzaXplKTtcbiAgICBjYXNlIFwiaXZlYzRcIjpcbiAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheSg0ICogc2l6ZSk7XG4gICAgY2FzZSBcInV2ZWMyXCI6XG4gICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KDIgKiBzaXplKTtcbiAgICBjYXNlIFwidXZlYzNcIjpcbiAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoMyAqIHNpemUpO1xuICAgIGNhc2UgXCJ1dmVjNFwiOlxuICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheSg0ICogc2l6ZSk7XG4gICAgY2FzZSBcImJvb2xcIjpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjYXNlIFwiYnZlYzJcIjpcbiAgICAgIHJldHVybiBib29sZWFuQXJyYXkoMiAqIHNpemUpO1xuICAgIGNhc2UgXCJidmVjM1wiOlxuICAgICAgcmV0dXJuIGJvb2xlYW5BcnJheSgzICogc2l6ZSk7XG4gICAgY2FzZSBcImJ2ZWM0XCI6XG4gICAgICByZXR1cm4gYm9vbGVhbkFycmF5KDQgKiBzaXplKTtcbiAgICBjYXNlIFwibWF0MlwiOlxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxXG4gICAgICBdKTtcbiAgICBjYXNlIFwibWF0M1wiOlxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxXG4gICAgICBdKTtcbiAgICBjYXNlIFwibWF0NFwiOlxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxXG4gICAgICBdKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0cy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0VmFsdWUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBHTFByb2dyYW0gPSByZXF1aXJlKCcuLi9HTFByb2dyYW0uanMnKTtcbnZhciBjb21waWxlU2hhZGVyID0gcmVxdWlyZSgnLi9jb21waWxlU2hhZGVyLmpzJyk7XG52YXIgZGVmYXVsdFZhbHVlID0gcmVxdWlyZSgnLi9kZWZhdWx0VmFsdWUuanMnKTtcbnZhciBnZXRBdHRyaWJ1dGVEYXRhID0gcmVxdWlyZSgnLi9nZXRBdHRyaWJ1dGVEYXRhLmpzJyk7XG52YXIgZ2V0VW5pZm9ybURhdGEgPSByZXF1aXJlKCcuL2dldFVuaWZvcm1EYXRhLmpzJyk7XG52YXIgbG9nUHJvZ3JhbUVycm9yID0gcmVxdWlyZSgnLi9sb2dQcm9ncmFtRXJyb3IuanMnKTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVQcm9ncmFtKGdsLCBwcm9ncmFtKSB7XG4gIGNvbnN0IGdsVmVydFNoYWRlciA9IGNvbXBpbGVTaGFkZXIuY29tcGlsZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgcHJvZ3JhbS52ZXJ0ZXhTcmMpO1xuICBjb25zdCBnbEZyYWdTaGFkZXIgPSBjb21waWxlU2hhZGVyLmNvbXBpbGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgcHJvZ3JhbS5mcmFnbWVudFNyYyk7XG4gIGNvbnN0IHdlYkdMUHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgZ2wuYXR0YWNoU2hhZGVyKHdlYkdMUHJvZ3JhbSwgZ2xWZXJ0U2hhZGVyKTtcbiAgZ2wuYXR0YWNoU2hhZGVyKHdlYkdMUHJvZ3JhbSwgZ2xGcmFnU2hhZGVyKTtcbiAgY29uc3QgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyA9IHByb2dyYW0uZXh0cmE/LnRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3M7XG4gIGlmICh0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzKSB7XG4gICAgaWYgKHR5cGVvZiBnbC50cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgVHJhbnNmb3JtRmVlZGJhY2sgaXMgbm90IHN1cHBvcnRlZCBidXQgVHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyBhcmUgZ2l2ZW4uYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3Mod2ViR0xQcm9ncmFtLCB0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzLm5hbWVzLCB0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzLmJ1ZmZlck1vZGUgPT09IFwic2VwYXJhdGVcIiA/IGdsLlNFUEFSQVRFX0FUVFJJQlMgOiBnbC5JTlRFUkxFQVZFRF9BVFRSSUJTKTtcbiAgICB9XG4gIH1cbiAgZ2wubGlua1Byb2dyYW0od2ViR0xQcm9ncmFtKTtcbiAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHdlYkdMUHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgbG9nUHJvZ3JhbUVycm9yLmxvZ1Byb2dyYW1FcnJvcihnbCwgd2ViR0xQcm9ncmFtLCBnbFZlcnRTaGFkZXIsIGdsRnJhZ1NoYWRlcik7XG4gIH1cbiAgcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhID0gZ2V0QXR0cmlidXRlRGF0YS5nZXRBdHRyaWJ1dGVEYXRhKHdlYkdMUHJvZ3JhbSwgZ2wpO1xuICBwcm9ncmFtLnVuaWZvcm1EYXRhID0gZ2V0VW5pZm9ybURhdGEuZ2V0VW5pZm9ybURhdGEod2ViR0xQcm9ncmFtLCBnbCk7XG4gIGlmICghL15bIFxcdF0qI1sgXFx0XSp2ZXJzaW9uWyBcXHRdKzMwMFsgXFx0XStlc1sgXFx0XSokL20udGVzdChwcm9ncmFtLnZlcnRleFNyYykpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvZ3JhbS5hdHRyaWJ1dGVEYXRhKTtcbiAgICBrZXlzLnNvcnQoKGEsIGIpID0+IGEgPiBiID8gMSA6IC0xKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb2dyYW0uYXR0cmlidXRlRGF0YVtrZXlzW2ldXS5sb2NhdGlvbiA9IGk7XG4gICAgICBnbC5iaW5kQXR0cmliTG9jYXRpb24od2ViR0xQcm9ncmFtLCBpLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgZ2wubGlua1Byb2dyYW0od2ViR0xQcm9ncmFtKTtcbiAgfVxuICBnbC5kZWxldGVTaGFkZXIoZ2xWZXJ0U2hhZGVyKTtcbiAgZ2wuZGVsZXRlU2hhZGVyKGdsRnJhZ1NoYWRlcik7XG4gIGNvbnN0IHVuaWZvcm1EYXRhID0ge307XG4gIGZvciAoY29uc3QgaSBpbiBwcm9ncmFtLnVuaWZvcm1EYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IHByb2dyYW0udW5pZm9ybURhdGFbaV07XG4gICAgdW5pZm9ybURhdGFbaV0gPSB7XG4gICAgICBsb2NhdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHdlYkdMUHJvZ3JhbSwgaSksXG4gICAgICB2YWx1ZTogZGVmYXVsdFZhbHVlLmRlZmF1bHRWYWx1ZShkYXRhLnR5cGUsIGRhdGEuc2l6ZSlcbiAgICB9O1xuICB9XG4gIGNvbnN0IGdsUHJvZ3JhbSA9IG5ldyBHTFByb2dyYW0uR0xQcm9ncmFtKHdlYkdMUHJvZ3JhbSwgdW5pZm9ybURhdGEpO1xuICByZXR1cm4gZ2xQcm9ncmFtO1xufVxuXG5leHBvcnRzLmdlbmVyYXRlUHJvZ3JhbSA9IGdlbmVyYXRlUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlUHJvZ3JhbS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxucmVxdWlyZSgnLi9pbmRleC5qcycpO1xudmFyIHVuaWZvcm1QYXJzZXJzID0gcmVxdWlyZSgnLi91bmlmb3JtUGFyc2Vycy5qcycpO1xudmFyIG1hcFNpemUgPSByZXF1aXJlKCcuL21hcFNpemUuanMnKTtcblxuZnVuY3Rpb24gdWJvVXBkYXRlKF91ZCwgX3V2LCBfcmVuZGVyZXIsIF9zeW5jRGF0YSwgYnVmZmVyKSB7XG4gIF9yZW5kZXJlci5idWZmZXIudXBkYXRlKGJ1ZmZlcik7XG59XG5jb25zdCBVQk9fVE9fU0lOR0xFX1NFVFRFUlMgPSB7XG4gIGZsb2F0OiBgXG4gICAgICAgIGRhdGFbb2Zmc2V0XSA9IHY7XG4gICAgYCxcbiAgdmVjMjogYFxuICAgICAgICBkYXRhW29mZnNldF0gPSB2WzBdO1xuICAgICAgICBkYXRhW29mZnNldCsxXSA9IHZbMV07XG4gICAgYCxcbiAgdmVjMzogYFxuICAgICAgICBkYXRhW29mZnNldF0gPSB2WzBdO1xuICAgICAgICBkYXRhW29mZnNldCsxXSA9IHZbMV07XG4gICAgICAgIGRhdGFbb2Zmc2V0KzJdID0gdlsyXTtcblxuICAgIGAsXG4gIHZlYzQ6IGBcbiAgICAgICAgZGF0YVtvZmZzZXRdID0gdlswXTtcbiAgICAgICAgZGF0YVtvZmZzZXQrMV0gPSB2WzFdO1xuICAgICAgICBkYXRhW29mZnNldCsyXSA9IHZbMl07XG4gICAgICAgIGRhdGFbb2Zmc2V0KzNdID0gdlszXTtcbiAgICBgLFxuICBtYXQyOiBgXG4gICAgICAgIGRhdGFbb2Zmc2V0XSA9IHZbMF07XG4gICAgICAgIGRhdGFbb2Zmc2V0KzFdID0gdlsxXTtcblxuICAgICAgICBkYXRhW29mZnNldCs0XSA9IHZbMl07XG4gICAgICAgIGRhdGFbb2Zmc2V0KzVdID0gdlszXTtcbiAgICBgLFxuICBtYXQzOiBgXG4gICAgICAgIGRhdGFbb2Zmc2V0XSA9IHZbMF07XG4gICAgICAgIGRhdGFbb2Zmc2V0KzFdID0gdlsxXTtcbiAgICAgICAgZGF0YVtvZmZzZXQrMl0gPSB2WzJdO1xuXG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgNF0gPSB2WzNdO1xuICAgICAgICBkYXRhW29mZnNldCArIDVdID0gdls0XTtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyA2XSA9IHZbNV07XG5cbiAgICAgICAgZGF0YVtvZmZzZXQgKyA4XSA9IHZbNl07XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgOV0gPSB2WzddO1xuICAgICAgICBkYXRhW29mZnNldCArIDEwXSA9IHZbOF07XG4gICAgYCxcbiAgbWF0NDogYFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyBpXSA9IHZbaV07XG4gICAgICAgIH1cbiAgICBgXG59O1xuY29uc3QgR0xTTF9UT19TVEQ0MF9TSVpFID0ge1xuICBmbG9hdDogNCxcbiAgdmVjMjogOCxcbiAgdmVjMzogMTIsXG4gIHZlYzQ6IDE2LFxuICBpbnQ6IDQsXG4gIGl2ZWMyOiA4LFxuICBpdmVjMzogMTIsXG4gIGl2ZWM0OiAxNixcbiAgdWludDogNCxcbiAgdXZlYzI6IDgsXG4gIHV2ZWMzOiAxMixcbiAgdXZlYzQ6IDE2LFxuICBib29sOiA0LFxuICBidmVjMjogOCxcbiAgYnZlYzM6IDEyLFxuICBidmVjNDogMTYsXG4gIG1hdDI6IDE2ICogMixcbiAgbWF0MzogMTYgKiAzLFxuICBtYXQ0OiAxNiAqIDRcbn07XG5mdW5jdGlvbiBjcmVhdGVVQk9FbGVtZW50cyh1bmlmb3JtRGF0YSkge1xuICBjb25zdCB1Ym9FbGVtZW50cyA9IHVuaWZvcm1EYXRhLm1hcCgoZGF0YSkgPT4gKHtcbiAgICBkYXRhLFxuICAgIG9mZnNldDogMCxcbiAgICBkYXRhTGVuOiAwLFxuICAgIGRpcnR5OiAwXG4gIH0pKTtcbiAgbGV0IHNpemUgPSAwO1xuICBsZXQgY2h1bmtTaXplID0gMDtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdWJvRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB1Ym9FbGVtZW50ID0gdWJvRWxlbWVudHNbaV07XG4gICAgc2l6ZSA9IEdMU0xfVE9fU1RENDBfU0laRVt1Ym9FbGVtZW50LmRhdGEudHlwZV07XG4gICAgaWYgKHVib0VsZW1lbnQuZGF0YS5zaXplID4gMSkge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KHNpemUsIDE2KSAqIHVib0VsZW1lbnQuZGF0YS5zaXplO1xuICAgIH1cbiAgICB1Ym9FbGVtZW50LmRhdGFMZW4gPSBzaXplO1xuICAgIGlmIChjaHVua1NpemUgJSBzaXplICE9PSAwICYmIGNodW5rU2l6ZSA8IDE2KSB7XG4gICAgICBjb25zdCBsaW5lVXBWYWx1ZSA9IGNodW5rU2l6ZSAlIHNpemUgJSAxNjtcbiAgICAgIGNodW5rU2l6ZSArPSBsaW5lVXBWYWx1ZTtcbiAgICAgIG9mZnNldCArPSBsaW5lVXBWYWx1ZTtcbiAgICB9XG4gICAgaWYgKGNodW5rU2l6ZSArIHNpemUgPiAxNikge1xuICAgICAgb2Zmc2V0ID0gTWF0aC5jZWlsKG9mZnNldCAvIDE2KSAqIDE2O1xuICAgICAgdWJvRWxlbWVudC5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgKz0gc2l6ZTtcbiAgICAgIGNodW5rU2l6ZSA9IHNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVib0VsZW1lbnQub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgY2h1bmtTaXplICs9IHNpemU7XG4gICAgICBvZmZzZXQgKz0gc2l6ZTtcbiAgICB9XG4gIH1cbiAgb2Zmc2V0ID0gTWF0aC5jZWlsKG9mZnNldCAvIDE2KSAqIDE2O1xuICByZXR1cm4geyB1Ym9FbGVtZW50cywgc2l6ZTogb2Zmc2V0IH07XG59XG5mdW5jdGlvbiBnZXRVQk9EYXRhKHVuaWZvcm1zLCB1bmlmb3JtRGF0YSkge1xuICBjb25zdCB1c2VkVW5pZm9ybURhdGFzID0gW107XG4gIGZvciAoY29uc3QgaSBpbiB1bmlmb3Jtcykge1xuICAgIGlmICh1bmlmb3JtRGF0YVtpXSkge1xuICAgICAgdXNlZFVuaWZvcm1EYXRhcy5wdXNoKHVuaWZvcm1EYXRhW2ldKTtcbiAgICB9XG4gIH1cbiAgdXNlZFVuaWZvcm1EYXRhcy5zb3J0KChhLCBiKSA9PiBhLmluZGV4IC0gYi5pbmRleCk7XG4gIHJldHVybiB1c2VkVW5pZm9ybURhdGFzO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYyhncm91cCwgdW5pZm9ybURhdGEpIHtcbiAgaWYgKCFncm91cC5hdXRvTWFuYWdlKSB7XG4gICAgcmV0dXJuIHsgc2l6ZTogMCwgc3luY0Z1bmM6IHVib1VwZGF0ZSB9O1xuICB9XG4gIGNvbnN0IHVzZWRVbmlmb3JtRGF0YXMgPSBnZXRVQk9EYXRhKGdyb3VwLnVuaWZvcm1zLCB1bmlmb3JtRGF0YSk7XG4gIGNvbnN0IHsgdWJvRWxlbWVudHMsIHNpemUgfSA9IGNyZWF0ZVVCT0VsZW1lbnRzKHVzZWRVbmlmb3JtRGF0YXMpO1xuICBjb25zdCBmdW5jRnJhZ21lbnRzID0gW2BcbiAgICB2YXIgdiA9IG51bGw7XG4gICAgdmFyIHYyID0gbnVsbDtcbiAgICB2YXIgY3YgPSBudWxsO1xuICAgIHZhciB0ID0gMDtcbiAgICB2YXIgZ2wgPSByZW5kZXJlci5nbFxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGRhdGEgPSBidWZmZXIuZGF0YTtcbiAgICBgXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1Ym9FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHVib0VsZW1lbnQgPSB1Ym9FbGVtZW50c1tpXTtcbiAgICBjb25zdCB1bmlmb3JtID0gZ3JvdXAudW5pZm9ybXNbdWJvRWxlbWVudC5kYXRhLm5hbWVdO1xuICAgIGNvbnN0IG5hbWUgPSB1Ym9FbGVtZW50LmRhdGEubmFtZTtcbiAgICBsZXQgcGFyc2VkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB1bmlmb3JtUGFyc2Vycy51bmlmb3JtUGFyc2Vycy5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3QgdW5pZm9ybVBhcnNlciA9IHVuaWZvcm1QYXJzZXJzLnVuaWZvcm1QYXJzZXJzW2pdO1xuICAgICAgaWYgKHVuaWZvcm1QYXJzZXIuY29kZVVibyAmJiB1bmlmb3JtUGFyc2VyLnRlc3QodWJvRWxlbWVudC5kYXRhLCB1bmlmb3JtKSkge1xuICAgICAgICBmdW5jRnJhZ21lbnRzLnB1c2goYG9mZnNldCA9ICR7dWJvRWxlbWVudC5vZmZzZXQgLyA0fTtgLCB1bmlmb3JtUGFyc2Vycy51bmlmb3JtUGFyc2Vyc1tqXS5jb2RlVWJvKHVib0VsZW1lbnQuZGF0YS5uYW1lLCB1bmlmb3JtKSk7XG4gICAgICAgIHBhcnNlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgaWYgKHVib0VsZW1lbnQuZGF0YS5zaXplID4gMSkge1xuICAgICAgICBjb25zdCBzaXplMiA9IG1hcFNpemUubWFwU2l6ZSh1Ym9FbGVtZW50LmRhdGEudHlwZSk7XG4gICAgICAgIGNvbnN0IHJvd1NpemUgPSBNYXRoLm1heChHTFNMX1RPX1NURDQwX1NJWkVbdWJvRWxlbWVudC5kYXRhLnR5cGVdIC8gMTYsIDEpO1xuICAgICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHNpemUyIC8gcm93U2l6ZTtcbiAgICAgICAgY29uc3QgcmVtYWluZGVyID0gKDQgLSBlbGVtZW50U2l6ZSAlIDQpICUgNDtcbiAgICAgICAgZnVuY0ZyYWdtZW50cy5wdXNoKGBcbiAgICAgICAgICAgICAgICBjdiA9IHVkLiR7bmFtZX0udmFsdWU7XG4gICAgICAgICAgICAgICAgdiA9IHV2LiR7bmFtZX07XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gJHt1Ym9FbGVtZW50Lm9mZnNldCAvIDR9O1xuXG4gICAgICAgICAgICAgICAgdCA9IDA7XG5cbiAgICAgICAgICAgICAgICBmb3IodmFyIGk9MDsgaSA8ICR7dWJvRWxlbWVudC5kYXRhLnNpemUgKiByb3dTaXplfTsgaSsrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8ICR7ZWxlbWVudFNpemV9OyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdID0gdlt0KytdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSAke3JlbWFpbmRlcn07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IFVCT19UT19TSU5HTEVfU0VUVEVSU1t1Ym9FbGVtZW50LmRhdGEudHlwZV07XG4gICAgICAgIGZ1bmNGcmFnbWVudHMucHVzaChgXG4gICAgICAgICAgICAgICAgY3YgPSB1ZC4ke25hbWV9LnZhbHVlO1xuICAgICAgICAgICAgICAgIHYgPSB1di4ke25hbWV9O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9ICR7dWJvRWxlbWVudC5vZmZzZXQgLyA0fTtcbiAgICAgICAgICAgICAgICAke3RlbXBsYXRlfTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY0ZyYWdtZW50cy5wdXNoKGBcbiAgICAgICByZW5kZXJlci5idWZmZXIudXBkYXRlKGJ1ZmZlcik7XG4gICAgYCk7XG4gIHJldHVybiB7XG4gICAgc2l6ZSxcbiAgICBzeW5jRnVuYzogbmV3IEZ1bmN0aW9uKFwidWRcIiwgXCJ1dlwiLCBcInJlbmRlcmVyXCIsIFwic3luY0RhdGFcIiwgXCJidWZmZXJcIiwgZnVuY0ZyYWdtZW50cy5qb2luKFwiXFxuXCIpKVxuICB9O1xufVxuXG5leHBvcnRzLmNyZWF0ZVVCT0VsZW1lbnRzID0gY3JlYXRlVUJPRWxlbWVudHM7XG5leHBvcnRzLmdlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMgPSBnZW5lcmF0ZVVuaWZvcm1CdWZmZXJTeW5jO1xuZXhwb3J0cy5nZXRVQk9EYXRhID0gZ2V0VUJPRGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB1bmlmb3JtUGFyc2VycyA9IHJlcXVpcmUoJy4vdW5pZm9ybVBhcnNlcnMuanMnKTtcblxuY29uc3QgR0xTTF9UT19TSU5HTEVfU0VUVEVSU19DQUNIRUQgPSB7XG4gIGZsb2F0OiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuICAgICAgICBnbC51bmlmb3JtMWYobG9jYXRpb24sIHYpO1xuICAgIH1gLFxuICB2ZWMyOiBgXG4gICAgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdKVxuICAgIHtcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICBjdlsxXSA9IHZbMV07XG5cbiAgICAgICAgZ2wudW5pZm9ybTJmKGxvY2F0aW9uLCB2WzBdLCB2WzFdKVxuICAgIH1gLFxuICB2ZWMzOiBgXG4gICAgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdKVxuICAgIHtcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgIGN2WzJdID0gdlsyXTtcblxuICAgICAgICBnbC51bmlmb3JtM2YobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0pXG4gICAgfWAsXG4gIHZlYzQ6IGBcbiAgICBpZiAoY3ZbMF0gIT09IHZbMF0gfHwgY3ZbMV0gIT09IHZbMV0gfHwgY3ZbMl0gIT09IHZbMl0gfHwgY3ZbM10gIT09IHZbM10pXG4gICAge1xuICAgICAgICBjdlswXSA9IHZbMF07XG4gICAgICAgIGN2WzFdID0gdlsxXTtcbiAgICAgICAgY3ZbMl0gPSB2WzJdO1xuICAgICAgICBjdlszXSA9IHZbM107XG5cbiAgICAgICAgZ2wudW5pZm9ybTRmKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdLCB2WzNdKTtcbiAgICB9YCxcbiAgaW50OiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdik7XG4gICAgfWAsXG4gIGl2ZWMyOiBgXG4gICAgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdKVxuICAgIHtcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICBjdlsxXSA9IHZbMV07XG5cbiAgICAgICAgZ2wudW5pZm9ybTJpKGxvY2F0aW9uLCB2WzBdLCB2WzFdKTtcbiAgICB9YCxcbiAgaXZlYzM6IGBcbiAgICBpZiAoY3ZbMF0gIT09IHZbMF0gfHwgY3ZbMV0gIT09IHZbMV0gfHwgY3ZbMl0gIT09IHZbMl0pXG4gICAge1xuICAgICAgICBjdlswXSA9IHZbMF07XG4gICAgICAgIGN2WzFdID0gdlsxXTtcbiAgICAgICAgY3ZbMl0gPSB2WzJdO1xuXG4gICAgICAgIGdsLnVuaWZvcm0zaShsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSk7XG4gICAgfWAsXG4gIGl2ZWM0OiBgXG4gICAgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdIHx8IGN2WzNdICE9PSB2WzNdKVxuICAgIHtcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgIGN2WzJdID0gdlsyXTtcbiAgICAgICAgY3ZbM10gPSB2WzNdO1xuXG4gICAgICAgIGdsLnVuaWZvcm00aShsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSwgdlszXSk7XG4gICAgfWAsXG4gIHVpbnQ6IGBcbiAgICBpZiAoY3YgIT09IHYpXG4gICAge1xuICAgICAgICBjdS52YWx1ZSA9IHY7XG5cbiAgICAgICAgZ2wudW5pZm9ybTF1aShsb2NhdGlvbiwgdik7XG4gICAgfWAsXG4gIHV2ZWMyOiBgXG4gICAgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdKVxuICAgIHtcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICBjdlsxXSA9IHZbMV07XG5cbiAgICAgICAgZ2wudW5pZm9ybTJ1aShsb2NhdGlvbiwgdlswXSwgdlsxXSk7XG4gICAgfWAsXG4gIHV2ZWMzOiBgXG4gICAgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdKVxuICAgIHtcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgIGN2WzJdID0gdlsyXTtcblxuICAgICAgICBnbC51bmlmb3JtM3VpKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdKTtcbiAgICB9YCxcbiAgdXZlYzQ6IGBcbiAgICBpZiAoY3ZbMF0gIT09IHZbMF0gfHwgY3ZbMV0gIT09IHZbMV0gfHwgY3ZbMl0gIT09IHZbMl0gfHwgY3ZbM10gIT09IHZbM10pXG4gICAge1xuICAgICAgICBjdlswXSA9IHZbMF07XG4gICAgICAgIGN2WzFdID0gdlsxXTtcbiAgICAgICAgY3ZbMl0gPSB2WzJdO1xuICAgICAgICBjdlszXSA9IHZbM107XG5cbiAgICAgICAgZ2wudW5pZm9ybTR1aShsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSwgdlszXSk7XG4gICAgfWAsXG4gIGJvb2w6IGBcbiAgICBpZiAoY3YgIT09IHYpXG4gICAge1xuICAgICAgICBjdS52YWx1ZSA9IHY7XG4gICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdik7XG4gICAgfWAsXG4gIGJ2ZWMyOiBgXG4gICAgaWYgKGN2WzBdICE9IHZbMF0gfHwgY3ZbMV0gIT0gdlsxXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuXG4gICAgICAgIGdsLnVuaWZvcm0yaShsb2NhdGlvbiwgdlswXSwgdlsxXSk7XG4gICAgfWAsXG4gIGJ2ZWMzOiBgXG4gICAgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdKVxuICAgIHtcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgIGN2WzJdID0gdlsyXTtcblxuICAgICAgICBnbC51bmlmb3JtM2kobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0pO1xuICAgIH1gLFxuICBidmVjNDogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSB8fCBjdlszXSAhPT0gdlszXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICBjdlsyXSA9IHZbMl07XG4gICAgICAgIGN2WzNdID0gdlszXTtcblxuICAgICAgICBnbC51bmlmb3JtNGkobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0sIHZbM10pO1xuICAgIH1gLFxuICBtYXQyOiBcImdsLnVuaWZvcm1NYXRyaXgyZnYobG9jYXRpb24sIGZhbHNlLCB2KVwiLFxuICBtYXQzOiBcImdsLnVuaWZvcm1NYXRyaXgzZnYobG9jYXRpb24sIGZhbHNlLCB2KVwiLFxuICBtYXQ0OiBcImdsLnVuaWZvcm1NYXRyaXg0ZnYobG9jYXRpb24sIGZhbHNlLCB2KVwiLFxuICBzYW1wbGVyMkQ6IGBcbiAgICBpZiAoY3YgIT09IHYpXG4gICAge1xuICAgICAgICBjdS52YWx1ZSA9IHY7XG5cbiAgICAgICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2KTtcbiAgICB9YCxcbiAgc2FtcGxlckN1YmU6IGBcbiAgICBpZiAoY3YgIT09IHYpXG4gICAge1xuICAgICAgICBjdS52YWx1ZSA9IHY7XG5cbiAgICAgICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2KTtcbiAgICB9YCxcbiAgc2FtcGxlcjJEQXJyYXk6IGBcbiAgICBpZiAoY3YgIT09IHYpXG4gICAge1xuICAgICAgICBjdS52YWx1ZSA9IHY7XG5cbiAgICAgICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2KTtcbiAgICB9YFxufTtcbmNvbnN0IEdMU0xfVE9fQVJSQVlfU0VUVEVSUyA9IHtcbiAgZmxvYXQ6IGBnbC51bmlmb3JtMWZ2KGxvY2F0aW9uLCB2KWAsXG4gIHZlYzI6IGBnbC51bmlmb3JtMmZ2KGxvY2F0aW9uLCB2KWAsXG4gIHZlYzM6IGBnbC51bmlmb3JtM2Z2KGxvY2F0aW9uLCB2KWAsXG4gIHZlYzQ6IFwiZ2wudW5pZm9ybTRmdihsb2NhdGlvbiwgdilcIixcbiAgbWF0NDogXCJnbC51bmlmb3JtTWF0cml4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgbWF0MzogXCJnbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgbWF0MjogXCJnbC51bmlmb3JtTWF0cml4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgaW50OiBcImdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpXCIsXG4gIGl2ZWMyOiBcImdsLnVuaWZvcm0yaXYobG9jYXRpb24sIHYpXCIsXG4gIGl2ZWMzOiBcImdsLnVuaWZvcm0zaXYobG9jYXRpb24sIHYpXCIsXG4gIGl2ZWM0OiBcImdsLnVuaWZvcm00aXYobG9jYXRpb24sIHYpXCIsXG4gIHVpbnQ6IFwiZ2wudW5pZm9ybTF1aXYobG9jYXRpb24sIHYpXCIsXG4gIHV2ZWMyOiBcImdsLnVuaWZvcm0ydWl2KGxvY2F0aW9uLCB2KVwiLFxuICB1dmVjMzogXCJnbC51bmlmb3JtM3Vpdihsb2NhdGlvbiwgdilcIixcbiAgdXZlYzQ6IFwiZ2wudW5pZm9ybTR1aXYobG9jYXRpb24sIHYpXCIsXG4gIGJvb2w6IFwiZ2wudW5pZm9ybTFpdihsb2NhdGlvbiwgdilcIixcbiAgYnZlYzI6IFwiZ2wudW5pZm9ybTJpdihsb2NhdGlvbiwgdilcIixcbiAgYnZlYzM6IFwiZ2wudW5pZm9ybTNpdihsb2NhdGlvbiwgdilcIixcbiAgYnZlYzQ6IFwiZ2wudW5pZm9ybTRpdihsb2NhdGlvbiwgdilcIixcbiAgc2FtcGxlcjJEOiBcImdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpXCIsXG4gIHNhbXBsZXJDdWJlOiBcImdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpXCIsXG4gIHNhbXBsZXIyREFycmF5OiBcImdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpXCJcbn07XG5mdW5jdGlvbiBnZW5lcmF0ZVVuaWZvcm1zU3luYyhncm91cCwgdW5pZm9ybURhdGEpIHtcbiAgY29uc3QgZnVuY0ZyYWdtZW50cyA9IFtgXG4gICAgICAgIHZhciB2ID0gbnVsbDtcbiAgICAgICAgdmFyIGN2ID0gbnVsbDtcbiAgICAgICAgdmFyIGN1ID0gbnVsbDtcbiAgICAgICAgdmFyIHQgPSAwO1xuICAgICAgICB2YXIgZ2wgPSByZW5kZXJlci5nbDtcbiAgICBgXTtcbiAgZm9yIChjb25zdCBpIGluIGdyb3VwLnVuaWZvcm1zKSB7XG4gICAgY29uc3QgZGF0YSA9IHVuaWZvcm1EYXRhW2ldO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgaWYgKGdyb3VwLnVuaWZvcm1zW2ldPy5ncm91cCkge1xuICAgICAgICBpZiAoZ3JvdXAudW5pZm9ybXNbaV0udWJvKSB7XG4gICAgICAgICAgZnVuY0ZyYWdtZW50cy5wdXNoKGBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNoYWRlci5zeW5jVW5pZm9ybUJ1ZmZlckdyb3VwKHV2LiR7aX0sICcke2l9Jyk7XG4gICAgICAgICAgICAgICAgICAgIGApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZ1bmNGcmFnbWVudHMucHVzaChgXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlci5zaGFkZXIuc3luY1VuaWZvcm1Hcm91cCh1di4ke2l9LCBzeW5jRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdW5pZm9ybSA9IGdyb3VwLnVuaWZvcm1zW2ldO1xuICAgIGxldCBwYXJzZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHVuaWZvcm1QYXJzZXJzLnVuaWZvcm1QYXJzZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAodW5pZm9ybVBhcnNlcnMudW5pZm9ybVBhcnNlcnNbal0udGVzdChkYXRhLCB1bmlmb3JtKSkge1xuICAgICAgICBmdW5jRnJhZ21lbnRzLnB1c2godW5pZm9ybVBhcnNlcnMudW5pZm9ybVBhcnNlcnNbal0uY29kZShpLCB1bmlmb3JtKSk7XG4gICAgICAgIHBhcnNlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgY29uc3QgdGVtcGxhdGVUeXBlID0gZGF0YS5zaXplID09PSAxICYmICFkYXRhLmlzQXJyYXkgPyBHTFNMX1RPX1NJTkdMRV9TRVRURVJTX0NBQ0hFRCA6IEdMU0xfVE9fQVJSQVlfU0VUVEVSUztcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVUeXBlW2RhdGEudHlwZV0ucmVwbGFjZShcImxvY2F0aW9uXCIsIGB1ZFtcIiR7aX1cIl0ubG9jYXRpb25gKTtcbiAgICAgIGZ1bmNGcmFnbWVudHMucHVzaChgXG4gICAgICAgICAgICBjdSA9IHVkW1wiJHtpfVwiXTtcbiAgICAgICAgICAgIGN2ID0gY3UudmFsdWU7XG4gICAgICAgICAgICB2ID0gdXZbXCIke2l9XCJdO1xuICAgICAgICAgICAgJHt0ZW1wbGF0ZX07YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgRnVuY3Rpb24oXCJ1ZFwiLCBcInV2XCIsIFwicmVuZGVyZXJcIiwgXCJzeW5jRGF0YVwiLCBmdW5jRnJhZ21lbnRzLmpvaW4oXCJcXG5cIikpO1xufVxuXG5leHBvcnRzLmdlbmVyYXRlVW5pZm9ybXNTeW5jID0gZ2VuZXJhdGVVbmlmb3Jtc1N5bmM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZVVuaWZvcm1zU3luYy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIG1hcFNpemUgPSByZXF1aXJlKCcuL21hcFNpemUuanMnKTtcbnZhciBtYXBUeXBlID0gcmVxdWlyZSgnLi9tYXBUeXBlLmpzJyk7XG5cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZURhdGEocHJvZ3JhbSwgZ2wpIHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICBjb25zdCB0b3RhbEF0dHJpYnV0ZXMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkFDVElWRV9BVFRSSUJVVEVTKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbEF0dHJpYnV0ZXM7IGkrKykge1xuICAgIGNvbnN0IGF0dHJpYkRhdGEgPSBnbC5nZXRBY3RpdmVBdHRyaWIocHJvZ3JhbSwgaSk7XG4gICAgaWYgKGF0dHJpYkRhdGEubmFtZS5zdGFydHNXaXRoKFwiZ2xfXCIpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IG1hcFR5cGUubWFwVHlwZShnbCwgYXR0cmliRGF0YS50eXBlKTtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgdHlwZSxcbiAgICAgIG5hbWU6IGF0dHJpYkRhdGEubmFtZSxcbiAgICAgIHNpemU6IG1hcFNpemUubWFwU2l6ZSh0eXBlKSxcbiAgICAgIGxvY2F0aW9uOiBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyaWJEYXRhLm5hbWUpXG4gICAgfTtcbiAgICBhdHRyaWJ1dGVzW2F0dHJpYkRhdGEubmFtZV0gPSBkYXRhO1xuICB9XG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufVxuXG5leHBvcnRzLmdldEF0dHJpYnV0ZURhdGEgPSBnZXRBdHRyaWJ1dGVEYXRhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0QXR0cmlidXRlRGF0YS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ0BwaXhpL2NvbnN0YW50cycpO1xudmFyIGdldFRlc3RDb250ZXh0ID0gcmVxdWlyZSgnLi9nZXRUZXN0Q29udGV4dC5qcycpO1xuXG5sZXQgbWF4RnJhZ21lbnRQcmVjaXNpb247XG5mdW5jdGlvbiBnZXRNYXhGcmFnbWVudFByZWNpc2lvbigpIHtcbiAgaWYgKCFtYXhGcmFnbWVudFByZWNpc2lvbikge1xuICAgIG1heEZyYWdtZW50UHJlY2lzaW9uID0gY29uc3RhbnRzLlBSRUNJU0lPTi5NRURJVU07XG4gICAgY29uc3QgZ2wgPSBnZXRUZXN0Q29udGV4dC5nZXRUZXN0Q29udGV4dCgpO1xuICAgIGlmIChnbCkge1xuICAgICAgaWYgKGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCkge1xuICAgICAgICBjb25zdCBzaGFkZXJGcmFnbWVudCA9IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfRkxPQVQpO1xuICAgICAgICBtYXhGcmFnbWVudFByZWNpc2lvbiA9IHNoYWRlckZyYWdtZW50LnByZWNpc2lvbiA/IGNvbnN0YW50cy5QUkVDSVNJT04uSElHSCA6IGNvbnN0YW50cy5QUkVDSVNJT04uTUVESVVNO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWF4RnJhZ21lbnRQcmVjaXNpb247XG59XG5cbmV4cG9ydHMuZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24gPSBnZXRNYXhGcmFnbWVudFByZWNpc2lvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldE1heEZyYWdtZW50UHJlY2lzaW9uLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnQHBpeGkvY29uc3RhbnRzJyk7XG52YXIgc2V0dGluZ3MgPSByZXF1aXJlKCdAcGl4aS9zZXR0aW5ncycpO1xuXG5jb25zdCB1bmtub3duQ29udGV4dCA9IHt9O1xubGV0IGNvbnRleHQgPSB1bmtub3duQ29udGV4dDtcbmZ1bmN0aW9uIGdldFRlc3RDb250ZXh0KCkge1xuICBpZiAoY29udGV4dCA9PT0gdW5rbm93bkNvbnRleHQgfHwgY29udGV4dD8uaXNDb250ZXh0TG9zdCgpKSB7XG4gICAgY29uc3QgY2FudmFzID0gc2V0dGluZ3Muc2V0dGluZ3MuQURBUFRFUi5jcmVhdGVDYW52YXMoKTtcbiAgICBsZXQgZ2w7XG4gICAgaWYgKHNldHRpbmdzLnNldHRpbmdzLlBSRUZFUl9FTlYgPj0gY29uc3RhbnRzLkVOVi5XRUJHTDIpIHtcbiAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbDJcIiwge30pO1xuICAgIH1cbiAgICBpZiAoIWdsKSB7XG4gICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiwge30pIHx8IGNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIHt9KTtcbiAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgZ2wgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfZHJhd19idWZmZXJzXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb250ZXh0ID0gZ2w7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmV4cG9ydHMuZ2V0VGVzdENvbnRleHQgPSBnZXRUZXN0Q29udGV4dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFRlc3RDb250ZXh0LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZGVmYXVsdFZhbHVlID0gcmVxdWlyZSgnLi9kZWZhdWx0VmFsdWUuanMnKTtcbnZhciBtYXBUeXBlID0gcmVxdWlyZSgnLi9tYXBUeXBlLmpzJyk7XG5cbmZ1bmN0aW9uIGdldFVuaWZvcm1EYXRhKHByb2dyYW0sIGdsKSB7XG4gIGNvbnN0IHVuaWZvcm1zID0ge307XG4gIGNvbnN0IHRvdGFsVW5pZm9ybXMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkFDVElWRV9VTklGT1JNUyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxVbmlmb3JtczsgaSsrKSB7XG4gICAgY29uc3QgdW5pZm9ybURhdGEgPSBnbC5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGkpO1xuICAgIGNvbnN0IG5hbWUgPSB1bmlmb3JtRGF0YS5uYW1lLnJlcGxhY2UoL1xcWy4qP1xcXSQvLCBcIlwiKTtcbiAgICBjb25zdCBpc0FycmF5ID0gISF1bmlmb3JtRGF0YS5uYW1lLm1hdGNoKC9cXFsuKj9cXF0kLyk7XG4gICAgY29uc3QgdHlwZSA9IG1hcFR5cGUubWFwVHlwZShnbCwgdW5pZm9ybURhdGEudHlwZSk7XG4gICAgdW5pZm9ybXNbbmFtZV0gPSB7XG4gICAgICBuYW1lLFxuICAgICAgaW5kZXg6IGksXG4gICAgICB0eXBlLFxuICAgICAgc2l6ZTogdW5pZm9ybURhdGEuc2l6ZSxcbiAgICAgIGlzQXJyYXksXG4gICAgICB2YWx1ZTogZGVmYXVsdFZhbHVlLmRlZmF1bHRWYWx1ZSh0eXBlLCB1bmlmb3JtRGF0YS5zaXplKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHVuaWZvcm1zO1xufVxuXG5leHBvcnRzLmdldFVuaWZvcm1EYXRhID0gZ2V0VW5pZm9ybURhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRVbmlmb3JtRGF0YS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIgPSByZXF1aXJlKCcuL2NoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIuanMnKTtcbnZhciBjb21waWxlU2hhZGVyID0gcmVxdWlyZSgnLi9jb21waWxlU2hhZGVyLmpzJyk7XG52YXIgZGVmYXVsdFZhbHVlID0gcmVxdWlyZSgnLi9kZWZhdWx0VmFsdWUuanMnKTtcbnZhciBnZW5lcmF0ZVVuaWZvcm1zU3luYyA9IHJlcXVpcmUoJy4vZ2VuZXJhdGVVbmlmb3Jtc1N5bmMuanMnKTtcbnZhciBnZXRNYXhGcmFnbWVudFByZWNpc2lvbiA9IHJlcXVpcmUoJy4vZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24uanMnKTtcbnZhciBnZXRUZXN0Q29udGV4dCA9IHJlcXVpcmUoJy4vZ2V0VGVzdENvbnRleHQuanMnKTtcbnZhciBsb2dQcm9ncmFtRXJyb3IgPSByZXF1aXJlKCcuL2xvZ1Byb2dyYW1FcnJvci5qcycpO1xudmFyIG1hcFNpemUgPSByZXF1aXJlKCcuL21hcFNpemUuanMnKTtcbnZhciBtYXBUeXBlID0gcmVxdWlyZSgnLi9tYXBUeXBlLmpzJyk7XG52YXIgc2V0UHJlY2lzaW9uID0gcmVxdWlyZSgnLi9zZXRQcmVjaXNpb24uanMnKTtcbnZhciB1bmlmb3JtUGFyc2VycyA9IHJlcXVpcmUoJy4vdW5pZm9ybVBhcnNlcnMuanMnKTtcbnZhciB1bnNhZmVFdmFsU3VwcG9ydGVkID0gcmVxdWlyZSgnLi91bnNhZmVFdmFsU3VwcG9ydGVkLmpzJyk7XG5cblxuXG5leHBvcnRzLmNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIgPSBjaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyLmNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXI7XG5leHBvcnRzLmNvbXBpbGVTaGFkZXIgPSBjb21waWxlU2hhZGVyLmNvbXBpbGVTaGFkZXI7XG5leHBvcnRzLmRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZS5kZWZhdWx0VmFsdWU7XG5leHBvcnRzLmdlbmVyYXRlVW5pZm9ybXNTeW5jID0gZ2VuZXJhdGVVbmlmb3Jtc1N5bmMuZ2VuZXJhdGVVbmlmb3Jtc1N5bmM7XG5leHBvcnRzLmdldE1heEZyYWdtZW50UHJlY2lzaW9uID0gZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24uZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb247XG5leHBvcnRzLmdldFRlc3RDb250ZXh0ID0gZ2V0VGVzdENvbnRleHQuZ2V0VGVzdENvbnRleHQ7XG5leHBvcnRzLmxvZ1Byb2dyYW1FcnJvciA9IGxvZ1Byb2dyYW1FcnJvci5sb2dQcm9ncmFtRXJyb3I7XG5leHBvcnRzLm1hcFNpemUgPSBtYXBTaXplLm1hcFNpemU7XG5leHBvcnRzLm1hcFR5cGUgPSBtYXBUeXBlLm1hcFR5cGU7XG5leHBvcnRzLnNldFByZWNpc2lvbiA9IHNldFByZWNpc2lvbi5zZXRQcmVjaXNpb247XG5leHBvcnRzLnVuaWZvcm1QYXJzZXJzID0gdW5pZm9ybVBhcnNlcnMudW5pZm9ybVBhcnNlcnM7XG5leHBvcnRzLnVuc2FmZUV2YWxTdXBwb3J0ZWQgPSB1bnNhZmVFdmFsU3VwcG9ydGVkLnVuc2FmZUV2YWxTdXBwb3J0ZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gbG9nUHJldHR5U2hhZGVyRXJyb3IoZ2wsIHNoYWRlcikge1xuICBjb25zdCBzaGFkZXJTcmMgPSBnbC5nZXRTaGFkZXJTb3VyY2Uoc2hhZGVyKS5zcGxpdChcIlxcblwiKS5tYXAoKGxpbmUsIGluZGV4KSA9PiBgJHtpbmRleH06ICR7bGluZX1gKTtcbiAgY29uc3Qgc2hhZGVyTG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICBjb25zdCBzcGxpdFNoYWRlciA9IHNoYWRlckxvZy5zcGxpdChcIlxcblwiKTtcbiAgY29uc3QgZGVkdXBlID0ge307XG4gIGNvbnN0IGxpbmVOdW1iZXJzID0gc3BsaXRTaGFkZXIubWFwKChsaW5lKSA9PiBwYXJzZUZsb2F0KGxpbmUucmVwbGFjZSgvXkVSUk9SXFw6IDBcXDooW1xcZF0rKVxcOi4qJC8sIFwiJDFcIikpKS5maWx0ZXIoKG4pID0+IHtcbiAgICBpZiAobiAmJiAhZGVkdXBlW25dKSB7XG4gICAgICBkZWR1cGVbbl0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG4gIGNvbnN0IGxvZ0FyZ3MgPSBbXCJcIl07XG4gIGxpbmVOdW1iZXJzLmZvckVhY2goKG51bWJlcikgPT4ge1xuICAgIHNoYWRlclNyY1tudW1iZXIgLSAxXSA9IGAlYyR7c2hhZGVyU3JjW251bWJlciAtIDFdfSVjYDtcbiAgICBsb2dBcmdzLnB1c2goXCJiYWNrZ3JvdW5kOiAjRkYwMDAwOyBjb2xvcjojRkZGRkZGOyBmb250LXNpemU6IDEwcHhcIiwgXCJmb250LXNpemU6IDEwcHhcIik7XG4gIH0pO1xuICBjb25zdCBmcmFnbWVudFNvdXJjZVRvTG9nID0gc2hhZGVyU3JjLmpvaW4oXCJcXG5cIik7XG4gIGxvZ0FyZ3NbMF0gPSBmcmFnbWVudFNvdXJjZVRvTG9nO1xuICBjb25zb2xlLmVycm9yKHNoYWRlckxvZyk7XG4gIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXCJjbGljayB0byB2aWV3IGZ1bGwgc2hhZGVyIGNvZGVcIik7XG4gIGNvbnNvbGUud2FybiguLi5sb2dBcmdzKTtcbiAgY29uc29sZS5ncm91cEVuZCgpO1xufVxuZnVuY3Rpb24gbG9nUHJvZ3JhbUVycm9yKGdsLCBwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKSB7XG4gIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0ZXhTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgbG9nUHJldHR5U2hhZGVyRXJyb3IoZ2wsIHZlcnRleFNoYWRlcik7XG4gICAgfVxuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKGZyYWdtZW50U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgIGxvZ1ByZXR0eVNoYWRlckVycm9yKGdsLCBmcmFnbWVudFNoYWRlcik7XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoXCJQaXhpSlMgRXJyb3I6IENvdWxkIG5vdCBpbml0aWFsaXplIHNoYWRlci5cIik7XG4gICAgaWYgKGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pICE9PSBcIlwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJQaXhpSlMgV2FybmluZzogZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coKVwiLCBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMubG9nUHJvZ3JhbUVycm9yID0gbG9nUHJvZ3JhbUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nUHJvZ3JhbUVycm9yLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jb25zdCBHTFNMX1RPX1NJWkUgPSB7XG4gIGZsb2F0OiAxLFxuICB2ZWMyOiAyLFxuICB2ZWMzOiAzLFxuICB2ZWM0OiA0LFxuICBpbnQ6IDEsXG4gIGl2ZWMyOiAyLFxuICBpdmVjMzogMyxcbiAgaXZlYzQ6IDQsXG4gIHVpbnQ6IDEsXG4gIHV2ZWMyOiAyLFxuICB1dmVjMzogMyxcbiAgdXZlYzQ6IDQsXG4gIGJvb2w6IDEsXG4gIGJ2ZWMyOiAyLFxuICBidmVjMzogMyxcbiAgYnZlYzQ6IDQsXG4gIG1hdDI6IDQsXG4gIG1hdDM6IDksXG4gIG1hdDQ6IDE2LFxuICBzYW1wbGVyMkQ6IDFcbn07XG5mdW5jdGlvbiBtYXBTaXplKHR5cGUpIHtcbiAgcmV0dXJuIEdMU0xfVE9fU0laRVt0eXBlXTtcbn1cblxuZXhwb3J0cy5tYXBTaXplID0gbWFwU2l6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcFNpemUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmxldCBHTF9UQUJMRSA9IG51bGw7XG5jb25zdCBHTF9UT19HTFNMX1RZUEVTID0ge1xuICBGTE9BVDogXCJmbG9hdFwiLFxuICBGTE9BVF9WRUMyOiBcInZlYzJcIixcbiAgRkxPQVRfVkVDMzogXCJ2ZWMzXCIsXG4gIEZMT0FUX1ZFQzQ6IFwidmVjNFwiLFxuICBJTlQ6IFwiaW50XCIsXG4gIElOVF9WRUMyOiBcIml2ZWMyXCIsXG4gIElOVF9WRUMzOiBcIml2ZWMzXCIsXG4gIElOVF9WRUM0OiBcIml2ZWM0XCIsXG4gIFVOU0lHTkVEX0lOVDogXCJ1aW50XCIsXG4gIFVOU0lHTkVEX0lOVF9WRUMyOiBcInV2ZWMyXCIsXG4gIFVOU0lHTkVEX0lOVF9WRUMzOiBcInV2ZWMzXCIsXG4gIFVOU0lHTkVEX0lOVF9WRUM0OiBcInV2ZWM0XCIsXG4gIEJPT0w6IFwiYm9vbFwiLFxuICBCT09MX1ZFQzI6IFwiYnZlYzJcIixcbiAgQk9PTF9WRUMzOiBcImJ2ZWMzXCIsXG4gIEJPT0xfVkVDNDogXCJidmVjNFwiLFxuICBGTE9BVF9NQVQyOiBcIm1hdDJcIixcbiAgRkxPQVRfTUFUMzogXCJtYXQzXCIsXG4gIEZMT0FUX01BVDQ6IFwibWF0NFwiLFxuICBTQU1QTEVSXzJEOiBcInNhbXBsZXIyRFwiLFxuICBJTlRfU0FNUExFUl8yRDogXCJzYW1wbGVyMkRcIixcbiAgVU5TSUdORURfSU5UX1NBTVBMRVJfMkQ6IFwic2FtcGxlcjJEXCIsXG4gIFNBTVBMRVJfQ1VCRTogXCJzYW1wbGVyQ3ViZVwiLFxuICBJTlRfU0FNUExFUl9DVUJFOiBcInNhbXBsZXJDdWJlXCIsXG4gIFVOU0lHTkVEX0lOVF9TQU1QTEVSX0NVQkU6IFwic2FtcGxlckN1YmVcIixcbiAgU0FNUExFUl8yRF9BUlJBWTogXCJzYW1wbGVyMkRBcnJheVwiLFxuICBJTlRfU0FNUExFUl8yRF9BUlJBWTogXCJzYW1wbGVyMkRBcnJheVwiLFxuICBVTlNJR05FRF9JTlRfU0FNUExFUl8yRF9BUlJBWTogXCJzYW1wbGVyMkRBcnJheVwiXG59O1xuZnVuY3Rpb24gbWFwVHlwZShnbCwgdHlwZSkge1xuICBpZiAoIUdMX1RBQkxFKSB7XG4gICAgY29uc3QgdHlwZU5hbWVzID0gT2JqZWN0LmtleXMoR0xfVE9fR0xTTF9UWVBFUyk7XG4gICAgR0xfVEFCTEUgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVOYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgdG4gPSB0eXBlTmFtZXNbaV07XG4gICAgICBHTF9UQUJMRVtnbFt0bl1dID0gR0xfVE9fR0xTTF9UWVBFU1t0bl07XG4gICAgfVxuICB9XG4gIHJldHVybiBHTF9UQUJMRVt0eXBlXTtcbn1cblxuZXhwb3J0cy5tYXBUeXBlID0gbWFwVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcFR5cGUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCdAcGl4aS9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gc2V0UHJlY2lzaW9uKHNyYywgcmVxdWVzdGVkUHJlY2lzaW9uLCBtYXhTdXBwb3J0ZWRQcmVjaXNpb24pIHtcbiAgaWYgKHNyYy5zdWJzdHJpbmcoMCwgOSkgIT09IFwicHJlY2lzaW9uXCIpIHtcbiAgICBsZXQgcHJlY2lzaW9uID0gcmVxdWVzdGVkUHJlY2lzaW9uO1xuICAgIGlmIChyZXF1ZXN0ZWRQcmVjaXNpb24gPT09IGNvbnN0YW50cy5QUkVDSVNJT04uSElHSCAmJiBtYXhTdXBwb3J0ZWRQcmVjaXNpb24gIT09IGNvbnN0YW50cy5QUkVDSVNJT04uSElHSCkge1xuICAgICAgcHJlY2lzaW9uID0gY29uc3RhbnRzLlBSRUNJU0lPTi5NRURJVU07XG4gICAgfVxuICAgIHJldHVybiBgcHJlY2lzaW9uICR7cHJlY2lzaW9ufSBmbG9hdDtcbiR7c3JjfWA7XG4gIH0gZWxzZSBpZiAobWF4U3VwcG9ydGVkUHJlY2lzaW9uICE9PSBjb25zdGFudHMuUFJFQ0lTSU9OLkhJR0ggJiYgc3JjLnN1YnN0cmluZygwLCAxNSkgPT09IFwicHJlY2lzaW9uIGhpZ2hwXCIpIHtcbiAgICByZXR1cm4gc3JjLnJlcGxhY2UoXCJwcmVjaXNpb24gaGlnaHBcIiwgXCJwcmVjaXNpb24gbWVkaXVtcFwiKTtcbiAgfVxuICByZXR1cm4gc3JjO1xufVxuXG5leHBvcnRzLnNldFByZWNpc2lvbiA9IHNldFByZWNpc2lvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNldFByZWNpc2lvbi5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY29uc3QgdW5pZm9ybVBhcnNlcnMgPSBbXG4gIHtcbiAgICB0ZXN0OiAoZGF0YSkgPT4gZGF0YS50eXBlID09PSBcImZsb2F0XCIgJiYgZGF0YS5zaXplID09PSAxICYmICFkYXRhLmlzQXJyYXksXG4gICAgY29kZTogKG5hbWUpID0+IGBcbiAgICAgICAgICAgIGlmKHV2W1wiJHtuYW1lfVwiXSAhPT0gdWRbXCIke25hbWV9XCJdLnZhbHVlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVkW1wiJHtuYW1lfVwiXS52YWx1ZSA9IHV2W1wiJHtuYW1lfVwiXVxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xZih1ZFtcIiR7bmFtZX1cIl0ubG9jYXRpb24sIHV2W1wiJHtuYW1lfVwiXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGBcbiAgfSxcbiAge1xuICAgIHRlc3Q6IChkYXRhLCB1bmlmb3JtKSA9PiAoZGF0YS50eXBlID09PSBcInNhbXBsZXIyRFwiIHx8IGRhdGEudHlwZSA9PT0gXCJzYW1wbGVyQ3ViZVwiIHx8IGRhdGEudHlwZSA9PT0gXCJzYW1wbGVyMkRBcnJheVwiKSAmJiBkYXRhLnNpemUgPT09IDEgJiYgIWRhdGEuaXNBcnJheSAmJiAodW5pZm9ybSA9PSBudWxsIHx8IHVuaWZvcm0uY2FzdFRvQmFzZVRleHR1cmUgIT09IHZvaWQgMCksXG4gICAgY29kZTogKG5hbWUpID0+IGB0ID0gc3luY0RhdGEudGV4dHVyZUNvdW50Kys7XG5cbiAgICAgICAgICAgIHJlbmRlcmVyLnRleHR1cmUuYmluZCh1dltcIiR7bmFtZX1cIl0sIHQpO1xuXG4gICAgICAgICAgICBpZih1ZFtcIiR7bmFtZX1cIl0udmFsdWUgIT09IHQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdWRbXCIke25hbWV9XCJdLnZhbHVlID0gdDtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkodWRbXCIke25hbWV9XCJdLmxvY2F0aW9uLCB0KTtcbjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbGVuXG4gICAgICAgICAgICB9YFxuICB9LFxuICB7XG4gICAgdGVzdDogKGRhdGEsIHVuaWZvcm0pID0+IGRhdGEudHlwZSA9PT0gXCJtYXQzXCIgJiYgZGF0YS5zaXplID09PSAxICYmICFkYXRhLmlzQXJyYXkgJiYgdW5pZm9ybS5hICE9PSB2b2lkIDAsXG4gICAgY29kZTogKG5hbWUpID0+IGBcbiAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodWRbXCIke25hbWV9XCJdLmxvY2F0aW9uLCBmYWxzZSwgdXZbXCIke25hbWV9XCJdLnRvQXJyYXkodHJ1ZSkpO1xuICAgICAgICAgICAgYCxcbiAgICBjb2RlVWJvOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgICAgIHZhciAke25hbWV9X21hdHJpeCA9IHV2LiR7bmFtZX0udG9BcnJheSh0cnVlKTtcblxuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9ICR7bmFtZX1fbWF0cml4WzBdO1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KzFdID0gJHtuYW1lfV9tYXRyaXhbMV07XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrMl0gPSAke25hbWV9X21hdHJpeFsyXTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyA0XSA9ICR7bmFtZX1fbWF0cml4WzNdO1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgNV0gPSAke25hbWV9X21hdHJpeFs0XTtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDZdID0gJHtuYW1lfV9tYXRyaXhbNV07XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgOF0gPSAke25hbWV9X21hdHJpeFs2XTtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDldID0gJHtuYW1lfV9tYXRyaXhbN107XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAxMF0gPSAke25hbWV9X21hdHJpeFs4XTtcbiAgICAgICAgICAgIGBcbiAgfSxcbiAge1xuICAgIHRlc3Q6IChkYXRhLCB1bmlmb3JtKSA9PiBkYXRhLnR5cGUgPT09IFwidmVjMlwiICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5ICYmIHVuaWZvcm0ueCAhPT0gdm9pZCAwLFxuICAgIGNvZGU6IChuYW1lKSA9PiBgXG4gICAgICAgICAgICAgICAgY3YgPSB1ZFtcIiR7bmFtZX1cIl0udmFsdWU7XG4gICAgICAgICAgICAgICAgdiA9IHV2W1wiJHtuYW1lfVwiXTtcblxuICAgICAgICAgICAgICAgIGlmKGN2WzBdICE9PSB2LnggfHwgY3ZbMV0gIT09IHYueSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGN2WzBdID0gdi54O1xuICAgICAgICAgICAgICAgICAgICBjdlsxXSA9IHYueTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmKHVkW1wiJHtuYW1lfVwiXS5sb2NhdGlvbiwgdi54LCB2LnkpO1xuICAgICAgICAgICAgICAgIH1gLFxuICAgIGNvZGVVYm86IChuYW1lKSA9PiBgXG4gICAgICAgICAgICAgICAgdiA9IHV2LiR7bmFtZX07XG5cbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldF0gPSB2Lng7XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrMV0gPSB2Lnk7XG4gICAgICAgICAgICBgXG4gIH0sXG4gIHtcbiAgICB0ZXN0OiAoZGF0YSkgPT4gZGF0YS50eXBlID09PSBcInZlYzJcIiAmJiBkYXRhLnNpemUgPT09IDEgJiYgIWRhdGEuaXNBcnJheSxcbiAgICBjb2RlOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgICAgIGN2ID0gdWRbXCIke25hbWV9XCJdLnZhbHVlO1xuICAgICAgICAgICAgICAgIHYgPSB1dltcIiR7bmFtZX1cIl07XG5cbiAgICAgICAgICAgICAgICBpZihjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmYodWRbXCIke25hbWV9XCJdLmxvY2F0aW9uLCB2WzBdLCB2WzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgXG4gIH0sXG4gIHtcbiAgICB0ZXN0OiAoZGF0YSwgdW5pZm9ybSkgPT4gZGF0YS50eXBlID09PSBcInZlYzRcIiAmJiBkYXRhLnNpemUgPT09IDEgJiYgIWRhdGEuaXNBcnJheSAmJiB1bmlmb3JtLndpZHRoICE9PSB2b2lkIDAsXG4gICAgY29kZTogKG5hbWUpID0+IGBcbiAgICAgICAgICAgICAgICBjdiA9IHVkW1wiJHtuYW1lfVwiXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2ID0gdXZbXCIke25hbWV9XCJdO1xuXG4gICAgICAgICAgICAgICAgaWYoY3ZbMF0gIT09IHYueCB8fCBjdlsxXSAhPT0gdi55IHx8IGN2WzJdICE9PSB2LndpZHRoIHx8IGN2WzNdICE9PSB2LmhlaWdodClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGN2WzBdID0gdi54O1xuICAgICAgICAgICAgICAgICAgICBjdlsxXSA9IHYueTtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMl0gPSB2LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBjdlszXSA9IHYuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtNGYodWRbXCIke25hbWV9XCJdLmxvY2F0aW9uLCB2LngsIHYueSwgdi53aWR0aCwgdi5oZWlnaHQpXG4gICAgICAgICAgICAgICAgfWAsXG4gICAgY29kZVVibzogKG5hbWUpID0+IGBcbiAgICAgICAgICAgICAgICAgICAgdiA9IHV2LiR7bmFtZX07XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gdi54O1xuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsxXSA9IHYueTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrMl0gPSB2LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCszXSA9IHYuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGBcbiAgfSxcbiAge1xuICAgIHRlc3Q6IChkYXRhLCB1bmlmb3JtKSA9PiBkYXRhLnR5cGUgPT09IFwidmVjNFwiICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5ICYmIHVuaWZvcm0ucmVkICE9PSB2b2lkIDAsXG4gICAgY29kZTogKG5hbWUpID0+IGBcbiAgICAgICAgICAgICAgICBjdiA9IHVkW1wiJHtuYW1lfVwiXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2ID0gdXZbXCIke25hbWV9XCJdO1xuXG4gICAgICAgICAgICAgICAgaWYoY3ZbMF0gIT09IHYucmVkIHx8IGN2WzFdICE9PSB2LmdyZWVuIHx8IGN2WzJdICE9PSB2LmJsdWUgfHwgY3ZbM10gIT09IHYuYWxwaGEpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjdlswXSA9IHYucmVkO1xuICAgICAgICAgICAgICAgICAgICBjdlsxXSA9IHYuZ3JlZW47XG4gICAgICAgICAgICAgICAgICAgIGN2WzJdID0gdi5ibHVlO1xuICAgICAgICAgICAgICAgICAgICBjdlszXSA9IHYuYWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm00Zih1ZFtcIiR7bmFtZX1cIl0ubG9jYXRpb24sIHYucmVkLCB2LmdyZWVuLCB2LmJsdWUsIHYuYWxwaGEpXG4gICAgICAgICAgICAgICAgfWAsXG4gICAgY29kZVVibzogKG5hbWUpID0+IGBcbiAgICAgICAgICAgICAgICAgICAgdiA9IHV2LiR7bmFtZX07XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gdi5yZWQ7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KzFdID0gdi5ncmVlbjtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrMl0gPSB2LmJsdWU7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KzNdID0gdi5hbHBoYTtcbiAgICAgICAgICAgICAgICBgXG4gIH0sXG4gIHtcbiAgICB0ZXN0OiAoZGF0YSwgdW5pZm9ybSkgPT4gZGF0YS50eXBlID09PSBcInZlYzNcIiAmJiBkYXRhLnNpemUgPT09IDEgJiYgIWRhdGEuaXNBcnJheSAmJiB1bmlmb3JtLnJlZCAhPT0gdm9pZCAwLFxuICAgIGNvZGU6IChuYW1lKSA9PiBgXG4gICAgICAgICAgICAgICAgY3YgPSB1ZFtcIiR7bmFtZX1cIl0udmFsdWU7XG4gICAgICAgICAgICAgICAgdiA9IHV2W1wiJHtuYW1lfVwiXTtcblxuICAgICAgICAgICAgICAgIGlmKGN2WzBdICE9PSB2LnJlZCB8fCBjdlsxXSAhPT0gdi5ncmVlbiB8fCBjdlsyXSAhPT0gdi5ibHVlIHx8IGN2WzNdICE9PSB2LmEpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjdlswXSA9IHYucmVkO1xuICAgICAgICAgICAgICAgICAgICBjdlsxXSA9IHYuZ3JlZW47XG4gICAgICAgICAgICAgICAgICAgIGN2WzJdID0gdi5ibHVlO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2YodWRbXCIke25hbWV9XCJdLmxvY2F0aW9uLCB2LnJlZCwgdi5ncmVlbiwgdi5ibHVlKVxuICAgICAgICAgICAgICAgIH1gLFxuICAgIGNvZGVVYm86IChuYW1lKSA9PiBgXG4gICAgICAgICAgICAgICAgICAgIHYgPSB1di4ke25hbWV9O1xuXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IHYucmVkO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsxXSA9IHYuZ3JlZW47XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KzJdID0gdi5ibHVlO1xuICAgICAgICAgICAgICAgIGBcbiAgfSxcbiAge1xuICAgIHRlc3Q6IChkYXRhKSA9PiBkYXRhLnR5cGUgPT09IFwidmVjNFwiICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5LFxuICAgIGNvZGU6IChuYW1lKSA9PiBgXG4gICAgICAgICAgICAgICAgY3YgPSB1ZFtcIiR7bmFtZX1cIl0udmFsdWU7XG4gICAgICAgICAgICAgICAgdiA9IHV2W1wiJHtuYW1lfVwiXTtcblxuICAgICAgICAgICAgICAgIGlmKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdIHx8IGN2WzNdICE9PSB2WzNdKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICAgICAgICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgICAgICAgICAgICAgIGN2WzJdID0gdlsyXTtcbiAgICAgICAgICAgICAgICAgICAgY3ZbM10gPSB2WzNdO1xuXG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm00Zih1ZFtcIiR7bmFtZX1cIl0ubG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0sIHZbM10pXG4gICAgICAgICAgICAgICAgfWBcbiAgfVxuXTtcblxuZXhwb3J0cy51bmlmb3JtUGFyc2VycyA9IHVuaWZvcm1QYXJzZXJzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pZm9ybVBhcnNlcnMuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmxldCB1bnNhZmVFdmFsO1xuZnVuY3Rpb24gdW5zYWZlRXZhbFN1cHBvcnRlZCgpIHtcbiAgaWYgKHR5cGVvZiB1bnNhZmVFdmFsID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiB1bnNhZmVFdmFsO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgZnVuYyA9IG5ldyBGdW5jdGlvbihcInBhcmFtMVwiLCBcInBhcmFtMlwiLCBcInBhcmFtM1wiLCBcInJldHVybiBwYXJhbTFbcGFyYW0yXSA9PT0gcGFyYW0zO1wiKTtcbiAgICB1bnNhZmVFdmFsID0gZnVuYyh7IGE6IFwiYlwiIH0sIFwiYVwiLCBcImJcIikgPT09IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB1bnNhZmVFdmFsID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHVuc2FmZUV2YWw7XG59XG5cbmV4cG9ydHMudW5zYWZlRXZhbFN1cHBvcnRlZCA9IHVuc2FmZUV2YWxTdXBwb3J0ZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bnNhZmVFdmFsU3VwcG9ydGVkLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZXh0ZW5zaW9ucyA9IHJlcXVpcmUoJ0BwaXhpL2V4dGVuc2lvbnMnKTtcblxuY2xhc3MgU3RhcnR1cFN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIHJ1bihvcHRpb25zKSB7XG4gICAgY29uc3QgeyByZW5kZXJlciB9ID0gdGhpcztcbiAgICByZW5kZXJlci5ydW5uZXJzLmluaXQuZW1pdChyZW5kZXJlci5vcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5oZWxsbykge1xuICAgICAgY29uc29sZS5sb2coYFBpeGlKUyAke1wiNy4yLjRcIn0gLSAke3JlbmRlcmVyLnJlbmRlcmVyTG9nSWR9IC0gaHR0cHM6Ly9waXhpanMuY29tYCk7XG4gICAgfVxuICAgIHJlbmRlcmVyLnJlc2l6ZShyZW5kZXJlci5zY3JlZW4ud2lkdGgsIHJlbmRlcmVyLnNjcmVlbi5oZWlnaHQpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gIH1cbn1cblN0YXJ0dXBTeXN0ZW0uZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGhlbGxvOiBmYWxzZVxufTtcblN0YXJ0dXBTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICAgIGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5DYW52YXNSZW5kZXJlclN5c3RlbVxuICBdLFxuICBuYW1lOiBcInN0YXJ0dXBcIlxufTtcbmV4dGVuc2lvbnMuZXh0ZW5zaW9ucy5hZGQoU3RhcnR1cFN5c3RlbSk7XG5cbmV4cG9ydHMuU3RhcnR1cFN5c3RlbSA9IFN0YXJ0dXBTeXN0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGFydHVwU3lzdGVtLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnQHBpeGkvY29uc3RhbnRzJyk7XG5cbmNvbnN0IEJMRU5EID0gMDtcbmNvbnN0IE9GRlNFVCA9IDE7XG5jb25zdCBDVUxMSU5HID0gMjtcbmNvbnN0IERFUFRIX1RFU1QgPSAzO1xuY29uc3QgV0lORElORyA9IDQ7XG5jb25zdCBERVBUSF9NQVNLID0gNTtcbmNsYXNzIFN0YXRlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kYXRhID0gMDtcbiAgICB0aGlzLmJsZW5kTW9kZSA9IGNvbnN0YW50cy5CTEVORF9NT0RFUy5OT1JNQUw7XG4gICAgdGhpcy5wb2x5Z29uT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmJsZW5kID0gdHJ1ZTtcbiAgICB0aGlzLmRlcHRoTWFzayA9IHRydWU7XG4gIH1cbiAgZ2V0IGJsZW5kKCkge1xuICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiAxIDw8IEJMRU5EKTtcbiAgfVxuICBzZXQgYmxlbmQodmFsdWUpIHtcbiAgICBpZiAoISEodGhpcy5kYXRhICYgMSA8PCBCTEVORCkgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmRhdGEgXj0gMSA8PCBCTEVORDtcbiAgICB9XG4gIH1cbiAgZ2V0IG9mZnNldHMoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuZGF0YSAmIDEgPDwgT0ZGU0VUKTtcbiAgfVxuICBzZXQgb2Zmc2V0cyh2YWx1ZSkge1xuICAgIGlmICghISh0aGlzLmRhdGEgJiAxIDw8IE9GRlNFVCkgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmRhdGEgXj0gMSA8PCBPRkZTRVQ7XG4gICAgfVxuICB9XG4gIGdldCBjdWxsaW5nKCkge1xuICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiAxIDw8IENVTExJTkcpO1xuICB9XG4gIHNldCBjdWxsaW5nKHZhbHVlKSB7XG4gICAgaWYgKCEhKHRoaXMuZGF0YSAmIDEgPDwgQ1VMTElORykgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmRhdGEgXj0gMSA8PCBDVUxMSU5HO1xuICAgIH1cbiAgfVxuICBnZXQgZGVwdGhUZXN0KCkge1xuICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiAxIDw8IERFUFRIX1RFU1QpO1xuICB9XG4gIHNldCBkZXB0aFRlc3QodmFsdWUpIHtcbiAgICBpZiAoISEodGhpcy5kYXRhICYgMSA8PCBERVBUSF9URVNUKSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuZGF0YSBePSAxIDw8IERFUFRIX1RFU1Q7XG4gICAgfVxuICB9XG4gIGdldCBkZXB0aE1hc2soKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuZGF0YSAmIDEgPDwgREVQVEhfTUFTSyk7XG4gIH1cbiAgc2V0IGRlcHRoTWFzayh2YWx1ZSkge1xuICAgIGlmICghISh0aGlzLmRhdGEgJiAxIDw8IERFUFRIX01BU0spICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5kYXRhIF49IDEgPDwgREVQVEhfTUFTSztcbiAgICB9XG4gIH1cbiAgZ2V0IGNsb2Nrd2lzZUZyb250RmFjZSgpIHtcbiAgICByZXR1cm4gISEodGhpcy5kYXRhICYgMSA8PCBXSU5ESU5HKTtcbiAgfVxuICBzZXQgY2xvY2t3aXNlRnJvbnRGYWNlKHZhbHVlKSB7XG4gICAgaWYgKCEhKHRoaXMuZGF0YSAmIDEgPDwgV0lORElORykgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmRhdGEgXj0gMSA8PCBXSU5ESU5HO1xuICAgIH1cbiAgfVxuICBnZXQgYmxlbmRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9ibGVuZE1vZGU7XG4gIH1cbiAgc2V0IGJsZW5kTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuYmxlbmQgPSB2YWx1ZSAhPT0gY29uc3RhbnRzLkJMRU5EX01PREVTLk5PTkU7XG4gICAgdGhpcy5fYmxlbmRNb2RlID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHBvbHlnb25PZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvbHlnb25PZmZzZXQ7XG4gIH1cbiAgc2V0IHBvbHlnb25PZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLm9mZnNldHMgPSAhIXZhbHVlO1xuICAgIHRoaXMuX3BvbHlnb25PZmZzZXQgPSB2YWx1ZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtAcGl4aS9jb3JlOlN0YXRlIGJsZW5kTW9kZT0ke3RoaXMuYmxlbmRNb2RlfSBjbG9ja3dpc2VGcm9udEZhY2U9JHt0aGlzLmNsb2Nrd2lzZUZyb250RmFjZX0gY3VsbGluZz0ke3RoaXMuY3VsbGluZ30gZGVwdGhNYXNrPSR7dGhpcy5kZXB0aE1hc2t9IHBvbHlnb25PZmZzZXQ9JHt0aGlzLnBvbHlnb25PZmZzZXR9XWA7XG4gIH1cbiAgc3RhdGljIGZvcjJkKCkge1xuICAgIGNvbnN0IHN0YXRlID0gbmV3IFN0YXRlKCk7XG4gICAgc3RhdGUuZGVwdGhUZXN0ID0gZmFsc2U7XG4gICAgc3RhdGUuYmxlbmQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5leHBvcnRzLlN0YXRlID0gU3RhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGF0ZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ0BwaXhpL2NvbnN0YW50cycpO1xudmFyIGV4dGVuc2lvbnMgPSByZXF1aXJlKCdAcGl4aS9leHRlbnNpb25zJyk7XG52YXIgU3RhdGUgPSByZXF1aXJlKCcuL1N0YXRlLmpzJyk7XG52YXIgbWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpID0gcmVxdWlyZSgnLi91dGlscy9tYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkuanMnKTtcblxuY29uc3QgQkxFTkQgPSAwO1xuY29uc3QgT0ZGU0VUID0gMTtcbmNvbnN0IENVTExJTkcgPSAyO1xuY29uc3QgREVQVEhfVEVTVCA9IDM7XG5jb25zdCBXSU5ESU5HID0gNDtcbmNvbnN0IERFUFRIX01BU0sgPSA1O1xuY29uc3QgX1N0YXRlU3lzdGVtID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmdsID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlSWQgPSAwO1xuICAgIHRoaXMucG9seWdvbk9mZnNldCA9IDA7XG4gICAgdGhpcy5ibGVuZE1vZGUgPSBjb25zdGFudHMuQkxFTkRfTU9ERVMuTk9ORTtcbiAgICB0aGlzLl9ibGVuZEVxID0gZmFsc2U7XG4gICAgdGhpcy5tYXAgPSBbXTtcbiAgICB0aGlzLm1hcFtCTEVORF0gPSB0aGlzLnNldEJsZW5kO1xuICAgIHRoaXMubWFwW09GRlNFVF0gPSB0aGlzLnNldE9mZnNldDtcbiAgICB0aGlzLm1hcFtDVUxMSU5HXSA9IHRoaXMuc2V0Q3VsbEZhY2U7XG4gICAgdGhpcy5tYXBbREVQVEhfVEVTVF0gPSB0aGlzLnNldERlcHRoVGVzdDtcbiAgICB0aGlzLm1hcFtXSU5ESU5HXSA9IHRoaXMuc2V0RnJvbnRGYWNlO1xuICAgIHRoaXMubWFwW0RFUFRIX01BU0tdID0gdGhpcy5zZXREZXB0aE1hc2s7XG4gICAgdGhpcy5jaGVja3MgPSBbXTtcbiAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IG5ldyBTdGF0ZS5TdGF0ZSgpO1xuICAgIHRoaXMuZGVmYXVsdFN0YXRlLmJsZW5kID0gdHJ1ZTtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKGdsKSB7XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMuYmxlbmRNb2RlcyA9IG1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aS5tYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkoZ2wpO1xuICAgIHRoaXMuc2V0KHRoaXMuZGVmYXVsdFN0YXRlKTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cbiAgc2V0KHN0YXRlKSB7XG4gICAgc3RhdGUgPSBzdGF0ZSB8fCB0aGlzLmRlZmF1bHRTdGF0ZTtcbiAgICBpZiAodGhpcy5zdGF0ZUlkICE9PSBzdGF0ZS5kYXRhKSB7XG4gICAgICBsZXQgZGlmZiA9IHRoaXMuc3RhdGVJZCBeIHN0YXRlLmRhdGE7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICB3aGlsZSAoZGlmZikge1xuICAgICAgICBpZiAoZGlmZiAmIDEpIHtcbiAgICAgICAgICB0aGlzLm1hcFtpXS5jYWxsKHRoaXMsICEhKHN0YXRlLmRhdGEgJiAxIDw8IGkpKTtcbiAgICAgICAgfVxuICAgICAgICBkaWZmID0gZGlmZiA+PiAxO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlSWQgPSBzdGF0ZS5kYXRhO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hlY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmNoZWNrc1tpXSh0aGlzLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZvcmNlU3RhdGUoc3RhdGUpIHtcbiAgICBzdGF0ZSA9IHN0YXRlIHx8IHRoaXMuZGVmYXVsdFN0YXRlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMubWFwW2ldLmNhbGwodGhpcywgISEoc3RhdGUuZGF0YSAmIDEgPDwgaSkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hlY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmNoZWNrc1tpXSh0aGlzLCBzdGF0ZSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGVJZCA9IHN0YXRlLmRhdGE7XG4gIH1cbiAgc2V0QmxlbmQodmFsdWUpIHtcbiAgICB0aGlzLnVwZGF0ZUNoZWNrKF9TdGF0ZVN5c3RlbS5jaGVja0JsZW5kTW9kZSwgdmFsdWUpO1xuICAgIHRoaXMuZ2xbdmFsdWUgPyBcImVuYWJsZVwiIDogXCJkaXNhYmxlXCJdKHRoaXMuZ2wuQkxFTkQpO1xuICB9XG4gIHNldE9mZnNldCh2YWx1ZSkge1xuICAgIHRoaXMudXBkYXRlQ2hlY2soX1N0YXRlU3lzdGVtLmNoZWNrUG9seWdvbk9mZnNldCwgdmFsdWUpO1xuICAgIHRoaXMuZ2xbdmFsdWUgPyBcImVuYWJsZVwiIDogXCJkaXNhYmxlXCJdKHRoaXMuZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCk7XG4gIH1cbiAgc2V0RGVwdGhUZXN0KHZhbHVlKSB7XG4gICAgdGhpcy5nbFt2YWx1ZSA/IFwiZW5hYmxlXCIgOiBcImRpc2FibGVcIl0odGhpcy5nbC5ERVBUSF9URVNUKTtcbiAgfVxuICBzZXREZXB0aE1hc2sodmFsdWUpIHtcbiAgICB0aGlzLmdsLmRlcHRoTWFzayh2YWx1ZSk7XG4gIH1cbiAgc2V0Q3VsbEZhY2UodmFsdWUpIHtcbiAgICB0aGlzLmdsW3ZhbHVlID8gXCJlbmFibGVcIiA6IFwiZGlzYWJsZVwiXSh0aGlzLmdsLkNVTExfRkFDRSk7XG4gIH1cbiAgc2V0RnJvbnRGYWNlKHZhbHVlKSB7XG4gICAgdGhpcy5nbC5mcm9udEZhY2UodGhpcy5nbFt2YWx1ZSA/IFwiQ1dcIiA6IFwiQ0NXXCJdKTtcbiAgfVxuICBzZXRCbGVuZE1vZGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMuYmxlbmRNb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYmxlbmRNb2RlID0gdmFsdWU7XG4gICAgY29uc3QgbW9kZSA9IHRoaXMuYmxlbmRNb2Rlc1t2YWx1ZV07XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGlmIChtb2RlLmxlbmd0aCA9PT0gMikge1xuICAgICAgZ2wuYmxlbmRGdW5jKG1vZGVbMF0sIG1vZGVbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShtb2RlWzBdLCBtb2RlWzFdLCBtb2RlWzJdLCBtb2RlWzNdKTtcbiAgICB9XG4gICAgaWYgKG1vZGUubGVuZ3RoID09PSA2KSB7XG4gICAgICB0aGlzLl9ibGVuZEVxID0gdHJ1ZTtcbiAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShtb2RlWzRdLCBtb2RlWzVdKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2JsZW5kRXEpIHtcbiAgICAgIHRoaXMuX2JsZW5kRXEgPSBmYWxzZTtcbiAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQpO1xuICAgIH1cbiAgfVxuICBzZXRQb2x5Z29uT2Zmc2V0KHZhbHVlLCBzY2FsZSkge1xuICAgIHRoaXMuZ2wucG9seWdvbk9mZnNldCh2YWx1ZSwgc2NhbGUpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuZ2wucGl4ZWxTdG9yZWkodGhpcy5nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgdGhpcy5mb3JjZVN0YXRlKHRoaXMuZGVmYXVsdFN0YXRlKTtcbiAgICB0aGlzLl9ibGVuZEVxID0gdHJ1ZTtcbiAgICB0aGlzLmJsZW5kTW9kZSA9IC0xO1xuICAgIHRoaXMuc2V0QmxlbmRNb2RlKDApO1xuICB9XG4gIHVwZGF0ZUNoZWNrKGZ1bmMsIHZhbHVlKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmNoZWNrcy5pbmRleE9mKGZ1bmMpO1xuICAgIGlmICh2YWx1ZSAmJiBpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRoaXMuY2hlY2tzLnB1c2goZnVuYyk7XG4gICAgfSBlbHNlIGlmICghdmFsdWUgJiYgaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLmNoZWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgY2hlY2tCbGVuZE1vZGUoc3lzdGVtLCBzdGF0ZSkge1xuICAgIHN5c3RlbS5zZXRCbGVuZE1vZGUoc3RhdGUuYmxlbmRNb2RlKTtcbiAgfVxuICBzdGF0aWMgY2hlY2tQb2x5Z29uT2Zmc2V0KHN5c3RlbSwgc3RhdGUpIHtcbiAgICBzeXN0ZW0uc2V0UG9seWdvbk9mZnNldCgxLCBzdGF0ZS5wb2x5Z29uT2Zmc2V0KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZ2wgPSBudWxsO1xuICB9XG59O1xubGV0IFN0YXRlU3lzdGVtID0gX1N0YXRlU3lzdGVtO1xuU3RhdGVTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwic3RhdGVcIlxufTtcbmV4dGVuc2lvbnMuZXh0ZW5zaW9ucy5hZGQoU3RhdGVTeXN0ZW0pO1xuXG5leHBvcnRzLlN0YXRlU3lzdGVtID0gU3RhdGVTeXN0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGF0ZVN5c3RlbS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ0BwaXhpL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBtYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkoZ2wsIGFycmF5ID0gW10pIHtcbiAgYXJyYXlbY29uc3RhbnRzLkJMRU5EX01PREVTLk5PUk1BTF0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYXJyYXlbY29uc3RhbnRzLkJMRU5EX01PREVTLkFERF0gPSBbZ2wuT05FLCBnbC5PTkVdO1xuICBhcnJheVtjb25zdGFudHMuQkxFTkRfTU9ERVMuTVVMVElQTFldID0gW2dsLkRTVF9DT0xPUiwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYXJyYXlbY29uc3RhbnRzLkJMRU5EX01PREVTLlNDUkVFTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBhcnJheVtjb25zdGFudHMuQkxFTkRfTU9ERVMuT1ZFUkxBWV0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYXJyYXlbY29uc3RhbnRzLkJMRU5EX01PREVTLkRBUktFTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYXJyYXlbY29uc3RhbnRzLkJMRU5EX01PREVTLkxJR0hURU5dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5DT0xPUl9ET0RHRV0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYXJyYXlbY29uc3RhbnRzLkJMRU5EX01PREVTLkNPTE9SX0JVUk5dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5IQVJEX0xJR0hUXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBhcnJheVtjb25zdGFudHMuQkxFTkRfTU9ERVMuU09GVF9MSUdIVF0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYXJyYXlbY29uc3RhbnRzLkJMRU5EX01PREVTLkRJRkZFUkVOQ0VdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5FWENMVVNJT05dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5IVUVdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5TQVRVUkFUSU9OXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBhcnJheVtjb25zdGFudHMuQkxFTkRfTU9ERVMuQ09MT1JdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5MVU1JTk9TSVRZXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBhcnJheVtjb25zdGFudHMuQkxFTkRfTU9ERVMuTk9ORV0gPSBbMCwgMF07XG4gIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5OT1JNQUxfTlBNXSA9IFtnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5BRERfTlBNXSA9IFtnbC5TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FLCBnbC5PTkVdO1xuICBhcnJheVtjb25zdGFudHMuQkxFTkRfTU9ERVMuU0NSRUVOX05QTV0gPSBbZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBhcnJheVtjb25zdGFudHMuQkxFTkRfTU9ERVMuU1JDX0lOXSA9IFtnbC5EU1RfQUxQSEEsIGdsLlpFUk9dO1xuICBhcnJheVtjb25zdGFudHMuQkxFTkRfTU9ERVMuU1JDX09VVF0gPSBbZ2wuT05FX01JTlVTX0RTVF9BTFBIQSwgZ2wuWkVST107XG4gIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5TUkNfQVRPUF0gPSBbZ2wuRFNUX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYXJyYXlbY29uc3RhbnRzLkJMRU5EX01PREVTLkRTVF9PVkVSXSA9IFtnbC5PTkVfTUlOVVNfRFNUX0FMUEhBLCBnbC5PTkVdO1xuICBhcnJheVtjb25zdGFudHMuQkxFTkRfTU9ERVMuRFNUX0lOXSA9IFtnbC5aRVJPLCBnbC5TUkNfQUxQSEFdO1xuICBhcnJheVtjb25zdGFudHMuQkxFTkRfTU9ERVMuRFNUX09VVF0gPSBbZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5EU1RfQVRPUF0gPSBbZ2wuT05FX01JTlVTX0RTVF9BTFBIQSwgZ2wuU1JDX0FMUEhBXTtcbiAgYXJyYXlbY29uc3RhbnRzLkJMRU5EX01PREVTLlhPUl0gPSBbZ2wuT05FX01JTlVTX0RTVF9BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5TVUJUUkFDVF0gPSBbZ2wuT05FLCBnbC5PTkUsIGdsLk9ORSwgZ2wuT05FLCBnbC5GVU5DX1JFVkVSU0VfU1VCVFJBQ1QsIGdsLkZVTkNfQUREXTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnRzLm1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aSA9IG1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SVN5c3RlbS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHJ1bm5lciA9IHJlcXVpcmUoJ0BwaXhpL3J1bm5lcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQHBpeGkvdXRpbHMnKTtcblxuY2xhc3MgU3lzdGVtTWFuYWdlciBleHRlbmRzIHV0aWxzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5ydW5uZXJzID0ge307XG4gICAgdGhpcy5fc3lzdGVtc0hhc2ggPSB7fTtcbiAgfVxuICBzZXR1cChjb25maWcpIHtcbiAgICB0aGlzLmFkZFJ1bm5lcnMoLi4uY29uZmlnLnJ1bm5lcnMpO1xuICAgIGNvbnN0IHByaW9yaXR5ID0gKGNvbmZpZy5wcmlvcml0eSA/PyBbXSkuZmlsdGVyKChrZXkpID0+IGNvbmZpZy5zeXN0ZW1zW2tleV0pO1xuICAgIGNvbnN0IG9yZGVyQnlQcmlvcml0eSA9IFtcbiAgICAgIC4uLnByaW9yaXR5LFxuICAgICAgLi4uT2JqZWN0LmtleXMoY29uZmlnLnN5c3RlbXMpLmZpbHRlcigoa2V5KSA9PiAhcHJpb3JpdHkuaW5jbHVkZXMoa2V5KSlcbiAgICBdO1xuICAgIGZvciAoY29uc3QgaSBvZiBvcmRlckJ5UHJpb3JpdHkpIHtcbiAgICAgIHRoaXMuYWRkU3lzdGVtKGNvbmZpZy5zeXN0ZW1zW2ldLCBpKTtcbiAgICB9XG4gIH1cbiAgYWRkUnVubmVycyguLi5ydW5uZXJJZHMpIHtcbiAgICBydW5uZXJJZHMuZm9yRWFjaCgocnVubmVySWQpID0+IHtcbiAgICAgIHRoaXMucnVubmVyc1tydW5uZXJJZF0gPSBuZXcgcnVubmVyLlJ1bm5lcihydW5uZXJJZCk7XG4gICAgfSk7XG4gIH1cbiAgYWRkU3lzdGVtKENsYXNzUmVmLCBuYW1lKSB7XG4gICAgY29uc3Qgc3lzdGVtID0gbmV3IENsYXNzUmVmKHRoaXMpO1xuICAgIGlmICh0aGlzW25hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFdob29wcyEgVGhlIG5hbWUgXCIke25hbWV9XCIgaXMgYWxyZWFkeSBpbiB1c2VgKTtcbiAgICB9XG4gICAgdGhpc1tuYW1lXSA9IHN5c3RlbTtcbiAgICB0aGlzLl9zeXN0ZW1zSGFzaFtuYW1lXSA9IHN5c3RlbTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5ydW5uZXJzKSB7XG4gICAgICB0aGlzLnJ1bm5lcnNbaV0uYWRkKHN5c3RlbSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGVtaXRXaXRoQ3VzdG9tT3B0aW9ucyhydW5uZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzeXN0ZW1IYXNoS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX3N5c3RlbXNIYXNoKTtcbiAgICBydW5uZXIuaXRlbXMuZm9yRWFjaCgoc3lzdGVtKSA9PiB7XG4gICAgICBjb25zdCBzeXN0ZW1OYW1lID0gc3lzdGVtSGFzaEtleXMuZmluZCgoc3lzdGVtSWQpID0+IHRoaXMuX3N5c3RlbXNIYXNoW3N5c3RlbUlkXSA9PT0gc3lzdGVtKTtcbiAgICAgIHN5c3RlbVtydW5uZXIubmFtZV0ob3B0aW9uc1tzeXN0ZW1OYW1lXSk7XG4gICAgfSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBPYmplY3QudmFsdWVzKHRoaXMucnVubmVycykuZm9yRWFjaCgocnVubmVyKSA9PiB7XG4gICAgICBydW5uZXIuZGVzdHJveSgpO1xuICAgIH0pO1xuICAgIHRoaXMuX3N5c3RlbXNIYXNoID0ge307XG4gIH1cbn1cblxuZXhwb3J0cy5TeXN0ZW1NYW5hZ2VyID0gU3lzdGVtTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN5c3RlbU1hbmFnZXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBCYWNrZ3JvdW5kU3lzdGVtID0gcmVxdWlyZSgnLi9iYWNrZ3JvdW5kL0JhY2tncm91bmRTeXN0ZW0uanMnKTtcbnZhciBCYXRjaFN5c3RlbSA9IHJlcXVpcmUoJy4vYmF0Y2gvQmF0Y2hTeXN0ZW0uanMnKTtcbnZhciBDb250ZXh0U3lzdGVtID0gcmVxdWlyZSgnLi9jb250ZXh0L0NvbnRleHRTeXN0ZW0uanMnKTtcbnZhciBGaWx0ZXJTeXN0ZW0gPSByZXF1aXJlKCcuL2ZpbHRlcnMvRmlsdGVyU3lzdGVtLmpzJyk7XG52YXIgRnJhbWVidWZmZXJTeXN0ZW0gPSByZXF1aXJlKCcuL2ZyYW1lYnVmZmVyL0ZyYW1lYnVmZmVyU3lzdGVtLmpzJyk7XG52YXIgR2VvbWV0cnlTeXN0ZW0gPSByZXF1aXJlKCcuL2dlb21ldHJ5L0dlb21ldHJ5U3lzdGVtLmpzJyk7XG52YXIgTWFza1N5c3RlbSA9IHJlcXVpcmUoJy4vbWFzay9NYXNrU3lzdGVtLmpzJyk7XG52YXIgU2Npc3NvclN5c3RlbSA9IHJlcXVpcmUoJy4vbWFzay9TY2lzc29yU3lzdGVtLmpzJyk7XG52YXIgU3RlbmNpbFN5c3RlbSA9IHJlcXVpcmUoJy4vbWFzay9TdGVuY2lsU3lzdGVtLmpzJyk7XG52YXIgUGx1Z2luU3lzdGVtID0gcmVxdWlyZSgnLi9wbHVnaW4vUGx1Z2luU3lzdGVtLmpzJyk7XG52YXIgUHJvamVjdGlvblN5c3RlbSA9IHJlcXVpcmUoJy4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uU3lzdGVtLmpzJyk7XG52YXIgR2VuZXJhdGVUZXh0dXJlU3lzdGVtID0gcmVxdWlyZSgnLi9yZW5kZXJUZXh0dXJlL0dlbmVyYXRlVGV4dHVyZVN5c3RlbS5qcycpO1xudmFyIFJlbmRlclRleHR1cmVTeXN0ZW0gPSByZXF1aXJlKCcuL3JlbmRlclRleHR1cmUvUmVuZGVyVGV4dHVyZVN5c3RlbS5qcycpO1xudmFyIFNoYWRlclN5c3RlbSA9IHJlcXVpcmUoJy4vc2hhZGVyL1NoYWRlclN5c3RlbS5qcycpO1xudmFyIFN0YXJ0dXBTeXN0ZW0gPSByZXF1aXJlKCcuL3N0YXJ0dXAvU3RhcnR1cFN5c3RlbS5qcycpO1xudmFyIFN0YXRlU3lzdGVtID0gcmVxdWlyZSgnLi9zdGF0ZS9TdGF0ZVN5c3RlbS5qcycpO1xudmFyIFN5c3RlbU1hbmFnZXIgPSByZXF1aXJlKCcuL3N5c3RlbS9TeXN0ZW1NYW5hZ2VyLmpzJyk7XG52YXIgVGV4dHVyZUdDU3lzdGVtID0gcmVxdWlyZSgnLi90ZXh0dXJlcy9UZXh0dXJlR0NTeXN0ZW0uanMnKTtcbnZhciBUZXh0dXJlU3lzdGVtID0gcmVxdWlyZSgnLi90ZXh0dXJlcy9UZXh0dXJlU3lzdGVtLmpzJyk7XG52YXIgVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0gPSByZXF1aXJlKCcuL3RyYW5zZm9ybUZlZWRiYWNrL1RyYW5zZm9ybUZlZWRiYWNrU3lzdGVtLmpzJyk7XG52YXIgVmlld1N5c3RlbSA9IHJlcXVpcmUoJy4vdmlldy9WaWV3U3lzdGVtLmpzJyk7XG5cblxuXG5leHBvcnRzLkJhY2tncm91bmRTeXN0ZW0gPSBCYWNrZ3JvdW5kU3lzdGVtLkJhY2tncm91bmRTeXN0ZW07XG5leHBvcnRzLkJhdGNoU3lzdGVtID0gQmF0Y2hTeXN0ZW0uQmF0Y2hTeXN0ZW07XG5leHBvcnRzLkNvbnRleHRTeXN0ZW0gPSBDb250ZXh0U3lzdGVtLkNvbnRleHRTeXN0ZW07XG5leHBvcnRzLkZpbHRlclN5c3RlbSA9IEZpbHRlclN5c3RlbS5GaWx0ZXJTeXN0ZW07XG5leHBvcnRzLkZyYW1lYnVmZmVyU3lzdGVtID0gRnJhbWVidWZmZXJTeXN0ZW0uRnJhbWVidWZmZXJTeXN0ZW07XG5leHBvcnRzLkdlb21ldHJ5U3lzdGVtID0gR2VvbWV0cnlTeXN0ZW0uR2VvbWV0cnlTeXN0ZW07XG5leHBvcnRzLk1hc2tTeXN0ZW0gPSBNYXNrU3lzdGVtLk1hc2tTeXN0ZW07XG5leHBvcnRzLlNjaXNzb3JTeXN0ZW0gPSBTY2lzc29yU3lzdGVtLlNjaXNzb3JTeXN0ZW07XG5leHBvcnRzLlN0ZW5jaWxTeXN0ZW0gPSBTdGVuY2lsU3lzdGVtLlN0ZW5jaWxTeXN0ZW07XG5leHBvcnRzLlBsdWdpblN5c3RlbSA9IFBsdWdpblN5c3RlbS5QbHVnaW5TeXN0ZW07XG5leHBvcnRzLlByb2plY3Rpb25TeXN0ZW0gPSBQcm9qZWN0aW9uU3lzdGVtLlByb2plY3Rpb25TeXN0ZW07XG5leHBvcnRzLkdlbmVyYXRlVGV4dHVyZVN5c3RlbSA9IEdlbmVyYXRlVGV4dHVyZVN5c3RlbS5HZW5lcmF0ZVRleHR1cmVTeXN0ZW07XG5leHBvcnRzLlJlbmRlclRleHR1cmVTeXN0ZW0gPSBSZW5kZXJUZXh0dXJlU3lzdGVtLlJlbmRlclRleHR1cmVTeXN0ZW07XG5leHBvcnRzLlNoYWRlclN5c3RlbSA9IFNoYWRlclN5c3RlbS5TaGFkZXJTeXN0ZW07XG5leHBvcnRzLlN0YXJ0dXBTeXN0ZW0gPSBTdGFydHVwU3lzdGVtLlN0YXJ0dXBTeXN0ZW07XG5leHBvcnRzLlN0YXRlU3lzdGVtID0gU3RhdGVTeXN0ZW0uU3RhdGVTeXN0ZW07XG5leHBvcnRzLlN5c3RlbU1hbmFnZXIgPSBTeXN0ZW1NYW5hZ2VyLlN5c3RlbU1hbmFnZXI7XG5leHBvcnRzLlRleHR1cmVHQ1N5c3RlbSA9IFRleHR1cmVHQ1N5c3RlbS5UZXh0dXJlR0NTeXN0ZW07XG5leHBvcnRzLlRleHR1cmVTeXN0ZW0gPSBUZXh0dXJlU3lzdGVtLlRleHR1cmVTeXN0ZW07XG5leHBvcnRzLlRyYW5zZm9ybUZlZWRiYWNrU3lzdGVtID0gVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0uVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW07XG5leHBvcnRzLlZpZXdTeXN0ZW0gPSBWaWV3U3lzdGVtLlZpZXdTeXN0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zeXN0ZW1zLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnQHBpeGkvY29uc3RhbnRzJyk7XG52YXIgc2V0dGluZ3MgPSByZXF1aXJlKCdAcGl4aS9zZXR0aW5ncycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQHBpeGkvdXRpbHMnKTtcbnZhciBhdXRvRGV0ZWN0UmVzb3VyY2UgPSByZXF1aXJlKCcuL3Jlc291cmNlcy9hdXRvRGV0ZWN0UmVzb3VyY2UuanMnKTtcbnZhciBCdWZmZXJSZXNvdXJjZSA9IHJlcXVpcmUoJy4vcmVzb3VyY2VzL0J1ZmZlclJlc291cmNlLmpzJyk7XG52YXIgUmVzb3VyY2UgPSByZXF1aXJlKCcuL3Jlc291cmNlcy9SZXNvdXJjZS5qcycpO1xuXG5jb25zdCBkZWZhdWx0QnVmZmVyT3B0aW9ucyA9IHtcbiAgc2NhbGVNb2RlOiBjb25zdGFudHMuU0NBTEVfTU9ERVMuTkVBUkVTVCxcbiAgZm9ybWF0OiBjb25zdGFudHMuRk9STUFUUy5SR0JBLFxuICBhbHBoYU1vZGU6IGNvbnN0YW50cy5BTFBIQV9NT0RFUy5OUE1cbn07XG5jb25zdCBfQmFzZVRleHR1cmUgPSBjbGFzcyBleHRlbmRzIHV0aWxzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKHJlc291cmNlID0gbnVsbCwgb3B0aW9ucyA9IG51bGwpIHtcbiAgICBzdXBlcigpO1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBfQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGFscGhhTW9kZSxcbiAgICAgIG1pcG1hcCxcbiAgICAgIGFuaXNvdHJvcGljTGV2ZWwsXG4gICAgICBzY2FsZU1vZGUsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHdyYXBNb2RlLFxuICAgICAgZm9ybWF0LFxuICAgICAgdHlwZSxcbiAgICAgIHRhcmdldCxcbiAgICAgIHJlc29sdXRpb24sXG4gICAgICByZXNvdXJjZU9wdGlvbnNcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAocmVzb3VyY2UgJiYgIShyZXNvdXJjZSBpbnN0YW5jZW9mIFJlc291cmNlLlJlc291cmNlKSkge1xuICAgICAgcmVzb3VyY2UgPSBhdXRvRGV0ZWN0UmVzb3VyY2UuYXV0b0RldGVjdFJlc291cmNlKHJlc291cmNlLCByZXNvdXJjZU9wdGlvbnMpO1xuICAgICAgcmVzb3VyY2UuaW50ZXJuYWwgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IHNldHRpbmdzLnNldHRpbmdzLlJFU09MVVRJT047XG4gICAgdGhpcy53aWR0aCA9IE1hdGgucm91bmQoKHdpZHRoIHx8IDApICogdGhpcy5yZXNvbHV0aW9uKSAvIHRoaXMucmVzb2x1dGlvbjtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgucm91bmQoKGhlaWdodCB8fCAwKSAqIHRoaXMucmVzb2x1dGlvbikgLyB0aGlzLnJlc29sdXRpb247XG4gICAgdGhpcy5fbWlwbWFwID0gbWlwbWFwO1xuICAgIHRoaXMuYW5pc290cm9waWNMZXZlbCA9IGFuaXNvdHJvcGljTGV2ZWw7XG4gICAgdGhpcy5fd3JhcE1vZGUgPSB3cmFwTW9kZTtcbiAgICB0aGlzLl9zY2FsZU1vZGUgPSBzY2FsZU1vZGU7XG4gICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLmFscGhhTW9kZSA9IGFscGhhTW9kZTtcbiAgICB0aGlzLnVpZCA9IHV0aWxzLnVpZCgpO1xuICAgIHRoaXMudG91Y2hlZCA9IDA7XG4gICAgdGhpcy5pc1Bvd2VyT2ZUd28gPSBmYWxzZTtcbiAgICB0aGlzLl9yZWZyZXNoUE9UKCk7XG4gICAgdGhpcy5fZ2xUZXh0dXJlcyA9IHt9O1xuICAgIHRoaXMuZGlydHlJZCA9IDA7XG4gICAgdGhpcy5kaXJ0eVN0eWxlSWQgPSAwO1xuICAgIHRoaXMuY2FjaGVJZCA9IG51bGw7XG4gICAgdGhpcy52YWxpZCA9IHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwO1xuICAgIHRoaXMudGV4dHVyZUNhY2hlSWRzID0gW107XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlc291cmNlID0gbnVsbDtcbiAgICB0aGlzLl9iYXRjaEVuYWJsZWQgPSAwO1xuICAgIHRoaXMuX2JhdGNoTG9jYXRpb24gPSAwO1xuICAgIHRoaXMucGFyZW50VGV4dHVyZUFycmF5ID0gbnVsbDtcbiAgICB0aGlzLnNldFJlc291cmNlKHJlc291cmNlKTtcbiAgfVxuICBnZXQgcmVhbFdpZHRoKCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMud2lkdGggKiB0aGlzLnJlc29sdXRpb24pO1xuICB9XG4gIGdldCByZWFsSGVpZ2h0KCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMuaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uKTtcbiAgfVxuICBnZXQgbWlwbWFwKCkge1xuICAgIHJldHVybiB0aGlzLl9taXBtYXA7XG4gIH1cbiAgc2V0IG1pcG1hcCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9taXBtYXAgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9taXBtYXAgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZGlydHlTdHlsZUlkKys7XG4gICAgfVxuICB9XG4gIGdldCBzY2FsZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NjYWxlTW9kZTtcbiAgfVxuICBzZXQgc2NhbGVNb2RlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3NjYWxlTW9kZSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX3NjYWxlTW9kZSA9IHZhbHVlO1xuICAgICAgdGhpcy5kaXJ0eVN0eWxlSWQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IHdyYXBNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl93cmFwTW9kZTtcbiAgfVxuICBzZXQgd3JhcE1vZGUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fd3JhcE1vZGUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl93cmFwTW9kZSA9IHZhbHVlO1xuICAgICAgdGhpcy5kaXJ0eVN0eWxlSWQrKztcbiAgICB9XG4gIH1cbiAgc2V0U3R5bGUoc2NhbGVNb2RlLCBtaXBtYXApIHtcbiAgICBsZXQgZGlydHk7XG4gICAgaWYgKHNjYWxlTW9kZSAhPT0gdm9pZCAwICYmIHNjYWxlTW9kZSAhPT0gdGhpcy5zY2FsZU1vZGUpIHtcbiAgICAgIHRoaXMuc2NhbGVNb2RlID0gc2NhbGVNb2RlO1xuICAgICAgZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobWlwbWFwICE9PSB2b2lkIDAgJiYgbWlwbWFwICE9PSB0aGlzLm1pcG1hcCkge1xuICAgICAgdGhpcy5taXBtYXAgPSBtaXBtYXA7XG4gICAgICBkaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChkaXJ0eSkge1xuICAgICAgdGhpcy5kaXJ0eVN0eWxlSWQrKztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0U2l6ZShkZXNpcmVkV2lkdGgsIGRlc2lyZWRIZWlnaHQsIHJlc29sdXRpb24pIHtcbiAgICByZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCB0aGlzLnJlc29sdXRpb247XG4gICAgcmV0dXJuIHRoaXMuc2V0UmVhbFNpemUoZGVzaXJlZFdpZHRoICogcmVzb2x1dGlvbiwgZGVzaXJlZEhlaWdodCAqIHJlc29sdXRpb24sIHJlc29sdXRpb24pO1xuICB9XG4gIHNldFJlYWxTaXplKHJlYWxXaWR0aCwgcmVhbEhlaWdodCwgcmVzb2x1dGlvbikge1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgdGhpcy5yZXNvbHV0aW9uO1xuICAgIHRoaXMud2lkdGggPSBNYXRoLnJvdW5kKHJlYWxXaWR0aCkgLyB0aGlzLnJlc29sdXRpb247XG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLnJvdW5kKHJlYWxIZWlnaHQpIC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHRoaXMuX3JlZnJlc2hQT1QoKTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9yZWZyZXNoUE9UKCkge1xuICAgIHRoaXMuaXNQb3dlck9mVHdvID0gdXRpbHMuaXNQb3cyKHRoaXMucmVhbFdpZHRoKSAmJiB1dGlscy5pc1BvdzIodGhpcy5yZWFsSGVpZ2h0KTtcbiAgfVxuICBzZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pIHtcbiAgICBjb25zdCBvbGRSZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIGlmIChvbGRSZXNvbHV0aW9uID09PSByZXNvbHV0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICBpZiAodGhpcy52YWxpZCkge1xuICAgICAgdGhpcy53aWR0aCA9IE1hdGgucm91bmQodGhpcy53aWR0aCAqIG9sZFJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmhlaWdodCAqIG9sZFJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5fcmVmcmVzaFBPVCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldFJlc291cmNlKHJlc291cmNlKSB7XG4gICAgaWYgKHRoaXMucmVzb3VyY2UgPT09IHJlc291cmNlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMucmVzb3VyY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlc291cmNlIGNhbiBiZSBzZXQgb25seSBvbmNlXCIpO1xuICAgIH1cbiAgICByZXNvdXJjZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgaWYgKCF0aGlzLnZhbGlkKSB7XG4gICAgICBpZiAodGhpcy53aWR0aCA+IDAgJiYgdGhpcy5oZWlnaHQgPiAwKSB7XG4gICAgICAgIHRoaXMudmFsaWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoXCJsb2FkZWRcIiwgdGhpcyk7XG4gICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXJ0eUlkKys7XG4gICAgICB0aGlzLmRpcnR5U3R5bGVJZCsrO1xuICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHRoaXMpO1xuICAgIH1cbiAgfVxuICBvbkVycm9yKGV2ZW50KSB7XG4gICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgdGhpcywgZXZlbnQpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMucmVzb3VyY2UpIHtcbiAgICAgIHRoaXMucmVzb3VyY2UudW5iaW5kKHRoaXMpO1xuICAgICAgaWYgKHRoaXMucmVzb3VyY2UuaW50ZXJuYWwpIHtcbiAgICAgICAgdGhpcy5yZXNvdXJjZS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc291cmNlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2FjaGVJZCkge1xuICAgICAgZGVsZXRlIHV0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbdGhpcy5jYWNoZUlkXTtcbiAgICAgIGRlbGV0ZSB1dGlscy5UZXh0dXJlQ2FjaGVbdGhpcy5jYWNoZUlkXTtcbiAgICAgIHRoaXMuY2FjaGVJZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIF9CYXNlVGV4dHVyZS5yZW1vdmVGcm9tQ2FjaGUodGhpcyk7XG4gICAgdGhpcy50ZXh0dXJlQ2FjaGVJZHMgPSBudWxsO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZW1pdChcImRpc3Bvc2VcIiwgdGhpcyk7XG4gIH1cbiAgY2FzdFRvQmFzZVRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RhdGljIGZyb20oc291cmNlLCBvcHRpb25zLCBzdHJpY3QgPSBzZXR0aW5ncy5zZXR0aW5ncy5TVFJJQ1RfVEVYVFVSRV9DQUNIRSkge1xuICAgIGNvbnN0IGlzRnJhbWUgPSB0eXBlb2Ygc291cmNlID09PSBcInN0cmluZ1wiO1xuICAgIGxldCBjYWNoZUlkID0gbnVsbDtcbiAgICBpZiAoaXNGcmFtZSkge1xuICAgICAgY2FjaGVJZCA9IHNvdXJjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFzb3VyY2UuX3BpeGlJZCkge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBvcHRpb25zPy5waXhpSWRQcmVmaXggfHwgXCJwaXhpaWRcIjtcbiAgICAgICAgc291cmNlLl9waXhpSWQgPSBgJHtwcmVmaXh9XyR7dXRpbHMudWlkKCl9YDtcbiAgICAgIH1cbiAgICAgIGNhY2hlSWQgPSBzb3VyY2UuX3BpeGlJZDtcbiAgICB9XG4gICAgbGV0IGJhc2VUZXh0dXJlID0gdXRpbHMuQmFzZVRleHR1cmVDYWNoZVtjYWNoZUlkXTtcbiAgICBpZiAoaXNGcmFtZSAmJiBzdHJpY3QgJiYgIWJhc2VUZXh0dXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBjYWNoZUlkIFwiJHtjYWNoZUlkfVwiIGRvZXMgbm90IGV4aXN0IGluIEJhc2VUZXh0dXJlQ2FjaGUuYCk7XG4gICAgfVxuICAgIGlmICghYmFzZVRleHR1cmUpIHtcbiAgICAgIGJhc2VUZXh0dXJlID0gbmV3IF9CYXNlVGV4dHVyZShzb3VyY2UsIG9wdGlvbnMpO1xuICAgICAgYmFzZVRleHR1cmUuY2FjaGVJZCA9IGNhY2hlSWQ7XG4gICAgICBfQmFzZVRleHR1cmUuYWRkVG9DYWNoZShiYXNlVGV4dHVyZSwgY2FjaGVJZCk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlVGV4dHVyZTtcbiAgfVxuICBzdGF0aWMgZnJvbUJ1ZmZlcihidWZmZXIsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICBidWZmZXIgPSBidWZmZXIgfHwgbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgIGNvbnN0IHJlc291cmNlID0gbmV3IEJ1ZmZlclJlc291cmNlLkJ1ZmZlclJlc291cmNlKGJ1ZmZlciwgeyB3aWR0aCwgaGVpZ2h0IH0pO1xuICAgIGNvbnN0IHR5cGUgPSBidWZmZXIgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgPyBjb25zdGFudHMuVFlQRVMuRkxPQVQgOiBjb25zdGFudHMuVFlQRVMuVU5TSUdORURfQllURTtcbiAgICByZXR1cm4gbmV3IF9CYXNlVGV4dHVyZShyZXNvdXJjZSwgT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEJ1ZmZlck9wdGlvbnMsIHsgdHlwZSB9LCBvcHRpb25zKSk7XG4gIH1cbiAgc3RhdGljIGFkZFRvQ2FjaGUoYmFzZVRleHR1cmUsIGlkKSB7XG4gICAgaWYgKGlkKSB7XG4gICAgICBpZiAoIWJhc2VUZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5pbmNsdWRlcyhpZCkpIHtcbiAgICAgICAgYmFzZVRleHR1cmUudGV4dHVyZUNhY2hlSWRzLnB1c2goaWQpO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbaWRdICYmIHV0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbaWRdICE9PSBiYXNlVGV4dHVyZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYEJhc2VUZXh0dXJlIGFkZGVkIHRvIHRoZSBjYWNoZSB3aXRoIGFuIGlkIFske2lkfV0gdGhhdCBhbHJlYWR5IGhhZCBhbiBlbnRyeWApO1xuICAgICAgfVxuICAgICAgdXRpbHMuQmFzZVRleHR1cmVDYWNoZVtpZF0gPSBiYXNlVGV4dHVyZTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHJlbW92ZUZyb21DYWNoZShiYXNlVGV4dHVyZSkge1xuICAgIGlmICh0eXBlb2YgYmFzZVRleHR1cmUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGJhc2VUZXh0dXJlRnJvbUNhY2hlID0gdXRpbHMuQmFzZVRleHR1cmVDYWNoZVtiYXNlVGV4dHVyZV07XG4gICAgICBpZiAoYmFzZVRleHR1cmVGcm9tQ2FjaGUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBiYXNlVGV4dHVyZUZyb21DYWNoZS50ZXh0dXJlQ2FjaGVJZHMuaW5kZXhPZihiYXNlVGV4dHVyZSk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgYmFzZVRleHR1cmVGcm9tQ2FjaGUudGV4dHVyZUNhY2hlSWRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHV0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbYmFzZVRleHR1cmVdO1xuICAgICAgICByZXR1cm4gYmFzZVRleHR1cmVGcm9tQ2FjaGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChiYXNlVGV4dHVyZT8udGV4dHVyZUNhY2hlSWRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2VUZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBkZWxldGUgdXRpbHMuQmFzZVRleHR1cmVDYWNoZVtiYXNlVGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHNbaV1dO1xuICAgICAgfVxuICAgICAgYmFzZVRleHR1cmUudGV4dHVyZUNhY2hlSWRzLmxlbmd0aCA9IDA7XG4gICAgICByZXR1cm4gYmFzZVRleHR1cmU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xubGV0IEJhc2VUZXh0dXJlID0gX0Jhc2VUZXh0dXJlO1xuQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIG1pcG1hcDogY29uc3RhbnRzLk1JUE1BUF9NT0RFUy5QT1cyLFxuICBhbmlzb3Ryb3BpY0xldmVsOiAwLFxuICBzY2FsZU1vZGU6IGNvbnN0YW50cy5TQ0FMRV9NT0RFUy5MSU5FQVIsXG4gIHdyYXBNb2RlOiBjb25zdGFudHMuV1JBUF9NT0RFUy5DTEFNUCxcbiAgYWxwaGFNb2RlOiBjb25zdGFudHMuQUxQSEFfTU9ERVMuVU5QQUNLLFxuICB0YXJnZXQ6IGNvbnN0YW50cy5UQVJHRVRTLlRFWFRVUkVfMkQsXG4gIGZvcm1hdDogY29uc3RhbnRzLkZPUk1BVFMuUkdCQSxcbiAgdHlwZTogY29uc3RhbnRzLlRZUEVTLlVOU0lHTkVEX0JZVEVcbn07XG5CYXNlVGV4dHVyZS5fZ2xvYmFsQmF0Y2ggPSAwO1xuXG5leHBvcnRzLkJhc2VUZXh0dXJlID0gQmFzZVRleHR1cmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlVGV4dHVyZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ0BwaXhpL2NvbnN0YW50cycpO1xuXG5jbGFzcyBHTFRleHR1cmUge1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlKSB7XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICB0aGlzLndpZHRoID0gLTE7XG4gICAgdGhpcy5oZWlnaHQgPSAtMTtcbiAgICB0aGlzLmRpcnR5SWQgPSAtMTtcbiAgICB0aGlzLmRpcnR5U3R5bGVJZCA9IC0xO1xuICAgIHRoaXMubWlwbWFwID0gZmFsc2U7XG4gICAgdGhpcy53cmFwTW9kZSA9IDMzMDcxO1xuICAgIHRoaXMudHlwZSA9IGNvbnN0YW50cy5UWVBFUy5VTlNJR05FRF9CWVRFO1xuICAgIHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBjb25zdGFudHMuRk9STUFUUy5SR0JBO1xuICAgIHRoaXMuc2FtcGxlclR5cGUgPSAwO1xuICB9XG59XG5cbmV4cG9ydHMuR0xUZXh0dXJlID0gR0xUZXh0dXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R0xUZXh0dXJlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbWF0aCA9IHJlcXVpcmUoJ0BwaXhpL21hdGgnKTtcbnZhciBzZXR0aW5ncyA9IHJlcXVpcmUoJ0BwaXhpL3NldHRpbmdzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdAcGl4aS91dGlscycpO1xudmFyIEJhc2VUZXh0dXJlID0gcmVxdWlyZSgnLi9CYXNlVGV4dHVyZS5qcycpO1xudmFyIEltYWdlUmVzb3VyY2UgPSByZXF1aXJlKCcuL3Jlc291cmNlcy9JbWFnZVJlc291cmNlLmpzJyk7XG52YXIgVGV4dHVyZVV2cyA9IHJlcXVpcmUoJy4vVGV4dHVyZVV2cy5qcycpO1xuXG5jb25zdCBERUZBVUxUX1VWUyA9IG5ldyBUZXh0dXJlVXZzLlRleHR1cmVVdnMoKTtcbmZ1bmN0aW9uIHJlbW92ZUFsbEhhbmRsZXJzKHRleCkge1xuICB0ZXguZGVzdHJveSA9IGZ1bmN0aW9uIF9lbXB0eURlc3Ryb3koKSB7XG4gIH07XG4gIHRleC5vbiA9IGZ1bmN0aW9uIF9lbXB0eU9uKCkge1xuICB9O1xuICB0ZXgub25jZSA9IGZ1bmN0aW9uIF9lbXB0eU9uY2UoKSB7XG4gIH07XG4gIHRleC5lbWl0ID0gZnVuY3Rpb24gX2VtcHR5RW1pdCgpIHtcbiAgfTtcbn1cbmNsYXNzIFRleHR1cmUgZXh0ZW5kcyB1dGlscy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihiYXNlVGV4dHVyZSwgZnJhbWUsIG9yaWcsIHRyaW0sIHJvdGF0ZSwgYW5jaG9yLCBib3JkZXJzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5vRnJhbWUgPSBmYWxzZTtcbiAgICBpZiAoIWZyYW1lKSB7XG4gICAgICB0aGlzLm5vRnJhbWUgPSB0cnVlO1xuICAgICAgZnJhbWUgPSBuZXcgbWF0aC5SZWN0YW5nbGUoMCwgMCwgMSwgMSk7XG4gICAgfVxuICAgIGlmIChiYXNlVGV4dHVyZSBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgIGJhc2VUZXh0dXJlID0gYmFzZVRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgfVxuICAgIHRoaXMuYmFzZVRleHR1cmUgPSBiYXNlVGV4dHVyZTtcbiAgICB0aGlzLl9mcmFtZSA9IGZyYW1lO1xuICAgIHRoaXMudHJpbSA9IHRyaW07XG4gICAgdGhpcy52YWxpZCA9IGZhbHNlO1xuICAgIHRoaXMuX3V2cyA9IERFRkFVTFRfVVZTO1xuICAgIHRoaXMudXZNYXRyaXggPSBudWxsO1xuICAgIHRoaXMub3JpZyA9IG9yaWcgfHwgZnJhbWU7XG4gICAgdGhpcy5fcm90YXRlID0gTnVtYmVyKHJvdGF0ZSB8fCAwKTtcbiAgICBpZiAocm90YXRlID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9yb3RhdGUgPSAyO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcm90YXRlICUgMiAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXR0ZW1wdCB0byB1c2UgZGlhbW9uZC1zaGFwZWQgVVZzLiBJZiB5b3UgYXJlIHN1cmUsIHNldCByb3RhdGlvbiBtYW51YWxseVwiKTtcbiAgICB9XG4gICAgdGhpcy5kZWZhdWx0QW5jaG9yID0gYW5jaG9yID8gbmV3IG1hdGguUG9pbnQoYW5jaG9yLngsIGFuY2hvci55KSA6IG5ldyBtYXRoLlBvaW50KDAsIDApO1xuICAgIHRoaXMuZGVmYXVsdEJvcmRlcnMgPSBib3JkZXJzO1xuICAgIHRoaXMuX3VwZGF0ZUlEID0gMDtcbiAgICB0aGlzLnRleHR1cmVDYWNoZUlkcyA9IFtdO1xuICAgIGlmICghYmFzZVRleHR1cmUudmFsaWQpIHtcbiAgICAgIGJhc2VUZXh0dXJlLm9uY2UoXCJsb2FkZWRcIiwgdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZCwgdGhpcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5vRnJhbWUpIHtcbiAgICAgIGlmIChiYXNlVGV4dHVyZS52YWxpZCkge1xuICAgICAgICB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkKGJhc2VUZXh0dXJlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mcmFtZSA9IGZyYW1lO1xuICAgIH1cbiAgICBpZiAodGhpcy5ub0ZyYW1lKSB7XG4gICAgICBiYXNlVGV4dHVyZS5vbihcInVwZGF0ZVwiLCB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGlmICh0aGlzLmJhc2VUZXh0dXJlLnJlc291cmNlKSB7XG4gICAgICB0aGlzLmJhc2VUZXh0dXJlLnJlc291cmNlLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBvbkJhc2VUZXh0dXJlVXBkYXRlZChiYXNlVGV4dHVyZSkge1xuICAgIGlmICh0aGlzLm5vRnJhbWUpIHtcbiAgICAgIGlmICghdGhpcy5iYXNlVGV4dHVyZS52YWxpZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9mcmFtZS53aWR0aCA9IGJhc2VUZXh0dXJlLndpZHRoO1xuICAgICAgdGhpcy5fZnJhbWUuaGVpZ2h0ID0gYmFzZVRleHR1cmUuaGVpZ2h0O1xuICAgICAgdGhpcy52YWxpZCA9IHRydWU7XG4gICAgICB0aGlzLnVwZGF0ZVV2cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZyYW1lID0gdGhpcy5fZnJhbWU7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKTtcbiAgfVxuICBkZXN0cm95KGRlc3Ryb3lCYXNlKSB7XG4gICAgaWYgKHRoaXMuYmFzZVRleHR1cmUpIHtcbiAgICAgIGlmIChkZXN0cm95QmFzZSkge1xuICAgICAgICBjb25zdCB7IHJlc291cmNlIH0gPSB0aGlzLmJhc2VUZXh0dXJlO1xuICAgICAgICBpZiAocmVzb3VyY2U/LnVybCAmJiB1dGlscy5UZXh0dXJlQ2FjaGVbcmVzb3VyY2UudXJsXSkge1xuICAgICAgICAgIFRleHR1cmUucmVtb3ZlRnJvbUNhY2hlKHJlc291cmNlLnVybCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmJhc2VUZXh0dXJlLm9mZihcImxvYWRlZFwiLCB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkLCB0aGlzKTtcbiAgICAgIHRoaXMuYmFzZVRleHR1cmUub2ZmKFwidXBkYXRlXCIsIHRoaXMub25CYXNlVGV4dHVyZVVwZGF0ZWQsIHRoaXMpO1xuICAgICAgdGhpcy5iYXNlVGV4dHVyZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX2ZyYW1lID0gbnVsbDtcbiAgICB0aGlzLl91dnMgPSBudWxsO1xuICAgIHRoaXMudHJpbSA9IG51bGw7XG4gICAgdGhpcy5vcmlnID0gbnVsbDtcbiAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG4gICAgVGV4dHVyZS5yZW1vdmVGcm9tQ2FjaGUodGhpcyk7XG4gICAgdGhpcy50ZXh0dXJlQ2FjaGVJZHMgPSBudWxsO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lZEZyYW1lID0gdGhpcy5fZnJhbWUuY2xvbmUoKTtcbiAgICBjb25zdCBjbG9uZWRPcmlnID0gdGhpcy5fZnJhbWUgPT09IHRoaXMub3JpZyA/IGNsb25lZEZyYW1lIDogdGhpcy5vcmlnLmNsb25lKCk7XG4gICAgY29uc3QgY2xvbmVkVGV4dHVyZSA9IG5ldyBUZXh0dXJlKHRoaXMuYmFzZVRleHR1cmUsICF0aGlzLm5vRnJhbWUgJiYgY2xvbmVkRnJhbWUsIGNsb25lZE9yaWcsIHRoaXMudHJpbT8uY2xvbmUoKSwgdGhpcy5yb3RhdGUsIHRoaXMuZGVmYXVsdEFuY2hvciwgdGhpcy5kZWZhdWx0Qm9yZGVycyk7XG4gICAgaWYgKHRoaXMubm9GcmFtZSkge1xuICAgICAgY2xvbmVkVGV4dHVyZS5fZnJhbWUgPSBjbG9uZWRGcmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZFRleHR1cmU7XG4gIH1cbiAgdXBkYXRlVXZzKCkge1xuICAgIGlmICh0aGlzLl91dnMgPT09IERFRkFVTFRfVVZTKSB7XG4gICAgICB0aGlzLl91dnMgPSBuZXcgVGV4dHVyZVV2cy5UZXh0dXJlVXZzKCk7XG4gICAgfVxuICAgIHRoaXMuX3V2cy5zZXQodGhpcy5fZnJhbWUsIHRoaXMuYmFzZVRleHR1cmUsIHRoaXMucm90YXRlKTtcbiAgICB0aGlzLl91cGRhdGVJRCsrO1xuICB9XG4gIHN0YXRpYyBmcm9tKHNvdXJjZSwgb3B0aW9ucyA9IHt9LCBzdHJpY3QgPSBzZXR0aW5ncy5zZXR0aW5ncy5TVFJJQ1RfVEVYVFVSRV9DQUNIRSkge1xuICAgIGNvbnN0IGlzRnJhbWUgPSB0eXBlb2Ygc291cmNlID09PSBcInN0cmluZ1wiO1xuICAgIGxldCBjYWNoZUlkID0gbnVsbDtcbiAgICBpZiAoaXNGcmFtZSkge1xuICAgICAgY2FjaGVJZCA9IHNvdXJjZTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEJhc2VUZXh0dXJlLkJhc2VUZXh0dXJlKSB7XG4gICAgICBpZiAoIXNvdXJjZS5jYWNoZUlkKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG9wdGlvbnM/LnBpeGlJZFByZWZpeCB8fCBcInBpeGlpZFwiO1xuICAgICAgICBzb3VyY2UuY2FjaGVJZCA9IGAke3ByZWZpeH0tJHt1dGlscy51aWQoKX1gO1xuICAgICAgICBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZS5hZGRUb0NhY2hlKHNvdXJjZSwgc291cmNlLmNhY2hlSWQpO1xuICAgICAgfVxuICAgICAgY2FjaGVJZCA9IHNvdXJjZS5jYWNoZUlkO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXNvdXJjZS5fcGl4aUlkKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG9wdGlvbnM/LnBpeGlJZFByZWZpeCB8fCBcInBpeGlpZFwiO1xuICAgICAgICBzb3VyY2UuX3BpeGlJZCA9IGAke3ByZWZpeH1fJHt1dGlscy51aWQoKX1gO1xuICAgICAgfVxuICAgICAgY2FjaGVJZCA9IHNvdXJjZS5fcGl4aUlkO1xuICAgIH1cbiAgICBsZXQgdGV4dHVyZSA9IHV0aWxzLlRleHR1cmVDYWNoZVtjYWNoZUlkXTtcbiAgICBpZiAoaXNGcmFtZSAmJiBzdHJpY3QgJiYgIXRleHR1cmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGNhY2hlSWQgXCIke2NhY2hlSWR9XCIgZG9lcyBub3QgZXhpc3QgaW4gVGV4dHVyZUNhY2hlLmApO1xuICAgIH1cbiAgICBpZiAoIXRleHR1cmUgJiYgIShzb3VyY2UgaW5zdGFuY2VvZiBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZSkpIHtcbiAgICAgIGlmICghb3B0aW9ucy5yZXNvbHV0aW9uKSB7XG4gICAgICAgIG9wdGlvbnMucmVzb2x1dGlvbiA9IHV0aWxzLmdldFJlc29sdXRpb25PZlVybChzb3VyY2UpO1xuICAgICAgfVxuICAgICAgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKG5ldyBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZShzb3VyY2UsIG9wdGlvbnMpKTtcbiAgICAgIHRleHR1cmUuYmFzZVRleHR1cmUuY2FjaGVJZCA9IGNhY2hlSWQ7XG4gICAgICBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZS5hZGRUb0NhY2hlKHRleHR1cmUuYmFzZVRleHR1cmUsIGNhY2hlSWQpO1xuICAgICAgVGV4dHVyZS5hZGRUb0NhY2hlKHRleHR1cmUsIGNhY2hlSWQpO1xuICAgIH0gZWxzZSBpZiAoIXRleHR1cmUgJiYgc291cmNlIGluc3RhbmNlb2YgQmFzZVRleHR1cmUuQmFzZVRleHR1cmUpIHtcbiAgICAgIHRleHR1cmUgPSBuZXcgVGV4dHVyZShzb3VyY2UpO1xuICAgICAgVGV4dHVyZS5hZGRUb0NhY2hlKHRleHR1cmUsIGNhY2hlSWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxuICBzdGF0aWMgZnJvbVVSTCh1cmwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXNvdXJjZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgYXV0b0xvYWQ6IGZhbHNlIH0sIG9wdGlvbnM/LnJlc291cmNlT3B0aW9ucyk7XG4gICAgY29uc3QgdGV4dHVyZSA9IFRleHR1cmUuZnJvbSh1cmwsIE9iamVjdC5hc3NpZ24oeyByZXNvdXJjZU9wdGlvbnMgfSwgb3B0aW9ucyksIGZhbHNlKTtcbiAgICBjb25zdCByZXNvdXJjZSA9IHRleHR1cmUuYmFzZVRleHR1cmUucmVzb3VyY2U7XG4gICAgaWYgKHRleHR1cmUuYmFzZVRleHR1cmUudmFsaWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGV4dHVyZSk7XG4gICAgfVxuICAgIHJldHVybiByZXNvdXJjZS5sb2FkKCkudGhlbigoKSA9PiBQcm9taXNlLnJlc29sdmUodGV4dHVyZSkpO1xuICB9XG4gIHN0YXRpYyBmcm9tQnVmZmVyKGJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVGV4dHVyZShCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZS5mcm9tQnVmZmVyKGJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykpO1xuICB9XG4gIHN0YXRpYyBmcm9tTG9hZGVyKHNvdXJjZSwgaW1hZ2VVcmwsIG5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBiYXNlVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZShzb3VyY2UsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgc2NhbGVNb2RlOiBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5zY2FsZU1vZGUsXG4gICAgICByZXNvbHV0aW9uOiB1dGlscy5nZXRSZXNvbHV0aW9uT2ZVcmwoaW1hZ2VVcmwpXG4gICAgfSwgb3B0aW9ucykpO1xuICAgIGNvbnN0IHsgcmVzb3VyY2UgfSA9IGJhc2VUZXh0dXJlO1xuICAgIGlmIChyZXNvdXJjZSBpbnN0YW5jZW9mIEltYWdlUmVzb3VyY2UuSW1hZ2VSZXNvdXJjZSkge1xuICAgICAgcmVzb3VyY2UudXJsID0gaW1hZ2VVcmw7XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZShiYXNlVGV4dHVyZSk7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBuYW1lID0gaW1hZ2VVcmw7XG4gICAgfVxuICAgIEJhc2VUZXh0dXJlLkJhc2VUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZS5iYXNlVGV4dHVyZSwgbmFtZSk7XG4gICAgVGV4dHVyZS5hZGRUb0NhY2hlKHRleHR1cmUsIG5hbWUpO1xuICAgIGlmIChuYW1lICE9PSBpbWFnZVVybCkge1xuICAgICAgQmFzZVRleHR1cmUuQmFzZVRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLCBpbWFnZVVybCk7XG4gICAgICBUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZSwgaW1hZ2VVcmwpO1xuICAgIH1cbiAgICBpZiAodGV4dHVyZS5iYXNlVGV4dHVyZS52YWxpZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0ZXh0dXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLm9uY2UoXCJsb2FkZWRcIiwgKCkgPT4gcmVzb2x2ZSh0ZXh0dXJlKSk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGFkZFRvQ2FjaGUodGV4dHVyZSwgaWQpIHtcbiAgICBpZiAoaWQpIHtcbiAgICAgIGlmICghdGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMuaW5jbHVkZXMoaWQpKSB7XG4gICAgICAgIHRleHR1cmUudGV4dHVyZUNhY2hlSWRzLnB1c2goaWQpO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWxzLlRleHR1cmVDYWNoZVtpZF0gJiYgdXRpbHMuVGV4dHVyZUNhY2hlW2lkXSAhPT0gdGV4dHVyZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFRleHR1cmUgYWRkZWQgdG8gdGhlIGNhY2hlIHdpdGggYW4gaWQgWyR7aWR9XSB0aGF0IGFscmVhZHkgaGFkIGFuIGVudHJ5YCk7XG4gICAgICB9XG4gICAgICB1dGlscy5UZXh0dXJlQ2FjaGVbaWRdID0gdGV4dHVyZTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHJlbW92ZUZyb21DYWNoZSh0ZXh0dXJlKSB7XG4gICAgaWYgKHR5cGVvZiB0ZXh0dXJlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlRnJvbUNhY2hlID0gdXRpbHMuVGV4dHVyZUNhY2hlW3RleHR1cmVdO1xuICAgICAgaWYgKHRleHR1cmVGcm9tQ2FjaGUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0ZXh0dXJlRnJvbUNhY2hlLnRleHR1cmVDYWNoZUlkcy5pbmRleE9mKHRleHR1cmUpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIHRleHR1cmVGcm9tQ2FjaGUudGV4dHVyZUNhY2hlSWRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHV0aWxzLlRleHR1cmVDYWNoZVt0ZXh0dXJlXTtcbiAgICAgICAgcmV0dXJuIHRleHR1cmVGcm9tQ2FjaGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0ZXh0dXJlPy50ZXh0dXJlQ2FjaGVJZHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHV0aWxzLlRleHR1cmVDYWNoZVt0ZXh0dXJlLnRleHR1cmVDYWNoZUlkc1tpXV0gPT09IHRleHR1cmUpIHtcbiAgICAgICAgICBkZWxldGUgdXRpbHMuVGV4dHVyZUNhY2hlW3RleHR1cmUudGV4dHVyZUNhY2hlSWRzW2ldXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMubGVuZ3RoID0gMDtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgcmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uO1xuICB9XG4gIGdldCBmcmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnJhbWU7XG4gIH1cbiAgc2V0IGZyYW1lKGZyYW1lKSB7XG4gICAgdGhpcy5fZnJhbWUgPSBmcmFtZTtcbiAgICB0aGlzLm5vRnJhbWUgPSBmYWxzZTtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IGZyYW1lO1xuICAgIGNvbnN0IHhOb3RGaXQgPSB4ICsgd2lkdGggPiB0aGlzLmJhc2VUZXh0dXJlLndpZHRoO1xuICAgIGNvbnN0IHlOb3RGaXQgPSB5ICsgaGVpZ2h0ID4gdGhpcy5iYXNlVGV4dHVyZS5oZWlnaHQ7XG4gICAgaWYgKHhOb3RGaXQgfHwgeU5vdEZpdCkge1xuICAgICAgY29uc3QgcmVsYXRpb25zaGlwID0geE5vdEZpdCAmJiB5Tm90Rml0ID8gXCJhbmRcIiA6IFwib3JcIjtcbiAgICAgIGNvbnN0IGVycm9yWCA9IGBYOiAke3h9ICsgJHt3aWR0aH0gPSAke3ggKyB3aWR0aH0gPiAke3RoaXMuYmFzZVRleHR1cmUud2lkdGh9YDtcbiAgICAgIGNvbnN0IGVycm9yWSA9IGBZOiAke3l9ICsgJHtoZWlnaHR9ID0gJHt5ICsgaGVpZ2h0fSA+ICR7dGhpcy5iYXNlVGV4dHVyZS5oZWlnaHR9YDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGV4dHVyZSBFcnJvcjogZnJhbWUgZG9lcyBub3QgZml0IGluc2lkZSB0aGUgYmFzZSBUZXh0dXJlIGRpbWVuc2lvbnM6ICR7ZXJyb3JYfSAke3JlbGF0aW9uc2hpcH0gJHtlcnJvcll9YCk7XG4gICAgfVxuICAgIHRoaXMudmFsaWQgPSB3aWR0aCAmJiBoZWlnaHQgJiYgdGhpcy5iYXNlVGV4dHVyZS52YWxpZDtcbiAgICBpZiAoIXRoaXMudHJpbSAmJiAhdGhpcy5yb3RhdGUpIHtcbiAgICAgIHRoaXMub3JpZyA9IGZyYW1lO1xuICAgIH1cbiAgICBpZiAodGhpcy52YWxpZCkge1xuICAgICAgdGhpcy51cGRhdGVVdnMoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHJvdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcm90YXRlO1xuICB9XG4gIHNldCByb3RhdGUocm90YXRlKSB7XG4gICAgdGhpcy5fcm90YXRlID0gcm90YXRlO1xuICAgIGlmICh0aGlzLnZhbGlkKSB7XG4gICAgICB0aGlzLnVwZGF0ZVV2cygpO1xuICAgIH1cbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZy53aWR0aDtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLm9yaWcuaGVpZ2h0O1xuICB9XG4gIGNhc3RUb0Jhc2VUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLmJhc2VUZXh0dXJlO1xuICB9XG4gIHN0YXRpYyBnZXQgRU1QVFkoKSB7XG4gICAgaWYgKCFUZXh0dXJlLl9FTVBUWSkge1xuICAgICAgVGV4dHVyZS5fRU1QVFkgPSBuZXcgVGV4dHVyZShuZXcgQmFzZVRleHR1cmUuQmFzZVRleHR1cmUoKSk7XG4gICAgICByZW1vdmVBbGxIYW5kbGVycyhUZXh0dXJlLl9FTVBUWSk7XG4gICAgICByZW1vdmVBbGxIYW5kbGVycyhUZXh0dXJlLl9FTVBUWS5iYXNlVGV4dHVyZSk7XG4gICAgfVxuICAgIHJldHVybiBUZXh0dXJlLl9FTVBUWTtcbiAgfVxuICBzdGF0aWMgZ2V0IFdISVRFKCkge1xuICAgIGlmICghVGV4dHVyZS5fV0hJVEUpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHNldHRpbmdzLnNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKDE2LCAxNik7XG4gICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IDE2O1xuICAgICAgY2FudmFzLmhlaWdodCA9IDE2O1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIDE2LCAxNik7XG4gICAgICBUZXh0dXJlLl9XSElURSA9IG5ldyBUZXh0dXJlKEJhc2VUZXh0dXJlLkJhc2VUZXh0dXJlLmZyb20oY2FudmFzKSk7XG4gICAgICByZW1vdmVBbGxIYW5kbGVycyhUZXh0dXJlLl9XSElURSk7XG4gICAgICByZW1vdmVBbGxIYW5kbGVycyhUZXh0dXJlLl9XSElURS5iYXNlVGV4dHVyZSk7XG4gICAgfVxuICAgIHJldHVybiBUZXh0dXJlLl9XSElURTtcbiAgfVxufVxuXG5leHBvcnRzLlRleHR1cmUgPSBUZXh0dXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dHVyZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ0BwaXhpL2NvbnN0YW50cycpO1xudmFyIGV4dGVuc2lvbnMgPSByZXF1aXJlKCdAcGl4aS9leHRlbnNpb25zJyk7XG5cbmNvbnN0IF9UZXh0dXJlR0NTeXN0ZW0gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMuY291bnQgPSAwO1xuICAgIHRoaXMuY2hlY2tDb3VudCA9IDA7XG4gICAgdGhpcy5tYXhJZGxlID0gX1RleHR1cmVHQ1N5c3RlbS5kZWZhdWx0TWF4SWRsZTtcbiAgICB0aGlzLmNoZWNrQ291bnRNYXggPSBfVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRDaGVja0NvdW50TWF4O1xuICAgIHRoaXMubW9kZSA9IF9UZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdE1vZGU7XG4gIH1cbiAgcG9zdHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMucmVuZGVyZXIub2JqZWN0UmVuZGVyZXIucmVuZGVyaW5nVG9TY3JlZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb3VudCsrO1xuICAgIGlmICh0aGlzLm1vZGUgPT09IGNvbnN0YW50cy5HQ19NT0RFUy5NQU5VQUwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jaGVja0NvdW50Kys7XG4gICAgaWYgKHRoaXMuY2hlY2tDb3VudCA+IHRoaXMuY2hlY2tDb3VudE1heCkge1xuICAgICAgdGhpcy5jaGVja0NvdW50ID0gMDtcbiAgICAgIHRoaXMucnVuKCk7XG4gICAgfVxuICB9XG4gIHJ1bigpIHtcbiAgICBjb25zdCB0bSA9IHRoaXMucmVuZGVyZXIudGV4dHVyZTtcbiAgICBjb25zdCBtYW5hZ2VkVGV4dHVyZXMgPSB0bS5tYW5hZ2VkVGV4dHVyZXM7XG4gICAgbGV0IHdhc1JlbW92ZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hbmFnZWRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGV4dHVyZSA9IG1hbmFnZWRUZXh0dXJlc1tpXTtcbiAgICAgIGlmICghdGV4dHVyZS5mcmFtZWJ1ZmZlciAmJiB0aGlzLmNvdW50IC0gdGV4dHVyZS50b3VjaGVkID4gdGhpcy5tYXhJZGxlKSB7XG4gICAgICAgIHRtLmRlc3Ryb3lUZXh0dXJlKHRleHR1cmUsIHRydWUpO1xuICAgICAgICBtYW5hZ2VkVGV4dHVyZXNbaV0gPSBudWxsO1xuICAgICAgICB3YXNSZW1vdmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdhc1JlbW92ZWQpIHtcbiAgICAgIGxldCBqID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFuYWdlZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChtYW5hZ2VkVGV4dHVyZXNbaV0gIT09IG51bGwpIHtcbiAgICAgICAgICBtYW5hZ2VkVGV4dHVyZXNbaisrXSA9IG1hbmFnZWRUZXh0dXJlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWFuYWdlZFRleHR1cmVzLmxlbmd0aCA9IGo7XG4gICAgfVxuICB9XG4gIHVubG9hZChkaXNwbGF5T2JqZWN0KSB7XG4gICAgY29uc3QgdG0gPSB0aGlzLnJlbmRlcmVyLnRleHR1cmU7XG4gICAgY29uc3QgdGV4dHVyZSA9IGRpc3BsYXlPYmplY3QuX3RleHR1cmU7XG4gICAgaWYgKHRleHR1cmUgJiYgIXRleHR1cmUuZnJhbWVidWZmZXIpIHtcbiAgICAgIHRtLmRlc3Ryb3lUZXh0dXJlKHRleHR1cmUpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gZGlzcGxheU9iamVjdC5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy51bmxvYWQoZGlzcGxheU9iamVjdC5jaGlsZHJlbltpXSk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn07XG5sZXQgVGV4dHVyZUdDU3lzdGVtID0gX1RleHR1cmVHQ1N5c3RlbTtcblRleHR1cmVHQ1N5c3RlbS5kZWZhdWx0TW9kZSA9IGNvbnN0YW50cy5HQ19NT0RFUy5BVVRPO1xuVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRNYXhJZGxlID0gNjAgKiA2MDtcblRleHR1cmVHQ1N5c3RlbS5kZWZhdWx0Q2hlY2tDb3VudE1heCA9IDYwICogMTA7XG5UZXh0dXJlR0NTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwidGV4dHVyZUdDXCJcbn07XG5leHRlbnNpb25zLmV4dGVuc2lvbnMuYWRkKFRleHR1cmVHQ1N5c3RlbSk7XG5cbmV4cG9ydHMuVGV4dHVyZUdDU3lzdGVtID0gVGV4dHVyZUdDU3lzdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dHVyZUdDU3lzdGVtLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbWF0aCA9IHJlcXVpcmUoJ0BwaXhpL21hdGgnKTtcblxuY29uc3QgdGVtcE1hdCA9IG5ldyBtYXRoLk1hdHJpeCgpO1xuY2xhc3MgVGV4dHVyZU1hdHJpeCB7XG4gIGNvbnN0cnVjdG9yKHRleHR1cmUsIGNsYW1wTWFyZ2luKSB7XG4gICAgdGhpcy5fdGV4dHVyZSA9IHRleHR1cmU7XG4gICAgdGhpcy5tYXBDb29yZCA9IG5ldyBtYXRoLk1hdHJpeCgpO1xuICAgIHRoaXMudUNsYW1wRnJhbWUgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgIHRoaXMudUNsYW1wT2Zmc2V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICB0aGlzLl90ZXh0dXJlSUQgPSAtMTtcbiAgICB0aGlzLl91cGRhdGVJRCA9IDA7XG4gICAgdGhpcy5jbGFtcE9mZnNldCA9IDA7XG4gICAgdGhpcy5jbGFtcE1hcmdpbiA9IHR5cGVvZiBjbGFtcE1hcmdpbiA9PT0gXCJ1bmRlZmluZWRcIiA/IDAuNSA6IGNsYW1wTWFyZ2luO1xuICAgIHRoaXMuaXNTaW1wbGUgPSBmYWxzZTtcbiAgfVxuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dHVyZTtcbiAgfVxuICBzZXQgdGV4dHVyZSh2YWx1ZSkge1xuICAgIHRoaXMuX3RleHR1cmUgPSB2YWx1ZTtcbiAgICB0aGlzLl90ZXh0dXJlSUQgPSAtMTtcbiAgfVxuICBtdWx0aXBseVV2cyh1dnMsIG91dCkge1xuICAgIGlmIChvdXQgPT09IHZvaWQgMCkge1xuICAgICAgb3V0ID0gdXZzO1xuICAgIH1cbiAgICBjb25zdCBtYXQgPSB0aGlzLm1hcENvb3JkO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXZzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjb25zdCB4ID0gdXZzW2ldO1xuICAgICAgY29uc3QgeSA9IHV2c1tpICsgMV07XG4gICAgICBvdXRbaV0gPSB4ICogbWF0LmEgKyB5ICogbWF0LmMgKyBtYXQudHg7XG4gICAgICBvdXRbaSArIDFdID0geCAqIG1hdC5iICsgeSAqIG1hdC5kICsgbWF0LnR5O1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIHVwZGF0ZShmb3JjZVVwZGF0ZSkge1xuICAgIGNvbnN0IHRleCA9IHRoaXMuX3RleHR1cmU7XG4gICAgaWYgKCF0ZXggfHwgIXRleC52YWxpZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWZvcmNlVXBkYXRlICYmIHRoaXMuX3RleHR1cmVJRCA9PT0gdGV4Ll91cGRhdGVJRCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl90ZXh0dXJlSUQgPSB0ZXguX3VwZGF0ZUlEO1xuICAgIHRoaXMuX3VwZGF0ZUlEKys7XG4gICAgY29uc3QgdXZzID0gdGV4Ll91dnM7XG4gICAgdGhpcy5tYXBDb29yZC5zZXQodXZzLngxIC0gdXZzLngwLCB1dnMueTEgLSB1dnMueTAsIHV2cy54MyAtIHV2cy54MCwgdXZzLnkzIC0gdXZzLnkwLCB1dnMueDAsIHV2cy55MCk7XG4gICAgY29uc3Qgb3JpZyA9IHRleC5vcmlnO1xuICAgIGNvbnN0IHRyaW0gPSB0ZXgudHJpbTtcbiAgICBpZiAodHJpbSkge1xuICAgICAgdGVtcE1hdC5zZXQob3JpZy53aWR0aCAvIHRyaW0ud2lkdGgsIDAsIDAsIG9yaWcuaGVpZ2h0IC8gdHJpbS5oZWlnaHQsIC10cmltLnggLyB0cmltLndpZHRoLCAtdHJpbS55IC8gdHJpbS5oZWlnaHQpO1xuICAgICAgdGhpcy5tYXBDb29yZC5hcHBlbmQodGVtcE1hdCk7XG4gICAgfVxuICAgIGNvbnN0IHRleEJhc2UgPSB0ZXguYmFzZVRleHR1cmU7XG4gICAgY29uc3QgZnJhbWUgPSB0aGlzLnVDbGFtcEZyYW1lO1xuICAgIGNvbnN0IG1hcmdpbiA9IHRoaXMuY2xhbXBNYXJnaW4gLyB0ZXhCYXNlLnJlc29sdXRpb247XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5jbGFtcE9mZnNldDtcbiAgICBmcmFtZVswXSA9ICh0ZXguX2ZyYW1lLnggKyBtYXJnaW4gKyBvZmZzZXQpIC8gdGV4QmFzZS53aWR0aDtcbiAgICBmcmFtZVsxXSA9ICh0ZXguX2ZyYW1lLnkgKyBtYXJnaW4gKyBvZmZzZXQpIC8gdGV4QmFzZS5oZWlnaHQ7XG4gICAgZnJhbWVbMl0gPSAodGV4Ll9mcmFtZS54ICsgdGV4Ll9mcmFtZS53aWR0aCAtIG1hcmdpbiArIG9mZnNldCkgLyB0ZXhCYXNlLndpZHRoO1xuICAgIGZyYW1lWzNdID0gKHRleC5fZnJhbWUueSArIHRleC5fZnJhbWUuaGVpZ2h0IC0gbWFyZ2luICsgb2Zmc2V0KSAvIHRleEJhc2UuaGVpZ2h0O1xuICAgIHRoaXMudUNsYW1wT2Zmc2V0WzBdID0gb2Zmc2V0IC8gdGV4QmFzZS5yZWFsV2lkdGg7XG4gICAgdGhpcy51Q2xhbXBPZmZzZXRbMV0gPSBvZmZzZXQgLyB0ZXhCYXNlLnJlYWxIZWlnaHQ7XG4gICAgdGhpcy5pc1NpbXBsZSA9IHRleC5fZnJhbWUud2lkdGggPT09IHRleEJhc2Uud2lkdGggJiYgdGV4Ll9mcmFtZS5oZWlnaHQgPT09IHRleEJhc2UuaGVpZ2h0ICYmIHRleC5yb3RhdGUgPT09IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0cy5UZXh0dXJlTWF0cml4ID0gVGV4dHVyZU1hdHJpeDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmVNYXRyaXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCdAcGl4aS9jb25zdGFudHMnKTtcbnZhciBleHRlbnNpb25zID0gcmVxdWlyZSgnQHBpeGkvZXh0ZW5zaW9ucycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQHBpeGkvdXRpbHMnKTtcbnZhciBCYXNlVGV4dHVyZSA9IHJlcXVpcmUoJy4vQmFzZVRleHR1cmUuanMnKTtcbnZhciBHTFRleHR1cmUgPSByZXF1aXJlKCcuL0dMVGV4dHVyZS5qcycpO1xudmFyIG1hcFR5cGVBbmRGb3JtYXRUb0ludGVybmFsRm9ybWF0ID0gcmVxdWlyZSgnLi91dGlscy9tYXBUeXBlQW5kRm9ybWF0VG9JbnRlcm5hbEZvcm1hdC5qcycpO1xuXG5jbGFzcyBUZXh0dXJlU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5ib3VuZFRleHR1cmVzID0gW107XG4gICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSAtMTtcbiAgICB0aGlzLm1hbmFnZWRUZXh0dXJlcyA9IFtdO1xuICAgIHRoaXMuX3Vua25vd25Cb3VuZFRleHR1cmVzID0gZmFsc2U7XG4gICAgdGhpcy51bmtub3duVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZSgpO1xuICAgIHRoaXMuaGFzSW50ZWdlclRleHR1cmVzID0gZmFsc2U7XG4gIH1cbiAgY29udGV4dENoYW5nZSgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgIHRoaXMuQ09OVEVYVF9VSUQgPSB0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEO1xuICAgIHRoaXMud2ViR0xWZXJzaW9uID0gdGhpcy5yZW5kZXJlci5jb250ZXh0LndlYkdMVmVyc2lvbjtcbiAgICB0aGlzLmludGVybmFsRm9ybWF0cyA9IG1hcFR5cGVBbmRGb3JtYXRUb0ludGVybmFsRm9ybWF0Lm1hcFR5cGVBbmRGb3JtYXRUb0ludGVybmFsRm9ybWF0KGdsKTtcbiAgICBjb25zdCBtYXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyk7XG4gICAgdGhpcy5ib3VuZFRleHR1cmVzLmxlbmd0aCA9IG1heFRleHR1cmVzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4VGV4dHVyZXM7IGkrKykge1xuICAgICAgdGhpcy5ib3VuZFRleHR1cmVzW2ldID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5lbXB0eVRleHR1cmVzID0ge307XG4gICAgY29uc3QgZW1wdHlUZXh0dXJlMkQgPSBuZXcgR0xUZXh0dXJlLkdMVGV4dHVyZShnbC5jcmVhdGVUZXh0dXJlKCkpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGVtcHR5VGV4dHVyZTJELnRleHR1cmUpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgMSwgMSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbmV3IFVpbnQ4QXJyYXkoNCkpO1xuICAgIHRoaXMuZW1wdHlUZXh0dXJlc1tnbC5URVhUVVJFXzJEXSA9IGVtcHR5VGV4dHVyZTJEO1xuICAgIHRoaXMuZW1wdHlUZXh0dXJlc1tnbC5URVhUVVJFX0NVQkVfTUFQXSA9IG5ldyBHTFRleHR1cmUuR0xUZXh0dXJlKGdsLmNyZWF0ZVRleHR1cmUoKSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGhpcy5lbXB0eVRleHR1cmVzW2dsLlRFWFRVUkVfQ1VCRV9NQVBdLnRleHR1cmUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsLlJHQkEsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgIH1cbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYm91bmRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5iaW5kKG51bGwsIGkpO1xuICAgIH1cbiAgfVxuICBiaW5kKHRleHR1cmUsIGxvY2F0aW9uID0gMCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgdGV4dHVyZSA9IHRleHR1cmU/LmNhc3RUb0Jhc2VUZXh0dXJlKCk7XG4gICAgaWYgKHRleHR1cmU/LnZhbGlkICYmICF0ZXh0dXJlLnBhcmVudFRleHR1cmVBcnJheSkge1xuICAgICAgdGV4dHVyZS50b3VjaGVkID0gdGhpcy5yZW5kZXJlci50ZXh0dXJlR0MuY291bnQ7XG4gICAgICBjb25zdCBnbFRleHR1cmUgPSB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdIHx8IHRoaXMuaW5pdFRleHR1cmUodGV4dHVyZSk7XG4gICAgICBpZiAodGhpcy5ib3VuZFRleHR1cmVzW2xvY2F0aW9uXSAhPT0gdGV4dHVyZSkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50TG9jYXRpb24gIT09IGxvY2F0aW9uKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgbG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKHRleHR1cmUudGFyZ2V0LCBnbFRleHR1cmUudGV4dHVyZSk7XG4gICAgICB9XG4gICAgICBpZiAoZ2xUZXh0dXJlLmRpcnR5SWQgIT09IHRleHR1cmUuZGlydHlJZCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50TG9jYXRpb24gIT09IGxvY2F0aW9uKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgbG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICAgIH0gZWxzZSBpZiAoZ2xUZXh0dXJlLmRpcnR5U3R5bGVJZCAhPT0gdGV4dHVyZS5kaXJ0eVN0eWxlSWQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0dXJlU3R5bGUodGV4dHVyZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmJvdW5kVGV4dHVyZXNbbG9jYXRpb25dID0gdGV4dHVyZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuY3VycmVudExvY2F0aW9uICE9PSBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgbG9jYXRpb24pO1xuICAgICAgfVxuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5lbXB0eVRleHR1cmVzW2dsLlRFWFRVUkVfMkRdLnRleHR1cmUpO1xuICAgICAgdGhpcy5ib3VuZFRleHR1cmVzW2xvY2F0aW9uXSA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Vua25vd25Cb3VuZFRleHR1cmVzID0gdHJ1ZTtcbiAgICB0aGlzLmhhc0ludGVnZXJUZXh0dXJlcyA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJvdW5kVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuYm91bmRUZXh0dXJlc1tpXSA9IHRoaXMudW5rbm93blRleHR1cmU7XG4gICAgfVxuICB9XG4gIHVuYmluZCh0ZXh0dXJlKSB7XG4gICAgY29uc3QgeyBnbCwgYm91bmRUZXh0dXJlcyB9ID0gdGhpcztcbiAgICBpZiAodGhpcy5fdW5rbm93bkJvdW5kVGV4dHVyZXMpIHtcbiAgICAgIHRoaXMuX3Vua25vd25Cb3VuZFRleHR1cmVzID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvdW5kVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGJvdW5kVGV4dHVyZXNbaV0gPT09IHRoaXMudW5rbm93blRleHR1cmUpIHtcbiAgICAgICAgICB0aGlzLmJpbmQobnVsbCwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3VuZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYm91bmRUZXh0dXJlc1tpXSA9PT0gdGV4dHVyZSkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50TG9jYXRpb24gIT09IGkpIHtcbiAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgaSk7XG4gICAgICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBpO1xuICAgICAgICB9XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKHRleHR1cmUudGFyZ2V0LCB0aGlzLmVtcHR5VGV4dHVyZXNbdGV4dHVyZS50YXJnZXRdLnRleHR1cmUpO1xuICAgICAgICBib3VuZFRleHR1cmVzW2ldID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZW5zdXJlU2FtcGxlclR5cGUobWF4VGV4dHVyZXMpIHtcbiAgICBjb25zdCB7IGJvdW5kVGV4dHVyZXMsIGhhc0ludGVnZXJUZXh0dXJlcywgQ09OVEVYVF9VSUQgfSA9IHRoaXM7XG4gICAgaWYgKCFoYXNJbnRlZ2VyVGV4dHVyZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IG1heFRleHR1cmVzIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHRleCA9IGJvdW5kVGV4dHVyZXNbaV07XG4gICAgICBpZiAodGV4KSB7XG4gICAgICAgIGNvbnN0IGdsVGV4dHVyZSA9IHRleC5fZ2xUZXh0dXJlc1tDT05URVhUX1VJRF07XG4gICAgICAgIGlmIChnbFRleHR1cmUuc2FtcGxlclR5cGUgIT09IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLkZMT0FUKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLnVuYmluZCh0ZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGluaXRUZXh0dXJlKHRleHR1cmUpIHtcbiAgICBjb25zdCBnbFRleHR1cmUgPSBuZXcgR0xUZXh0dXJlLkdMVGV4dHVyZSh0aGlzLmdsLmNyZWF0ZVRleHR1cmUoKSk7XG4gICAgZ2xUZXh0dXJlLmRpcnR5SWQgPSAtMTtcbiAgICB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdID0gZ2xUZXh0dXJlO1xuICAgIHRoaXMubWFuYWdlZFRleHR1cmVzLnB1c2godGV4dHVyZSk7XG4gICAgdGV4dHVyZS5vbihcImRpc3Bvc2VcIiwgdGhpcy5kZXN0cm95VGV4dHVyZSwgdGhpcyk7XG4gICAgcmV0dXJuIGdsVGV4dHVyZTtcbiAgfVxuICBpbml0VGV4dHVyZVR5cGUodGV4dHVyZSwgZ2xUZXh0dXJlKSB7XG4gICAgZ2xUZXh0dXJlLmludGVybmFsRm9ybWF0ID0gdGhpcy5pbnRlcm5hbEZvcm1hdHNbdGV4dHVyZS50eXBlXT8uW3RleHR1cmUuZm9ybWF0XSA/PyB0ZXh0dXJlLmZvcm1hdDtcbiAgICBpZiAodGhpcy53ZWJHTFZlcnNpb24gPT09IDIgJiYgdGV4dHVyZS50eXBlID09PSBjb25zdGFudHMuVFlQRVMuSEFMRl9GTE9BVCkge1xuICAgICAgZ2xUZXh0dXJlLnR5cGUgPSB0aGlzLmdsLkhBTEZfRkxPQVQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsVGV4dHVyZS50eXBlID0gdGV4dHVyZS50eXBlO1xuICAgIH1cbiAgfVxuICB1cGRhdGVUZXh0dXJlKHRleHR1cmUpIHtcbiAgICBjb25zdCBnbFRleHR1cmUgPSB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgIGlmICghZ2xUZXh0dXJlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICB0aGlzLmluaXRUZXh0dXJlVHlwZSh0ZXh0dXJlLCBnbFRleHR1cmUpO1xuICAgIGlmICh0ZXh0dXJlLnJlc291cmNlPy51cGxvYWQocmVuZGVyZXIsIHRleHR1cmUsIGdsVGV4dHVyZSkpIHtcbiAgICAgIGlmIChnbFRleHR1cmUuc2FtcGxlclR5cGUgIT09IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLkZMT0FUKSB7XG4gICAgICAgIHRoaXMuaGFzSW50ZWdlclRleHR1cmVzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd2lkdGggPSB0ZXh0dXJlLnJlYWxXaWR0aDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHRleHR1cmUucmVhbEhlaWdodDtcbiAgICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgICBpZiAoZ2xUZXh0dXJlLndpZHRoICE9PSB3aWR0aCB8fCBnbFRleHR1cmUuaGVpZ2h0ICE9PSBoZWlnaHQgfHwgZ2xUZXh0dXJlLmRpcnR5SWQgPCAwKSB7XG4gICAgICAgIGdsVGV4dHVyZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBnbFRleHR1cmUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBnbC50ZXhJbWFnZTJEKHRleHR1cmUudGFyZ2V0LCAwLCBnbFRleHR1cmUuaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIHRleHR1cmUuZm9ybWF0LCBnbFRleHR1cmUudHlwZSwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXh0dXJlLmRpcnR5U3R5bGVJZCAhPT0gZ2xUZXh0dXJlLmRpcnR5U3R5bGVJZCkge1xuICAgICAgdGhpcy51cGRhdGVUZXh0dXJlU3R5bGUodGV4dHVyZSk7XG4gICAgfVxuICAgIGdsVGV4dHVyZS5kaXJ0eUlkID0gdGV4dHVyZS5kaXJ0eUlkO1xuICB9XG4gIGRlc3Ryb3lUZXh0dXJlKHRleHR1cmUsIHNraXBSZW1vdmUpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzO1xuICAgIHRleHR1cmUgPSB0ZXh0dXJlLmNhc3RUb0Jhc2VUZXh0dXJlKCk7XG4gICAgaWYgKHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0pIHtcbiAgICAgIHRoaXMudW5iaW5kKHRleHR1cmUpO1xuICAgICAgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdLnRleHR1cmUpO1xuICAgICAgdGV4dHVyZS5vZmYoXCJkaXNwb3NlXCIsIHRoaXMuZGVzdHJveVRleHR1cmUsIHRoaXMpO1xuICAgICAgZGVsZXRlIHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgICBpZiAoIXNraXBSZW1vdmUpIHtcbiAgICAgICAgY29uc3QgaSA9IHRoaXMubWFuYWdlZFRleHR1cmVzLmluZGV4T2YodGV4dHVyZSk7XG4gICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgIHV0aWxzLnJlbW92ZUl0ZW1zKHRoaXMubWFuYWdlZFRleHR1cmVzLCBpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB1cGRhdGVUZXh0dXJlU3R5bGUodGV4dHVyZSkge1xuICAgIGNvbnN0IGdsVGV4dHVyZSA9IHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgaWYgKCFnbFRleHR1cmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCh0ZXh0dXJlLm1pcG1hcCA9PT0gY29uc3RhbnRzLk1JUE1BUF9NT0RFUy5QT1cyIHx8IHRoaXMud2ViR0xWZXJzaW9uICE9PSAyKSAmJiAhdGV4dHVyZS5pc1Bvd2VyT2ZUd28pIHtcbiAgICAgIGdsVGV4dHVyZS5taXBtYXAgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xUZXh0dXJlLm1pcG1hcCA9IHRleHR1cmUubWlwbWFwID49IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLndlYkdMVmVyc2lvbiAhPT0gMiAmJiAhdGV4dHVyZS5pc1Bvd2VyT2ZUd28pIHtcbiAgICAgIGdsVGV4dHVyZS53cmFwTW9kZSA9IGNvbnN0YW50cy5XUkFQX01PREVTLkNMQU1QO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbFRleHR1cmUud3JhcE1vZGUgPSB0ZXh0dXJlLndyYXBNb2RlO1xuICAgIH1cbiAgICBpZiAodGV4dHVyZS5yZXNvdXJjZT8uc3R5bGUodGhpcy5yZW5kZXJlciwgdGV4dHVyZSwgZ2xUZXh0dXJlKSkge1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFN0eWxlKHRleHR1cmUsIGdsVGV4dHVyZSk7XG4gICAgfVxuICAgIGdsVGV4dHVyZS5kaXJ0eVN0eWxlSWQgPSB0ZXh0dXJlLmRpcnR5U3R5bGVJZDtcbiAgfVxuICBzZXRTdHlsZSh0ZXh0dXJlLCBnbFRleHR1cmUpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgaWYgKGdsVGV4dHVyZS5taXBtYXAgJiYgdGV4dHVyZS5taXBtYXAgIT09IGNvbnN0YW50cy5NSVBNQVBfTU9ERVMuT05fTUFOVUFMKSB7XG4gICAgICBnbC5nZW5lcmF0ZU1pcG1hcCh0ZXh0dXJlLnRhcmdldCk7XG4gICAgfVxuICAgIGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZS50YXJnZXQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbFRleHR1cmUud3JhcE1vZGUpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZS50YXJnZXQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbFRleHR1cmUud3JhcE1vZGUpO1xuICAgIGlmIChnbFRleHR1cmUubWlwbWFwKSB7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmUudGFyZ2V0LCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID09PSBjb25zdGFudHMuU0NBTEVfTU9ERVMuTElORUFSID8gZ2wuTElORUFSX01JUE1BUF9MSU5FQVIgOiBnbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUKTtcbiAgICAgIGNvbnN0IGFuaXNvdHJvcGljRXh0ID0gdGhpcy5yZW5kZXJlci5jb250ZXh0LmV4dGVuc2lvbnMuYW5pc290cm9waWNGaWx0ZXJpbmc7XG4gICAgICBpZiAoYW5pc290cm9waWNFeHQgJiYgdGV4dHVyZS5hbmlzb3Ryb3BpY0xldmVsID4gMCAmJiB0ZXh0dXJlLnNjYWxlTW9kZSA9PT0gY29uc3RhbnRzLlNDQUxFX01PREVTLkxJTkVBUikge1xuICAgICAgICBjb25zdCBsZXZlbCA9IE1hdGgubWluKHRleHR1cmUuYW5pc290cm9waWNMZXZlbCwgZ2wuZ2V0UGFyYW1ldGVyKGFuaXNvdHJvcGljRXh0Lk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCkpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJmKHRleHR1cmUudGFyZ2V0LCBhbmlzb3Ryb3BpY0V4dC5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgbGV2ZWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmUudGFyZ2V0LCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID09PSBjb25zdGFudHMuU0NBTEVfTU9ERVMuTElORUFSID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCk7XG4gICAgfVxuICAgIGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZS50YXJnZXQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGV4dHVyZS5zY2FsZU1vZGUgPT09IGNvbnN0YW50cy5TQ0FMRV9NT0RFUy5MSU5FQVIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG5UZXh0dXJlU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcInRleHR1cmVcIlxufTtcbmV4dGVuc2lvbnMuZXh0ZW5zaW9ucy5hZGQoVGV4dHVyZVN5c3RlbSk7XG5cbmV4cG9ydHMuVGV4dHVyZVN5c3RlbSA9IFRleHR1cmVTeXN0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0dXJlU3lzdGVtLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbWF0aCA9IHJlcXVpcmUoJ0BwaXhpL21hdGgnKTtcblxuY2xhc3MgVGV4dHVyZVV2cyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMueDAgPSAwO1xuICAgIHRoaXMueTAgPSAwO1xuICAgIHRoaXMueDEgPSAxO1xuICAgIHRoaXMueTEgPSAwO1xuICAgIHRoaXMueDIgPSAxO1xuICAgIHRoaXMueTIgPSAxO1xuICAgIHRoaXMueDMgPSAwO1xuICAgIHRoaXMueTMgPSAxO1xuICAgIHRoaXMudXZzRmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XG4gIH1cbiAgc2V0KGZyYW1lLCBiYXNlRnJhbWUsIHJvdGF0ZSkge1xuICAgIGNvbnN0IHR3ID0gYmFzZUZyYW1lLndpZHRoO1xuICAgIGNvbnN0IHRoID0gYmFzZUZyYW1lLmhlaWdodDtcbiAgICBpZiAocm90YXRlKSB7XG4gICAgICBjb25zdCB3MiA9IGZyYW1lLndpZHRoIC8gMiAvIHR3O1xuICAgICAgY29uc3QgaDIgPSBmcmFtZS5oZWlnaHQgLyAyIC8gdGg7XG4gICAgICBjb25zdCBjWCA9IGZyYW1lLnggLyB0dyArIHcyO1xuICAgICAgY29uc3QgY1kgPSBmcmFtZS55IC8gdGggKyBoMjtcbiAgICAgIHJvdGF0ZSA9IG1hdGguZ3JvdXBEOC5hZGQocm90YXRlLCBtYXRoLmdyb3VwRDguTlcpO1xuICAgICAgdGhpcy54MCA9IGNYICsgdzIgKiBtYXRoLmdyb3VwRDgudVgocm90YXRlKTtcbiAgICAgIHRoaXMueTAgPSBjWSArIGgyICogbWF0aC5ncm91cEQ4LnVZKHJvdGF0ZSk7XG4gICAgICByb3RhdGUgPSBtYXRoLmdyb3VwRDguYWRkKHJvdGF0ZSwgMik7XG4gICAgICB0aGlzLngxID0gY1ggKyB3MiAqIG1hdGguZ3JvdXBEOC51WChyb3RhdGUpO1xuICAgICAgdGhpcy55MSA9IGNZICsgaDIgKiBtYXRoLmdyb3VwRDgudVkocm90YXRlKTtcbiAgICAgIHJvdGF0ZSA9IG1hdGguZ3JvdXBEOC5hZGQocm90YXRlLCAyKTtcbiAgICAgIHRoaXMueDIgPSBjWCArIHcyICogbWF0aC5ncm91cEQ4LnVYKHJvdGF0ZSk7XG4gICAgICB0aGlzLnkyID0gY1kgKyBoMiAqIG1hdGguZ3JvdXBEOC51WShyb3RhdGUpO1xuICAgICAgcm90YXRlID0gbWF0aC5ncm91cEQ4LmFkZChyb3RhdGUsIDIpO1xuICAgICAgdGhpcy54MyA9IGNYICsgdzIgKiBtYXRoLmdyb3VwRDgudVgocm90YXRlKTtcbiAgICAgIHRoaXMueTMgPSBjWSArIGgyICogbWF0aC5ncm91cEQ4LnVZKHJvdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueDAgPSBmcmFtZS54IC8gdHc7XG4gICAgICB0aGlzLnkwID0gZnJhbWUueSAvIHRoO1xuICAgICAgdGhpcy54MSA9IChmcmFtZS54ICsgZnJhbWUud2lkdGgpIC8gdHc7XG4gICAgICB0aGlzLnkxID0gZnJhbWUueSAvIHRoO1xuICAgICAgdGhpcy54MiA9IChmcmFtZS54ICsgZnJhbWUud2lkdGgpIC8gdHc7XG4gICAgICB0aGlzLnkyID0gKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpIC8gdGg7XG4gICAgICB0aGlzLngzID0gZnJhbWUueCAvIHR3O1xuICAgICAgdGhpcy55MyA9IChmcmFtZS55ICsgZnJhbWUuaGVpZ2h0KSAvIHRoO1xuICAgIH1cbiAgICB0aGlzLnV2c0Zsb2F0MzJbMF0gPSB0aGlzLngwO1xuICAgIHRoaXMudXZzRmxvYXQzMlsxXSA9IHRoaXMueTA7XG4gICAgdGhpcy51dnNGbG9hdDMyWzJdID0gdGhpcy54MTtcbiAgICB0aGlzLnV2c0Zsb2F0MzJbM10gPSB0aGlzLnkxO1xuICAgIHRoaXMudXZzRmxvYXQzMls0XSA9IHRoaXMueDI7XG4gICAgdGhpcy51dnNGbG9hdDMyWzVdID0gdGhpcy55MjtcbiAgICB0aGlzLnV2c0Zsb2F0MzJbNl0gPSB0aGlzLngzO1xuICAgIHRoaXMudXZzRmxvYXQzMls3XSA9IHRoaXMueTM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbQHBpeGkvY29yZTpUZXh0dXJlVXZzIHgwPSR7dGhpcy54MH0geTA9JHt0aGlzLnkwfSB4MT0ke3RoaXMueDF9IHkxPSR7dGhpcy55MX0geDI9JHt0aGlzLngyfSB5Mj0ke3RoaXMueTJ9IHgzPSR7dGhpcy54M30geTM9JHt0aGlzLnkzfV1gO1xuICB9XG59XG5cbmV4cG9ydHMuVGV4dHVyZVV2cyA9IFRleHR1cmVVdnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0dXJlVXZzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgQmFzZVRleHR1cmUgPSByZXF1aXJlKCcuLi9CYXNlVGV4dHVyZS5qcycpO1xudmFyIGF1dG9EZXRlY3RSZXNvdXJjZSA9IHJlcXVpcmUoJy4vYXV0b0RldGVjdFJlc291cmNlLmpzJyk7XG52YXIgUmVzb3VyY2UgPSByZXF1aXJlKCcuL1Jlc291cmNlLmpzJyk7XG5cbmNsYXNzIEFic3RyYWN0TXVsdGlSZXNvdXJjZSBleHRlbmRzIFJlc291cmNlLlJlc291cmNlIHtcbiAgY29uc3RydWN0b3IobGVuZ3RoLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIHN1cGVyKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICB0aGlzLml0ZW1EaXJ0eUlkcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnRUZXh0dXJlID0gbmV3IEJhc2VUZXh0dXJlLkJhc2VUZXh0dXJlKCk7XG4gICAgICB0aGlzLml0ZW1zLnB1c2gocGFydFRleHR1cmUpO1xuICAgICAgdGhpcy5pdGVtRGlydHlJZHMucHVzaCgtMik7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuX2xvYWQgPSBudWxsO1xuICAgIHRoaXMuYmFzZVRleHR1cmUgPSBudWxsO1xuICB9XG4gIGluaXRGcm9tQXJyYXkocmVzb3VyY2VzLCBvcHRpb25zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXJlc291cmNlc1tpXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNvdXJjZXNbaV0uY2FzdFRvQmFzZVRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5hZGRCYXNlVGV4dHVyZUF0KHJlc291cmNlc1tpXS5jYXN0VG9CYXNlVGV4dHVyZSgpLCBpKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzb3VyY2VzW2ldIGluc3RhbmNlb2YgUmVzb3VyY2UuUmVzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5hZGRSZXNvdXJjZUF0KHJlc291cmNlc1tpXSwgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZFJlc291cmNlQXQoYXV0b0RldGVjdFJlc291cmNlLmF1dG9EZXRlY3RSZXNvdXJjZShyZXNvdXJjZXNbaV0sIG9wdGlvbnMpLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGhpcy5pdGVtc1tpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuaXRlbXMgPSBudWxsO1xuICAgIHRoaXMuaXRlbURpcnR5SWRzID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkID0gbnVsbDtcbiAgfVxuICBhZGRSZXNvdXJjZUF0KHJlc291cmNlLCBpbmRleCkge1xuICAgIGlmICghdGhpcy5pdGVtc1tpbmRleF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5kZXggJHtpbmRleH0gaXMgb3V0IG9mIGJvdW5kc2ApO1xuICAgIH1cbiAgICBpZiAocmVzb3VyY2UudmFsaWQgJiYgIXRoaXMudmFsaWQpIHtcbiAgICAgIHRoaXMucmVzaXplKHJlc291cmNlLndpZHRoLCByZXNvdXJjZS5oZWlnaHQpO1xuICAgIH1cbiAgICB0aGlzLml0ZW1zW2luZGV4XS5zZXRSZXNvdXJjZShyZXNvdXJjZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmluZChiYXNlVGV4dHVyZSkge1xuICAgIGlmICh0aGlzLmJhc2VUZXh0dXJlICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBiYXNlIHRleHR1cmUgcGVyIFRleHR1cmVBcnJheSBpcyBhbGxvd2VkXCIpO1xuICAgIH1cbiAgICBzdXBlci5iaW5kKGJhc2VUZXh0dXJlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuaXRlbXNbaV0ucGFyZW50VGV4dHVyZUFycmF5ID0gYmFzZVRleHR1cmU7XG4gICAgICB0aGlzLml0ZW1zW2ldLm9uKFwidXBkYXRlXCIsIGJhc2VUZXh0dXJlLnVwZGF0ZSwgYmFzZVRleHR1cmUpO1xuICAgIH1cbiAgfVxuICB1bmJpbmQoYmFzZVRleHR1cmUpIHtcbiAgICBzdXBlci51bmJpbmQoYmFzZVRleHR1cmUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5pdGVtc1tpXS5wYXJlbnRUZXh0dXJlQXJyYXkgPSBudWxsO1xuICAgICAgdGhpcy5pdGVtc1tpXS5vZmYoXCJ1cGRhdGVcIiwgYmFzZVRleHR1cmUudXBkYXRlLCBiYXNlVGV4dHVyZSk7XG4gICAgfVxuICB9XG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuX2xvYWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICAgIH1cbiAgICBjb25zdCByZXNvdXJjZXMgPSB0aGlzLml0ZW1zLm1hcCgoaXRlbSkgPT4gaXRlbS5yZXNvdXJjZSkuZmlsdGVyKChpdGVtKSA9PiBpdGVtKTtcbiAgICBjb25zdCBwcm9taXNlcyA9IHJlc291cmNlcy5tYXAoKGl0ZW0pID0+IGl0ZW0ubG9hZCgpKTtcbiAgICB0aGlzLl9sb2FkID0gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgY29uc3QgeyByZWFsV2lkdGgsIHJlYWxIZWlnaHQgfSA9IHRoaXMuaXRlbXNbMF07XG4gICAgICB0aGlzLnJlc2l6ZShyZWFsV2lkdGgsIHJlYWxIZWlnaHQpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fbG9hZDtcbiAgfVxufVxuXG5leHBvcnRzLkFic3RyYWN0TXVsdGlSZXNvdXJjZSA9IEFic3RyYWN0TXVsdGlSZXNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFic3RyYWN0TXVsdGlSZXNvdXJjZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ0BwaXhpL2NvbnN0YW50cycpO1xudmFyIEFic3RyYWN0TXVsdGlSZXNvdXJjZSA9IHJlcXVpcmUoJy4vQWJzdHJhY3RNdWx0aVJlc291cmNlLmpzJyk7XG5cbmNsYXNzIEFycmF5UmVzb3VyY2UgZXh0ZW5kcyBBYnN0cmFjdE11bHRpUmVzb3VyY2UuQWJzdHJhY3RNdWx0aVJlc291cmNlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGxldCB1cmxzO1xuICAgIGxldCBsZW5ndGg7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgdXJscyA9IHNvdXJjZTtcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHNvdXJjZTtcbiAgICB9XG4gICAgc3VwZXIobGVuZ3RoLCB7IHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgaWYgKHVybHMpIHtcbiAgICAgIHRoaXMuaW5pdEZyb21BcnJheSh1cmxzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgYWRkQmFzZVRleHR1cmVBdChiYXNlVGV4dHVyZSwgaW5kZXgpIHtcbiAgICBpZiAoYmFzZVRleHR1cmUucmVzb3VyY2UpIHtcbiAgICAgIHRoaXMuYWRkUmVzb3VyY2VBdChiYXNlVGV4dHVyZS5yZXNvdXJjZSwgaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheVJlc291cmNlIGRvZXMgbm90IHN1cHBvcnQgUmVuZGVyVGV4dHVyZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmluZChiYXNlVGV4dHVyZSkge1xuICAgIHN1cGVyLmJpbmQoYmFzZVRleHR1cmUpO1xuICAgIGJhc2VUZXh0dXJlLnRhcmdldCA9IGNvbnN0YW50cy5UQVJHRVRTLlRFWFRVUkVfMkRfQVJSQVk7XG4gIH1cbiAgdXBsb2FkKHJlbmRlcmVyLCB0ZXh0dXJlLCBnbFRleHR1cmUpIHtcbiAgICBjb25zdCB7IGxlbmd0aCwgaXRlbURpcnR5SWRzLCBpdGVtcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGdsIH0gPSByZW5kZXJlcjtcbiAgICBpZiAoZ2xUZXh0dXJlLmRpcnR5SWQgPCAwKSB7XG4gICAgICBnbC50ZXhJbWFnZTNEKGdsLlRFWFRVUkVfMkRfQVJSQVksIDAsIGdsVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgbGVuZ3RoLCAwLCB0ZXh0dXJlLmZvcm1hdCwgZ2xUZXh0dXJlLnR5cGUsIG51bGwpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICBpZiAoaXRlbURpcnR5SWRzW2ldIDwgaXRlbS5kaXJ0eUlkKSB7XG4gICAgICAgIGl0ZW1EaXJ0eUlkc1tpXSA9IGl0ZW0uZGlydHlJZDtcbiAgICAgICAgaWYgKGl0ZW0udmFsaWQpIHtcbiAgICAgICAgICBnbC50ZXhTdWJJbWFnZTNEKGdsLlRFWFRVUkVfMkRfQVJSQVksIDAsIDAsIDAsIGksIGl0ZW0ucmVzb3VyY2Uud2lkdGgsIGl0ZW0ucmVzb3VyY2UuaGVpZ2h0LCAxLCB0ZXh0dXJlLmZvcm1hdCwgZ2xUZXh0dXJlLnR5cGUsIGl0ZW0ucmVzb3VyY2Uuc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnRzLkFycmF5UmVzb3VyY2UgPSBBcnJheVJlc291cmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXJyYXlSZXNvdXJjZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ0BwaXhpL2NvbnN0YW50cycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQHBpeGkvdXRpbHMnKTtcbnZhciBSZXNvdXJjZSA9IHJlcXVpcmUoJy4vUmVzb3VyY2UuanMnKTtcblxuY2xhc3MgQmFzZUltYWdlUmVzb3VyY2UgZXh0ZW5kcyBSZXNvdXJjZS5SZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIGNvbnN0IHNvdXJjZUFueSA9IHNvdXJjZTtcbiAgICBjb25zdCB3aWR0aCA9IHNvdXJjZUFueS5uYXR1cmFsV2lkdGggfHwgc291cmNlQW55LnZpZGVvV2lkdGggfHwgc291cmNlQW55LndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHNvdXJjZUFueS5uYXR1cmFsSGVpZ2h0IHx8IHNvdXJjZUFueS52aWRlb0hlaWdodCB8fCBzb3VyY2VBbnkuaGVpZ2h0O1xuICAgIHN1cGVyKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMubm9TdWJJbWFnZSA9IGZhbHNlO1xuICB9XG4gIHN0YXRpYyBjcm9zc09yaWdpbihlbGVtZW50LCB1cmwsIGNyb3Nzb3JpZ2luKSB7XG4gICAgaWYgKGNyb3Nzb3JpZ2luID09PSB2b2lkIDAgJiYgIXVybC5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICAgIGVsZW1lbnQuY3Jvc3NPcmlnaW4gPSB1dGlscy5kZXRlcm1pbmVDcm9zc09yaWdpbih1cmwpO1xuICAgIH0gZWxzZSBpZiAoY3Jvc3NvcmlnaW4gIT09IGZhbHNlKSB7XG4gICAgICBlbGVtZW50LmNyb3NzT3JpZ2luID0gdHlwZW9mIGNyb3Nzb3JpZ2luID09PSBcInN0cmluZ1wiID8gY3Jvc3NvcmlnaW4gOiBcImFub255bW91c1wiO1xuICAgIH1cbiAgfVxuICB1cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUsIHNvdXJjZSkge1xuICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgY29uc3Qgd2lkdGggPSBiYXNlVGV4dHVyZS5yZWFsV2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gYmFzZVRleHR1cmUucmVhbEhlaWdodDtcbiAgICBzb3VyY2UgPSBzb3VyY2UgfHwgdGhpcy5zb3VyY2U7XG4gICAgaWYgKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgIGlmICghc291cmNlLmNvbXBsZXRlIHx8IHNvdXJjZS5uYXR1cmFsV2lkdGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIEhUTUxWaWRlb0VsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgc291cmNlIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgaWYgKHNvdXJjZS5yZWFkeVN0YXRlIDw9IDEgJiYgc291cmNlLmJ1ZmZlcmVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgYmFzZVRleHR1cmUuYWxwaGFNb2RlID09PSBjb25zdGFudHMuQUxQSEFfTU9ERVMuVU5QQUNLKTtcbiAgICBpZiAoIXRoaXMubm9TdWJJbWFnZSAmJiBiYXNlVGV4dHVyZS50YXJnZXQgPT09IGdsLlRFWFRVUkVfMkQgJiYgZ2xUZXh0dXJlLndpZHRoID09PSB3aWR0aCAmJiBnbFRleHR1cmUuaGVpZ2h0ID09PSBoZWlnaHQpIHtcbiAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgYmFzZVRleHR1cmUuZm9ybWF0LCBnbFRleHR1cmUudHlwZSwgc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xUZXh0dXJlLndpZHRoID0gd2lkdGg7XG4gICAgICBnbFRleHR1cmUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgZ2wudGV4SW1hZ2UyRChiYXNlVGV4dHVyZS50YXJnZXQsIDAsIGdsVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgYmFzZVRleHR1cmUuZm9ybWF0LCBnbFRleHR1cmUudHlwZSwgc291cmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICBjb25zdCB3aWR0aCA9IHNvdXJjZS5uYXR1cmFsV2lkdGggfHwgc291cmNlLnZpZGVvV2lkdGggfHwgc291cmNlLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHNvdXJjZS5uYXR1cmFsSGVpZ2h0IHx8IHNvdXJjZS52aWRlb0hlaWdodCB8fCBzb3VyY2UuaGVpZ2h0O1xuICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHN1cGVyLnVwZGF0ZSgpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICB9XG59XG5cbmV4cG9ydHMuQmFzZUltYWdlUmVzb3VyY2UgPSBCYXNlSW1hZ2VSZXNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2VJbWFnZVJlc291cmNlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnQHBpeGkvY29uc3RhbnRzJyk7XG52YXIgUmVzb3VyY2UgPSByZXF1aXJlKCcuL1Jlc291cmNlLmpzJyk7XG5cbmNsYXNzIEJ1ZmZlclJlc291cmNlIGV4dGVuZHMgUmVzb3VyY2UuUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXJSZXNvdXJjZSB3aWR0aCBvciBoZWlnaHQgaW52YWxpZFwiKTtcbiAgICB9XG4gICAgc3VwZXIod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5kYXRhID0gc291cmNlO1xuICB9XG4gIHVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSkge1xuICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBiYXNlVGV4dHVyZS5hbHBoYU1vZGUgPT09IGNvbnN0YW50cy5BTFBIQV9NT0RFUy5VTlBBQ0spO1xuICAgIGNvbnN0IHdpZHRoID0gYmFzZVRleHR1cmUucmVhbFdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGJhc2VUZXh0dXJlLnJlYWxIZWlnaHQ7XG4gICAgaWYgKGdsVGV4dHVyZS53aWR0aCA9PT0gd2lkdGggJiYgZ2xUZXh0dXJlLmhlaWdodCA9PT0gaGVpZ2h0KSB7XG4gICAgICBnbC50ZXhTdWJJbWFnZTJEKGJhc2VUZXh0dXJlLnRhcmdldCwgMCwgMCwgMCwgd2lkdGgsIGhlaWdodCwgYmFzZVRleHR1cmUuZm9ybWF0LCBnbFRleHR1cmUudHlwZSwgdGhpcy5kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xUZXh0dXJlLndpZHRoID0gd2lkdGg7XG4gICAgICBnbFRleHR1cmUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgZ2wudGV4SW1hZ2UyRChiYXNlVGV4dHVyZS50YXJnZXQsIDAsIGdsVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgYmFzZVRleHR1cmUuZm9ybWF0LCBnbFRleHR1cmUudHlwZSwgdGhpcy5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICB9XG4gIHN0YXRpYyB0ZXN0KHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2UgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBzb3VyY2UgaW5zdGFuY2VvZiBVaW50MzJBcnJheTtcbiAgfVxufVxuXG5leHBvcnRzLkJ1ZmZlclJlc291cmNlID0gQnVmZmVyUmVzb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdWZmZXJSZXNvdXJjZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIEJhc2VJbWFnZVJlc291cmNlID0gcmVxdWlyZSgnLi9CYXNlSW1hZ2VSZXNvdXJjZS5qcycpO1xuXG5jbGFzcyBDYW52YXNSZXNvdXJjZSBleHRlbmRzIEJhc2VJbWFnZVJlc291cmNlLkJhc2VJbWFnZVJlc291cmNlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgc3VwZXIoc291cmNlKTtcbiAgfVxuICBzdGF0aWMgdGVzdChzb3VyY2UpIHtcbiAgICBjb25zdCB7IE9mZnNjcmVlbkNhbnZhcyB9ID0gZ2xvYmFsVGhpcztcbiAgICBpZiAoT2Zmc2NyZWVuQ2FudmFzICYmIHNvdXJjZSBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBnbG9iYWxUaGlzLkhUTUxDYW52YXNFbGVtZW50ICYmIHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50O1xuICB9XG59XG5cbmV4cG9ydHMuQ2FudmFzUmVzb3VyY2UgPSBDYW52YXNSZXNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbnZhc1Jlc291cmNlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnQHBpeGkvY29uc3RhbnRzJyk7XG52YXIgQWJzdHJhY3RNdWx0aVJlc291cmNlID0gcmVxdWlyZSgnLi9BYnN0cmFjdE11bHRpUmVzb3VyY2UuanMnKTtcblxuY29uc3QgX0N1YmVSZXNvdXJjZSA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RNdWx0aVJlc291cmNlLkFic3RyYWN0TXVsdGlSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgYXV0b0xvYWQsIGxpbmtCYXNlVGV4dHVyZSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoc291cmNlICYmIHNvdXJjZS5sZW5ndGggIT09IF9DdWJlUmVzb3VyY2UuU0lERVMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBsZW5ndGguIEdvdCAke3NvdXJjZS5sZW5ndGh9LCBleHBlY3RlZCA2YCk7XG4gICAgfVxuICAgIHN1cGVyKDYsIHsgd2lkdGgsIGhlaWdodCB9KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9DdWJlUmVzb3VyY2UuU0lERVM7IGkrKykge1xuICAgICAgdGhpcy5pdGVtc1tpXS50YXJnZXQgPSBjb25zdGFudHMuVEFSR0VUUy5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpO1xuICAgIH1cbiAgICB0aGlzLmxpbmtCYXNlVGV4dHVyZSA9IGxpbmtCYXNlVGV4dHVyZSAhPT0gZmFsc2U7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgdGhpcy5pbml0RnJvbUFycmF5KHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChhdXRvTG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMubG9hZCgpO1xuICAgIH1cbiAgfVxuICBiaW5kKGJhc2VUZXh0dXJlKSB7XG4gICAgc3VwZXIuYmluZChiYXNlVGV4dHVyZSk7XG4gICAgYmFzZVRleHR1cmUudGFyZ2V0ID0gY29uc3RhbnRzLlRBUkdFVFMuVEVYVFVSRV9DVUJFX01BUDtcbiAgfVxuICBhZGRCYXNlVGV4dHVyZUF0KGJhc2VUZXh0dXJlLCBpbmRleCwgbGlua0Jhc2VUZXh0dXJlKSB7XG4gICAgaWYgKGxpbmtCYXNlVGV4dHVyZSA9PT0gdm9pZCAwKSB7XG4gICAgICBsaW5rQmFzZVRleHR1cmUgPSB0aGlzLmxpbmtCYXNlVGV4dHVyZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLml0ZW1zW2luZGV4XSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbmRleCAke2luZGV4fSBpcyBvdXQgb2YgYm91bmRzYCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5saW5rQmFzZVRleHR1cmUgfHwgYmFzZVRleHR1cmUucGFyZW50VGV4dHVyZUFycmF5IHx8IE9iamVjdC5rZXlzKGJhc2VUZXh0dXJlLl9nbFRleHR1cmVzKS5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoYmFzZVRleHR1cmUucmVzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5hZGRSZXNvdXJjZUF0KGJhc2VUZXh0dXJlLnJlc291cmNlLCBpbmRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEN1YmVSZXNvdXJjZSBkb2VzIG5vdCBzdXBwb3J0IGNvcHlpbmcgb2YgcmVuZGVyVGV4dHVyZS5gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZVRleHR1cmUudGFyZ2V0ID0gY29uc3RhbnRzLlRBUkdFVFMuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaW5kZXg7XG4gICAgICBiYXNlVGV4dHVyZS5wYXJlbnRUZXh0dXJlQXJyYXkgPSB0aGlzLmJhc2VUZXh0dXJlO1xuICAgICAgdGhpcy5pdGVtc1tpbmRleF0gPSBiYXNlVGV4dHVyZTtcbiAgICB9XG4gICAgaWYgKGJhc2VUZXh0dXJlLnZhbGlkICYmICF0aGlzLnZhbGlkKSB7XG4gICAgICB0aGlzLnJlc2l6ZShiYXNlVGV4dHVyZS5yZWFsV2lkdGgsIGJhc2VUZXh0dXJlLnJlYWxIZWlnaHQpO1xuICAgIH1cbiAgICB0aGlzLml0ZW1zW2luZGV4XSA9IGJhc2VUZXh0dXJlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHVwbG9hZChyZW5kZXJlciwgX2Jhc2VUZXh0dXJlLCBnbFRleHR1cmUpIHtcbiAgICBjb25zdCBkaXJ0eSA9IHRoaXMuaXRlbURpcnR5SWRzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX0N1YmVSZXNvdXJjZS5TSURFUzsgaSsrKSB7XG4gICAgICBjb25zdCBzaWRlID0gdGhpcy5pdGVtc1tpXTtcbiAgICAgIGlmIChkaXJ0eVtpXSA8IHNpZGUuZGlydHlJZCB8fCBnbFRleHR1cmUuZGlydHlJZCA8IF9iYXNlVGV4dHVyZS5kaXJ0eUlkKSB7XG4gICAgICAgIGlmIChzaWRlLnZhbGlkICYmIHNpZGUucmVzb3VyY2UpIHtcbiAgICAgICAgICBzaWRlLnJlc291cmNlLnVwbG9hZChyZW5kZXJlciwgc2lkZSwgZ2xUZXh0dXJlKTtcbiAgICAgICAgICBkaXJ0eVtpXSA9IHNpZGUuZGlydHlJZDtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJ0eVtpXSA8IC0xKSB7XG4gICAgICAgICAgcmVuZGVyZXIuZ2wudGV4SW1hZ2UyRChzaWRlLnRhcmdldCwgMCwgZ2xUZXh0dXJlLmludGVybmFsRm9ybWF0LCBfYmFzZVRleHR1cmUucmVhbFdpZHRoLCBfYmFzZVRleHR1cmUucmVhbEhlaWdodCwgMCwgX2Jhc2VUZXh0dXJlLmZvcm1hdCwgZ2xUZXh0dXJlLnR5cGUsIG51bGwpO1xuICAgICAgICAgIGRpcnR5W2ldID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhdGljIHRlc3Qoc291cmNlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc291cmNlKSAmJiBzb3VyY2UubGVuZ3RoID09PSBfQ3ViZVJlc291cmNlLlNJREVTO1xuICB9XG59O1xubGV0IEN1YmVSZXNvdXJjZSA9IF9DdWJlUmVzb3VyY2U7XG5DdWJlUmVzb3VyY2UuU0lERVMgPSA2O1xuXG5leHBvcnRzLkN1YmVSZXNvdXJjZSA9IEN1YmVSZXNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUN1YmVSZXNvdXJjZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ0BwaXhpL2NvbnN0YW50cycpO1xudmFyIEJ1ZmZlclJlc291cmNlID0gcmVxdWlyZSgnLi9CdWZmZXJSZXNvdXJjZS5qcycpO1xuXG5jbGFzcyBEZXB0aFJlc291cmNlIGV4dGVuZHMgQnVmZmVyUmVzb3VyY2UuQnVmZmVyUmVzb3VyY2Uge1xuICB1cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpIHtcbiAgICBjb25zdCBnbCA9IHJlbmRlcmVyLmdsO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgYmFzZVRleHR1cmUuYWxwaGFNb2RlID09PSBjb25zdGFudHMuQUxQSEFfTU9ERVMuVU5QQUNLKTtcbiAgICBjb25zdCB3aWR0aCA9IGJhc2VUZXh0dXJlLnJlYWxXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBiYXNlVGV4dHVyZS5yZWFsSGVpZ2h0O1xuICAgIGlmIChnbFRleHR1cmUud2lkdGggPT09IHdpZHRoICYmIGdsVGV4dHVyZS5oZWlnaHQgPT09IGhlaWdodCkge1xuICAgICAgZ2wudGV4U3ViSW1hZ2UyRChiYXNlVGV4dHVyZS50YXJnZXQsIDAsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIGJhc2VUZXh0dXJlLmZvcm1hdCwgZ2xUZXh0dXJlLnR5cGUsIHRoaXMuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsVGV4dHVyZS53aWR0aCA9IHdpZHRoO1xuICAgICAgZ2xUZXh0dXJlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGdsLnRleEltYWdlMkQoYmFzZVRleHR1cmUudGFyZ2V0LCAwLCBnbFRleHR1cmUuaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGJhc2VUZXh0dXJlLmZvcm1hdCwgZ2xUZXh0dXJlLnR5cGUsIHRoaXMuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmV4cG9ydHMuRGVwdGhSZXNvdXJjZSA9IERlcHRoUmVzb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZXB0aFJlc291cmNlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnQHBpeGkvY29uc3RhbnRzJyk7XG52YXIgc2V0dGluZ3MgPSByZXF1aXJlKCdAcGl4aS9zZXR0aW5ncycpO1xudmFyIEJhc2VJbWFnZVJlc291cmNlID0gcmVxdWlyZSgnLi9CYXNlSW1hZ2VSZXNvdXJjZS5qcycpO1xuXG5jbGFzcyBJbWFnZUJpdG1hcFJlc291cmNlIGV4dGVuZHMgQmFzZUltYWdlUmVzb3VyY2UuQmFzZUltYWdlUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgYmFzZVNvdXJjZTtcbiAgICBsZXQgdXJsO1xuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBiYXNlU291cmNlID0gSW1hZ2VCaXRtYXBSZXNvdXJjZS5FTVBUWTtcbiAgICAgIHVybCA9IHNvdXJjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZVNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHVybCA9IG51bGw7XG4gICAgfVxuICAgIHN1cGVyKGJhc2VTb3VyY2UpO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSBvcHRpb25zLmNyb3NzT3JpZ2luID8/IHRydWU7XG4gICAgdGhpcy5hbHBoYU1vZGUgPSB0eXBlb2Ygb3B0aW9ucy5hbHBoYU1vZGUgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zLmFscGhhTW9kZSA6IG51bGw7XG4gICAgdGhpcy5fbG9hZCA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnMuYXV0b0xvYWQgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmxvYWQoKTtcbiAgICB9XG4gIH1cbiAgbG9hZCgpIHtcbiAgICBpZiAodGhpcy5fbG9hZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gICAgfVxuICAgIHRoaXMuX2xvYWQgPSBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy51cmwgPT09IG51bGwpIHtcbiAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZXR0aW5ncy5zZXR0aW5ncy5BREFQVEVSLmZldGNoKHRoaXMudXJsLCB7XG4gICAgICAgICAgbW9kZTogdGhpcy5jcm9zc09yaWdpbiA/IFwiY29yc1wiIDogXCJuby1jb3JzXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGltYWdlQmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaW1hZ2VCaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChpbWFnZUJsb2IsIHtcbiAgICAgICAgICBwcmVtdWx0aXBseUFscGhhOiB0aGlzLmFscGhhTW9kZSA9PT0gbnVsbCB8fCB0aGlzLmFscGhhTW9kZSA9PT0gY29uc3RhbnRzLkFMUEhBX01PREVTLlVOUEFDSyA/IFwicHJlbXVsdGlwbHlcIiA6IFwibm9uZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IGltYWdlQml0bWFwO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIHRoaXMub25FcnJvci5lbWl0KGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICB9XG4gIHVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSkge1xuICAgIGlmICghKHRoaXMuc291cmNlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApKSB7XG4gICAgICB0aGlzLmxvYWQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLmFscGhhTW9kZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgYmFzZVRleHR1cmUuYWxwaGFNb2RlID0gdGhpcy5hbHBoYU1vZGU7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci51cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuc291cmNlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApIHtcbiAgICAgIHRoaXMuc291cmNlLmNsb3NlKCk7XG4gICAgfVxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9sb2FkID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgdGVzdChzb3VyY2UpIHtcbiAgICByZXR1cm4gISFnbG9iYWxUaGlzLmNyZWF0ZUltYWdlQml0bWFwICYmIHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAodHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIiB8fCBzb3VyY2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCk7XG4gIH1cbiAgc3RhdGljIGdldCBFTVBUWSgpIHtcbiAgICBJbWFnZUJpdG1hcFJlc291cmNlLl9FTVBUWSA9IEltYWdlQml0bWFwUmVzb3VyY2UuX0VNUFRZID8/IHNldHRpbmdzLnNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKDAsIDApO1xuICAgIHJldHVybiBJbWFnZUJpdG1hcFJlc291cmNlLl9FTVBUWTtcbiAgfVxufVxuXG5leHBvcnRzLkltYWdlQml0bWFwUmVzb3VyY2UgPSBJbWFnZUJpdG1hcFJlc291cmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW1hZ2VCaXRtYXBSZXNvdXJjZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ0BwaXhpL2NvbnN0YW50cycpO1xudmFyIHNldHRpbmdzID0gcmVxdWlyZSgnQHBpeGkvc2V0dGluZ3MnKTtcbnZhciBCYXNlSW1hZ2VSZXNvdXJjZSA9IHJlcXVpcmUoJy4vQmFzZUltYWdlUmVzb3VyY2UuanMnKTtcblxuY2xhc3MgSW1hZ2VSZXNvdXJjZSBleHRlbmRzIEJhc2VJbWFnZVJlc291cmNlLkJhc2VJbWFnZVJlc291cmNlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xuICAgICAgQmFzZUltYWdlUmVzb3VyY2UuQmFzZUltYWdlUmVzb3VyY2UuY3Jvc3NPcmlnaW4oaW1hZ2VFbGVtZW50LCBzb3VyY2UsIG9wdGlvbnMuY3Jvc3NvcmlnaW4pO1xuICAgICAgaW1hZ2VFbGVtZW50LnNyYyA9IHNvdXJjZTtcbiAgICAgIHNvdXJjZSA9IGltYWdlRWxlbWVudDtcbiAgICB9XG4gICAgc3VwZXIoc291cmNlKTtcbiAgICBpZiAoIXNvdXJjZS5jb21wbGV0ZSAmJiAhIXRoaXMuX3dpZHRoICYmICEhdGhpcy5faGVpZ2h0KSB7XG4gICAgICB0aGlzLl93aWR0aCA9IDA7XG4gICAgICB0aGlzLl9oZWlnaHQgPSAwO1xuICAgIH1cbiAgICB0aGlzLnVybCA9IHNvdXJjZS5zcmM7XG4gICAgdGhpcy5fcHJvY2VzcyA9IG51bGw7XG4gICAgdGhpcy5wcmVzZXJ2ZUJpdG1hcCA9IGZhbHNlO1xuICAgIHRoaXMuY3JlYXRlQml0bWFwID0gKG9wdGlvbnMuY3JlYXRlQml0bWFwID8/IHNldHRpbmdzLnNldHRpbmdzLkNSRUFURV9JTUFHRV9CSVRNQVApICYmICEhZ2xvYmFsVGhpcy5jcmVhdGVJbWFnZUJpdG1hcDtcbiAgICB0aGlzLmFscGhhTW9kZSA9IHR5cGVvZiBvcHRpb25zLmFscGhhTW9kZSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMuYWxwaGFNb2RlIDogbnVsbDtcbiAgICB0aGlzLmJpdG1hcCA9IG51bGw7XG4gICAgdGhpcy5fbG9hZCA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnMuYXV0b0xvYWQgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmxvYWQoKTtcbiAgICB9XG4gIH1cbiAgbG9hZChjcmVhdGVCaXRtYXApIHtcbiAgICBpZiAodGhpcy5fbG9hZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gICAgfVxuICAgIGlmIChjcmVhdGVCaXRtYXAgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5jcmVhdGVCaXRtYXAgPSBjcmVhdGVCaXRtYXA7XG4gICAgfVxuICAgIHRoaXMuX2xvYWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgIHRoaXMudXJsID0gc291cmNlLnNyYztcbiAgICAgIGNvbnN0IGNvbXBsZXRlZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICBzb3VyY2Uub25lcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzaXplKHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCk7XG4gICAgICAgIHRoaXMuX2xvYWQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5jcmVhdGVCaXRtYXApIHtcbiAgICAgICAgICByZXNvbHZlKHRoaXMucHJvY2VzcygpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKHNvdXJjZS5jb21wbGV0ZSAmJiBzb3VyY2Uuc3JjKSB7XG4gICAgICAgIGNvbXBsZXRlZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlLm9ubG9hZCA9IGNvbXBsZXRlZDtcbiAgICAgICAgc291cmNlLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICByZWplY3QoZXZlbnQpO1xuICAgICAgICAgIHRoaXMub25FcnJvci5lbWl0KGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fbG9hZDtcbiAgfVxuICBwcm9jZXNzKCkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgIGlmICh0aGlzLl9wcm9jZXNzICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJvY2VzcztcbiAgICB9XG4gICAgaWYgKHRoaXMuYml0bWFwICE9PSBudWxsIHx8ICFnbG9iYWxUaGlzLmNyZWF0ZUltYWdlQml0bWFwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuICAgIH1cbiAgICBjb25zdCBjcmVhdGVJbWFnZUJpdG1hcCA9IGdsb2JhbFRoaXMuY3JlYXRlSW1hZ2VCaXRtYXA7XG4gICAgY29uc3QgY29ycyA9ICFzb3VyY2UuY3Jvc3NPcmlnaW4gfHwgc291cmNlLmNyb3NzT3JpZ2luID09PSBcImFub255bW91c1wiO1xuICAgIHRoaXMuX3Byb2Nlc3MgPSBmZXRjaChzb3VyY2Uuc3JjLCB7XG4gICAgICBtb2RlOiBjb3JzID8gXCJjb3JzXCIgOiBcIm5vLWNvcnNcIlxuICAgIH0pLnRoZW4oKHIpID0+IHIuYmxvYigpKS50aGVuKChibG9iKSA9PiBjcmVhdGVJbWFnZUJpdG1hcChibG9iLCAwLCAwLCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQsIHtcbiAgICAgIHByZW11bHRpcGx5QWxwaGE6IHRoaXMuYWxwaGFNb2RlID09PSBudWxsIHx8IHRoaXMuYWxwaGFNb2RlID09PSBjb25zdGFudHMuQUxQSEFfTU9ERVMuVU5QQUNLID8gXCJwcmVtdWx0aXBseVwiIDogXCJub25lXCJcbiAgICB9KSkudGhlbigoYml0bWFwKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmJpdG1hcCA9IGJpdG1hcDtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB0aGlzLl9wcm9jZXNzID0gbnVsbDtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3M7XG4gIH1cbiAgdXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmFscGhhTW9kZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgYmFzZVRleHR1cmUuYWxwaGFNb2RlID0gdGhpcy5hbHBoYU1vZGU7XG4gICAgfVxuICAgIGlmICghdGhpcy5jcmVhdGVCaXRtYXApIHtcbiAgICAgIHJldHVybiBzdXBlci51cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuYml0bWFwKSB7XG4gICAgICB0aGlzLnByb2Nlc3MoKTtcbiAgICAgIGlmICghdGhpcy5iaXRtYXApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci51cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUsIHRoaXMuYml0bWFwKTtcbiAgICBpZiAoIXRoaXMucHJlc2VydmVCaXRtYXApIHtcbiAgICAgIGxldCBmbGFnID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGdsVGV4dHVyZXMgPSBiYXNlVGV4dHVyZS5fZ2xUZXh0dXJlcztcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGdsVGV4dHVyZXMpIHtcbiAgICAgICAgY29uc3Qgb3RoZXJUZXggPSBnbFRleHR1cmVzW2tleV07XG4gICAgICAgIGlmIChvdGhlclRleCAhPT0gZ2xUZXh0dXJlICYmIG90aGVyVGV4LmRpcnR5SWQgIT09IGJhc2VUZXh0dXJlLmRpcnR5SWQpIHtcbiAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgIGlmICh0aGlzLmJpdG1hcC5jbG9zZSkge1xuICAgICAgICAgIHRoaXMuYml0bWFwLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaXRtYXAgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuc291cmNlLm9ubG9hZCA9IG51bGw7XG4gICAgdGhpcy5zb3VyY2Uub25lcnJvciA9IG51bGw7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIGlmICh0aGlzLmJpdG1hcCkge1xuICAgICAgdGhpcy5iaXRtYXAuY2xvc2UoKTtcbiAgICAgIHRoaXMuYml0bWFwID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fcHJvY2VzcyA9IG51bGw7XG4gICAgdGhpcy5fbG9hZCA9IG51bGw7XG4gIH1cbiAgc3RhdGljIHRlc3Qoc291cmNlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmICh0eXBlb2Ygc291cmNlID09PSBcInN0cmluZ1wiIHx8IHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpO1xuICB9XG59XG5cbmV4cG9ydHMuSW1hZ2VSZXNvdXJjZSA9IEltYWdlUmVzb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbWFnZVJlc291cmNlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgcnVubmVyID0gcmVxdWlyZSgnQHBpeGkvcnVubmVyJyk7XG5cbmNsYXNzIFJlc291cmNlIHtcbiAgY29uc3RydWN0b3Iod2lkdGggPSAwLCBoZWlnaHQgPSAwKSB7XG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmludGVybmFsID0gZmFsc2U7XG4gICAgdGhpcy5vblJlc2l6ZSA9IG5ldyBydW5uZXIuUnVubmVyKFwic2V0UmVhbFNpemVcIik7XG4gICAgdGhpcy5vblVwZGF0ZSA9IG5ldyBydW5uZXIuUnVubmVyKFwidXBkYXRlXCIpO1xuICAgIHRoaXMub25FcnJvciA9IG5ldyBydW5uZXIuUnVubmVyKFwib25FcnJvclwiKTtcbiAgfVxuICBiaW5kKGJhc2VUZXh0dXJlKSB7XG4gICAgdGhpcy5vblJlc2l6ZS5hZGQoYmFzZVRleHR1cmUpO1xuICAgIHRoaXMub25VcGRhdGUuYWRkKGJhc2VUZXh0dXJlKTtcbiAgICB0aGlzLm9uRXJyb3IuYWRkKGJhc2VUZXh0dXJlKTtcbiAgICBpZiAodGhpcy5fd2lkdGggfHwgdGhpcy5faGVpZ2h0KSB7XG4gICAgICB0aGlzLm9uUmVzaXplLmVtaXQodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG4gICAgfVxuICB9XG4gIHVuYmluZChiYXNlVGV4dHVyZSkge1xuICAgIHRoaXMub25SZXNpemUucmVtb3ZlKGJhc2VUZXh0dXJlKTtcbiAgICB0aGlzLm9uVXBkYXRlLnJlbW92ZShiYXNlVGV4dHVyZSk7XG4gICAgdGhpcy5vbkVycm9yLnJlbW92ZShiYXNlVGV4dHVyZSk7XG4gIH1cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAod2lkdGggIT09IHRoaXMuX3dpZHRoIHx8IGhlaWdodCAhPT0gdGhpcy5faGVpZ2h0KSB7XG4gICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdGhpcy5vblJlc2l6ZS5lbWl0KHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgfVxuICBnZXQgdmFsaWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fd2lkdGggJiYgISF0aGlzLl9oZWlnaHQ7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHRoaXMub25VcGRhdGUuZW1pdCgpO1xuICAgIH1cbiAgfVxuICBsb2FkKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gIH1cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH1cbiAgc3R5bGUoX3JlbmRlcmVyLCBfYmFzZVRleHR1cmUsIF9nbFRleHR1cmUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5vbkVycm9yLnJlbW92ZUFsbCgpO1xuICAgICAgdGhpcy5vbkVycm9yID0gbnVsbDtcbiAgICAgIHRoaXMub25SZXNpemUucmVtb3ZlQWxsKCk7XG4gICAgICB0aGlzLm9uUmVzaXplID0gbnVsbDtcbiAgICAgIHRoaXMub25VcGRhdGUucmVtb3ZlQWxsKCk7XG4gICAgICB0aGlzLm9uVXBkYXRlID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHRlc3QoX3NvdXJjZSwgX2V4dGVuc2lvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnRzLlJlc291cmNlID0gUmVzb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXNvdXJjZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHNldHRpbmdzID0gcmVxdWlyZSgnQHBpeGkvc2V0dGluZ3MnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BwaXhpL3V0aWxzJyk7XG52YXIgQmFzZUltYWdlUmVzb3VyY2UgPSByZXF1aXJlKCcuL0Jhc2VJbWFnZVJlc291cmNlLmpzJyk7XG5cbmNvbnN0IF9TVkdSZXNvdXJjZSA9IGNsYXNzIGV4dGVuZHMgQmFzZUltYWdlUmVzb3VyY2UuQmFzZUltYWdlUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2VCYXNlNjQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBzdXBlcihzZXR0aW5ncy5zZXR0aW5ncy5BREFQVEVSLmNyZWF0ZUNhbnZhcygpKTtcbiAgICB0aGlzLl93aWR0aCA9IDA7XG4gICAgdGhpcy5faGVpZ2h0ID0gMDtcbiAgICB0aGlzLnN2ZyA9IHNvdXJjZUJhc2U2NDtcbiAgICB0aGlzLnNjYWxlID0gb3B0aW9ucy5zY2FsZSB8fCAxO1xuICAgIHRoaXMuX292ZXJyaWRlV2lkdGggPSBvcHRpb25zLndpZHRoO1xuICAgIHRoaXMuX292ZXJyaWRlSGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gICAgdGhpcy5fcmVzb2x2ZSA9IG51bGw7XG4gICAgdGhpcy5fY3Jvc3NvcmlnaW4gPSBvcHRpb25zLmNyb3Nzb3JpZ2luO1xuICAgIHRoaXMuX2xvYWQgPSBudWxsO1xuICAgIGlmIChvcHRpb25zLmF1dG9Mb2FkICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5sb2FkKCk7XG4gICAgfVxuICB9XG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuX2xvYWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMuc291cmNlLndpZHRoLCB0aGlzLnNvdXJjZS5oZWlnaHQpO1xuICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgfTtcbiAgICAgIGlmIChfU1ZHUmVzb3VyY2UuU1ZHX1hNTC50ZXN0KHRoaXMuc3ZnLnRyaW0oKSkpIHtcbiAgICAgICAgaWYgKCFidG9hKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91ciBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBiYXNlNjQgY29udmVyc2lvbnMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ZnID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJHtidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnN2ZykpKX1gO1xuICAgICAgfVxuICAgICAgdGhpcy5fbG9hZFN2ZygpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICB9XG4gIF9sb2FkU3ZnKCkge1xuICAgIGNvbnN0IHRlbXBJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIEJhc2VJbWFnZVJlc291cmNlLkJhc2VJbWFnZVJlc291cmNlLmNyb3NzT3JpZ2luKHRlbXBJbWFnZSwgdGhpcy5zdmcsIHRoaXMuX2Nyb3Nzb3JpZ2luKTtcbiAgICB0ZW1wSW1hZ2Uuc3JjID0gdGhpcy5zdmc7XG4gICAgdGVtcEltYWdlLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghdGhpcy5fcmVzb2x2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0ZW1wSW1hZ2Uub25lcnJvciA9IG51bGw7XG4gICAgICB0aGlzLm9uRXJyb3IuZW1pdChldmVudCk7XG4gICAgfTtcbiAgICB0ZW1wSW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9yZXNvbHZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN2Z1dpZHRoID0gdGVtcEltYWdlLndpZHRoO1xuICAgICAgY29uc3Qgc3ZnSGVpZ2h0ID0gdGVtcEltYWdlLmhlaWdodDtcbiAgICAgIGlmICghc3ZnV2lkdGggfHwgIXN2Z0hlaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgU1ZHIGltYWdlIG11c3QgaGF2ZSB3aWR0aCBhbmQgaGVpZ2h0IGRlZmluZWQgKGluIHBpeGVscyksIGNhbnZhcyBBUEkgbmVlZHMgdGhlbS5cIik7XG4gICAgICB9XG4gICAgICBsZXQgd2lkdGggPSBzdmdXaWR0aCAqIHRoaXMuc2NhbGU7XG4gICAgICBsZXQgaGVpZ2h0ID0gc3ZnSGVpZ2h0ICogdGhpcy5zY2FsZTtcbiAgICAgIGlmICh0aGlzLl9vdmVycmlkZVdpZHRoIHx8IHRoaXMuX292ZXJyaWRlSGVpZ2h0KSB7XG4gICAgICAgIHdpZHRoID0gdGhpcy5fb3ZlcnJpZGVXaWR0aCB8fCB0aGlzLl9vdmVycmlkZUhlaWdodCAvIHN2Z0hlaWdodCAqIHN2Z1dpZHRoO1xuICAgICAgICBoZWlnaHQgPSB0aGlzLl9vdmVycmlkZUhlaWdodCB8fCB0aGlzLl9vdmVycmlkZVdpZHRoIC8gc3ZnV2lkdGggKiBzdmdIZWlnaHQ7XG4gICAgICB9XG4gICAgICB3aWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xuICAgICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQpO1xuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5zb3VyY2U7XG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBjYW52YXMuX3BpeGlJZCA9IGBjYW52YXNfJHt1dGlscy51aWQoKX1gO1xuICAgICAgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5kcmF3SW1hZ2UodGVtcEltYWdlLCAwLCAwLCBzdmdXaWR0aCwgc3ZnSGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuX3Jlc29sdmUoKTtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGdldFNpemUoc3ZnU3RyaW5nKSB7XG4gICAgY29uc3Qgc2l6ZU1hdGNoID0gX1NWR1Jlc291cmNlLlNWR19TSVpFLmV4ZWMoc3ZnU3RyaW5nKTtcbiAgICBjb25zdCBzaXplID0ge307XG4gICAgaWYgKHNpemVNYXRjaCkge1xuICAgICAgc2l6ZVtzaXplTWF0Y2hbMV1dID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KHNpemVNYXRjaFszXSkpO1xuICAgICAgc2l6ZVtzaXplTWF0Y2hbNV1dID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KHNpemVNYXRjaFs3XSkpO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcbiAgICB0aGlzLl9jcm9zc29yaWdpbiA9IG51bGw7XG4gIH1cbiAgc3RhdGljIHRlc3Qoc291cmNlLCBleHRlbnNpb24pIHtcbiAgICByZXR1cm4gZXh0ZW5zaW9uID09PSBcInN2Z1wiIHx8IHR5cGVvZiBzb3VyY2UgPT09IFwic3RyaW5nXCIgJiYgc291cmNlLnN0YXJ0c1dpdGgoXCJkYXRhOmltYWdlL3N2Zyt4bWxcIikgfHwgdHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIiAmJiBfU1ZHUmVzb3VyY2UuU1ZHX1hNTC50ZXN0KHNvdXJjZSk7XG4gIH1cbn07XG5sZXQgU1ZHUmVzb3VyY2UgPSBfU1ZHUmVzb3VyY2U7XG5TVkdSZXNvdXJjZS5TVkdfWE1MID0gL14oPFxcP3htbFteP10rXFw/Pik/XFxzKig8IS0tW14oLS0+KV0qLS0+KT9cXHMqXFw8c3ZnL207XG5TVkdSZXNvdXJjZS5TVkdfU0laRSA9IC88c3ZnW14+XSooPzpcXHMod2lkdGh8aGVpZ2h0KT0oJ3xcIikoXFxkKig/OlxcLlxcZCspPykoPzpweCk/KCd8XCIpKVtePl0qKD86XFxzKHdpZHRofGhlaWdodCk9KCd8XCIpKFxcZCooPzpcXC5cXGQrKT8pKD86cHgpPygnfFwiKSlbXj5dKj4vaTtcblxuZXhwb3J0cy5TVkdSZXNvdXJjZSA9IFNWR1Jlc291cmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U1ZHUmVzb3VyY2UuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB0aWNrZXIgPSByZXF1aXJlKCdAcGl4aS90aWNrZXInKTtcbnZhciBCYXNlSW1hZ2VSZXNvdXJjZSA9IHJlcXVpcmUoJy4vQmFzZUltYWdlUmVzb3VyY2UuanMnKTtcblxuY29uc3QgX1ZpZGVvUmVzb3VyY2UgPSBjbGFzcyBleHRlbmRzIEJhc2VJbWFnZVJlc291cmNlLkJhc2VJbWFnZVJlc291cmNlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkpIHtcbiAgICAgIGNvbnN0IHZpZGVvRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKTtcbiAgICAgIHZpZGVvRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJwcmVsb2FkXCIsIFwiYXV0b1wiKTtcbiAgICAgIHZpZGVvRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ3ZWJraXQtcGxheXNpbmxpbmVcIiwgXCJcIik7XG4gICAgICB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKFwicGxheXNpbmxpbmVcIiwgXCJcIik7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzb3VyY2UgPSBbc291cmNlXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpcnN0U3JjID0gc291cmNlWzBdLnNyYyB8fCBzb3VyY2VbMF07XG4gICAgICBCYXNlSW1hZ2VSZXNvdXJjZS5CYXNlSW1hZ2VSZXNvdXJjZS5jcm9zc09yaWdpbih2aWRlb0VsZW1lbnQsIGZpcnN0U3JjLCBvcHRpb25zLmNyb3Nzb3JpZ2luKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic291cmNlXCIpO1xuICAgICAgICBsZXQgeyBzcmMsIG1pbWUgfSA9IHNvdXJjZVtpXTtcbiAgICAgICAgc3JjID0gc3JjIHx8IHNvdXJjZVtpXTtcbiAgICAgICAgY29uc3QgYmFzZVNyYyA9IHNyYy5zcGxpdChcIj9cIikuc2hpZnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBleHQgPSBiYXNlU3JjLnNsaWNlKGJhc2VTcmMubGFzdEluZGV4T2YoXCIuXCIpICsgMSk7XG4gICAgICAgIG1pbWUgPSBtaW1lIHx8IF9WaWRlb1Jlc291cmNlLk1JTUVfVFlQRVNbZXh0XSB8fCBgdmlkZW8vJHtleHR9YDtcbiAgICAgICAgc291cmNlRWxlbWVudC5zcmMgPSBzcmM7XG4gICAgICAgIHNvdXJjZUVsZW1lbnQudHlwZSA9IG1pbWU7XG4gICAgICAgIHZpZGVvRWxlbWVudC5hcHBlbmRDaGlsZChzb3VyY2VFbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZSA9IHZpZGVvRWxlbWVudDtcbiAgICB9XG4gICAgc3VwZXIoc291cmNlKTtcbiAgICB0aGlzLm5vU3ViSW1hZ2UgPSB0cnVlO1xuICAgIHRoaXMuX2F1dG9VcGRhdGUgPSB0cnVlO1xuICAgIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSBmYWxzZTtcbiAgICB0aGlzLl91cGRhdGVGUFMgPSBvcHRpb25zLnVwZGF0ZUZQUyB8fCAwO1xuICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gMDtcbiAgICB0aGlzLmF1dG9QbGF5ID0gb3B0aW9ucy5hdXRvUGxheSAhPT0gZmFsc2U7XG4gICAgdGhpcy5fbG9hZCA9IG51bGw7XG4gICAgdGhpcy5fcmVzb2x2ZSA9IG51bGw7XG4gICAgdGhpcy5fb25DYW5QbGF5ID0gdGhpcy5fb25DYW5QbGF5LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25FcnJvciA9IHRoaXMuX29uRXJyb3IuYmluZCh0aGlzKTtcbiAgICBpZiAob3B0aW9ucy5hdXRvTG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMubG9hZCgpO1xuICAgIH1cbiAgfVxuICB1cGRhdGUoX2RlbHRhVGltZSA9IDApIHtcbiAgICBpZiAoIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICBjb25zdCBlbGFwc2VkTVMgPSB0aWNrZXIuVGlja2VyLnNoYXJlZC5lbGFwc2VkTVMgKiB0aGlzLnNvdXJjZS5wbGF5YmFja1JhdGU7XG4gICAgICB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA9IE1hdGguZmxvb3IodGhpcy5fbXNUb05leHRVcGRhdGUgLSBlbGFwc2VkTVMpO1xuICAgICAgaWYgKCF0aGlzLl91cGRhdGVGUFMgfHwgdGhpcy5fbXNUb05leHRVcGRhdGUgPD0gMCkge1xuICAgICAgICBzdXBlci51cGRhdGUoKTtcbiAgICAgICAgdGhpcy5fbXNUb05leHRVcGRhdGUgPSB0aGlzLl91cGRhdGVGUFMgPyBNYXRoLmZsb29yKDFlMyAvIHRoaXMuX3VwZGF0ZUZQUykgOiAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsb2FkKCkge1xuICAgIGlmICh0aGlzLl9sb2FkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9hZDtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgaWYgKChzb3VyY2UucmVhZHlTdGF0ZSA9PT0gc291cmNlLkhBVkVfRU5PVUdIX0RBVEEgfHwgc291cmNlLnJlYWR5U3RhdGUgPT09IHNvdXJjZS5IQVZFX0ZVVFVSRV9EQVRBKSAmJiBzb3VyY2Uud2lkdGggJiYgc291cmNlLmhlaWdodCkge1xuICAgICAgc291cmNlLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJwbGF5XCIsIHRoaXMuX29uUGxheVN0YXJ0LmJpbmQodGhpcykpO1xuICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwicGF1c2VcIiwgdGhpcy5fb25QbGF5U3RvcC5iaW5kKHRoaXMpKTtcbiAgICBpZiAoIXRoaXMuX2lzU291cmNlUmVhZHkoKSkge1xuICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIHRoaXMuX29uQ2FuUGxheSk7XG4gICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsIHRoaXMuX29uQ2FuUGxheSk7XG4gICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMuX29uRXJyb3IsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vbkNhblBsYXkoKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZiAodGhpcy52YWxpZCkge1xuICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIHNvdXJjZS5sb2FkKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gIH1cbiAgX29uRXJyb3IoZXZlbnQpIHtcbiAgICB0aGlzLnNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5fb25FcnJvciwgdHJ1ZSk7XG4gICAgdGhpcy5vbkVycm9yLmVtaXQoZXZlbnQpO1xuICB9XG4gIF9pc1NvdXJjZVBsYXlpbmcoKSB7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgcmV0dXJuICFzb3VyY2UucGF1c2VkICYmICFzb3VyY2UuZW5kZWQgJiYgdGhpcy5faXNTb3VyY2VSZWFkeSgpO1xuICB9XG4gIF9pc1NvdXJjZVJlYWR5KCkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgIHJldHVybiBzb3VyY2UucmVhZHlTdGF0ZSA+IDI7XG4gIH1cbiAgX29uUGxheVN0YXJ0KCkge1xuICAgIGlmICghdGhpcy52YWxpZCkge1xuICAgICAgdGhpcy5fb25DYW5QbGF5KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmF1dG9VcGRhdGUgJiYgIXRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIpIHtcbiAgICAgIHRpY2tlci5UaWNrZXIuc2hhcmVkLmFkZCh0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgICB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgX29uUGxheVN0b3AoKSB7XG4gICAgaWYgKHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIpIHtcbiAgICAgIHRpY2tlci5UaWNrZXIuc2hhcmVkLnJlbW92ZSh0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgICB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIF9vbkNhblBsYXkoKSB7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIHRoaXMuX29uQ2FuUGxheSk7XG4gICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLCB0aGlzLl9vbkNhblBsYXkpO1xuICAgIGNvbnN0IHZhbGlkID0gdGhpcy52YWxpZDtcbiAgICB0aGlzLnJlc2l6ZShzb3VyY2UudmlkZW9XaWR0aCwgc291cmNlLnZpZGVvSGVpZ2h0KTtcbiAgICBpZiAoIXZhbGlkICYmIHRoaXMuX3Jlc29sdmUpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmUodGhpcyk7XG4gICAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzU291cmNlUGxheWluZygpKSB7XG4gICAgICB0aGlzLl9vblBsYXlTdGFydCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hdXRvUGxheSkge1xuICAgICAgc291cmNlLnBsYXkoKTtcbiAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlcikge1xuICAgICAgdGlja2VyLlRpY2tlci5zaGFyZWQucmVtb3ZlKHRoaXMudXBkYXRlLCB0aGlzKTtcbiAgICAgIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLl9vbkVycm9yLCB0cnVlKTtcbiAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgc291cmNlLnNyYyA9IFwiXCI7XG4gICAgICBzb3VyY2UubG9hZCgpO1xuICAgIH1cbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgZ2V0IGF1dG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9VcGRhdGU7XG4gIH1cbiAgc2V0IGF1dG9VcGRhdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX2F1dG9VcGRhdGUpIHtcbiAgICAgIHRoaXMuX2F1dG9VcGRhdGUgPSB2YWx1ZTtcbiAgICAgIGlmICghdGhpcy5fYXV0b1VwZGF0ZSAmJiB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyKSB7XG4gICAgICAgIHRpY2tlci5UaWNrZXIuc2hhcmVkLnJlbW92ZSh0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYXV0b1VwZGF0ZSAmJiAhdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlciAmJiB0aGlzLl9pc1NvdXJjZVBsYXlpbmcoKSkge1xuICAgICAgICB0aWNrZXIuVGlja2VyLnNoYXJlZC5hZGQodGhpcy51cGRhdGUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IHVwZGF0ZUZQUygpIHtcbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlRlBTO1xuICB9XG4gIHNldCB1cGRhdGVGUFModmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX3VwZGF0ZUZQUykge1xuICAgICAgdGhpcy5fdXBkYXRlRlBTID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHN0YXRpYyB0ZXN0KHNvdXJjZSwgZXh0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMuSFRNTFZpZGVvRWxlbWVudCAmJiBzb3VyY2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50IHx8IF9WaWRlb1Jlc291cmNlLlRZUEVTLmluY2x1ZGVzKGV4dGVuc2lvbik7XG4gIH1cbn07XG5sZXQgVmlkZW9SZXNvdXJjZSA9IF9WaWRlb1Jlc291cmNlO1xuVmlkZW9SZXNvdXJjZS5UWVBFUyA9IFtcIm1wNFwiLCBcIm00dlwiLCBcIndlYm1cIiwgXCJvZ2dcIiwgXCJvZ3ZcIiwgXCJoMjY0XCIsIFwiYXZpXCIsIFwibW92XCJdO1xuVmlkZW9SZXNvdXJjZS5NSU1FX1RZUEVTID0ge1xuICBvZ3Y6IFwidmlkZW8vb2dnXCIsXG4gIG1vdjogXCJ2aWRlby9xdWlja3RpbWVcIixcbiAgbTR2OiBcInZpZGVvL21wNFwiXG59O1xuXG5leHBvcnRzLlZpZGVvUmVzb3VyY2UgPSBWaWRlb1Jlc291cmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmlkZW9SZXNvdXJjZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY29uc3QgSU5TVEFMTEVEID0gW107XG5mdW5jdGlvbiBhdXRvRGV0ZWN0UmVzb3VyY2Uoc291cmNlLCBvcHRpb25zKSB7XG4gIGlmICghc291cmNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IGV4dGVuc2lvbiA9IFwiXCI7XG4gIGlmICh0eXBlb2Ygc291cmNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gL1xcLihcXHd7Myw0fSkoPzokfFxcP3wjKS9pLmV4ZWMoc291cmNlKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBleHRlbnNpb24gPSByZXN1bHRbMV0udG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IElOU1RBTExFRC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGNvbnN0IFJlc291cmNlUGx1Z2luID0gSU5TVEFMTEVEW2ldO1xuICAgIGlmIChSZXNvdXJjZVBsdWdpbi50ZXN0ICYmIFJlc291cmNlUGx1Z2luLnRlc3Qoc291cmNlLCBleHRlbnNpb24pKSB7XG4gICAgICByZXR1cm4gbmV3IFJlc291cmNlUGx1Z2luKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBzb3VyY2UgdHlwZSB0byBhdXRvLWRldGVjdCBSZXNvdXJjZVwiKTtcbn1cblxuZXhwb3J0cy5JTlNUQUxMRUQgPSBJTlNUQUxMRUQ7XG5leHBvcnRzLmF1dG9EZXRlY3RSZXNvdXJjZSA9IGF1dG9EZXRlY3RSZXNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dG9EZXRlY3RSZXNvdXJjZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIEFycmF5UmVzb3VyY2UgPSByZXF1aXJlKCcuL0FycmF5UmVzb3VyY2UuanMnKTtcbnZhciBhdXRvRGV0ZWN0UmVzb3VyY2UgPSByZXF1aXJlKCcuL2F1dG9EZXRlY3RSZXNvdXJjZS5qcycpO1xudmFyIEJ1ZmZlclJlc291cmNlID0gcmVxdWlyZSgnLi9CdWZmZXJSZXNvdXJjZS5qcycpO1xudmFyIENhbnZhc1Jlc291cmNlID0gcmVxdWlyZSgnLi9DYW52YXNSZXNvdXJjZS5qcycpO1xudmFyIEN1YmVSZXNvdXJjZSA9IHJlcXVpcmUoJy4vQ3ViZVJlc291cmNlLmpzJyk7XG52YXIgSW1hZ2VCaXRtYXBSZXNvdXJjZSA9IHJlcXVpcmUoJy4vSW1hZ2VCaXRtYXBSZXNvdXJjZS5qcycpO1xudmFyIEltYWdlUmVzb3VyY2UgPSByZXF1aXJlKCcuL0ltYWdlUmVzb3VyY2UuanMnKTtcbnZhciBTVkdSZXNvdXJjZSA9IHJlcXVpcmUoJy4vU1ZHUmVzb3VyY2UuanMnKTtcbnZhciBWaWRlb1Jlc291cmNlID0gcmVxdWlyZSgnLi9WaWRlb1Jlc291cmNlLmpzJyk7XG52YXIgQmFzZUltYWdlUmVzb3VyY2UgPSByZXF1aXJlKCcuL0Jhc2VJbWFnZVJlc291cmNlLmpzJyk7XG52YXIgUmVzb3VyY2UgPSByZXF1aXJlKCcuL1Jlc291cmNlLmpzJyk7XG52YXIgQWJzdHJhY3RNdWx0aVJlc291cmNlID0gcmVxdWlyZSgnLi9BYnN0cmFjdE11bHRpUmVzb3VyY2UuanMnKTtcblxuYXV0b0RldGVjdFJlc291cmNlLklOU1RBTExFRC5wdXNoKEltYWdlQml0bWFwUmVzb3VyY2UuSW1hZ2VCaXRtYXBSZXNvdXJjZSwgSW1hZ2VSZXNvdXJjZS5JbWFnZVJlc291cmNlLCBDYW52YXNSZXNvdXJjZS5DYW52YXNSZXNvdXJjZSwgVmlkZW9SZXNvdXJjZS5WaWRlb1Jlc291cmNlLCBTVkdSZXNvdXJjZS5TVkdSZXNvdXJjZSwgQnVmZmVyUmVzb3VyY2UuQnVmZmVyUmVzb3VyY2UsIEN1YmVSZXNvdXJjZS5DdWJlUmVzb3VyY2UsIEFycmF5UmVzb3VyY2UuQXJyYXlSZXNvdXJjZSk7XG5cbmV4cG9ydHMuQXJyYXlSZXNvdXJjZSA9IEFycmF5UmVzb3VyY2UuQXJyYXlSZXNvdXJjZTtcbmV4cG9ydHMuSU5TVEFMTEVEID0gYXV0b0RldGVjdFJlc291cmNlLklOU1RBTExFRDtcbmV4cG9ydHMuYXV0b0RldGVjdFJlc291cmNlID0gYXV0b0RldGVjdFJlc291cmNlLmF1dG9EZXRlY3RSZXNvdXJjZTtcbmV4cG9ydHMuQnVmZmVyUmVzb3VyY2UgPSBCdWZmZXJSZXNvdXJjZS5CdWZmZXJSZXNvdXJjZTtcbmV4cG9ydHMuQ2FudmFzUmVzb3VyY2UgPSBDYW52YXNSZXNvdXJjZS5DYW52YXNSZXNvdXJjZTtcbmV4cG9ydHMuQ3ViZVJlc291cmNlID0gQ3ViZVJlc291cmNlLkN1YmVSZXNvdXJjZTtcbmV4cG9ydHMuSW1hZ2VCaXRtYXBSZXNvdXJjZSA9IEltYWdlQml0bWFwUmVzb3VyY2UuSW1hZ2VCaXRtYXBSZXNvdXJjZTtcbmV4cG9ydHMuSW1hZ2VSZXNvdXJjZSA9IEltYWdlUmVzb3VyY2UuSW1hZ2VSZXNvdXJjZTtcbmV4cG9ydHMuU1ZHUmVzb3VyY2UgPSBTVkdSZXNvdXJjZS5TVkdSZXNvdXJjZTtcbmV4cG9ydHMuVmlkZW9SZXNvdXJjZSA9IFZpZGVvUmVzb3VyY2UuVmlkZW9SZXNvdXJjZTtcbmV4cG9ydHMuQmFzZUltYWdlUmVzb3VyY2UgPSBCYXNlSW1hZ2VSZXNvdXJjZS5CYXNlSW1hZ2VSZXNvdXJjZTtcbmV4cG9ydHMuUmVzb3VyY2UgPSBSZXNvdXJjZS5SZXNvdXJjZTtcbmV4cG9ydHMuQWJzdHJhY3RNdWx0aVJlc291cmNlID0gQWJzdHJhY3RNdWx0aVJlc291cmNlLkFic3RyYWN0TXVsdGlSZXNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnQHBpeGkvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIG1hcFR5cGVBbmRGb3JtYXRUb0ludGVybmFsRm9ybWF0KGdsKSB7XG4gIGxldCB0YWJsZTtcbiAgaWYgKFwiV2ViR0wyUmVuZGVyaW5nQ29udGV4dFwiIGluIGdsb2JhbFRoaXMgJiYgZ2wgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLldlYkdMMlJlbmRlcmluZ0NvbnRleHQpIHtcbiAgICB0YWJsZSA9IHtcbiAgICAgIFtjb25zdGFudHMuVFlQRVMuVU5TSUdORURfQllURV06IHtcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQkFdOiBnbC5SR0JBOCxcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQl06IGdsLlJHQjgsXG4gICAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR106IGdsLlJHOCxcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJFRF06IGdsLlI4LFxuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCQV9JTlRFR0VSXTogZ2wuUkdCQThVSSxcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQl9JTlRFR0VSXTogZ2wuUkdCOFVJLFxuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdfSU5URUdFUl06IGdsLlJHOFVJLFxuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkVEX0lOVEVHRVJdOiBnbC5SOFVJLFxuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuQUxQSEFdOiBnbC5BTFBIQSxcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLkxVTUlOQU5DRV06IGdsLkxVTUlOQU5DRSxcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLkxVTUlOQU5DRV9BTFBIQV06IGdsLkxVTUlOQU5DRV9BTFBIQVxuICAgICAgfSxcbiAgICAgIFtjb25zdGFudHMuVFlQRVMuQllURV06IHtcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQkFdOiBnbC5SR0JBOF9TTk9STSxcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQl06IGdsLlJHQjhfU05PUk0sXG4gICAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR106IGdsLlJHOF9TTk9STSxcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJFRF06IGdsLlI4X1NOT1JNLFxuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCQV9JTlRFR0VSXTogZ2wuUkdCQThJLFxuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCX0lOVEVHRVJdOiBnbC5SR0I4SSxcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHX0lOVEVHRVJdOiBnbC5SRzhJLFxuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkVEX0lOVEVHRVJdOiBnbC5SOElcbiAgICAgIH0sXG4gICAgICBbY29uc3RhbnRzLlRZUEVTLlVOU0lHTkVEX1NIT1JUXToge1xuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCQV9JTlRFR0VSXTogZ2wuUkdCQTE2VUksXG4gICAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR0JfSU5URUdFUl06IGdsLlJHQjE2VUksXG4gICAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR19JTlRFR0VSXTogZ2wuUkcxNlVJLFxuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkVEX0lOVEVHRVJdOiBnbC5SMTZVSSxcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLkRFUFRIX0NPTVBPTkVOVF06IGdsLkRFUFRIX0NPTVBPTkVOVDE2XG4gICAgICB9LFxuICAgICAgW2NvbnN0YW50cy5UWVBFUy5TSE9SVF06IHtcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQkFfSU5URUdFUl06IGdsLlJHQkExNkksXG4gICAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR0JfSU5URUdFUl06IGdsLlJHQjE2SSxcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHX0lOVEVHRVJdOiBnbC5SRzE2SSxcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJFRF9JTlRFR0VSXTogZ2wuUjE2SVxuICAgICAgfSxcbiAgICAgIFtjb25zdGFudHMuVFlQRVMuVU5TSUdORURfSU5UXToge1xuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCQV9JTlRFR0VSXTogZ2wuUkdCQTMyVUksXG4gICAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR0JfSU5URUdFUl06IGdsLlJHQjMyVUksXG4gICAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR19JTlRFR0VSXTogZ2wuUkczMlVJLFxuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkVEX0lOVEVHRVJdOiBnbC5SMzJVSSxcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLkRFUFRIX0NPTVBPTkVOVF06IGdsLkRFUFRIX0NPTVBPTkVOVDI0XG4gICAgICB9LFxuICAgICAgW2NvbnN0YW50cy5UWVBFUy5JTlRdOiB7XG4gICAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR0JBX0lOVEVHRVJdOiBnbC5SR0JBMzJJLFxuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCX0lOVEVHRVJdOiBnbC5SR0IzMkksXG4gICAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR19JTlRFR0VSXTogZ2wuUkczMkksXG4gICAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SRURfSU5URUdFUl06IGdsLlIzMklcbiAgICAgIH0sXG4gICAgICBbY29uc3RhbnRzLlRZUEVTLkZMT0FUXToge1xuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCQV06IGdsLlJHQkEzMkYsXG4gICAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR0JdOiBnbC5SR0IzMkYsXG4gICAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR106IGdsLlJHMzJGLFxuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkVEXTogZ2wuUjMyRixcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLkRFUFRIX0NPTVBPTkVOVF06IGdsLkRFUFRIX0NPTVBPTkVOVDMyRlxuICAgICAgfSxcbiAgICAgIFtjb25zdGFudHMuVFlQRVMuSEFMRl9GTE9BVF06IHtcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQkFdOiBnbC5SR0JBMTZGLFxuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCXTogZ2wuUkdCMTZGLFxuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkddOiBnbC5SRzE2RixcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJFRF06IGdsLlIxNkZcbiAgICAgIH0sXG4gICAgICBbY29uc3RhbnRzLlRZUEVTLlVOU0lHTkVEX1NIT1JUXzVfNl81XToge1xuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCXTogZ2wuUkdCNTY1XG4gICAgICB9LFxuICAgICAgW2NvbnN0YW50cy5UWVBFUy5VTlNJR05FRF9TSE9SVF80XzRfNF80XToge1xuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCQV06IGdsLlJHQkE0XG4gICAgICB9LFxuICAgICAgW2NvbnN0YW50cy5UWVBFUy5VTlNJR05FRF9TSE9SVF81XzVfNV8xXToge1xuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCQV06IGdsLlJHQjVfQTFcbiAgICAgIH0sXG4gICAgICBbY29uc3RhbnRzLlRZUEVTLlVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFVl06IHtcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQkFdOiBnbC5SR0IxMF9BMixcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQkFfSU5URUdFUl06IGdsLlJHQjEwX0EyVUlcbiAgICAgIH0sXG4gICAgICBbY29uc3RhbnRzLlRZUEVTLlVOU0lHTkVEX0lOVF8xMEZfMTFGXzExRl9SRVZdOiB7XG4gICAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR0JdOiBnbC5SMTFGX0cxMUZfQjEwRlxuICAgICAgfSxcbiAgICAgIFtjb25zdGFudHMuVFlQRVMuVU5TSUdORURfSU5UXzVfOV85XzlfUkVWXToge1xuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCXTogZ2wuUkdCOV9FNVxuICAgICAgfSxcbiAgICAgIFtjb25zdGFudHMuVFlQRVMuVU5TSUdORURfSU5UXzI0XzhdOiB7XG4gICAgICAgIFtjb25zdGFudHMuRk9STUFUUy5ERVBUSF9TVEVOQ0lMXTogZ2wuREVQVEgyNF9TVEVOQ0lMOFxuICAgICAgfSxcbiAgICAgIFtjb25zdGFudHMuVFlQRVMuRkxPQVRfMzJfVU5TSUdORURfSU5UXzI0XzhfUkVWXToge1xuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuREVQVEhfU1RFTkNJTF06IGdsLkRFUFRIMzJGX1NURU5DSUw4XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0YWJsZSA9IHtcbiAgICAgIFtjb25zdGFudHMuVFlQRVMuVU5TSUdORURfQllURV06IHtcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQkFdOiBnbC5SR0JBLFxuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCXTogZ2wuUkdCLFxuICAgICAgICBbY29uc3RhbnRzLkZPUk1BVFMuQUxQSEFdOiBnbC5BTFBIQSxcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLkxVTUlOQU5DRV06IGdsLkxVTUlOQU5DRSxcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLkxVTUlOQU5DRV9BTFBIQV06IGdsLkxVTUlOQU5DRV9BTFBIQVxuICAgICAgfSxcbiAgICAgIFtjb25zdGFudHMuVFlQRVMuVU5TSUdORURfU0hPUlRfNV82XzVdOiB7XG4gICAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR0JdOiBnbC5SR0JcbiAgICAgIH0sXG4gICAgICBbY29uc3RhbnRzLlRZUEVTLlVOU0lHTkVEX1NIT1JUXzRfNF80XzRdOiB7XG4gICAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR0JBXTogZ2wuUkdCQVxuICAgICAgfSxcbiAgICAgIFtjb25zdGFudHMuVFlQRVMuVU5TSUdORURfU0hPUlRfNV81XzVfMV06IHtcbiAgICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQkFdOiBnbC5SR0JBXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gdGFibGU7XG59XG5cbmV4cG9ydHMubWFwVHlwZUFuZEZvcm1hdFRvSW50ZXJuYWxGb3JtYXQgPSBtYXBUeXBlQW5kRm9ybWF0VG9JbnRlcm5hbEZvcm1hdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcFR5cGVBbmRGb3JtYXRUb0ludGVybmFsRm9ybWF0LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgcnVubmVyID0gcmVxdWlyZSgnQHBpeGkvcnVubmVyJyk7XG5cbmNsYXNzIFRyYW5zZm9ybUZlZWRiYWNrIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZ2xUcmFuc2Zvcm1GZWVkYmFja3MgPSB7fTtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICB0aGlzLmRpc3Bvc2VSdW5uZXIgPSBuZXcgcnVubmVyLlJ1bm5lcihcImRpc3Bvc2VUcmFuc2Zvcm1GZWVkYmFja1wiKTtcbiAgfVxuICBiaW5kQnVmZmVyKGluZGV4LCBidWZmZXIpIHtcbiAgICB0aGlzLmJ1ZmZlcnNbaW5kZXhdID0gYnVmZmVyO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kaXNwb3NlUnVubmVyLmVtaXQodGhpcywgZmFsc2UpO1xuICB9XG59XG5cbmV4cG9ydHMuVHJhbnNmb3JtRmVlZGJhY2sgPSBUcmFuc2Zvcm1GZWVkYmFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zZm9ybUZlZWRiYWNrLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZXh0ZW5zaW9ucyA9IHJlcXVpcmUoJ0BwaXhpL2V4dGVuc2lvbnMnKTtcblxuY2xhc3MgVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKCkge1xuICAgIHRoaXMuZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgIHRoaXMuQ09OVEVYVF9VSUQgPSB0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEO1xuICB9XG4gIGJpbmQodHJhbnNmb3JtRmVlZGJhY2spIHtcbiAgICBjb25zdCB7IGdsLCBDT05URVhUX1VJRCB9ID0gdGhpcztcbiAgICBjb25zdCBnbFRyYW5zZm9ybUZlZWRiYWNrID0gdHJhbnNmb3JtRmVlZGJhY2suX2dsVHJhbnNmb3JtRmVlZGJhY2tzW0NPTlRFWFRfVUlEXSB8fCB0aGlzLmNyZWF0ZUdMVHJhbnNmb3JtRmVlZGJhY2sodHJhbnNmb3JtRmVlZGJhY2spO1xuICAgIGdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayhnbC5UUkFOU0ZPUk1fRkVFREJBQ0ssIGdsVHJhbnNmb3JtRmVlZGJhY2spO1xuICB9XG4gIHVuYmluZCgpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzO1xuICAgIGdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayhnbC5UUkFOU0ZPUk1fRkVFREJBQ0ssIG51bGwpO1xuICB9XG4gIGJlZ2luVHJhbnNmb3JtRmVlZGJhY2soZHJhd01vZGUsIHNoYWRlcikge1xuICAgIGNvbnN0IHsgZ2wsIHJlbmRlcmVyIH0gPSB0aGlzO1xuICAgIGlmIChzaGFkZXIpIHtcbiAgICAgIHJlbmRlcmVyLnNoYWRlci5iaW5kKHNoYWRlcik7XG4gICAgfVxuICAgIGdsLmJlZ2luVHJhbnNmb3JtRmVlZGJhY2soZHJhd01vZGUpO1xuICB9XG4gIGVuZFRyYW5zZm9ybUZlZWRiYWNrKCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgZ2wuZW5kVHJhbnNmb3JtRmVlZGJhY2soKTtcbiAgfVxuICBjcmVhdGVHTFRyYW5zZm9ybUZlZWRiYWNrKHRmKSB7XG4gICAgY29uc3QgeyBnbCwgcmVuZGVyZXIsIENPTlRFWFRfVUlEIH0gPSB0aGlzO1xuICAgIGNvbnN0IGdsVHJhbnNmb3JtRmVlZGJhY2sgPSBnbC5jcmVhdGVUcmFuc2Zvcm1GZWVkYmFjaygpO1xuICAgIHRmLl9nbFRyYW5zZm9ybUZlZWRiYWNrc1tDT05URVhUX1VJRF0gPSBnbFRyYW5zZm9ybUZlZWRiYWNrO1xuICAgIGdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayhnbC5UUkFOU0ZPUk1fRkVFREJBQ0ssIGdsVHJhbnNmb3JtRmVlZGJhY2spO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGYuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYnVmZmVyID0gdGYuYnVmZmVyc1tpXTtcbiAgICAgIGlmICghYnVmZmVyKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHJlbmRlcmVyLmJ1ZmZlci51cGRhdGUoYnVmZmVyKTtcbiAgICAgIGJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXS5yZWZDb3VudCsrO1xuICAgICAgZ2wuYmluZEJ1ZmZlckJhc2UoZ2wuVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUiwgaSwgYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdLmJ1ZmZlciB8fCBudWxsKTtcbiAgICB9XG4gICAgZ2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKGdsLlRSQU5TRk9STV9GRUVEQkFDSywgbnVsbCk7XG4gICAgdGYuZGlzcG9zZVJ1bm5lci5hZGQodGhpcyk7XG4gICAgcmV0dXJuIGdsVHJhbnNmb3JtRmVlZGJhY2s7XG4gIH1cbiAgZGlzcG9zZVRyYW5zZm9ybUZlZWRiYWNrKHRmLCBjb250ZXh0TG9zdCkge1xuICAgIGNvbnN0IGdsVEYgPSB0Zi5fZ2xUcmFuc2Zvcm1GZWVkYmFja3NbdGhpcy5DT05URVhUX1VJRF07XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIHRmLmRpc3Bvc2VSdW5uZXIucmVtb3ZlKHRoaXMpO1xuICAgIGNvbnN0IGJ1ZmZlclN5c3RlbSA9IHRoaXMucmVuZGVyZXIuYnVmZmVyO1xuICAgIGlmIChidWZmZXJTeXN0ZW0pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGYuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB0Zi5idWZmZXJzW2ldO1xuICAgICAgICBpZiAoIWJ1ZmZlcilcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgYnVmID0gYnVmZmVyLl9nbEJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgICAgIGlmIChidWYpIHtcbiAgICAgICAgICBidWYucmVmQ291bnQtLTtcbiAgICAgICAgICBpZiAoYnVmLnJlZkNvdW50ID09PSAwICYmICFjb250ZXh0TG9zdCkge1xuICAgICAgICAgICAgYnVmZmVyU3lzdGVtLmRpc3Bvc2UoYnVmZmVyLCBjb250ZXh0TG9zdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZ2xURikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNvbnRleHRMb3N0KSB7XG4gICAgICBnbC5kZWxldGVUcmFuc2Zvcm1GZWVkYmFjayhnbFRGKTtcbiAgICB9XG4gICAgZGVsZXRlIHRmLl9nbFRyYW5zZm9ybUZlZWRiYWNrc1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG5UcmFuc2Zvcm1GZWVkYmFja1N5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJ0cmFuc2Zvcm1GZWVkYmFja1wiXG59O1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmFkZChUcmFuc2Zvcm1GZWVkYmFja1N5c3RlbSk7XG5cbmV4cG9ydHMuVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0gPSBUcmFuc2Zvcm1GZWVkYmFja1N5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zZm9ybUZlZWRiYWNrU3lzdGVtLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgR2VvbWV0cnkgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9HZW9tZXRyeS5qcycpO1xuXG5jbGFzcyBRdWFkIGV4dGVuZHMgR2VvbWV0cnkuR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYWRkQXR0cmlidXRlKFwiYVZlcnRleFBvc2l0aW9uXCIsIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDFcbiAgICBdKSkuYWRkSW5kZXgoWzAsIDEsIDMsIDJdKTtcbiAgfVxufVxuXG5leHBvcnRzLlF1YWQgPSBRdWFkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVhZC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L0J1ZmZlci5qcycpO1xudmFyIEdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvR2VvbWV0cnkuanMnKTtcblxuY2xhc3MgUXVhZFV2IGV4dGVuZHMgR2VvbWV0cnkuR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgIC0xLFxuICAgICAgLTEsXG4gICAgICAxLFxuICAgICAgLTEsXG4gICAgICAxLFxuICAgICAgMSxcbiAgICAgIC0xLFxuICAgICAgMVxuICAgIF0pO1xuICAgIHRoaXMudXZzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMVxuICAgIF0pO1xuICAgIHRoaXMudmVydGV4QnVmZmVyID0gbmV3IEJ1ZmZlci5CdWZmZXIodGhpcy52ZXJ0aWNlcyk7XG4gICAgdGhpcy51dkJ1ZmZlciA9IG5ldyBCdWZmZXIuQnVmZmVyKHRoaXMudXZzKTtcbiAgICB0aGlzLmFkZEF0dHJpYnV0ZShcImFWZXJ0ZXhQb3NpdGlvblwiLCB0aGlzLnZlcnRleEJ1ZmZlcikuYWRkQXR0cmlidXRlKFwiYVRleHR1cmVDb29yZFwiLCB0aGlzLnV2QnVmZmVyKS5hZGRJbmRleChbMCwgMSwgMiwgMCwgMiwgM10pO1xuICB9XG4gIG1hcCh0YXJnZXRUZXh0dXJlRnJhbWUsIGRlc3RpbmF0aW9uRnJhbWUpIHtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHkgPSAwO1xuICAgIHRoaXMudXZzWzBdID0geDtcbiAgICB0aGlzLnV2c1sxXSA9IHk7XG4gICAgdGhpcy51dnNbMl0gPSB4ICsgZGVzdGluYXRpb25GcmFtZS53aWR0aCAvIHRhcmdldFRleHR1cmVGcmFtZS53aWR0aDtcbiAgICB0aGlzLnV2c1szXSA9IHk7XG4gICAgdGhpcy51dnNbNF0gPSB4ICsgZGVzdGluYXRpb25GcmFtZS53aWR0aCAvIHRhcmdldFRleHR1cmVGcmFtZS53aWR0aDtcbiAgICB0aGlzLnV2c1s1XSA9IHkgKyBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAvIHRhcmdldFRleHR1cmVGcmFtZS5oZWlnaHQ7XG4gICAgdGhpcy51dnNbNl0gPSB4O1xuICAgIHRoaXMudXZzWzddID0geSArIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0IC8gdGFyZ2V0VGV4dHVyZUZyYW1lLmhlaWdodDtcbiAgICB4ID0gZGVzdGluYXRpb25GcmFtZS54O1xuICAgIHkgPSBkZXN0aW5hdGlvbkZyYW1lLnk7XG4gICAgdGhpcy52ZXJ0aWNlc1swXSA9IHg7XG4gICAgdGhpcy52ZXJ0aWNlc1sxXSA9IHk7XG4gICAgdGhpcy52ZXJ0aWNlc1syXSA9IHggKyBkZXN0aW5hdGlvbkZyYW1lLndpZHRoO1xuICAgIHRoaXMudmVydGljZXNbM10gPSB5O1xuICAgIHRoaXMudmVydGljZXNbNF0gPSB4ICsgZGVzdGluYXRpb25GcmFtZS53aWR0aDtcbiAgICB0aGlzLnZlcnRpY2VzWzVdID0geSArIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0O1xuICAgIHRoaXMudmVydGljZXNbNl0gPSB4O1xuICAgIHRoaXMudmVydGljZXNbN10gPSB5ICsgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQ7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICB0aGlzLnZlcnRleEJ1ZmZlci5fdXBkYXRlSUQrKztcbiAgICB0aGlzLnV2QnVmZmVyLl91cGRhdGVJRCsrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbmV4cG9ydHMuUXVhZFV2ID0gUXVhZFV2O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVhZFV2LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZXh0ZW5zaW9ucyA9IHJlcXVpcmUoJ0BwaXhpL2V4dGVuc2lvbnMnKTtcbnZhciBtYXRoID0gcmVxdWlyZSgnQHBpeGkvbWF0aCcpO1xudmFyIHNldHRpbmdzID0gcmVxdWlyZSgnQHBpeGkvc2V0dGluZ3MnKTtcblxuY2xhc3MgVmlld1N5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIGluaXQob3B0aW9ucykge1xuICAgIHRoaXMuc2NyZWVuID0gbmV3IG1hdGguUmVjdGFuZ2xlKDAsIDAsIG9wdGlvbnMud2lkdGgsIG9wdGlvbnMuaGVpZ2h0KTtcbiAgICB0aGlzLmVsZW1lbnQgPSBvcHRpb25zLnZpZXcgfHwgc2V0dGluZ3Muc2V0dGluZ3MuQURBUFRFUi5jcmVhdGVDYW52YXMoKTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSBvcHRpb25zLnJlc29sdXRpb24gfHwgc2V0dGluZ3Muc2V0dGluZ3MuUkVTT0xVVElPTjtcbiAgICB0aGlzLmF1dG9EZW5zaXR5ID0gISFvcHRpb25zLmF1dG9EZW5zaXR5O1xuICB9XG4gIHJlc2l6ZVZpZXcoZGVzaXJlZFNjcmVlbldpZHRoLCBkZXNpcmVkU2NyZWVuSGVpZ2h0KSB7XG4gICAgdGhpcy5lbGVtZW50LndpZHRoID0gTWF0aC5yb3VuZChkZXNpcmVkU2NyZWVuV2lkdGggKiB0aGlzLnJlc29sdXRpb24pO1xuICAgIHRoaXMuZWxlbWVudC5oZWlnaHQgPSBNYXRoLnJvdW5kKGRlc2lyZWRTY3JlZW5IZWlnaHQgKiB0aGlzLnJlc29sdXRpb24pO1xuICAgIGNvbnN0IHNjcmVlbldpZHRoID0gdGhpcy5lbGVtZW50LndpZHRoIC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgIGNvbnN0IHNjcmVlbkhlaWdodCA9IHRoaXMuZWxlbWVudC5oZWlnaHQgLyB0aGlzLnJlc29sdXRpb247XG4gICAgdGhpcy5zY3JlZW4ud2lkdGggPSBzY3JlZW5XaWR0aDtcbiAgICB0aGlzLnNjcmVlbi5oZWlnaHQgPSBzY3JlZW5IZWlnaHQ7XG4gICAgaWYgKHRoaXMuYXV0b0RlbnNpdHkpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9IGAke3NjcmVlbldpZHRofXB4YDtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHtzY3JlZW5IZWlnaHR9cHhgO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlcmVyLmVtaXQoXCJyZXNpemVcIiwgc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJlci5ydW5uZXJzLnJlc2l6ZS5lbWl0KHRoaXMuc2NyZWVuLndpZHRoLCB0aGlzLnNjcmVlbi5oZWlnaHQpO1xuICB9XG4gIGRlc3Ryb3kocmVtb3ZlVmlldykge1xuICAgIGlmIChyZW1vdmVWaWV3KSB7XG4gICAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZT8ucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLnNjcmVlbiA9IG51bGw7XG4gIH1cbn1cblZpZXdTeXN0ZW0uZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHdpZHRoOiA4MDAsXG4gIGhlaWdodDogNjAwLFxuICByZXNvbHV0aW9uOiBzZXR0aW5ncy5zZXR0aW5ncy5SRVNPTFVUSU9OLFxuICBhdXRvRGVuc2l0eTogZmFsc2Vcbn07XG5WaWV3U3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgICBleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuQ2FudmFzUmVuZGVyZXJTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJfdmlld1wiXG59O1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmFkZChWaWV3U3lzdGVtKTtcblxuZXhwb3J0cy5WaWV3U3lzdGVtID0gVmlld1N5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpZXdTeXN0ZW0uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xuXG5jbGFzcyBCb3VuZHMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm1pblggPSBJbmZpbml0eTtcbiAgICB0aGlzLm1pblkgPSBJbmZpbml0eTtcbiAgICB0aGlzLm1heFggPSAtSW5maW5pdHk7XG4gICAgdGhpcy5tYXhZID0gLUluZmluaXR5O1xuICAgIHRoaXMucmVjdCA9IG51bGw7XG4gICAgdGhpcy51cGRhdGVJRCA9IC0xO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubWluWCA+IHRoaXMubWF4WCB8fCB0aGlzLm1pblkgPiB0aGlzLm1heFk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5taW5YID0gSW5maW5pdHk7XG4gICAgdGhpcy5taW5ZID0gSW5maW5pdHk7XG4gICAgdGhpcy5tYXhYID0gLUluZmluaXR5O1xuICAgIHRoaXMubWF4WSA9IC1JbmZpbml0eTtcbiAgfVxuICBnZXRSZWN0YW5nbGUocmVjdCkge1xuICAgIGlmICh0aGlzLm1pblggPiB0aGlzLm1heFggfHwgdGhpcy5taW5ZID4gdGhpcy5tYXhZKSB7XG4gICAgICByZXR1cm4gY29yZS5SZWN0YW5nbGUuRU1QVFk7XG4gICAgfVxuICAgIHJlY3QgPSByZWN0IHx8IG5ldyBjb3JlLlJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcbiAgICByZWN0LnggPSB0aGlzLm1pblg7XG4gICAgcmVjdC55ID0gdGhpcy5taW5ZO1xuICAgIHJlY3Qud2lkdGggPSB0aGlzLm1heFggLSB0aGlzLm1pblg7XG4gICAgcmVjdC5oZWlnaHQgPSB0aGlzLm1heFkgLSB0aGlzLm1pblk7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cbiAgYWRkUG9pbnQocG9pbnQpIHtcbiAgICB0aGlzLm1pblggPSBNYXRoLm1pbih0aGlzLm1pblgsIHBvaW50LngpO1xuICAgIHRoaXMubWF4WCA9IE1hdGgubWF4KHRoaXMubWF4WCwgcG9pbnQueCk7XG4gICAgdGhpcy5taW5ZID0gTWF0aC5taW4odGhpcy5taW5ZLCBwb2ludC55KTtcbiAgICB0aGlzLm1heFkgPSBNYXRoLm1heCh0aGlzLm1heFksIHBvaW50LnkpO1xuICB9XG4gIGFkZFBvaW50TWF0cml4KG1hdHJpeCwgcG9pbnQpIHtcbiAgICBjb25zdCB7IGEsIGIsIGMsIGQsIHR4LCB0eSB9ID0gbWF0cml4O1xuICAgIGNvbnN0IHggPSBhICogcG9pbnQueCArIGMgKiBwb2ludC55ICsgdHg7XG4gICAgY29uc3QgeSA9IGIgKiBwb2ludC54ICsgZCAqIHBvaW50LnkgKyB0eTtcbiAgICB0aGlzLm1pblggPSBNYXRoLm1pbih0aGlzLm1pblgsIHgpO1xuICAgIHRoaXMubWF4WCA9IE1hdGgubWF4KHRoaXMubWF4WCwgeCk7XG4gICAgdGhpcy5taW5ZID0gTWF0aC5taW4odGhpcy5taW5ZLCB5KTtcbiAgICB0aGlzLm1heFkgPSBNYXRoLm1heCh0aGlzLm1heFksIHkpO1xuICB9XG4gIGFkZFF1YWQodmVydGljZXMpIHtcbiAgICBsZXQgbWluWCA9IHRoaXMubWluWDtcbiAgICBsZXQgbWluWSA9IHRoaXMubWluWTtcbiAgICBsZXQgbWF4WCA9IHRoaXMubWF4WDtcbiAgICBsZXQgbWF4WSA9IHRoaXMubWF4WTtcbiAgICBsZXQgeCA9IHZlcnRpY2VzWzBdO1xuICAgIGxldCB5ID0gdmVydGljZXNbMV07XG4gICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgeCA9IHZlcnRpY2VzWzJdO1xuICAgIHkgPSB2ZXJ0aWNlc1szXTtcbiAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcbiAgICB4ID0gdmVydGljZXNbNF07XG4gICAgeSA9IHZlcnRpY2VzWzVdO1xuICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgIHggPSB2ZXJ0aWNlc1s2XTtcbiAgICB5ID0gdmVydGljZXNbN107XG4gICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgdGhpcy5taW5YID0gbWluWDtcbiAgICB0aGlzLm1pblkgPSBtaW5ZO1xuICAgIHRoaXMubWF4WCA9IG1heFg7XG4gICAgdGhpcy5tYXhZID0gbWF4WTtcbiAgfVxuICBhZGRGcmFtZSh0cmFuc2Zvcm0sIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgdGhpcy5hZGRGcmFtZU1hdHJpeCh0cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0sIHgwLCB5MCwgeDEsIHkxKTtcbiAgfVxuICBhZGRGcmFtZU1hdHJpeChtYXRyaXgsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgY29uc3QgYSA9IG1hdHJpeC5hO1xuICAgIGNvbnN0IGIgPSBtYXRyaXguYjtcbiAgICBjb25zdCBjID0gbWF0cml4LmM7XG4gICAgY29uc3QgZCA9IG1hdHJpeC5kO1xuICAgIGNvbnN0IHR4ID0gbWF0cml4LnR4O1xuICAgIGNvbnN0IHR5ID0gbWF0cml4LnR5O1xuICAgIGxldCBtaW5YID0gdGhpcy5taW5YO1xuICAgIGxldCBtaW5ZID0gdGhpcy5taW5ZO1xuICAgIGxldCBtYXhYID0gdGhpcy5tYXhYO1xuICAgIGxldCBtYXhZID0gdGhpcy5tYXhZO1xuICAgIGxldCB4ID0gYSAqIHgwICsgYyAqIHkwICsgdHg7XG4gICAgbGV0IHkgPSBiICogeDAgKyBkICogeTAgKyB0eTtcbiAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcbiAgICB4ID0gYSAqIHgxICsgYyAqIHkwICsgdHg7XG4gICAgeSA9IGIgKiB4MSArIGQgKiB5MCArIHR5O1xuICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgIHggPSBhICogeDAgKyBjICogeTEgKyB0eDtcbiAgICB5ID0gYiAqIHgwICsgZCAqIHkxICsgdHk7XG4gICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgeCA9IGEgKiB4MSArIGMgKiB5MSArIHR4O1xuICAgIHkgPSBiICogeDEgKyBkICogeTEgKyB0eTtcbiAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcbiAgICB0aGlzLm1pblggPSBtaW5YO1xuICAgIHRoaXMubWluWSA9IG1pblk7XG4gICAgdGhpcy5tYXhYID0gbWF4WDtcbiAgICB0aGlzLm1heFkgPSBtYXhZO1xuICB9XG4gIGFkZFZlcnRleERhdGEodmVydGV4RGF0YSwgYmVnaW5PZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIGxldCBtaW5YID0gdGhpcy5taW5YO1xuICAgIGxldCBtaW5ZID0gdGhpcy5taW5ZO1xuICAgIGxldCBtYXhYID0gdGhpcy5tYXhYO1xuICAgIGxldCBtYXhZID0gdGhpcy5tYXhZO1xuICAgIGZvciAobGV0IGkgPSBiZWdpbk9mZnNldDsgaSA8IGVuZE9mZnNldDsgaSArPSAyKSB7XG4gICAgICBjb25zdCB4ID0gdmVydGV4RGF0YVtpXTtcbiAgICAgIGNvbnN0IHkgPSB2ZXJ0ZXhEYXRhW2kgKyAxXTtcbiAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgIH1cbiAgICB0aGlzLm1pblggPSBtaW5YO1xuICAgIHRoaXMubWluWSA9IG1pblk7XG4gICAgdGhpcy5tYXhYID0gbWF4WDtcbiAgICB0aGlzLm1heFkgPSBtYXhZO1xuICB9XG4gIGFkZFZlcnRpY2VzKHRyYW5zZm9ybSwgdmVydGljZXMsIGJlZ2luT2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICB0aGlzLmFkZFZlcnRpY2VzTWF0cml4KHRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybSwgdmVydGljZXMsIGJlZ2luT2Zmc2V0LCBlbmRPZmZzZXQpO1xuICB9XG4gIGFkZFZlcnRpY2VzTWF0cml4KG1hdHJpeCwgdmVydGljZXMsIGJlZ2luT2Zmc2V0LCBlbmRPZmZzZXQsIHBhZFggPSAwLCBwYWRZID0gcGFkWCkge1xuICAgIGNvbnN0IGEgPSBtYXRyaXguYTtcbiAgICBjb25zdCBiID0gbWF0cml4LmI7XG4gICAgY29uc3QgYyA9IG1hdHJpeC5jO1xuICAgIGNvbnN0IGQgPSBtYXRyaXguZDtcbiAgICBjb25zdCB0eCA9IG1hdHJpeC50eDtcbiAgICBjb25zdCB0eSA9IG1hdHJpeC50eTtcbiAgICBsZXQgbWluWCA9IHRoaXMubWluWDtcbiAgICBsZXQgbWluWSA9IHRoaXMubWluWTtcbiAgICBsZXQgbWF4WCA9IHRoaXMubWF4WDtcbiAgICBsZXQgbWF4WSA9IHRoaXMubWF4WTtcbiAgICBmb3IgKGxldCBpID0gYmVnaW5PZmZzZXQ7IGkgPCBlbmRPZmZzZXQ7IGkgKz0gMikge1xuICAgICAgY29uc3QgcmF3WCA9IHZlcnRpY2VzW2ldO1xuICAgICAgY29uc3QgcmF3WSA9IHZlcnRpY2VzW2kgKyAxXTtcbiAgICAgIGNvbnN0IHggPSBhICogcmF3WCArIGMgKiByYXdZICsgdHg7XG4gICAgICBjb25zdCB5ID0gZCAqIHJhd1kgKyBiICogcmF3WCArIHR5O1xuICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHggLSBwYWRYKTtcbiAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4ICsgcGFkWCk7XG4gICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSAtIHBhZFkpO1xuICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkgKyBwYWRZKTtcbiAgICB9XG4gICAgdGhpcy5taW5YID0gbWluWDtcbiAgICB0aGlzLm1pblkgPSBtaW5ZO1xuICAgIHRoaXMubWF4WCA9IG1heFg7XG4gICAgdGhpcy5tYXhZID0gbWF4WTtcbiAgfVxuICBhZGRCb3VuZHMoYm91bmRzKSB7XG4gICAgY29uc3QgbWluWCA9IHRoaXMubWluWDtcbiAgICBjb25zdCBtaW5ZID0gdGhpcy5taW5ZO1xuICAgIGNvbnN0IG1heFggPSB0aGlzLm1heFg7XG4gICAgY29uc3QgbWF4WSA9IHRoaXMubWF4WTtcbiAgICB0aGlzLm1pblggPSBib3VuZHMubWluWCA8IG1pblggPyBib3VuZHMubWluWCA6IG1pblg7XG4gICAgdGhpcy5taW5ZID0gYm91bmRzLm1pblkgPCBtaW5ZID8gYm91bmRzLm1pblkgOiBtaW5ZO1xuICAgIHRoaXMubWF4WCA9IGJvdW5kcy5tYXhYID4gbWF4WCA/IGJvdW5kcy5tYXhYIDogbWF4WDtcbiAgICB0aGlzLm1heFkgPSBib3VuZHMubWF4WSA+IG1heFkgPyBib3VuZHMubWF4WSA6IG1heFk7XG4gIH1cbiAgYWRkQm91bmRzTWFzayhib3VuZHMsIG1hc2spIHtcbiAgICBjb25zdCBfbWluWCA9IGJvdW5kcy5taW5YID4gbWFzay5taW5YID8gYm91bmRzLm1pblggOiBtYXNrLm1pblg7XG4gICAgY29uc3QgX21pblkgPSBib3VuZHMubWluWSA+IG1hc2subWluWSA/IGJvdW5kcy5taW5ZIDogbWFzay5taW5ZO1xuICAgIGNvbnN0IF9tYXhYID0gYm91bmRzLm1heFggPCBtYXNrLm1heFggPyBib3VuZHMubWF4WCA6IG1hc2subWF4WDtcbiAgICBjb25zdCBfbWF4WSA9IGJvdW5kcy5tYXhZIDwgbWFzay5tYXhZID8gYm91bmRzLm1heFkgOiBtYXNrLm1heFk7XG4gICAgaWYgKF9taW5YIDw9IF9tYXhYICYmIF9taW5ZIDw9IF9tYXhZKSB7XG4gICAgICBjb25zdCBtaW5YID0gdGhpcy5taW5YO1xuICAgICAgY29uc3QgbWluWSA9IHRoaXMubWluWTtcbiAgICAgIGNvbnN0IG1heFggPSB0aGlzLm1heFg7XG4gICAgICBjb25zdCBtYXhZID0gdGhpcy5tYXhZO1xuICAgICAgdGhpcy5taW5YID0gX21pblggPCBtaW5YID8gX21pblggOiBtaW5YO1xuICAgICAgdGhpcy5taW5ZID0gX21pblkgPCBtaW5ZID8gX21pblkgOiBtaW5ZO1xuICAgICAgdGhpcy5tYXhYID0gX21heFggPiBtYXhYID8gX21heFggOiBtYXhYO1xuICAgICAgdGhpcy5tYXhZID0gX21heFkgPiBtYXhZID8gX21heFkgOiBtYXhZO1xuICAgIH1cbiAgfVxuICBhZGRCb3VuZHNNYXRyaXgoYm91bmRzLCBtYXRyaXgpIHtcbiAgICB0aGlzLmFkZEZyYW1lTWF0cml4KG1hdHJpeCwgYm91bmRzLm1pblgsIGJvdW5kcy5taW5ZLCBib3VuZHMubWF4WCwgYm91bmRzLm1heFkpO1xuICB9XG4gIGFkZEJvdW5kc0FyZWEoYm91bmRzLCBhcmVhKSB7XG4gICAgY29uc3QgX21pblggPSBib3VuZHMubWluWCA+IGFyZWEueCA/IGJvdW5kcy5taW5YIDogYXJlYS54O1xuICAgIGNvbnN0IF9taW5ZID0gYm91bmRzLm1pblkgPiBhcmVhLnkgPyBib3VuZHMubWluWSA6IGFyZWEueTtcbiAgICBjb25zdCBfbWF4WCA9IGJvdW5kcy5tYXhYIDwgYXJlYS54ICsgYXJlYS53aWR0aCA/IGJvdW5kcy5tYXhYIDogYXJlYS54ICsgYXJlYS53aWR0aDtcbiAgICBjb25zdCBfbWF4WSA9IGJvdW5kcy5tYXhZIDwgYXJlYS55ICsgYXJlYS5oZWlnaHQgPyBib3VuZHMubWF4WSA6IGFyZWEueSArIGFyZWEuaGVpZ2h0O1xuICAgIGlmIChfbWluWCA8PSBfbWF4WCAmJiBfbWluWSA8PSBfbWF4WSkge1xuICAgICAgY29uc3QgbWluWCA9IHRoaXMubWluWDtcbiAgICAgIGNvbnN0IG1pblkgPSB0aGlzLm1pblk7XG4gICAgICBjb25zdCBtYXhYID0gdGhpcy5tYXhYO1xuICAgICAgY29uc3QgbWF4WSA9IHRoaXMubWF4WTtcbiAgICAgIHRoaXMubWluWCA9IF9taW5YIDwgbWluWCA/IF9taW5YIDogbWluWDtcbiAgICAgIHRoaXMubWluWSA9IF9taW5ZIDwgbWluWSA/IF9taW5ZIDogbWluWTtcbiAgICAgIHRoaXMubWF4WCA9IF9tYXhYID4gbWF4WCA/IF9tYXhYIDogbWF4WDtcbiAgICAgIHRoaXMubWF4WSA9IF9tYXhZID4gbWF4WSA/IF9tYXhZIDogbWF4WTtcbiAgICB9XG4gIH1cbiAgcGFkKHBhZGRpbmdYID0gMCwgcGFkZGluZ1kgPSBwYWRkaW5nWCkge1xuICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMubWluWCAtPSBwYWRkaW5nWDtcbiAgICAgIHRoaXMubWF4WCArPSBwYWRkaW5nWDtcbiAgICAgIHRoaXMubWluWSAtPSBwYWRkaW5nWTtcbiAgICAgIHRoaXMubWF4WSArPSBwYWRkaW5nWTtcbiAgICB9XG4gIH1cbiAgYWRkRnJhbWVQYWQoeDAsIHkwLCB4MSwgeTEsIHBhZFgsIHBhZFkpIHtcbiAgICB4MCAtPSBwYWRYO1xuICAgIHkwIC09IHBhZFk7XG4gICAgeDEgKz0gcGFkWDtcbiAgICB5MSArPSBwYWRZO1xuICAgIHRoaXMubWluWCA9IHRoaXMubWluWCA8IHgwID8gdGhpcy5taW5YIDogeDA7XG4gICAgdGhpcy5tYXhYID0gdGhpcy5tYXhYID4geDEgPyB0aGlzLm1heFggOiB4MTtcbiAgICB0aGlzLm1pblkgPSB0aGlzLm1pblkgPCB5MCA/IHRoaXMubWluWSA6IHkwO1xuICAgIHRoaXMubWF4WSA9IHRoaXMubWF4WSA+IHkxID8gdGhpcy5tYXhZIDogeTE7XG4gIH1cbn1cblxuZXhwb3J0cy5Cb3VuZHMgPSBCb3VuZHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Cb3VuZHMuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xudmFyIERpc3BsYXlPYmplY3QgPSByZXF1aXJlKCcuL0Rpc3BsYXlPYmplY3QuanMnKTtcblxuY29uc3QgdGVtcE1hdHJpeCA9IG5ldyBjb3JlLk1hdHJpeCgpO1xuZnVuY3Rpb24gc29ydENoaWxkcmVuKGEsIGIpIHtcbiAgaWYgKGEuekluZGV4ID09PSBiLnpJbmRleCkge1xuICAgIHJldHVybiBhLl9sYXN0U29ydGVkSW5kZXggLSBiLl9sYXN0U29ydGVkSW5kZXg7XG4gIH1cbiAgcmV0dXJuIGEuekluZGV4IC0gYi56SW5kZXg7XG59XG5jb25zdCBfQ29udGFpbmVyID0gY2xhc3MgZXh0ZW5kcyBEaXNwbGF5T2JqZWN0LkRpc3BsYXlPYmplY3Qge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLnNvcnRhYmxlQ2hpbGRyZW4gPSBfQ29udGFpbmVyLmRlZmF1bHRTb3J0YWJsZUNoaWxkcmVuO1xuICAgIHRoaXMuc29ydERpcnR5ID0gZmFsc2U7XG4gIH1cbiAgb25DaGlsZHJlbkNoYW5nZShfbGVuZ3RoKSB7XG4gIH1cbiAgYWRkQ2hpbGQoLi4uY2hpbGRyZW4pIHtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZENoaWxkKGNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlblswXTtcbiAgICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICB0aGlzLnNvcnREaXJ0eSA9IHRydWU7XG4gICAgICBjaGlsZC50cmFuc2Zvcm0uX3BhcmVudElEID0gLTE7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgdGhpcy5fYm91bmRzSUQrKztcbiAgICAgIHRoaXMub25DaGlsZHJlbkNoYW5nZSh0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgdGhpcy5lbWl0KFwiY2hpbGRBZGRlZFwiLCBjaGlsZCwgdGhpcywgdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgIGNoaWxkLmVtaXQoXCJhZGRlZFwiLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuWzBdO1xuICB9XG4gIGFkZENoaWxkQXQoY2hpbGQsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y2hpbGR9YWRkQ2hpbGRBdDogVGhlIGluZGV4ICR7aW5kZXh9IHN1cHBsaWVkIGlzIG91dCBvZiBib3VuZHMgJHt0aGlzLmNoaWxkcmVuLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICB0aGlzLnNvcnREaXJ0eSA9IHRydWU7XG4gICAgY2hpbGQudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xuICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBjaGlsZCk7XG4gICAgdGhpcy5fYm91bmRzSUQrKztcbiAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpO1xuICAgIGNoaWxkLmVtaXQoXCJhZGRlZFwiLCB0aGlzKTtcbiAgICB0aGlzLmVtaXQoXCJjaGlsZEFkZGVkXCIsIGNoaWxkLCB0aGlzLCBpbmRleCk7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG4gIHN3YXBDaGlsZHJlbihjaGlsZCwgY2hpbGQyKSB7XG4gICAgaWYgKGNoaWxkID09PSBjaGlsZDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5kZXgxID0gdGhpcy5nZXRDaGlsZEluZGV4KGNoaWxkKTtcbiAgICBjb25zdCBpbmRleDIgPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQyKTtcbiAgICB0aGlzLmNoaWxkcmVuW2luZGV4MV0gPSBjaGlsZDI7XG4gICAgdGhpcy5jaGlsZHJlbltpbmRleDJdID0gY2hpbGQ7XG4gICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4MSA8IGluZGV4MiA/IGluZGV4MSA6IGluZGV4Mik7XG4gIH1cbiAgZ2V0Q2hpbGRJbmRleChjaGlsZCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3VwcGxpZWQgRGlzcGxheU9iamVjdCBtdXN0IGJlIGEgY2hpbGQgb2YgdGhlIGNhbGxlclwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG4gIHNldENoaWxkSW5kZXgoY2hpbGQsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgaW5kZXggJHtpbmRleH0gc3VwcGxpZWQgaXMgb3V0IG9mIGJvdW5kcyAke3RoaXMuY2hpbGRyZW4ubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpO1xuICAgIGNvcmUudXRpbHMucmVtb3ZlSXRlbXModGhpcy5jaGlsZHJlbiwgY3VycmVudEluZGV4LCAxKTtcbiAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuICAgIHRoaXMub25DaGlsZHJlbkNoYW5nZShpbmRleCk7XG4gIH1cbiAgZ2V0Q2hpbGRBdChpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZ2V0Q2hpbGRBdDogSW5kZXggKCR7aW5kZXh9KSBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baW5kZXhdO1xuICB9XG4gIHJlbW92ZUNoaWxkKC4uLmNoaWxkcmVuKSB7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bMF07XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICBjaGlsZC50cmFuc2Zvcm0uX3BhcmVudElEID0gLTE7XG4gICAgICBjb3JlLnV0aWxzLnJlbW92ZUl0ZW1zKHRoaXMuY2hpbGRyZW4sIGluZGV4LCAxKTtcbiAgICAgIHRoaXMuX2JvdW5kc0lEKys7XG4gICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpO1xuICAgICAgY2hpbGQuZW1pdChcInJlbW92ZWRcIiwgdGhpcyk7XG4gICAgICB0aGlzLmVtaXQoXCJjaGlsZFJlbW92ZWRcIiwgY2hpbGQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuWzBdO1xuICB9XG4gIHJlbW92ZUNoaWxkQXQoaW5kZXgpIHtcbiAgICBjb25zdCBjaGlsZCA9IHRoaXMuZ2V0Q2hpbGRBdChpbmRleCk7XG4gICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICBjaGlsZC50cmFuc2Zvcm0uX3BhcmVudElEID0gLTE7XG4gICAgY29yZS51dGlscy5yZW1vdmVJdGVtcyh0aGlzLmNoaWxkcmVuLCBpbmRleCwgMSk7XG4gICAgdGhpcy5fYm91bmRzSUQrKztcbiAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpO1xuICAgIGNoaWxkLmVtaXQoXCJyZW1vdmVkXCIsIHRoaXMpO1xuICAgIHRoaXMuZW1pdChcImNoaWxkUmVtb3ZlZFwiLCBjaGlsZCwgdGhpcywgaW5kZXgpO1xuICAgIHJldHVybiBjaGlsZDtcbiAgfVxuICByZW1vdmVDaGlsZHJlbihiZWdpbkluZGV4ID0gMCwgZW5kSW5kZXggPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGNvbnN0IGJlZ2luID0gYmVnaW5JbmRleDtcbiAgICBjb25zdCBlbmQgPSBlbmRJbmRleDtcbiAgICBjb25zdCByYW5nZSA9IGVuZCAtIGJlZ2luO1xuICAgIGxldCByZW1vdmVkO1xuICAgIGlmIChyYW5nZSA+IDAgJiYgcmFuZ2UgPD0gZW5kKSB7XG4gICAgICByZW1vdmVkID0gdGhpcy5jaGlsZHJlbi5zcGxpY2UoYmVnaW4sIHJhbmdlKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICByZW1vdmVkW2ldLnBhcmVudCA9IG51bGw7XG4gICAgICAgIGlmIChyZW1vdmVkW2ldLnRyYW5zZm9ybSkge1xuICAgICAgICAgIHJlbW92ZWRbaV0udHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9ib3VuZHNJRCsrO1xuICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGJlZ2luSW5kZXgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlbW92ZWRbaV0uZW1pdChcInJlbW92ZWRcIiwgdGhpcyk7XG4gICAgICAgIHRoaXMuZW1pdChcImNoaWxkUmVtb3ZlZFwiLCByZW1vdmVkW2ldLCB0aGlzLCBpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0gZWxzZSBpZiAocmFuZ2UgPT09IDAgJiYgdGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJyZW1vdmVDaGlsZHJlbjogbnVtZXJpYyB2YWx1ZXMgYXJlIG91dHNpZGUgdGhlIGFjY2VwdGFibGUgcmFuZ2UuXCIpO1xuICB9XG4gIHNvcnRDaGlsZHJlbigpIHtcbiAgICBsZXQgc29ydFJlcXVpcmVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSkge1xuICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgY2hpbGQuX2xhc3RTb3J0ZWRJbmRleCA9IGk7XG4gICAgICBpZiAoIXNvcnRSZXF1aXJlZCAmJiBjaGlsZC56SW5kZXggIT09IDApIHtcbiAgICAgICAgc29ydFJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNvcnRSZXF1aXJlZCAmJiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4uc29ydChzb3J0Q2hpbGRyZW4pO1xuICAgIH1cbiAgICB0aGlzLnNvcnREaXJ0eSA9IGZhbHNlO1xuICB9XG4gIHVwZGF0ZVRyYW5zZm9ybSgpIHtcbiAgICBpZiAodGhpcy5zb3J0YWJsZUNoaWxkcmVuICYmIHRoaXMuc29ydERpcnR5KSB7XG4gICAgICB0aGlzLnNvcnRDaGlsZHJlbigpO1xuICAgIH1cbiAgICB0aGlzLl9ib3VuZHNJRCsrO1xuICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZVRyYW5zZm9ybSh0aGlzLnBhcmVudC50cmFuc2Zvcm0pO1xuICAgIHRoaXMud29ybGRBbHBoYSA9IHRoaXMuYWxwaGEgKiB0aGlzLnBhcmVudC53b3JsZEFscGhhO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaGlsZC52aXNpYmxlKSB7XG4gICAgICAgIGNoaWxkLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgdGhpcy5fYm91bmRzLmNsZWFyKCk7XG4gICAgdGhpcy5fY2FsY3VsYXRlQm91bmRzKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICBpZiAoIWNoaWxkLnZpc2libGUgfHwgIWNoaWxkLnJlbmRlcmFibGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjaGlsZC5jYWxjdWxhdGVCb3VuZHMoKTtcbiAgICAgIGlmIChjaGlsZC5fbWFzaykge1xuICAgICAgICBjb25zdCBtYXNrT2JqZWN0ID0gY2hpbGQuX21hc2suaXNNYXNrRGF0YSA/IGNoaWxkLl9tYXNrLm1hc2tPYmplY3QgOiBjaGlsZC5fbWFzaztcbiAgICAgICAgaWYgKG1hc2tPYmplY3QpIHtcbiAgICAgICAgICBtYXNrT2JqZWN0LmNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICAgIHRoaXMuX2JvdW5kcy5hZGRCb3VuZHNNYXNrKGNoaWxkLl9ib3VuZHMsIG1hc2tPYmplY3QuX2JvdW5kcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fYm91bmRzLmFkZEJvdW5kcyhjaGlsZC5fYm91bmRzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGlsZC5maWx0ZXJBcmVhKSB7XG4gICAgICAgIHRoaXMuX2JvdW5kcy5hZGRCb3VuZHNBcmVhKGNoaWxkLl9ib3VuZHMsIGNoaWxkLmZpbHRlckFyZWEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYm91bmRzLmFkZEJvdW5kcyhjaGlsZC5fYm91bmRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fYm91bmRzLnVwZGF0ZUlEID0gdGhpcy5fYm91bmRzSUQ7XG4gIH1cbiAgZ2V0TG9jYWxCb3VuZHMocmVjdCwgc2tpcENoaWxkcmVuVXBkYXRlID0gZmFsc2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBzdXBlci5nZXRMb2NhbEJvdW5kcyhyZWN0KTtcbiAgICBpZiAoIXNraXBDaGlsZHJlblVwZGF0ZSkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChjaGlsZC52aXNpYmxlKSB7XG4gICAgICAgICAgY2hpbGQudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfY2FsY3VsYXRlQm91bmRzKCkge1xuICB9XG4gIF9yZW5kZXJXaXRoQ3VsbGluZyhyZW5kZXJlcikge1xuICAgIGNvbnN0IHNvdXJjZUZyYW1lID0gcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5zb3VyY2VGcmFtZTtcbiAgICBpZiAoIShzb3VyY2VGcmFtZS53aWR0aCA+IDAgJiYgc291cmNlRnJhbWUuaGVpZ2h0ID4gMCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGJvdW5kcztcbiAgICBsZXQgdHJhbnNmb3JtO1xuICAgIGlmICh0aGlzLmN1bGxBcmVhKSB7XG4gICAgICBib3VuZHMgPSB0aGlzLmN1bGxBcmVhO1xuICAgICAgdHJhbnNmb3JtID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3JlbmRlciAhPT0gX0NvbnRhaW5lci5wcm90b3R5cGUuX3JlbmRlcikge1xuICAgICAgYm91bmRzID0gdGhpcy5nZXRCb3VuZHModHJ1ZSk7XG4gICAgfVxuICAgIGNvbnN0IHByb2plY3Rpb25UcmFuc2Zvcm0gPSByZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybTtcbiAgICBpZiAocHJvamVjdGlvblRyYW5zZm9ybSkge1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB0cmFuc2Zvcm0gPSB0ZW1wTWF0cml4LmNvcHlGcm9tKHRyYW5zZm9ybSk7XG4gICAgICAgIHRyYW5zZm9ybS5wcmVwZW5kKHByb2plY3Rpb25UcmFuc2Zvcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNmb3JtID0gcHJvamVjdGlvblRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJvdW5kcyAmJiBzb3VyY2VGcmFtZS5pbnRlcnNlY3RzKGJvdW5kcywgdHJhbnNmb3JtKSkge1xuICAgICAgdGhpcy5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VsbEFyZWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSkge1xuICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgY2hpbGRDdWxsYWJsZSA9IGNoaWxkLmN1bGxhYmxlO1xuICAgICAgY2hpbGQuY3VsbGFibGUgPSBjaGlsZEN1bGxhYmxlIHx8ICF0aGlzLmN1bGxBcmVhO1xuICAgICAgY2hpbGQucmVuZGVyKHJlbmRlcmVyKTtcbiAgICAgIGNoaWxkLmN1bGxhYmxlID0gY2hpbGRDdWxsYWJsZTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy53b3JsZEFscGhhIDw9IDAgfHwgIXRoaXMucmVuZGVyYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbWFzayB8fCB0aGlzLmZpbHRlcnM/Lmxlbmd0aCkge1xuICAgICAgdGhpcy5yZW5kZXJBZHZhbmNlZChyZW5kZXJlcik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1bGxhYmxlKSB7XG4gICAgICB0aGlzLl9yZW5kZXJXaXRoQ3VsbGluZyhyZW5kZXJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbmRlcihyZW5kZXJlcik7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0ucmVuZGVyKHJlbmRlcmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVuZGVyQWR2YW5jZWQocmVuZGVyZXIpIHtcbiAgICBjb25zdCBmaWx0ZXJzID0gdGhpcy5maWx0ZXJzO1xuICAgIGNvbnN0IG1hc2sgPSB0aGlzLl9tYXNrO1xuICAgIGlmIChmaWx0ZXJzKSB7XG4gICAgICBpZiAoIXRoaXMuX2VuYWJsZWRGaWx0ZXJzKSB7XG4gICAgICAgIHRoaXMuX2VuYWJsZWRGaWx0ZXJzID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLl9lbmFibGVkRmlsdGVycy5sZW5ndGggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmaWx0ZXJzW2ldLmVuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLl9lbmFibGVkRmlsdGVycy5wdXNoKGZpbHRlcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZsdXNoID0gZmlsdGVycyAmJiB0aGlzLl9lbmFibGVkRmlsdGVycz8ubGVuZ3RoIHx8IG1hc2sgJiYgKCFtYXNrLmlzTWFza0RhdGEgfHwgbWFzay5lbmFibGVkICYmIChtYXNrLmF1dG9EZXRlY3QgfHwgbWFzay50eXBlICE9PSBjb3JlLk1BU0tfVFlQRVMuTk9ORSkpO1xuICAgIGlmIChmbHVzaCkge1xuICAgICAgcmVuZGVyZXIuYmF0Y2guZmx1c2goKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlcnMgJiYgdGhpcy5fZW5hYmxlZEZpbHRlcnM/Lmxlbmd0aCkge1xuICAgICAgcmVuZGVyZXIuZmlsdGVyLnB1c2godGhpcywgdGhpcy5fZW5hYmxlZEZpbHRlcnMpO1xuICAgIH1cbiAgICBpZiAobWFzaykge1xuICAgICAgcmVuZGVyZXIubWFzay5wdXNoKHRoaXMsIHRoaXMuX21hc2spO1xuICAgIH1cbiAgICBpZiAodGhpcy5jdWxsYWJsZSkge1xuICAgICAgdGhpcy5fcmVuZGVyV2l0aEN1bGxpbmcocmVuZGVyZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnJlbmRlcihyZW5kZXJlcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmbHVzaCkge1xuICAgICAgcmVuZGVyZXIuYmF0Y2guZmx1c2goKTtcbiAgICB9XG4gICAgaWYgKG1hc2spIHtcbiAgICAgIHJlbmRlcmVyLm1hc2sucG9wKHRoaXMpO1xuICAgIH1cbiAgICBpZiAoZmlsdGVycyAmJiB0aGlzLl9lbmFibGVkRmlsdGVycz8ubGVuZ3RoKSB7XG4gICAgICByZW5kZXJlci5maWx0ZXIucG9wKCk7XG4gICAgfVxuICB9XG4gIF9yZW5kZXIoX3JlbmRlcmVyKSB7XG4gIH1cbiAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuc29ydERpcnR5ID0gZmFsc2U7XG4gICAgY29uc3QgZGVzdHJveUNoaWxkcmVuID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucyA6IG9wdGlvbnM/LmNoaWxkcmVuO1xuICAgIGNvbnN0IG9sZENoaWxkcmVuID0gdGhpcy5yZW1vdmVDaGlsZHJlbigwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgaWYgKGRlc3Ryb3lDaGlsZHJlbikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbGRDaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBvbGRDaGlsZHJlbltpXS5kZXN0cm95KG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGUueCAqIHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS53aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS53aWR0aDtcbiAgICBpZiAod2lkdGggIT09IDApIHtcbiAgICAgIHRoaXMuc2NhbGUueCA9IHZhbHVlIC8gd2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2NhbGUueCA9IDE7XG4gICAgfVxuICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gIH1cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZS55ICogdGhpcy5nZXRMb2NhbEJvdW5kcygpLmhlaWdodDtcbiAgfVxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpLmhlaWdodDtcbiAgICBpZiAoaGVpZ2h0ICE9PSAwKSB7XG4gICAgICB0aGlzLnNjYWxlLnkgPSB2YWx1ZSAvIGhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zY2FsZS55ID0gMTtcbiAgICB9XG4gICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gIH1cbn07XG5sZXQgQ29udGFpbmVyID0gX0NvbnRhaW5lcjtcbkNvbnRhaW5lci5kZWZhdWx0U29ydGFibGVDaGlsZHJlbiA9IGZhbHNlO1xuQ29udGFpbmVyLnByb3RvdHlwZS5jb250YWluZXJVcGRhdGVUcmFuc2Zvcm0gPSBDb250YWluZXIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybTtcblxuZXhwb3J0cy5Db250YWluZXIgPSBDb250YWluZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250YWluZXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xudmFyIEJvdW5kcyA9IHJlcXVpcmUoJy4vQm91bmRzLmpzJyk7XG5cbmNsYXNzIERpc3BsYXlPYmplY3QgZXh0ZW5kcyBjb3JlLnV0aWxzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50ZW1wRGlzcGxheU9iamVjdFBhcmVudCA9IG51bGw7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBuZXcgY29yZS5UcmFuc2Zvcm0oKTtcbiAgICB0aGlzLmFscGhhID0gMTtcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMucmVuZGVyYWJsZSA9IHRydWU7XG4gICAgdGhpcy5jdWxsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuY3VsbEFyZWEgPSBudWxsO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLndvcmxkQWxwaGEgPSAxO1xuICAgIHRoaXMuX2xhc3RTb3J0ZWRJbmRleCA9IDA7XG4gICAgdGhpcy5fekluZGV4ID0gMDtcbiAgICB0aGlzLmZpbHRlckFyZWEgPSBudWxsO1xuICAgIHRoaXMuZmlsdGVycyA9IG51bGw7XG4gICAgdGhpcy5fZW5hYmxlZEZpbHRlcnMgPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHMuQm91bmRzKCk7XG4gICAgdGhpcy5fbG9jYWxCb3VuZHMgPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kc0lEID0gMDtcbiAgICB0aGlzLl9ib3VuZHNSZWN0ID0gbnVsbDtcbiAgICB0aGlzLl9sb2NhbEJvdW5kc1JlY3QgPSBudWxsO1xuICAgIHRoaXMuX21hc2sgPSBudWxsO1xuICAgIHRoaXMuX21hc2tSZWZDb3VudCA9IDA7XG4gICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5pc1Nwcml0ZSA9IGZhbHNlO1xuICAgIHRoaXMuaXNNYXNrID0gZmFsc2U7XG4gIH1cbiAgc3RhdGljIG1peGluKHNvdXJjZSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgcHJvcGVydHlOYW1lID0ga2V5c1tpXTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaXNwbGF5T2JqZWN0LnByb3RvdHlwZSwgcHJvcGVydHlOYW1lLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgcHJvcGVydHlOYW1lKSk7XG4gICAgfVxuICB9XG4gIGdldCBkZXN0cm95ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rlc3Ryb3llZDtcbiAgfVxuICBfcmVjdXJzaXZlUG9zdFVwZGF0ZVRyYW5zZm9ybSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50Ll9yZWN1cnNpdmVQb3N0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICB0aGlzLnRyYW5zZm9ybS51cGRhdGVUcmFuc2Zvcm0odGhpcy5wYXJlbnQudHJhbnNmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlVHJhbnNmb3JtKHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50LnRyYW5zZm9ybSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVRyYW5zZm9ybSgpIHtcbiAgICB0aGlzLl9ib3VuZHNJRCsrO1xuICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZVRyYW5zZm9ybSh0aGlzLnBhcmVudC50cmFuc2Zvcm0pO1xuICAgIHRoaXMud29ybGRBbHBoYSA9IHRoaXMuYWxwaGEgKiB0aGlzLnBhcmVudC53b3JsZEFscGhhO1xuICB9XG4gIGdldEJvdW5kcyhza2lwVXBkYXRlLCByZWN0KSB7XG4gICAgaWYgKCFza2lwVXBkYXRlKSB7XG4gICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX2JvdW5kcy51cGRhdGVJRCAhPT0gdGhpcy5fYm91bmRzSUQpIHtcbiAgICAgIHRoaXMuY2FsY3VsYXRlQm91bmRzKCk7XG4gICAgICB0aGlzLl9ib3VuZHMudXBkYXRlSUQgPSB0aGlzLl9ib3VuZHNJRDtcbiAgICB9XG4gICAgaWYgKCFyZWN0KSB7XG4gICAgICBpZiAoIXRoaXMuX2JvdW5kc1JlY3QpIHtcbiAgICAgICAgdGhpcy5fYm91bmRzUmVjdCA9IG5ldyBjb3JlLlJlY3RhbmdsZSgpO1xuICAgICAgfVxuICAgICAgcmVjdCA9IHRoaXMuX2JvdW5kc1JlY3Q7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ib3VuZHMuZ2V0UmVjdGFuZ2xlKHJlY3QpO1xuICB9XG4gIGdldExvY2FsQm91bmRzKHJlY3QpIHtcbiAgICBpZiAoIXJlY3QpIHtcbiAgICAgIGlmICghdGhpcy5fbG9jYWxCb3VuZHNSZWN0KSB7XG4gICAgICAgIHRoaXMuX2xvY2FsQm91bmRzUmVjdCA9IG5ldyBjb3JlLlJlY3RhbmdsZSgpO1xuICAgICAgfVxuICAgICAgcmVjdCA9IHRoaXMuX2xvY2FsQm91bmRzUmVjdDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9sb2NhbEJvdW5kcykge1xuICAgICAgdGhpcy5fbG9jYWxCb3VuZHMgPSBuZXcgQm91bmRzLkJvdW5kcygpO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2Zvcm1SZWYgPSB0aGlzLnRyYW5zZm9ybTtcbiAgICBjb25zdCBwYXJlbnRSZWYgPSB0aGlzLnBhcmVudDtcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudC50cmFuc2Zvcm07XG4gICAgY29uc3Qgd29ybGRCb3VuZHMgPSB0aGlzLl9ib3VuZHM7XG4gICAgY29uc3Qgd29ybGRCb3VuZHNJRCA9IHRoaXMuX2JvdW5kc0lEO1xuICAgIHRoaXMuX2JvdW5kcyA9IHRoaXMuX2xvY2FsQm91bmRzO1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKGZhbHNlLCByZWN0KTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudFJlZjtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVJlZjtcbiAgICB0aGlzLl9ib3VuZHMgPSB3b3JsZEJvdW5kcztcbiAgICB0aGlzLl9ib3VuZHMudXBkYXRlSUQgKz0gdGhpcy5fYm91bmRzSUQgLSB3b3JsZEJvdW5kc0lEO1xuICAgIHJldHVybiBib3VuZHM7XG4gIH1cbiAgdG9HbG9iYWwocG9zaXRpb24sIHBvaW50LCBza2lwVXBkYXRlID0gZmFsc2UpIHtcbiAgICBpZiAoIXNraXBVcGRhdGUpIHtcbiAgICAgIHRoaXMuX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcbiAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseShwb3NpdGlvbiwgcG9pbnQpO1xuICB9XG4gIHRvTG9jYWwocG9zaXRpb24sIGZyb20sIHBvaW50LCBza2lwVXBkYXRlKSB7XG4gICAgaWYgKGZyb20pIHtcbiAgICAgIHBvc2l0aW9uID0gZnJvbS50b0dsb2JhbChwb3NpdGlvbiwgcG9pbnQsIHNraXBVcGRhdGUpO1xuICAgIH1cbiAgICBpZiAoIXNraXBVcGRhdGUpIHtcbiAgICAgIHRoaXMuX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcbiAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UocG9zaXRpb24sIHBvaW50KTtcbiAgfVxuICBzZXRQYXJlbnQoY29udGFpbmVyKSB7XG4gICAgaWYgKCFjb250YWluZXIgfHwgIWNvbnRhaW5lci5hZGRDaGlsZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2V0UGFyZW50OiBBcmd1bWVudCBtdXN0IGJlIGEgQ29udGFpbmVyXCIpO1xuICAgIH1cbiAgICBjb250YWluZXIuYWRkQ2hpbGQodGhpcyk7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICByZW1vdmVGcm9tUGFyZW50KCkge1xuICAgIHRoaXMucGFyZW50Py5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgfVxuICBzZXRUcmFuc2Zvcm0oeCA9IDAsIHkgPSAwLCBzY2FsZVggPSAxLCBzY2FsZVkgPSAxLCByb3RhdGlvbiA9IDAsIHNrZXdYID0gMCwgc2tld1kgPSAwLCBwaXZvdFggPSAwLCBwaXZvdFkgPSAwKSB7XG4gICAgdGhpcy5wb3NpdGlvbi54ID0geDtcbiAgICB0aGlzLnBvc2l0aW9uLnkgPSB5O1xuICAgIHRoaXMuc2NhbGUueCA9ICFzY2FsZVggPyAxIDogc2NhbGVYO1xuICAgIHRoaXMuc2NhbGUueSA9ICFzY2FsZVkgPyAxIDogc2NhbGVZO1xuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLnNrZXcueCA9IHNrZXdYO1xuICAgIHRoaXMuc2tldy55ID0gc2tld1k7XG4gICAgdGhpcy5waXZvdC54ID0gcGl2b3RYO1xuICAgIHRoaXMucGl2b3QueSA9IHBpdm90WTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkZXN0cm95KF9vcHRpb25zKSB7XG4gICAgdGhpcy5yZW1vdmVGcm9tUGFyZW50KCk7XG4gICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG51bGw7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kcyA9IG51bGw7XG4gICAgdGhpcy5tYXNrID0gbnVsbDtcbiAgICB0aGlzLmN1bGxBcmVhID0gbnVsbDtcbiAgICB0aGlzLmZpbHRlcnMgPSBudWxsO1xuICAgIHRoaXMuZmlsdGVyQXJlYSA9IG51bGw7XG4gICAgdGhpcy5oaXRBcmVhID0gbnVsbDtcbiAgICB0aGlzLmV2ZW50TW9kZSA9IFwiYXV0b1wiO1xuICAgIHRoaXMuaW50ZXJhY3RpdmVDaGlsZHJlbiA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdChcImRlc3Ryb3llZFwiKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG4gIGdldCBfdGVtcERpc3BsYXlPYmplY3RQYXJlbnQoKSB7XG4gICAgaWYgKHRoaXMudGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHRoaXMudGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPSBuZXcgVGVtcG9yYXJ5RGlzcGxheU9iamVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcbiAgfVxuICBlbmFibGVUZW1wUGFyZW50KCkge1xuICAgIGNvbnN0IG15UGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgdGhpcy5wYXJlbnQgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcbiAgICByZXR1cm4gbXlQYXJlbnQ7XG4gIH1cbiAgZGlzYWJsZVRlbXBQYXJlbnQoY2FjaGVQYXJlbnQpIHtcbiAgICB0aGlzLnBhcmVudCA9IGNhY2hlUGFyZW50O1xuICB9XG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLng7XG4gIH1cbiAgc2V0IHgodmFsdWUpIHtcbiAgICB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbi54ID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueTtcbiAgfVxuICBzZXQgeSh2YWx1ZSkge1xuICAgIHRoaXMudHJhbnNmb3JtLnBvc2l0aW9uLnkgPSB2YWx1ZTtcbiAgfVxuICBnZXQgd29ybGRUcmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICB9XG4gIGdldCBsb2NhbFRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubG9jYWxUcmFuc2Zvcm07XG4gIH1cbiAgZ2V0IHBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgfVxuICBzZXQgcG9zaXRpb24odmFsdWUpIHtcbiAgICB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5RnJvbSh2YWx1ZSk7XG4gIH1cbiAgZ2V0IHNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5zY2FsZTtcbiAgfVxuICBzZXQgc2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnRyYW5zZm9ybS5zY2FsZS5jb3B5RnJvbSh2YWx1ZSk7XG4gIH1cbiAgZ2V0IHBpdm90KCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5waXZvdDtcbiAgfVxuICBzZXQgcGl2b3QodmFsdWUpIHtcbiAgICB0aGlzLnRyYW5zZm9ybS5waXZvdC5jb3B5RnJvbSh2YWx1ZSk7XG4gIH1cbiAgZ2V0IHNrZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnNrZXc7XG4gIH1cbiAgc2V0IHNrZXcodmFsdWUpIHtcbiAgICB0aGlzLnRyYW5zZm9ybS5za2V3LmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICBnZXQgcm90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uO1xuICB9XG4gIHNldCByb3RhdGlvbih2YWx1ZSkge1xuICAgIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uID0gdmFsdWU7XG4gIH1cbiAgZ2V0IGFuZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbiAqIGNvcmUuUkFEX1RPX0RFRztcbiAgfVxuICBzZXQgYW5nbGUodmFsdWUpIHtcbiAgICB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbiA9IHZhbHVlICogY29yZS5ERUdfVE9fUkFEO1xuICB9XG4gIGdldCB6SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3pJbmRleDtcbiAgfVxuICBzZXQgekluZGV4KHZhbHVlKSB7XG4gICAgdGhpcy5fekluZGV4ID0gdmFsdWU7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5zb3J0RGlydHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBnZXQgd29ybGRWaXNpYmxlKCkge1xuICAgIGxldCBpdGVtID0gdGhpcztcbiAgICBkbyB7XG4gICAgICBpZiAoIWl0ZW0udmlzaWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpdGVtID0gaXRlbS5wYXJlbnQ7XG4gICAgfSB3aGlsZSAoaXRlbSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0IG1hc2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hc2s7XG4gIH1cbiAgc2V0IG1hc2sodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fbWFzayA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX21hc2spIHtcbiAgICAgIGNvbnN0IG1hc2tPYmplY3QgPSB0aGlzLl9tYXNrLmlzTWFza0RhdGEgPyB0aGlzLl9tYXNrLm1hc2tPYmplY3QgOiB0aGlzLl9tYXNrO1xuICAgICAgaWYgKG1hc2tPYmplY3QpIHtcbiAgICAgICAgbWFza09iamVjdC5fbWFza1JlZkNvdW50LS07XG4gICAgICAgIGlmIChtYXNrT2JqZWN0Ll9tYXNrUmVmQ291bnQgPT09IDApIHtcbiAgICAgICAgICBtYXNrT2JqZWN0LnJlbmRlcmFibGUgPSB0cnVlO1xuICAgICAgICAgIG1hc2tPYmplY3QuaXNNYXNrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbWFzayA9IHZhbHVlO1xuICAgIGlmICh0aGlzLl9tYXNrKSB7XG4gICAgICBjb25zdCBtYXNrT2JqZWN0ID0gdGhpcy5fbWFzay5pc01hc2tEYXRhID8gdGhpcy5fbWFzay5tYXNrT2JqZWN0IDogdGhpcy5fbWFzaztcbiAgICAgIGlmIChtYXNrT2JqZWN0KSB7XG4gICAgICAgIGlmIChtYXNrT2JqZWN0Ll9tYXNrUmVmQ291bnQgPT09IDApIHtcbiAgICAgICAgICBtYXNrT2JqZWN0LnJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICBtYXNrT2JqZWN0LmlzTWFzayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbWFza09iamVjdC5fbWFza1JlZkNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jbGFzcyBUZW1wb3JhcnlEaXNwbGF5T2JqZWN0IGV4dGVuZHMgRGlzcGxheU9iamVjdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zb3J0RGlydHkgPSBudWxsO1xuICB9XG59XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtID0gRGlzcGxheU9iamVjdC5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtO1xuXG5leHBvcnRzLkRpc3BsYXlPYmplY3QgPSBEaXNwbGF5T2JqZWN0O1xuZXhwb3J0cy5UZW1wb3JhcnlEaXNwbGF5T2JqZWN0ID0gVGVtcG9yYXJ5RGlzcGxheU9iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpc3BsYXlPYmplY3QuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnJlcXVpcmUoJy4vc2V0dGluZ3MuanMnKTtcbnZhciBCb3VuZHMgPSByZXF1aXJlKCcuL0JvdW5kcy5qcycpO1xudmFyIENvbnRhaW5lciA9IHJlcXVpcmUoJy4vQ29udGFpbmVyLmpzJyk7XG52YXIgRGlzcGxheU9iamVjdCA9IHJlcXVpcmUoJy4vRGlzcGxheU9iamVjdC5qcycpO1xuXG5cblxuZXhwb3J0cy5Cb3VuZHMgPSBCb3VuZHMuQm91bmRzO1xuZXhwb3J0cy5Db250YWluZXIgPSBDb250YWluZXIuQ29udGFpbmVyO1xuZXhwb3J0cy5EaXNwbGF5T2JqZWN0ID0gRGlzcGxheU9iamVjdC5EaXNwbGF5T2JqZWN0O1xuZXhwb3J0cy5UZW1wb3JhcnlEaXNwbGF5T2JqZWN0ID0gRGlzcGxheU9iamVjdC5UZW1wb3JhcnlEaXNwbGF5T2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xudmFyIENvbnRhaW5lciA9IHJlcXVpcmUoJy4vQ29udGFpbmVyLmpzJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvcmUuc2V0dGluZ3MsIHtcbiAgU09SVEFCTEVfQ0hJTERSRU46IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gQ29udGFpbmVyLkNvbnRhaW5lci5kZWZhdWx0U29ydGFibGVDaGlsZHJlbjtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgY29yZS51dGlscy5kZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuU09SVEFCTEVfQ0hJTERSRU4gaXMgZGVwcmVjYXRlZCwgdXNlIENvbnRhaW5lci5kZWZhdWx0U29ydGFibGVDaGlsZHJlblwiKTtcbiAgICAgIENvbnRhaW5lci5Db250YWluZXIuZGVmYXVsdFNvcnRhYmxlQ2hpbGRyZW4gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3NldHRpbmdzJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3JlLnNldHRpbmdzOyB9XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNldHRpbmdzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBFdmVudFRpY2tlciA9IHJlcXVpcmUoJy4vRXZlbnRUaWNrZXIuanMnKTtcbnZhciBGZWRlcmF0ZWRNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9GZWRlcmF0ZWRNb3VzZUV2ZW50LmpzJyk7XG52YXIgRmVkZXJhdGVkUG9pbnRlckV2ZW50ID0gcmVxdWlyZSgnLi9GZWRlcmF0ZWRQb2ludGVyRXZlbnQuanMnKTtcbnZhciBGZWRlcmF0ZWRXaGVlbEV2ZW50ID0gcmVxdWlyZSgnLi9GZWRlcmF0ZWRXaGVlbEV2ZW50LmpzJyk7XG5cbmNvbnN0IFBST1BBR0FUSU9OX0xJTUlUID0gMjA0ODtcbmNvbnN0IHRlbXBIaXRMb2NhdGlvbiA9IG5ldyBjb3JlLlBvaW50KCk7XG5jb25zdCB0ZW1wTG9jYWxNYXBwaW5nID0gbmV3IGNvcmUuUG9pbnQoKTtcbmNsYXNzIEV2ZW50Qm91bmRhcnkge1xuICBjb25zdHJ1Y3Rvcihyb290VGFyZ2V0KSB7XG4gICAgdGhpcy5kaXNwYXRjaCA9IG5ldyBjb3JlLnV0aWxzLkV2ZW50RW1pdHRlcigpO1xuICAgIHRoaXMubW92ZU9uQWxsID0gZmFsc2U7XG4gICAgdGhpcy5lbmFibGVHbG9iYWxNb3ZlRXZlbnRzID0gdHJ1ZTtcbiAgICB0aGlzLm1hcHBpbmdTdGF0ZSA9IHtcbiAgICAgIHRyYWNraW5nRGF0YToge31cbiAgICB9O1xuICAgIHRoaXMuZXZlbnRQb29sID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9hbGxJbnRlcmFjdGl2ZUVsZW1lbnRzID0gW107XG4gICAgdGhpcy5faGl0RWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLl9pc1BvaW50ZXJNb3ZlRXZlbnQgPSBmYWxzZTtcbiAgICB0aGlzLnJvb3RUYXJnZXQgPSByb290VGFyZ2V0O1xuICAgIHRoaXMuaGl0UHJ1bmVGbiA9IHRoaXMuaGl0UHJ1bmVGbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGl0VGVzdEZuID0gdGhpcy5oaXRUZXN0Rm4uYmluZCh0aGlzKTtcbiAgICB0aGlzLm1hcFBvaW50ZXJEb3duID0gdGhpcy5tYXBQb2ludGVyRG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMubWFwUG9pbnRlck1vdmUgPSB0aGlzLm1hcFBvaW50ZXJNb3ZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5tYXBQb2ludGVyT3V0ID0gdGhpcy5tYXBQb2ludGVyT3V0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5tYXBQb2ludGVyT3ZlciA9IHRoaXMubWFwUG9pbnRlck92ZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLm1hcFBvaW50ZXJVcCA9IHRoaXMubWFwUG9pbnRlclVwLmJpbmQodGhpcyk7XG4gICAgdGhpcy5tYXBQb2ludGVyVXBPdXRzaWRlID0gdGhpcy5tYXBQb2ludGVyVXBPdXRzaWRlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5tYXBXaGVlbCA9IHRoaXMubWFwV2hlZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLm1hcHBpbmdUYWJsZSA9IHt9O1xuICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKFwicG9pbnRlcmRvd25cIiwgdGhpcy5tYXBQb2ludGVyRG93bik7XG4gICAgdGhpcy5hZGRFdmVudE1hcHBpbmcoXCJwb2ludGVybW92ZVwiLCB0aGlzLm1hcFBvaW50ZXJNb3ZlKTtcbiAgICB0aGlzLmFkZEV2ZW50TWFwcGluZyhcInBvaW50ZXJvdXRcIiwgdGhpcy5tYXBQb2ludGVyT3V0KTtcbiAgICB0aGlzLmFkZEV2ZW50TWFwcGluZyhcInBvaW50ZXJsZWF2ZVwiLCB0aGlzLm1hcFBvaW50ZXJPdXQpO1xuICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKFwicG9pbnRlcm92ZXJcIiwgdGhpcy5tYXBQb2ludGVyT3Zlcik7XG4gICAgdGhpcy5hZGRFdmVudE1hcHBpbmcoXCJwb2ludGVydXBcIiwgdGhpcy5tYXBQb2ludGVyVXApO1xuICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKFwicG9pbnRlcnVwb3V0c2lkZVwiLCB0aGlzLm1hcFBvaW50ZXJVcE91dHNpZGUpO1xuICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKFwid2hlZWxcIiwgdGhpcy5tYXBXaGVlbCk7XG4gIH1cbiAgYWRkRXZlbnRNYXBwaW5nKHR5cGUsIGZuKSB7XG4gICAgaWYgKCF0aGlzLm1hcHBpbmdUYWJsZVt0eXBlXSkge1xuICAgICAgdGhpcy5tYXBwaW5nVGFibGVbdHlwZV0gPSBbXTtcbiAgICB9XG4gICAgdGhpcy5tYXBwaW5nVGFibGVbdHlwZV0ucHVzaCh7XG4gICAgICBmbixcbiAgICAgIHByaW9yaXR5OiAwXG4gICAgfSk7XG4gICAgdGhpcy5tYXBwaW5nVGFibGVbdHlwZV0uc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuICB9XG4gIGRpc3BhdGNoRXZlbnQoZSwgdHlwZSkge1xuICAgIGUucHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG4gICAgZS5wcm9wYWdhdGlvbkltbWVkaWF0ZWx5U3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMucHJvcGFnYXRlKGUsIHR5cGUpO1xuICAgIHRoaXMuZGlzcGF0Y2guZW1pdCh0eXBlIHx8IGUudHlwZSwgZSk7XG4gIH1cbiAgbWFwRXZlbnQoZSkge1xuICAgIGlmICghdGhpcy5yb290VGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1hcHBlcnMgPSB0aGlzLm1hcHBpbmdUYWJsZVtlLnR5cGVdO1xuICAgIGlmIChtYXBwZXJzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaiA9IG1hcHBlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIG1hcHBlcnNbaV0uZm4oZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihgW0V2ZW50Qm91bmRhcnldOiBFdmVudCBtYXBwaW5nIG5vdCBkZWZpbmVkIGZvciAke2UudHlwZX1gKTtcbiAgICB9XG4gIH1cbiAgaGl0VGVzdCh4LCB5KSB7XG4gICAgRXZlbnRUaWNrZXIuRXZlbnRzVGlja2VyLnBhdXNlVXBkYXRlID0gdHJ1ZTtcbiAgICBjb25zdCB1c2VNb3ZlID0gdGhpcy5faXNQb2ludGVyTW92ZUV2ZW50ICYmIHRoaXMuZW5hYmxlR2xvYmFsTW92ZUV2ZW50cztcbiAgICBjb25zdCBmbiA9IHVzZU1vdmUgPyBcImhpdFRlc3RNb3ZlUmVjdXJzaXZlXCIgOiBcImhpdFRlc3RSZWN1cnNpdmVcIjtcbiAgICBjb25zdCBpbnZlcnRlZFBhdGggPSB0aGlzW2ZuXSh0aGlzLnJvb3RUYXJnZXQsIHRoaXMucm9vdFRhcmdldC5ldmVudE1vZGUsIHRlbXBIaXRMb2NhdGlvbi5zZXQoeCwgeSksIHRoaXMuaGl0VGVzdEZuLCB0aGlzLmhpdFBydW5lRm4pO1xuICAgIHJldHVybiBpbnZlcnRlZFBhdGggJiYgaW52ZXJ0ZWRQYXRoWzBdO1xuICB9XG4gIHByb3BhZ2F0ZShlLCB0eXBlKSB7XG4gICAgaWYgKCFlLnRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb21wb3NlZFBhdGggPSBlLmNvbXBvc2VkUGF0aCgpO1xuICAgIGUuZXZlbnRQaGFzZSA9IGUuQ0FQVFVSSU5HX1BIQVNFO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gY29tcG9zZWRQYXRoLmxlbmd0aCAtIDE7IGkgPCBqOyBpKyspIHtcbiAgICAgIGUuY3VycmVudFRhcmdldCA9IGNvbXBvc2VkUGF0aFtpXTtcbiAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGUsIHR5cGUpO1xuICAgICAgaWYgKGUucHJvcGFnYXRpb25TdG9wcGVkIHx8IGUucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5ldmVudFBoYXNlID0gZS5BVF9UQVJHRVQ7XG4gICAgZS5jdXJyZW50VGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgdHlwZSk7XG4gICAgaWYgKGUucHJvcGFnYXRpb25TdG9wcGVkIHx8IGUucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQpXG4gICAgICByZXR1cm47XG4gICAgZS5ldmVudFBoYXNlID0gZS5CVUJCTElOR19QSEFTRTtcbiAgICBmb3IgKGxldCBpID0gY29tcG9zZWRQYXRoLmxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBlLmN1cnJlbnRUYXJnZXQgPSBjb21wb3NlZFBhdGhbaV07XG4gICAgICB0aGlzLm5vdGlmeVRhcmdldChlLCB0eXBlKTtcbiAgICAgIGlmIChlLnByb3BhZ2F0aW9uU3RvcHBlZCB8fCBlLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGFsbChlLCB0eXBlLCB0YXJnZXRzID0gdGhpcy5fYWxsSW50ZXJhY3RpdmVFbGVtZW50cykge1xuICAgIGlmICh0YXJnZXRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBlLmV2ZW50UGhhc2UgPSBlLkJVQkJMSU5HX1BIQVNFO1xuICAgIGNvbnN0IGV2ZW50cyA9IEFycmF5LmlzQXJyYXkodHlwZSkgPyB0eXBlIDogW3R5cGVdO1xuICAgIGZvciAobGV0IGkgPSB0YXJnZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgICAgZS5jdXJyZW50VGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHByb3BhZ2F0aW9uUGF0aCh0YXJnZXQpIHtcbiAgICBjb25zdCBwcm9wYWdhdGlvblBhdGggPSBbdGFyZ2V0XTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFBST1BBR0FUSU9OX0xJTUlUICYmIHRhcmdldCAhPT0gdGhpcy5yb290VGFyZ2V0OyBpKyspIHtcbiAgICAgIGlmICghdGFyZ2V0LnBhcmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBwcm9wYWdhdGlvbiBwYXRoIHRvIGRpc2Nvbm5lY3RlZCB0YXJnZXRcIik7XG4gICAgICB9XG4gICAgICBwcm9wYWdhdGlvblBhdGgucHVzaCh0YXJnZXQucGFyZW50KTtcbiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnQ7XG4gICAgfVxuICAgIHByb3BhZ2F0aW9uUGF0aC5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHByb3BhZ2F0aW9uUGF0aDtcbiAgfVxuICBoaXRUZXN0TW92ZVJlY3Vyc2l2ZShjdXJyZW50VGFyZ2V0LCBldmVudE1vZGUsIGxvY2F0aW9uLCB0ZXN0Rm4sIHBydW5lRm4sIGlnbm9yZSA9IGZhbHNlKSB7XG4gICAgbGV0IHNob3VsZFJldHVybiA9IGZhbHNlO1xuICAgIGlmICh0aGlzLl9pbnRlcmFjdGl2ZVBydW5lKGN1cnJlbnRUYXJnZXQpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGN1cnJlbnRUYXJnZXQuZXZlbnRNb2RlID09PSBcImR5bmFtaWNcIiB8fCBldmVudE1vZGUgPT09IFwiZHluYW1pY1wiKSB7XG4gICAgICBFdmVudFRpY2tlci5FdmVudHNUaWNrZXIucGF1c2VVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRUYXJnZXQuaW50ZXJhY3RpdmVDaGlsZHJlbiAmJiBjdXJyZW50VGFyZ2V0LmNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGN1cnJlbnRUYXJnZXQuY2hpbGRyZW47XG4gICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgY29uc3QgbmVzdGVkSGl0ID0gdGhpcy5oaXRUZXN0TW92ZVJlY3Vyc2l2ZShjaGlsZCwgdGhpcy5faXNJbnRlcmFjdGl2ZShldmVudE1vZGUpID8gZXZlbnRNb2RlIDogY2hpbGQuZXZlbnRNb2RlLCBsb2NhdGlvbiwgdGVzdEZuLCBwcnVuZUZuLCBpZ25vcmUgfHwgcHJ1bmVGbihjdXJyZW50VGFyZ2V0LCBsb2NhdGlvbikpO1xuICAgICAgICBpZiAobmVzdGVkSGl0KSB7XG4gICAgICAgICAgaWYgKG5lc3RlZEhpdC5sZW5ndGggPiAwICYmICFuZXN0ZWRIaXRbbmVzdGVkSGl0Lmxlbmd0aCAtIDFdLnBhcmVudCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlzSW50ZXJhY3RpdmUgPSBjdXJyZW50VGFyZ2V0LmlzSW50ZXJhY3RpdmUoKTtcbiAgICAgICAgICBpZiAobmVzdGVkSGl0Lmxlbmd0aCA+IDAgfHwgaXNJbnRlcmFjdGl2ZSkge1xuICAgICAgICAgICAgaWYgKGlzSW50ZXJhY3RpdmUpXG4gICAgICAgICAgICAgIHRoaXMuX2FsbEludGVyYWN0aXZlRWxlbWVudHMucHVzaChjdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICAgIG5lc3RlZEhpdC5wdXNoKGN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5faGl0RWxlbWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhpcy5faGl0RWxlbWVudHMgPSBuZXN0ZWRIaXQ7XG4gICAgICAgICAgc2hvdWxkUmV0dXJuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpc0ludGVyYWN0aXZlTW9kZSA9IHRoaXMuX2lzSW50ZXJhY3RpdmUoZXZlbnRNb2RlKTtcbiAgICBjb25zdCBpc0ludGVyYWN0aXZlVGFyZ2V0ID0gY3VycmVudFRhcmdldC5pc0ludGVyYWN0aXZlKCk7XG4gICAgaWYgKGlzSW50ZXJhY3RpdmVUYXJnZXQgJiYgaXNJbnRlcmFjdGl2ZVRhcmdldClcbiAgICAgIHRoaXMuX2FsbEludGVyYWN0aXZlRWxlbWVudHMucHVzaChjdXJyZW50VGFyZ2V0KTtcbiAgICBpZiAoaWdub3JlIHx8IHRoaXMuX2hpdEVsZW1lbnRzLmxlbmd0aCA+IDApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoc2hvdWxkUmV0dXJuKVxuICAgICAgcmV0dXJuIHRoaXMuX2hpdEVsZW1lbnRzO1xuICAgIGlmIChpc0ludGVyYWN0aXZlTW9kZSAmJiAoIXBydW5lRm4oY3VycmVudFRhcmdldCwgbG9jYXRpb24pICYmIHRlc3RGbihjdXJyZW50VGFyZ2V0LCBsb2NhdGlvbikpKSB7XG4gICAgICByZXR1cm4gaXNJbnRlcmFjdGl2ZVRhcmdldCA/IFtjdXJyZW50VGFyZ2V0XSA6IFtdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBoaXRUZXN0UmVjdXJzaXZlKGN1cnJlbnRUYXJnZXQsIGV2ZW50TW9kZSwgbG9jYXRpb24sIHRlc3RGbiwgcHJ1bmVGbikge1xuICAgIGlmICh0aGlzLl9pbnRlcmFjdGl2ZVBydW5lKGN1cnJlbnRUYXJnZXQpIHx8IHBydW5lRm4oY3VycmVudFRhcmdldCwgbG9jYXRpb24pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRUYXJnZXQuZXZlbnRNb2RlID09PSBcImR5bmFtaWNcIiB8fCBldmVudE1vZGUgPT09IFwiZHluYW1pY1wiKSB7XG4gICAgICBFdmVudFRpY2tlci5FdmVudHNUaWNrZXIucGF1c2VVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRUYXJnZXQuaW50ZXJhY3RpdmVDaGlsZHJlbiAmJiBjdXJyZW50VGFyZ2V0LmNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGN1cnJlbnRUYXJnZXQuY2hpbGRyZW47XG4gICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgY29uc3QgbmVzdGVkSGl0ID0gdGhpcy5oaXRUZXN0UmVjdXJzaXZlKGNoaWxkLCB0aGlzLl9pc0ludGVyYWN0aXZlKGV2ZW50TW9kZSkgPyBldmVudE1vZGUgOiBjaGlsZC5ldmVudE1vZGUsIGxvY2F0aW9uLCB0ZXN0Rm4sIHBydW5lRm4pO1xuICAgICAgICBpZiAobmVzdGVkSGl0KSB7XG4gICAgICAgICAgaWYgKG5lc3RlZEhpdC5sZW5ndGggPiAwICYmICFuZXN0ZWRIaXRbbmVzdGVkSGl0Lmxlbmd0aCAtIDFdLnBhcmVudCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlzSW50ZXJhY3RpdmUgPSBjdXJyZW50VGFyZ2V0LmlzSW50ZXJhY3RpdmUoKTtcbiAgICAgICAgICBpZiAobmVzdGVkSGl0Lmxlbmd0aCA+IDAgfHwgaXNJbnRlcmFjdGl2ZSlcbiAgICAgICAgICAgIG5lc3RlZEhpdC5wdXNoKGN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgIHJldHVybiBuZXN0ZWRIaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaXNJbnRlcmFjdGl2ZU1vZGUgPSB0aGlzLl9pc0ludGVyYWN0aXZlKGV2ZW50TW9kZSk7XG4gICAgY29uc3QgaXNJbnRlcmFjdGl2ZVRhcmdldCA9IGN1cnJlbnRUYXJnZXQuaXNJbnRlcmFjdGl2ZSgpO1xuICAgIGlmIChpc0ludGVyYWN0aXZlTW9kZSAmJiB0ZXN0Rm4oY3VycmVudFRhcmdldCwgbG9jYXRpb24pKSB7XG4gICAgICByZXR1cm4gaXNJbnRlcmFjdGl2ZVRhcmdldCA/IFtjdXJyZW50VGFyZ2V0XSA6IFtdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBfaXNJbnRlcmFjdGl2ZShpbnQpIHtcbiAgICByZXR1cm4gaW50ID09PSBcInN0YXRpY1wiIHx8IGludCA9PT0gXCJkeW5hbWljXCI7XG4gIH1cbiAgX2ludGVyYWN0aXZlUHJ1bmUoZGlzcGxheU9iamVjdCkge1xuICAgIGlmICghZGlzcGxheU9iamVjdCB8fCBkaXNwbGF5T2JqZWN0LmlzTWFzayB8fCAhZGlzcGxheU9iamVjdC52aXNpYmxlIHx8ICFkaXNwbGF5T2JqZWN0LnJlbmRlcmFibGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZGlzcGxheU9iamVjdC5ldmVudE1vZGUgPT09IFwibm9uZVwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXlPYmplY3QuZXZlbnRNb2RlID09PSBcInBhc3NpdmVcIiAmJiAhZGlzcGxheU9iamVjdC5pbnRlcmFjdGl2ZUNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXlPYmplY3QuaXNNYXNrKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGhpdFBydW5lRm4oZGlzcGxheU9iamVjdCwgbG9jYXRpb24pIHtcbiAgICBpZiAoZGlzcGxheU9iamVjdC5oaXRBcmVhKSB7XG4gICAgICBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShsb2NhdGlvbiwgdGVtcExvY2FsTWFwcGluZyk7XG4gICAgICBpZiAoIWRpc3BsYXlPYmplY3QuaGl0QXJlYS5jb250YWlucyh0ZW1wTG9jYWxNYXBwaW5nLngsIHRlbXBMb2NhbE1hcHBpbmcueSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkaXNwbGF5T2JqZWN0Ll9tYXNrKSB7XG4gICAgICBjb25zdCBtYXNrT2JqZWN0ID0gZGlzcGxheU9iamVjdC5fbWFzay5pc01hc2tEYXRhID8gZGlzcGxheU9iamVjdC5fbWFzay5tYXNrT2JqZWN0IDogZGlzcGxheU9iamVjdC5fbWFzaztcbiAgICAgIGlmIChtYXNrT2JqZWN0ICYmICFtYXNrT2JqZWN0LmNvbnRhaW5zUG9pbnQ/Lihsb2NhdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBoaXRUZXN0Rm4oZGlzcGxheU9iamVjdCwgbG9jYXRpb24pIHtcbiAgICBpZiAoZGlzcGxheU9iamVjdC5ldmVudE1vZGUgPT09IFwicGFzc2l2ZVwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkaXNwbGF5T2JqZWN0LmhpdEFyZWEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZGlzcGxheU9iamVjdC5jb250YWluc1BvaW50KSB7XG4gICAgICByZXR1cm4gZGlzcGxheU9iamVjdC5jb250YWluc1BvaW50KGxvY2F0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG5vdGlmeVRhcmdldChlLCB0eXBlKSB7XG4gICAgdHlwZSA9IHR5cGUgPz8gZS50eXBlO1xuICAgIGNvbnN0IGhhbmRsZXJLZXkgPSBgb24ke3R5cGV9YDtcbiAgICBlLmN1cnJlbnRUYXJnZXRbaGFuZGxlcktleV0/LihlKTtcbiAgICBjb25zdCBrZXkgPSBlLmV2ZW50UGhhc2UgPT09IGUuQ0FQVFVSSU5HX1BIQVNFIHx8IGUuZXZlbnRQaGFzZSA9PT0gZS5BVF9UQVJHRVQgPyBgJHt0eXBlfWNhcHR1cmVgIDogdHlwZTtcbiAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhlLCBrZXkpO1xuICAgIGlmIChlLmV2ZW50UGhhc2UgPT09IGUuQVRfVEFSR0VUKSB7XG4gICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhlLCB0eXBlKTtcbiAgICB9XG4gIH1cbiAgbWFwUG9pbnRlckRvd24oZnJvbSkge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRQb2ludGVyRXZlbnQuRmVkZXJhdGVkUG9pbnRlckV2ZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiRXZlbnRCb3VuZGFyeSBjYW5ub3QgbWFwIGEgbm9uLXBvaW50ZXIgZXZlbnQgYXMgYSBwb2ludGVyIGV2ZW50XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwicG9pbnRlcmRvd25cIik7XG4gICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwidG91Y2hzdGFydFwiKTtcbiAgICB9IGVsc2UgaWYgKGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInBlblwiKSB7XG4gICAgICBjb25zdCBpc1JpZ2h0QnV0dG9uID0gZS5idXR0b24gPT09IDI7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSwgaXNSaWdodEJ1dHRvbiA/IFwicmlnaHRkb3duXCIgOiBcIm1vdXNlZG93blwiKTtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tpbmdEYXRhID0gdGhpcy50cmFja2luZ0RhdGEoZnJvbS5wb2ludGVySWQpO1xuICAgIHRyYWNraW5nRGF0YS5wcmVzc1RhcmdldHNCeUJ1dHRvbltmcm9tLmJ1dHRvbl0gPSBlLmNvbXBvc2VkUGF0aCgpO1xuICAgIHRoaXMuZnJlZUV2ZW50KGUpO1xuICB9XG4gIG1hcFBvaW50ZXJNb3ZlKGZyb20pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50LkZlZGVyYXRlZFBvaW50ZXJFdmVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkV2ZW50Qm91bmRhcnkgY2Fubm90IG1hcCBhIG5vbi1wb2ludGVyIGV2ZW50IGFzIGEgcG9pbnRlciBldmVudFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fYWxsSW50ZXJhY3RpdmVFbGVtZW50cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX2hpdEVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5faXNQb2ludGVyTW92ZUV2ZW50ID0gdHJ1ZTtcbiAgICBjb25zdCBlID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSk7XG4gICAgdGhpcy5faXNQb2ludGVyTW92ZUV2ZW50ID0gZmFsc2U7XG4gICAgY29uc3QgaXNNb3VzZSA9IGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInBlblwiO1xuICAgIGNvbnN0IHRyYWNraW5nRGF0YSA9IHRoaXMudHJhY2tpbmdEYXRhKGZyb20ucG9pbnRlcklkKTtcbiAgICBjb25zdCBvdXRUYXJnZXQgPSB0aGlzLmZpbmRNb3VudGVkVGFyZ2V0KHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cyk7XG4gICAgaWYgKHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cz8ubGVuZ3RoID4gMCAmJiBvdXRUYXJnZXQgIT09IGUudGFyZ2V0KSB7XG4gICAgICBjb25zdCBvdXRUeXBlID0gZnJvbS50eXBlID09PSBcIm1vdXNlbW92ZVwiID8gXCJtb3VzZW91dFwiIDogXCJwb2ludGVyb3V0XCI7XG4gICAgICBjb25zdCBvdXRFdmVudCA9IHRoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20sIG91dFR5cGUsIG91dFRhcmdldCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQob3V0RXZlbnQsIFwicG9pbnRlcm91dFwiKTtcbiAgICAgIGlmIChpc01vdXNlKVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQob3V0RXZlbnQsIFwibW91c2VvdXRcIik7XG4gICAgICBpZiAoIWUuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMob3V0VGFyZ2V0KSkge1xuICAgICAgICBjb25zdCBsZWF2ZUV2ZW50ID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSwgXCJwb2ludGVybGVhdmVcIiwgb3V0VGFyZ2V0KTtcbiAgICAgICAgbGVhdmVFdmVudC5ldmVudFBoYXNlID0gbGVhdmVFdmVudC5BVF9UQVJHRVQ7XG4gICAgICAgIHdoaWxlIChsZWF2ZUV2ZW50LnRhcmdldCAmJiAhZS5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhsZWF2ZUV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICBsZWF2ZUV2ZW50LmN1cnJlbnRUYXJnZXQgPSBsZWF2ZUV2ZW50LnRhcmdldDtcbiAgICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChsZWF2ZUV2ZW50KTtcbiAgICAgICAgICBpZiAoaXNNb3VzZSlcbiAgICAgICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGxlYXZlRXZlbnQsIFwibW91c2VsZWF2ZVwiKTtcbiAgICAgICAgICBsZWF2ZUV2ZW50LnRhcmdldCA9IGxlYXZlRXZlbnQudGFyZ2V0LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyZWVFdmVudChsZWF2ZUV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJlZUV2ZW50KG91dEV2ZW50KTtcbiAgICB9XG4gICAgaWYgKG91dFRhcmdldCAhPT0gZS50YXJnZXQpIHtcbiAgICAgIGNvbnN0IG92ZXJUeXBlID0gZnJvbS50eXBlID09PSBcIm1vdXNlbW92ZVwiID8gXCJtb3VzZW92ZXJcIiA6IFwicG9pbnRlcm92ZXJcIjtcbiAgICAgIGNvbnN0IG92ZXJFdmVudCA9IHRoaXMuY2xvbmVQb2ludGVyRXZlbnQoZSwgb3ZlclR5cGUpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG92ZXJFdmVudCwgXCJwb2ludGVyb3ZlclwiKTtcbiAgICAgIGlmIChpc01vdXNlKVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQob3ZlckV2ZW50LCBcIm1vdXNlb3ZlclwiKTtcbiAgICAgIGxldCBvdmVyVGFyZ2V0QW5jZXN0b3IgPSBvdXRUYXJnZXQ/LnBhcmVudDtcbiAgICAgIHdoaWxlIChvdmVyVGFyZ2V0QW5jZXN0b3IgJiYgb3ZlclRhcmdldEFuY2VzdG9yICE9PSB0aGlzLnJvb3RUYXJnZXQucGFyZW50KSB7XG4gICAgICAgIGlmIChvdmVyVGFyZ2V0QW5jZXN0b3IgPT09IGUudGFyZ2V0KVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBvdmVyVGFyZ2V0QW5jZXN0b3IgPSBvdmVyVGFyZ2V0QW5jZXN0b3IucGFyZW50O1xuICAgICAgfVxuICAgICAgY29uc3QgZGlkUG9pbnRlckVudGVyID0gIW92ZXJUYXJnZXRBbmNlc3RvciB8fCBvdmVyVGFyZ2V0QW5jZXN0b3IgPT09IHRoaXMucm9vdFRhcmdldC5wYXJlbnQ7XG4gICAgICBpZiAoZGlkUG9pbnRlckVudGVyKSB7XG4gICAgICAgIGNvbnN0IGVudGVyRXZlbnQgPSB0aGlzLmNsb25lUG9pbnRlckV2ZW50KGUsIFwicG9pbnRlcmVudGVyXCIpO1xuICAgICAgICBlbnRlckV2ZW50LmV2ZW50UGhhc2UgPSBlbnRlckV2ZW50LkFUX1RBUkdFVDtcbiAgICAgICAgd2hpbGUgKGVudGVyRXZlbnQudGFyZ2V0ICYmIGVudGVyRXZlbnQudGFyZ2V0ICE9PSBvdXRUYXJnZXQgJiYgZW50ZXJFdmVudC50YXJnZXQgIT09IHRoaXMucm9vdFRhcmdldC5wYXJlbnQpIHtcbiAgICAgICAgICBlbnRlckV2ZW50LmN1cnJlbnRUYXJnZXQgPSBlbnRlckV2ZW50LnRhcmdldDtcbiAgICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChlbnRlckV2ZW50KTtcbiAgICAgICAgICBpZiAoaXNNb3VzZSlcbiAgICAgICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGVudGVyRXZlbnQsIFwibW91c2VlbnRlclwiKTtcbiAgICAgICAgICBlbnRlckV2ZW50LnRhcmdldCA9IGVudGVyRXZlbnQudGFyZ2V0LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyZWVFdmVudChlbnRlckV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJlZUV2ZW50KG92ZXJFdmVudCk7XG4gICAgfVxuICAgIGNvbnN0IGFsbE1ldGhvZHMgPSBbXTtcbiAgICBjb25zdCBhbGxvd0dsb2JhbFBvaW50ZXJFdmVudHMgPSB0aGlzLmVuYWJsZUdsb2JhbE1vdmVFdmVudHMgPz8gdHJ1ZTtcbiAgICB0aGlzLm1vdmVPbkFsbCA/IGFsbE1ldGhvZHMucHVzaChcInBvaW50ZXJtb3ZlXCIpIDogdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwicG9pbnRlcm1vdmVcIik7XG4gICAgYWxsb3dHbG9iYWxQb2ludGVyRXZlbnRzICYmIGFsbE1ldGhvZHMucHVzaChcImdsb2JhbHBvaW50ZXJtb3ZlXCIpO1xuICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgIHRoaXMubW92ZU9uQWxsID8gYWxsTWV0aG9kcy5zcGxpY2UoMSwgMCwgXCJ0b3VjaG1vdmVcIikgOiB0aGlzLmRpc3BhdGNoRXZlbnQoZSwgXCJ0b3VjaG1vdmVcIik7XG4gICAgICBhbGxvd0dsb2JhbFBvaW50ZXJFdmVudHMgJiYgYWxsTWV0aG9kcy5wdXNoKFwiZ2xvYmFsdG91Y2htb3ZlXCIpO1xuICAgIH1cbiAgICBpZiAoaXNNb3VzZSkge1xuICAgICAgdGhpcy5tb3ZlT25BbGwgPyBhbGxNZXRob2RzLnNwbGljZSgxLCAwLCBcIm1vdXNlbW92ZVwiKSA6IHRoaXMuZGlzcGF0Y2hFdmVudChlLCBcIm1vdXNlbW92ZVwiKTtcbiAgICAgIGFsbG93R2xvYmFsUG9pbnRlckV2ZW50cyAmJiBhbGxNZXRob2RzLnB1c2goXCJnbG9iYWxtb3VzZW1vdmVcIik7XG4gICAgICB0aGlzLmN1cnNvciA9IGUudGFyZ2V0Py5jdXJzb3I7XG4gICAgfVxuICAgIGlmIChhbGxNZXRob2RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuYWxsKGUsIGFsbE1ldGhvZHMpO1xuICAgIH1cbiAgICB0aGlzLl9hbGxJbnRlcmFjdGl2ZUVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5faGl0RWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICB0cmFja2luZ0RhdGEub3ZlclRhcmdldHMgPSBlLmNvbXBvc2VkUGF0aCgpO1xuICAgIHRoaXMuZnJlZUV2ZW50KGUpO1xuICB9XG4gIG1hcFBvaW50ZXJPdmVyKGZyb20pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50LkZlZGVyYXRlZFBvaW50ZXJFdmVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkV2ZW50Qm91bmRhcnkgY2Fubm90IG1hcCBhIG5vbi1wb2ludGVyIGV2ZW50IGFzIGEgcG9pbnRlciBldmVudFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tpbmdEYXRhID0gdGhpcy50cmFja2luZ0RhdGEoZnJvbS5wb2ludGVySWQpO1xuICAgIGNvbnN0IGUgPSB0aGlzLmNyZWF0ZVBvaW50ZXJFdmVudChmcm9tKTtcbiAgICBjb25zdCBpc01vdXNlID0gZS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiIHx8IGUucG9pbnRlclR5cGUgPT09IFwicGVuXCI7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwicG9pbnRlcm92ZXJcIik7XG4gICAgaWYgKGlzTW91c2UpXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSwgXCJtb3VzZW92ZXJcIik7XG4gICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIilcbiAgICAgIHRoaXMuY3Vyc29yID0gZS50YXJnZXQ/LmN1cnNvcjtcbiAgICBjb25zdCBlbnRlckV2ZW50ID0gdGhpcy5jbG9uZVBvaW50ZXJFdmVudChlLCBcInBvaW50ZXJlbnRlclwiKTtcbiAgICBlbnRlckV2ZW50LmV2ZW50UGhhc2UgPSBlbnRlckV2ZW50LkFUX1RBUkdFVDtcbiAgICB3aGlsZSAoZW50ZXJFdmVudC50YXJnZXQgJiYgZW50ZXJFdmVudC50YXJnZXQgIT09IHRoaXMucm9vdFRhcmdldC5wYXJlbnQpIHtcbiAgICAgIGVudGVyRXZlbnQuY3VycmVudFRhcmdldCA9IGVudGVyRXZlbnQudGFyZ2V0O1xuICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZW50ZXJFdmVudCk7XG4gICAgICBpZiAoaXNNb3VzZSlcbiAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZW50ZXJFdmVudCwgXCJtb3VzZWVudGVyXCIpO1xuICAgICAgZW50ZXJFdmVudC50YXJnZXQgPSBlbnRlckV2ZW50LnRhcmdldC5wYXJlbnQ7XG4gICAgfVxuICAgIHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cyA9IGUuY29tcG9zZWRQYXRoKCk7XG4gICAgdGhpcy5mcmVlRXZlbnQoZSk7XG4gICAgdGhpcy5mcmVlRXZlbnQoZW50ZXJFdmVudCk7XG4gIH1cbiAgbWFwUG9pbnRlck91dChmcm9tKSB7XG4gICAgaWYgKCEoZnJvbSBpbnN0YW5jZW9mIEZlZGVyYXRlZFBvaW50ZXJFdmVudC5GZWRlcmF0ZWRQb2ludGVyRXZlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJFdmVudEJvdW5kYXJ5IGNhbm5vdCBtYXAgYSBub24tcG9pbnRlciBldmVudCBhcyBhIHBvaW50ZXIgZXZlbnRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyYWNraW5nRGF0YSA9IHRoaXMudHJhY2tpbmdEYXRhKGZyb20ucG9pbnRlcklkKTtcbiAgICBpZiAodHJhY2tpbmdEYXRhLm92ZXJUYXJnZXRzKSB7XG4gICAgICBjb25zdCBpc01vdXNlID0gZnJvbS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiIHx8IGZyb20ucG9pbnRlclR5cGUgPT09IFwicGVuXCI7XG4gICAgICBjb25zdCBvdXRUYXJnZXQgPSB0aGlzLmZpbmRNb3VudGVkVGFyZ2V0KHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cyk7XG4gICAgICBjb25zdCBvdXRFdmVudCA9IHRoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20sIFwicG9pbnRlcm91dFwiLCBvdXRUYXJnZXQpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG91dEV2ZW50KTtcbiAgICAgIGlmIChpc01vdXNlKVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQob3V0RXZlbnQsIFwibW91c2VvdXRcIik7XG4gICAgICBjb25zdCBsZWF2ZUV2ZW50ID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSwgXCJwb2ludGVybGVhdmVcIiwgb3V0VGFyZ2V0KTtcbiAgICAgIGxlYXZlRXZlbnQuZXZlbnRQaGFzZSA9IGxlYXZlRXZlbnQuQVRfVEFSR0VUO1xuICAgICAgd2hpbGUgKGxlYXZlRXZlbnQudGFyZ2V0ICYmIGxlYXZlRXZlbnQudGFyZ2V0ICE9PSB0aGlzLnJvb3RUYXJnZXQucGFyZW50KSB7XG4gICAgICAgIGxlYXZlRXZlbnQuY3VycmVudFRhcmdldCA9IGxlYXZlRXZlbnQudGFyZ2V0O1xuICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChsZWF2ZUV2ZW50KTtcbiAgICAgICAgaWYgKGlzTW91c2UpXG4gICAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQobGVhdmVFdmVudCwgXCJtb3VzZWxlYXZlXCIpO1xuICAgICAgICBsZWF2ZUV2ZW50LnRhcmdldCA9IGxlYXZlRXZlbnQudGFyZ2V0LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cyA9IG51bGw7XG4gICAgICB0aGlzLmZyZWVFdmVudChvdXRFdmVudCk7XG4gICAgICB0aGlzLmZyZWVFdmVudChsZWF2ZUV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICB9XG4gIG1hcFBvaW50ZXJVcChmcm9tKSB7XG4gICAgaWYgKCEoZnJvbSBpbnN0YW5jZW9mIEZlZGVyYXRlZFBvaW50ZXJFdmVudC5GZWRlcmF0ZWRQb2ludGVyRXZlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJFdmVudEJvdW5kYXJ5IGNhbm5vdCBtYXAgYSBub24tcG9pbnRlciBldmVudCBhcyBhIHBvaW50ZXIgZXZlbnRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IGUgPSB0aGlzLmNyZWF0ZVBvaW50ZXJFdmVudChmcm9tKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSwgXCJwb2ludGVydXBcIik7XG4gICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwidG91Y2hlbmRcIik7XG4gICAgfSBlbHNlIGlmIChlLnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIgfHwgZS5wb2ludGVyVHlwZSA9PT0gXCJwZW5cIikge1xuICAgICAgY29uc3QgaXNSaWdodEJ1dHRvbiA9IGUuYnV0dG9uID09PSAyO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIGlzUmlnaHRCdXR0b24gPyBcInJpZ2h0dXBcIiA6IFwibW91c2V1cFwiKTtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tpbmdEYXRhID0gdGhpcy50cmFja2luZ0RhdGEoZnJvbS5wb2ludGVySWQpO1xuICAgIGNvbnN0IHByZXNzVGFyZ2V0ID0gdGhpcy5maW5kTW91bnRlZFRhcmdldCh0cmFja2luZ0RhdGEucHJlc3NUYXJnZXRzQnlCdXR0b25bZnJvbS5idXR0b25dKTtcbiAgICBsZXQgY2xpY2tUYXJnZXQgPSBwcmVzc1RhcmdldDtcbiAgICBpZiAocHJlc3NUYXJnZXQgJiYgIWUuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMocHJlc3NUYXJnZXQpKSB7XG4gICAgICBsZXQgY3VycmVudFRhcmdldCA9IHByZXNzVGFyZ2V0O1xuICAgICAgd2hpbGUgKGN1cnJlbnRUYXJnZXQgJiYgIWUuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMoY3VycmVudFRhcmdldCkpIHtcbiAgICAgICAgZS5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgXCJwb2ludGVydXBvdXRzaWRlXCIpO1xuICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgXCJ0b3VjaGVuZG91dHNpZGVcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiIHx8IGUucG9pbnRlclR5cGUgPT09IFwicGVuXCIpIHtcbiAgICAgICAgICBjb25zdCBpc1JpZ2h0QnV0dG9uID0gZS5idXR0b24gPT09IDI7XG4gICAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgaXNSaWdodEJ1dHRvbiA/IFwicmlnaHR1cG91dHNpZGVcIiA6IFwibW91c2V1cG91dHNpZGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQucGFyZW50O1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRyYWNraW5nRGF0YS5wcmVzc1RhcmdldHNCeUJ1dHRvbltmcm9tLmJ1dHRvbl07XG4gICAgICBjbGlja1RhcmdldCA9IGN1cnJlbnRUYXJnZXQ7XG4gICAgfVxuICAgIGlmIChjbGlja1RhcmdldCkge1xuICAgICAgY29uc3QgY2xpY2tFdmVudCA9IHRoaXMuY2xvbmVQb2ludGVyRXZlbnQoZSwgXCJjbGlja1wiKTtcbiAgICAgIGNsaWNrRXZlbnQudGFyZ2V0ID0gY2xpY2tUYXJnZXQ7XG4gICAgICBjbGlja0V2ZW50LnBhdGggPSBudWxsO1xuICAgICAgaWYgKCF0cmFja2luZ0RhdGEuY2xpY2tzQnlCdXR0b25bZnJvbS5idXR0b25dKSB7XG4gICAgICAgIHRyYWNraW5nRGF0YS5jbGlja3NCeUJ1dHRvbltmcm9tLmJ1dHRvbl0gPSB7XG4gICAgICAgICAgY2xpY2tDb3VudDogMCxcbiAgICAgICAgICB0YXJnZXQ6IGNsaWNrRXZlbnQudGFyZ2V0LFxuICAgICAgICAgIHRpbWVTdGFtcDogbm93XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBjbGlja0hpc3RvcnkgPSB0cmFja2luZ0RhdGEuY2xpY2tzQnlCdXR0b25bZnJvbS5idXR0b25dO1xuICAgICAgaWYgKGNsaWNrSGlzdG9yeS50YXJnZXQgPT09IGNsaWNrRXZlbnQudGFyZ2V0ICYmIG5vdyAtIGNsaWNrSGlzdG9yeS50aW1lU3RhbXAgPCAyMDApIHtcbiAgICAgICAgKytjbGlja0hpc3RvcnkuY2xpY2tDb3VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaWNrSGlzdG9yeS5jbGlja0NvdW50ID0gMTtcbiAgICAgIH1cbiAgICAgIGNsaWNrSGlzdG9yeS50YXJnZXQgPSBjbGlja0V2ZW50LnRhcmdldDtcbiAgICAgIGNsaWNrSGlzdG9yeS50aW1lU3RhbXAgPSBub3c7XG4gICAgICBjbGlja0V2ZW50LmRldGFpbCA9IGNsaWNrSGlzdG9yeS5jbGlja0NvdW50O1xuICAgICAgaWYgKGNsaWNrRXZlbnQucG9pbnRlclR5cGUgPT09IFwibW91c2VcIikge1xuICAgICAgICBjb25zdCBpc1JpZ2h0QnV0dG9uID0gY2xpY2tFdmVudC5idXR0b24gPT09IDI7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50LCBpc1JpZ2h0QnV0dG9uID8gXCJyaWdodGNsaWNrXCIgOiBcImNsaWNrXCIpO1xuICAgICAgfSBlbHNlIGlmIChjbGlja0V2ZW50LnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQsIFwidGFwXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQsIFwicG9pbnRlcnRhcFwiKTtcbiAgICAgIHRoaXMuZnJlZUV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLmZyZWVFdmVudChlKTtcbiAgfVxuICBtYXBQb2ludGVyVXBPdXRzaWRlKGZyb20pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50LkZlZGVyYXRlZFBvaW50ZXJFdmVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkV2ZW50Qm91bmRhcnkgY2Fubm90IG1hcCBhIG5vbi1wb2ludGVyIGV2ZW50IGFzIGEgcG9pbnRlciBldmVudFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tpbmdEYXRhID0gdGhpcy50cmFja2luZ0RhdGEoZnJvbS5wb2ludGVySWQpO1xuICAgIGNvbnN0IHByZXNzVGFyZ2V0ID0gdGhpcy5maW5kTW91bnRlZFRhcmdldCh0cmFja2luZ0RhdGEucHJlc3NUYXJnZXRzQnlCdXR0b25bZnJvbS5idXR0b25dKTtcbiAgICBjb25zdCBlID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSk7XG4gICAgaWYgKHByZXNzVGFyZ2V0KSB7XG4gICAgICBsZXQgY3VycmVudFRhcmdldCA9IHByZXNzVGFyZ2V0O1xuICAgICAgd2hpbGUgKGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgZS5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgXCJwb2ludGVydXBvdXRzaWRlXCIpO1xuICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgXCJ0b3VjaGVuZG91dHNpZGVcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiIHx8IGUucG9pbnRlclR5cGUgPT09IFwicGVuXCIpIHtcbiAgICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChlLCBlLmJ1dHRvbiA9PT0gMiA/IFwicmlnaHR1cG91dHNpZGVcIiA6IFwibW91c2V1cG91dHNpZGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQucGFyZW50O1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRyYWNraW5nRGF0YS5wcmVzc1RhcmdldHNCeUJ1dHRvbltmcm9tLmJ1dHRvbl07XG4gICAgfVxuICAgIHRoaXMuZnJlZUV2ZW50KGUpO1xuICB9XG4gIG1hcFdoZWVsKGZyb20pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkV2hlZWxFdmVudC5GZWRlcmF0ZWRXaGVlbEV2ZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiRXZlbnRCb3VuZGFyeSBjYW5ub3QgbWFwIGEgbm9uLXdoZWVsIGV2ZW50IGFzIGEgd2hlZWwgZXZlbnRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdoZWVsRXZlbnQgPSB0aGlzLmNyZWF0ZVdoZWVsRXZlbnQoZnJvbSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KHdoZWVsRXZlbnQpO1xuICAgIHRoaXMuZnJlZUV2ZW50KHdoZWVsRXZlbnQpO1xuICB9XG4gIGZpbmRNb3VudGVkVGFyZ2V0KHByb3BhZ2F0aW9uUGF0aCkge1xuICAgIGlmICghcHJvcGFnYXRpb25QYXRoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRUYXJnZXQgPSBwcm9wYWdhdGlvblBhdGhbMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwcm9wYWdhdGlvblBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwcm9wYWdhdGlvblBhdGhbaV0ucGFyZW50ID09PSBjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgIGN1cnJlbnRUYXJnZXQgPSBwcm9wYWdhdGlvblBhdGhbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRUYXJnZXQ7XG4gIH1cbiAgY3JlYXRlUG9pbnRlckV2ZW50KGZyb20sIHR5cGUsIHRhcmdldCkge1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5hbGxvY2F0ZUV2ZW50KEZlZGVyYXRlZFBvaW50ZXJFdmVudC5GZWRlcmF0ZWRQb2ludGVyRXZlbnQpO1xuICAgIHRoaXMuY29weVBvaW50ZXJEYXRhKGZyb20sIGV2ZW50KTtcbiAgICB0aGlzLmNvcHlNb3VzZURhdGEoZnJvbSwgZXZlbnQpO1xuICAgIHRoaXMuY29weURhdGEoZnJvbSwgZXZlbnQpO1xuICAgIGV2ZW50Lm5hdGl2ZUV2ZW50ID0gZnJvbS5uYXRpdmVFdmVudDtcbiAgICBldmVudC5vcmlnaW5hbEV2ZW50ID0gZnJvbTtcbiAgICBldmVudC50YXJnZXQgPSB0YXJnZXQgPz8gdGhpcy5oaXRUZXN0KGV2ZW50Lmdsb2JhbC54LCBldmVudC5nbG9iYWwueSkgPz8gdGhpcy5faGl0RWxlbWVudHNbMF07XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBldmVudC50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIGNyZWF0ZVdoZWVsRXZlbnQoZnJvbSkge1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5hbGxvY2F0ZUV2ZW50KEZlZGVyYXRlZFdoZWVsRXZlbnQuRmVkZXJhdGVkV2hlZWxFdmVudCk7XG4gICAgdGhpcy5jb3B5V2hlZWxEYXRhKGZyb20sIGV2ZW50KTtcbiAgICB0aGlzLmNvcHlNb3VzZURhdGEoZnJvbSwgZXZlbnQpO1xuICAgIHRoaXMuY29weURhdGEoZnJvbSwgZXZlbnQpO1xuICAgIGV2ZW50Lm5hdGl2ZUV2ZW50ID0gZnJvbS5uYXRpdmVFdmVudDtcbiAgICBldmVudC5vcmlnaW5hbEV2ZW50ID0gZnJvbTtcbiAgICBldmVudC50YXJnZXQgPSB0aGlzLmhpdFRlc3QoZXZlbnQuZ2xvYmFsLngsIGV2ZW50Lmdsb2JhbC55KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgY2xvbmVQb2ludGVyRXZlbnQoZnJvbSwgdHlwZSkge1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5hbGxvY2F0ZUV2ZW50KEZlZGVyYXRlZFBvaW50ZXJFdmVudC5GZWRlcmF0ZWRQb2ludGVyRXZlbnQpO1xuICAgIGV2ZW50Lm5hdGl2ZUV2ZW50ID0gZnJvbS5uYXRpdmVFdmVudDtcbiAgICBldmVudC5vcmlnaW5hbEV2ZW50ID0gZnJvbS5vcmlnaW5hbEV2ZW50O1xuICAgIHRoaXMuY29weVBvaW50ZXJEYXRhKGZyb20sIGV2ZW50KTtcbiAgICB0aGlzLmNvcHlNb3VzZURhdGEoZnJvbSwgZXZlbnQpO1xuICAgIHRoaXMuY29weURhdGEoZnJvbSwgZXZlbnQpO1xuICAgIGV2ZW50LnRhcmdldCA9IGZyb20udGFyZ2V0O1xuICAgIGV2ZW50LnBhdGggPSBmcm9tLmNvbXBvc2VkUGF0aCgpLnNsaWNlKCk7XG4gICAgZXZlbnQudHlwZSA9IHR5cGUgPz8gZXZlbnQudHlwZTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgY29weVdoZWVsRGF0YShmcm9tLCB0bykge1xuICAgIHRvLmRlbHRhTW9kZSA9IGZyb20uZGVsdGFNb2RlO1xuICAgIHRvLmRlbHRhWCA9IGZyb20uZGVsdGFYO1xuICAgIHRvLmRlbHRhWSA9IGZyb20uZGVsdGFZO1xuICAgIHRvLmRlbHRhWiA9IGZyb20uZGVsdGFaO1xuICB9XG4gIGNvcHlQb2ludGVyRGF0YShmcm9tLCB0bykge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRQb2ludGVyRXZlbnQuRmVkZXJhdGVkUG9pbnRlckV2ZW50ICYmIHRvIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50LkZlZGVyYXRlZFBvaW50ZXJFdmVudCkpXG4gICAgICByZXR1cm47XG4gICAgdG8ucG9pbnRlcklkID0gZnJvbS5wb2ludGVySWQ7XG4gICAgdG8ud2lkdGggPSBmcm9tLndpZHRoO1xuICAgIHRvLmhlaWdodCA9IGZyb20uaGVpZ2h0O1xuICAgIHRvLmlzUHJpbWFyeSA9IGZyb20uaXNQcmltYXJ5O1xuICAgIHRvLnBvaW50ZXJUeXBlID0gZnJvbS5wb2ludGVyVHlwZTtcbiAgICB0by5wcmVzc3VyZSA9IGZyb20ucHJlc3N1cmU7XG4gICAgdG8udGFuZ2VudGlhbFByZXNzdXJlID0gZnJvbS50YW5nZW50aWFsUHJlc3N1cmU7XG4gICAgdG8udGlsdFggPSBmcm9tLnRpbHRYO1xuICAgIHRvLnRpbHRZID0gZnJvbS50aWx0WTtcbiAgICB0by50d2lzdCA9IGZyb20udHdpc3Q7XG4gIH1cbiAgY29weU1vdXNlRGF0YShmcm9tLCB0bykge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRNb3VzZUV2ZW50LkZlZGVyYXRlZE1vdXNlRXZlbnQgJiYgdG8gaW5zdGFuY2VvZiBGZWRlcmF0ZWRNb3VzZUV2ZW50LkZlZGVyYXRlZE1vdXNlRXZlbnQpKVxuICAgICAgcmV0dXJuO1xuICAgIHRvLmFsdEtleSA9IGZyb20uYWx0S2V5O1xuICAgIHRvLmJ1dHRvbiA9IGZyb20uYnV0dG9uO1xuICAgIHRvLmJ1dHRvbnMgPSBmcm9tLmJ1dHRvbnM7XG4gICAgdG8uY2xpZW50LmNvcHlGcm9tKGZyb20uY2xpZW50KTtcbiAgICB0by5jdHJsS2V5ID0gZnJvbS5jdHJsS2V5O1xuICAgIHRvLm1ldGFLZXkgPSBmcm9tLm1ldGFLZXk7XG4gICAgdG8ubW92ZW1lbnQuY29weUZyb20oZnJvbS5tb3ZlbWVudCk7XG4gICAgdG8uc2NyZWVuLmNvcHlGcm9tKGZyb20uc2NyZWVuKTtcbiAgICB0by5zaGlmdEtleSA9IGZyb20uc2hpZnRLZXk7XG4gICAgdG8uZ2xvYmFsLmNvcHlGcm9tKGZyb20uZ2xvYmFsKTtcbiAgfVxuICBjb3B5RGF0YShmcm9tLCB0bykge1xuICAgIHRvLmlzVHJ1c3RlZCA9IGZyb20uaXNUcnVzdGVkO1xuICAgIHRvLnNyY0VsZW1lbnQgPSBmcm9tLnNyY0VsZW1lbnQ7XG4gICAgdG8udGltZVN0YW1wID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdG8udHlwZSA9IGZyb20udHlwZTtcbiAgICB0by5kZXRhaWwgPSBmcm9tLmRldGFpbDtcbiAgICB0by52aWV3ID0gZnJvbS52aWV3O1xuICAgIHRvLndoaWNoID0gZnJvbS53aGljaDtcbiAgICB0by5sYXllci5jb3B5RnJvbShmcm9tLmxheWVyKTtcbiAgICB0by5wYWdlLmNvcHlGcm9tKGZyb20ucGFnZSk7XG4gIH1cbiAgdHJhY2tpbmdEYXRhKGlkKSB7XG4gICAgaWYgKCF0aGlzLm1hcHBpbmdTdGF0ZS50cmFja2luZ0RhdGFbaWRdKSB7XG4gICAgICB0aGlzLm1hcHBpbmdTdGF0ZS50cmFja2luZ0RhdGFbaWRdID0ge1xuICAgICAgICBwcmVzc1RhcmdldHNCeUJ1dHRvbjoge30sXG4gICAgICAgIGNsaWNrc0J5QnV0dG9uOiB7fSxcbiAgICAgICAgb3ZlclRhcmdldDogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWFwcGluZ1N0YXRlLnRyYWNraW5nRGF0YVtpZF07XG4gIH1cbiAgYWxsb2NhdGVFdmVudChjb25zdHJ1Y3Rvcikge1xuICAgIGlmICghdGhpcy5ldmVudFBvb2wuaGFzKGNvbnN0cnVjdG9yKSkge1xuICAgICAgdGhpcy5ldmVudFBvb2wuc2V0KGNvbnN0cnVjdG9yLCBbXSk7XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5ldmVudFBvb2wuZ2V0KGNvbnN0cnVjdG9yKS5wb3AoKSB8fCBuZXcgY29uc3RydWN0b3IodGhpcyk7XG4gICAgZXZlbnQuZXZlbnRQaGFzZSA9IGV2ZW50Lk5PTkU7XG4gICAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG4gICAgZXZlbnQucGF0aCA9IG51bGw7XG4gICAgZXZlbnQudGFyZ2V0ID0gbnVsbDtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgZnJlZUV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50Lm1hbmFnZXIgIT09IHRoaXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJdCBpcyBpbGxlZ2FsIHRvIGZyZWUgYW4gZXZlbnQgbm90IG1hbmFnZWQgYnkgdGhpcyBFdmVudEJvdW5kYXJ5IVwiKTtcbiAgICBjb25zdCBjb25zdHJ1Y3RvciA9IGV2ZW50LmNvbnN0cnVjdG9yO1xuICAgIGlmICghdGhpcy5ldmVudFBvb2wuaGFzKGNvbnN0cnVjdG9yKSkge1xuICAgICAgdGhpcy5ldmVudFBvb2wuc2V0KGNvbnN0cnVjdG9yLCBbXSk7XG4gICAgfVxuICAgIHRoaXMuZXZlbnRQb29sLmdldChjb25zdHJ1Y3RvcikucHVzaChldmVudCk7XG4gIH1cbiAgbm90aWZ5TGlzdGVuZXJzKGUsIHR5cGUpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBlLmN1cnJlbnRUYXJnZXQuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAoIWxpc3RlbmVycylcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIWUuY3VycmVudFRhcmdldC5pc0ludGVyYWN0aXZlKCkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKFwiZm5cIiBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIGlmIChsaXN0ZW5lcnMub25jZSlcbiAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycy5mbiwgdm9pZCAwLCB0cnVlKTtcbiAgICAgIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgaiAmJiAhZS5wcm9wYWdhdGlvbkltbWVkaWF0ZWx5U3RvcHBlZDsgaSsrKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSlcbiAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldLmZuLCB2b2lkIDAsIHRydWUpO1xuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuRXZlbnRCb3VuZGFyeSA9IEV2ZW50Qm91bmRhcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudEJvdW5kYXJ5LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBFdmVudEJvdW5kYXJ5ID0gcmVxdWlyZSgnLi9FdmVudEJvdW5kYXJ5LmpzJyk7XG52YXIgRXZlbnRUaWNrZXIgPSByZXF1aXJlKCcuL0V2ZW50VGlja2VyLmpzJyk7XG52YXIgRmVkZXJhdGVkUG9pbnRlckV2ZW50ID0gcmVxdWlyZSgnLi9GZWRlcmF0ZWRQb2ludGVyRXZlbnQuanMnKTtcbnZhciBGZWRlcmF0ZWRXaGVlbEV2ZW50ID0gcmVxdWlyZSgnLi9GZWRlcmF0ZWRXaGVlbEV2ZW50LmpzJyk7XG5cbmNvbnN0IE1PVVNFX1BPSU5URVJfSUQgPSAxO1xuY29uc3QgVE9VQ0hfVE9fUE9JTlRFUiA9IHtcbiAgdG91Y2hzdGFydDogXCJwb2ludGVyZG93blwiLFxuICB0b3VjaGVuZDogXCJwb2ludGVydXBcIixcbiAgdG91Y2hlbmRvdXRzaWRlOiBcInBvaW50ZXJ1cG91dHNpZGVcIixcbiAgdG91Y2htb3ZlOiBcInBvaW50ZXJtb3ZlXCIsXG4gIHRvdWNoY2FuY2VsOiBcInBvaW50ZXJjYW5jZWxcIlxufTtcbmNvbnN0IF9FdmVudFN5c3RlbSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMgPSBcIm9udG91Y2hzdGFydFwiIGluIGdsb2JhbFRoaXM7XG4gICAgdGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMgPSAhIWdsb2JhbFRoaXMuUG9pbnRlckV2ZW50O1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gMTtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5yb290Qm91bmRhcnkgPSBuZXcgRXZlbnRCb3VuZGFyeS5FdmVudEJvdW5kYXJ5KG51bGwpO1xuICAgIEV2ZW50VGlja2VyLkV2ZW50c1RpY2tlci5pbml0KHRoaXMpO1xuICAgIHRoaXMuYXV0b1ByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICB0aGlzLmV2ZW50c0FkZGVkID0gZmFsc2U7XG4gICAgdGhpcy5yb290UG9pbnRlckV2ZW50ID0gbmV3IEZlZGVyYXRlZFBvaW50ZXJFdmVudC5GZWRlcmF0ZWRQb2ludGVyRXZlbnQobnVsbCk7XG4gICAgdGhpcy5yb290V2hlZWxFdmVudCA9IG5ldyBGZWRlcmF0ZWRXaGVlbEV2ZW50LkZlZGVyYXRlZFdoZWVsRXZlbnQobnVsbCk7XG4gICAgdGhpcy5jdXJzb3JTdHlsZXMgPSB7XG4gICAgICBkZWZhdWx0OiBcImluaGVyaXRcIixcbiAgICAgIHBvaW50ZXI6IFwicG9pbnRlclwiXG4gICAgfTtcbiAgICB0aGlzLmZlYXR1cmVzID0gbmV3IFByb3h5KHsgLi4uX0V2ZW50U3lzdGVtLmRlZmF1bHRFdmVudEZlYXR1cmVzIH0sIHtcbiAgICAgIHNldDogKHRhcmdldCwga2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoa2V5ID09PSBcImdsb2JhbE1vdmVcIikge1xuICAgICAgICAgIHRoaXMucm9vdEJvdW5kYXJ5LmVuYWJsZUdsb2JhbE1vdmVFdmVudHMgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLm9uUG9pbnRlckRvd24gPSB0aGlzLm9uUG9pbnRlckRvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uUG9pbnRlck1vdmUgPSB0aGlzLm9uUG9pbnRlck1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uUG9pbnRlclVwID0gdGhpcy5vblBvaW50ZXJVcC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25Qb2ludGVyT3Zlck91dCA9IHRoaXMub25Qb2ludGVyT3Zlck91dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25XaGVlbCA9IHRoaXMub25XaGVlbC5iaW5kKHRoaXMpO1xuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdEV2ZW50TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmYXVsdEV2ZW50TW9kZTtcbiAgfVxuICBpbml0KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHZpZXcsIHJlc29sdXRpb24gfSA9IHRoaXMucmVuZGVyZXI7XG4gICAgdGhpcy5zZXRUYXJnZXRFbGVtZW50KHZpZXcpO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgX0V2ZW50U3lzdGVtLl9kZWZhdWx0RXZlbnRNb2RlID0gb3B0aW9ucy5ldmVudE1vZGUgPz8gXCJhdXRvXCI7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmZlYXR1cmVzLCBvcHRpb25zLmV2ZW50RmVhdHVyZXMgPz8ge30pO1xuICAgIHRoaXMucm9vdEJvdW5kYXJ5LmVuYWJsZUdsb2JhbE1vdmVFdmVudHMgPSB0aGlzLmZlYXR1cmVzLmdsb2JhbE1vdmU7XG4gIH1cbiAgcmVzb2x1dGlvbkNoYW5nZShyZXNvbHV0aW9uKSB7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc2V0VGFyZ2V0RWxlbWVudChudWxsKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxuICBzZXRDdXJzb3IobW9kZSkge1xuICAgIG1vZGUgPSBtb2RlIHx8IFwiZGVmYXVsdFwiO1xuICAgIGxldCBhcHBseVN0eWxlcyA9IHRydWU7XG4gICAgaWYgKGdsb2JhbFRoaXMuT2Zmc2NyZWVuQ2FudmFzICYmIHRoaXMuZG9tRWxlbWVudCBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xuICAgICAgYXBwbHlTdHlsZXMgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3VycmVudEN1cnNvciA9PT0gbW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRDdXJzb3IgPSBtb2RlO1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5jdXJzb3JTdHlsZXNbbW9kZV07XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiBzdHlsZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgaWYgKGFwcGx5U3R5bGVzKSB7XG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gc3R5bGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICBzdHlsZShtb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIGlmIChhcHBseVN0eWxlcykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmRvbUVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcHBseVN0eWxlcyAmJiB0eXBlb2YgbW9kZSA9PT0gXCJzdHJpbmdcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY3Vyc29yU3R5bGVzLCBtb2RlKSkge1xuICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLmN1cnNvciA9IG1vZGU7XG4gICAgfVxuICB9XG4gIGdldCBwb2ludGVyKCkge1xuICAgIHJldHVybiB0aGlzLnJvb3RQb2ludGVyRXZlbnQ7XG4gIH1cbiAgb25Qb2ludGVyRG93bihuYXRpdmVFdmVudCkge1xuICAgIGlmICghdGhpcy5mZWF0dXJlcy5jbGljaylcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnJvb3RCb3VuZGFyeS5yb290VGFyZ2V0ID0gdGhpcy5yZW5kZXJlci5sYXN0T2JqZWN0UmVuZGVyZWQ7XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiBuYXRpdmVFdmVudC5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMubm9ybWFsaXplVG9Qb2ludGVyRGF0YShuYXRpdmVFdmVudCk7XG4gICAgaWYgKHRoaXMuYXV0b1ByZXZlbnREZWZhdWx0ICYmIGV2ZW50c1swXS5pc05vcm1hbGl6ZWQpIHtcbiAgICAgIGNvbnN0IGNhbmNlbGFibGUgPSBuYXRpdmVFdmVudC5jYW5jZWxhYmxlIHx8ICEoXCJjYW5jZWxhYmxlXCIgaW4gbmF0aXZlRXZlbnQpO1xuICAgICAgaWYgKGNhbmNlbGFibGUpIHtcbiAgICAgICAgbmF0aXZlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSBldmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBjb25zdCBuYXRpdmVFdmVudDIgPSBldmVudHNbaV07XG4gICAgICBjb25zdCBmZWRlcmF0ZWRFdmVudCA9IHRoaXMuYm9vdHN0cmFwRXZlbnQodGhpcy5yb290UG9pbnRlckV2ZW50LCBuYXRpdmVFdmVudDIpO1xuICAgICAgdGhpcy5yb290Qm91bmRhcnkubWFwRXZlbnQoZmVkZXJhdGVkRXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLnNldEN1cnNvcih0aGlzLnJvb3RCb3VuZGFyeS5jdXJzb3IpO1xuICB9XG4gIG9uUG9pbnRlck1vdmUobmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXMubW92ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnJvb3RCb3VuZGFyeS5yb290VGFyZ2V0ID0gdGhpcy5yZW5kZXJlci5sYXN0T2JqZWN0UmVuZGVyZWQ7XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiBuYXRpdmVFdmVudC5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKVxuICAgICAgcmV0dXJuO1xuICAgIEV2ZW50VGlja2VyLkV2ZW50c1RpY2tlci5wb2ludGVyTW92ZWQoKTtcbiAgICBjb25zdCBub3JtYWxpemVkRXZlbnRzID0gdGhpcy5ub3JtYWxpemVUb1BvaW50ZXJEYXRhKG5hdGl2ZUV2ZW50KTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IG5vcm1hbGl6ZWRFdmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBjb25zdCBldmVudCA9IHRoaXMuYm9vdHN0cmFwRXZlbnQodGhpcy5yb290UG9pbnRlckV2ZW50LCBub3JtYWxpemVkRXZlbnRzW2ldKTtcbiAgICAgIHRoaXMucm9vdEJvdW5kYXJ5Lm1hcEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5zZXRDdXJzb3IodGhpcy5yb290Qm91bmRhcnkuY3Vyc29yKTtcbiAgfVxuICBvblBvaW50ZXJVcChuYXRpdmVFdmVudCkge1xuICAgIGlmICghdGhpcy5mZWF0dXJlcy5jbGljaylcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnJvb3RCb3VuZGFyeS5yb290VGFyZ2V0ID0gdGhpcy5yZW5kZXJlci5sYXN0T2JqZWN0UmVuZGVyZWQ7XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiBuYXRpdmVFdmVudC5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB0YXJnZXQgPSBuYXRpdmVFdmVudC50YXJnZXQ7XG4gICAgaWYgKG5hdGl2ZUV2ZW50LmNvbXBvc2VkUGF0aCAmJiBuYXRpdmVFdmVudC5jb21wb3NlZFBhdGgoKS5sZW5ndGggPiAwKSB7XG4gICAgICB0YXJnZXQgPSBuYXRpdmVFdmVudC5jb21wb3NlZFBhdGgoKVswXTtcbiAgICB9XG4gICAgY29uc3Qgb3V0c2lkZSA9IHRhcmdldCAhPT0gdGhpcy5kb21FbGVtZW50ID8gXCJvdXRzaWRlXCIgOiBcIlwiO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRFdmVudHMgPSB0aGlzLm5vcm1hbGl6ZVRvUG9pbnRlckRhdGEobmF0aXZlRXZlbnQpO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gbm9ybWFsaXplZEV2ZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5ib290c3RyYXBFdmVudCh0aGlzLnJvb3RQb2ludGVyRXZlbnQsIG5vcm1hbGl6ZWRFdmVudHNbaV0pO1xuICAgICAgZXZlbnQudHlwZSArPSBvdXRzaWRlO1xuICAgICAgdGhpcy5yb290Qm91bmRhcnkubWFwRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLnNldEN1cnNvcih0aGlzLnJvb3RCb3VuZGFyeS5jdXJzb3IpO1xuICB9XG4gIG9uUG9pbnRlck92ZXJPdXQobmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXMuY2xpY2spXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yb290Qm91bmRhcnkucm9vdFRhcmdldCA9IHRoaXMucmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkO1xuICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMgJiYgbmF0aXZlRXZlbnQucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBub3JtYWxpemVkRXZlbnRzID0gdGhpcy5ub3JtYWxpemVUb1BvaW50ZXJEYXRhKG5hdGl2ZUV2ZW50KTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IG5vcm1hbGl6ZWRFdmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBjb25zdCBldmVudCA9IHRoaXMuYm9vdHN0cmFwRXZlbnQodGhpcy5yb290UG9pbnRlckV2ZW50LCBub3JtYWxpemVkRXZlbnRzW2ldKTtcbiAgICAgIHRoaXMucm9vdEJvdW5kYXJ5Lm1hcEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5zZXRDdXJzb3IodGhpcy5yb290Qm91bmRhcnkuY3Vyc29yKTtcbiAgfVxuICBvbldoZWVsKG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzLndoZWVsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHdoZWVsRXZlbnQgPSB0aGlzLm5vcm1hbGl6ZVdoZWVsRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIHRoaXMucm9vdEJvdW5kYXJ5LnJvb3RUYXJnZXQgPSB0aGlzLnJlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZDtcbiAgICB0aGlzLnJvb3RCb3VuZGFyeS5tYXBFdmVudCh3aGVlbEV2ZW50KTtcbiAgfVxuICBzZXRUYXJnZXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50cygpO1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgRXZlbnRUaWNrZXIuRXZlbnRzVGlja2VyLmRvbUVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuYWRkRXZlbnRzKCk7XG4gIH1cbiAgYWRkRXZlbnRzKCkge1xuICAgIGlmICh0aGlzLmV2ZW50c0FkZGVkIHx8ICF0aGlzLmRvbUVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgRXZlbnRUaWNrZXIuRXZlbnRzVGlja2VyLmFkZFRpY2tlckxpc3RlbmVyKCk7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLmRvbUVsZW1lbnQuc3R5bGU7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBpZiAoZ2xvYmFsVGhpcy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCkge1xuICAgICAgICBzdHlsZS5tc0NvbnRlbnRab29taW5nID0gXCJub25lXCI7XG4gICAgICAgIHN0eWxlLm1zVG91Y2hBY3Rpb24gPSBcIm5vbmVcIjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgc3R5bGUudG91Y2hBY3Rpb24gPSBcIm5vbmVcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzKSB7XG4gICAgICBnbG9iYWxUaGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLm9uUG9pbnRlck1vdmUsIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLm9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgdGhpcy5vblBvaW50ZXJPdmVyT3V0LCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm92ZXJcIiwgdGhpcy5vblBvaW50ZXJPdmVyT3V0LCB0cnVlKTtcbiAgICAgIGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLm9uUG9pbnRlclVwLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xvYmFsVGhpcy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMub25Qb2ludGVyTW92ZSwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCB0aGlzLm9uUG9pbnRlck92ZXJPdXQsIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgdGhpcy5vblBvaW50ZXJPdmVyT3V0LCB0cnVlKTtcbiAgICAgIGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5vblBvaW50ZXJVcCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLm9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLm9uUG9pbnRlclVwLCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMub25Qb2ludGVyTW92ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdGhpcy5vbldoZWVsLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuZXZlbnRzQWRkZWQgPSB0cnVlO1xuICB9XG4gIHJlbW92ZUV2ZW50cygpIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRzQWRkZWQgfHwgIXRoaXMuZG9tRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBFdmVudFRpY2tlci5FdmVudHNUaWNrZXIucmVtb3ZlVGlja2VyTGlzdGVuZXIoKTtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuZG9tRWxlbWVudC5zdHlsZTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCkge1xuICAgICAgc3R5bGUubXNDb250ZW50Wm9vbWluZyA9IFwiXCI7XG4gICAgICBzdHlsZS5tc1RvdWNoQWN0aW9uID0gXCJcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzKSB7XG4gICAgICBzdHlsZS50b3VjaEFjdGlvbiA9IFwiXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLnN1cHBvcnRzUG9pbnRlckV2ZW50cykge1xuICAgICAgZ2xvYmFsVGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy5vblBvaW50ZXJNb3ZlLCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy5vblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmxlYXZlXCIsIHRoaXMub25Qb2ludGVyT3Zlck91dCwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJvdmVyXCIsIHRoaXMub25Qb2ludGVyT3Zlck91dCwgdHJ1ZSk7XG4gICAgICBnbG9iYWxUaGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy5vblBvaW50ZXJVcCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsb2JhbFRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm9uUG9pbnRlck1vdmUsIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5vblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgdGhpcy5vblBvaW50ZXJPdmVyT3V0LCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIHRoaXMub25Qb2ludGVyT3Zlck91dCwgdHJ1ZSk7XG4gICAgICBnbG9iYWxUaGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMub25Qb2ludGVyVXAsIHRydWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzKSB7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5vblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5vblBvaW50ZXJVcCwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLm9uUG9pbnRlck1vdmUsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMub25XaGVlbCwgdHJ1ZSk7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmV2ZW50c0FkZGVkID0gZmFsc2U7XG4gIH1cbiAgbWFwUG9zaXRpb25Ub1BvaW50KHBvaW50LCB4LCB5KSB7XG4gICAgbGV0IHJlY3Q7XG4gICAgaWYgKCF0aGlzLmRvbUVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgcmVjdCA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IHRoaXMuZG9tRWxlbWVudC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmRvbUVsZW1lbnQuaGVpZ2h0LFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDBcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY3QgPSB0aGlzLmRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdXRpb25NdWx0aXBsaWVyID0gMSAvIHRoaXMucmVzb2x1dGlvbjtcbiAgICBwb2ludC54ID0gKHggLSByZWN0LmxlZnQpICogKHRoaXMuZG9tRWxlbWVudC53aWR0aCAvIHJlY3Qud2lkdGgpICogcmVzb2x1dGlvbk11bHRpcGxpZXI7XG4gICAgcG9pbnQueSA9ICh5IC0gcmVjdC50b3ApICogKHRoaXMuZG9tRWxlbWVudC5oZWlnaHQgLyByZWN0LmhlaWdodCkgKiByZXNvbHV0aW9uTXVsdGlwbGllcjtcbiAgfVxuICBub3JtYWxpemVUb1BvaW50ZXJEYXRhKGV2ZW50KSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZEV2ZW50cyA9IFtdO1xuICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMgJiYgZXZlbnQgaW5zdGFuY2VvZiBUb3VjaEV2ZW50KSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGkgPSBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkgPCBsaTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2guYnV0dG9uID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLmJ1dHRvbiA9IDA7XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2guYnV0dG9ucyA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICB0b3VjaC5idXR0b25zID0gMTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5pc1ByaW1hcnkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0b3VjaC5pc1ByaW1hcnkgPSBldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSAmJiBldmVudC50eXBlID09PSBcInRvdWNoc3RhcnRcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLndpZHRoID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLndpZHRoID0gdG91Y2gucmFkaXVzWCB8fCAxO1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLmhlaWdodCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICB0b3VjaC5oZWlnaHQgPSB0b3VjaC5yYWRpdXNZIHx8IDE7XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2gudGlsdFggPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2gudGlsdFggPSAwO1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnRpbHRZID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLnRpbHRZID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5wb2ludGVyVHlwZSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICB0b3VjaC5wb2ludGVyVHlwZSA9IFwidG91Y2hcIjtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5wb2ludGVySWQgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2gucG9pbnRlcklkID0gdG91Y2guaWRlbnRpZmllciB8fCAwO1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnByZXNzdXJlID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLnByZXNzdXJlID0gdG91Y2guZm9yY2UgfHwgMC41O1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnR3aXN0ID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLnR3aXN0ID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC50YW5nZW50aWFsUHJlc3N1cmUgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2gudGFuZ2VudGlhbFByZXNzdXJlID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5sYXllclggPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2gubGF5ZXJYID0gdG91Y2gub2Zmc2V0WCA9IHRvdWNoLmNsaWVudFg7XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2gubGF5ZXJZID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLmxheWVyWSA9IHRvdWNoLm9mZnNldFkgPSB0b3VjaC5jbGllbnRZO1xuICAgICAgICB0b3VjaC5pc05vcm1hbGl6ZWQgPSB0cnVlO1xuICAgICAgICB0b3VjaC50eXBlID0gZXZlbnQudHlwZTtcbiAgICAgICAgbm9ybWFsaXplZEV2ZW50cy5wdXNoKHRvdWNoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFnbG9iYWxUaGlzLk1vdXNlRXZlbnQgfHwgZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50ICYmICghdGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMgfHwgIShldmVudCBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuUG9pbnRlckV2ZW50KSkpIHtcbiAgICAgIGNvbnN0IHRlbXBFdmVudCA9IGV2ZW50O1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wRXZlbnQuaXNQcmltYXJ5ID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0ZW1wRXZlbnQuaXNQcmltYXJ5ID0gdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2YgdGVtcEV2ZW50LndpZHRoID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0ZW1wRXZlbnQud2lkdGggPSAxO1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wRXZlbnQuaGVpZ2h0ID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0ZW1wRXZlbnQuaGVpZ2h0ID0gMTtcbiAgICAgIGlmICh0eXBlb2YgdGVtcEV2ZW50LnRpbHRYID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0ZW1wRXZlbnQudGlsdFggPSAwO1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wRXZlbnQudGlsdFkgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRlbXBFdmVudC50aWx0WSA9IDA7XG4gICAgICBpZiAodHlwZW9mIHRlbXBFdmVudC5wb2ludGVyVHlwZSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgdGVtcEV2ZW50LnBvaW50ZXJUeXBlID0gXCJtb3VzZVwiO1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wRXZlbnQucG9pbnRlcklkID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0ZW1wRXZlbnQucG9pbnRlcklkID0gTU9VU0VfUE9JTlRFUl9JRDtcbiAgICAgIGlmICh0eXBlb2YgdGVtcEV2ZW50LnByZXNzdXJlID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0ZW1wRXZlbnQucHJlc3N1cmUgPSAwLjU7XG4gICAgICBpZiAodHlwZW9mIHRlbXBFdmVudC50d2lzdCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgdGVtcEV2ZW50LnR3aXN0ID0gMDtcbiAgICAgIGlmICh0eXBlb2YgdGVtcEV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgdGVtcEV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZSA9IDA7XG4gICAgICB0ZW1wRXZlbnQuaXNOb3JtYWxpemVkID0gdHJ1ZTtcbiAgICAgIG5vcm1hbGl6ZWRFdmVudHMucHVzaCh0ZW1wRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3JtYWxpemVkRXZlbnRzLnB1c2goZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZEV2ZW50cztcbiAgfVxuICBub3JtYWxpemVXaGVlbEV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLnJvb3RXaGVlbEV2ZW50O1xuICAgIHRoaXMudHJhbnNmZXJNb3VzZURhdGEoZXZlbnQsIG5hdGl2ZUV2ZW50KTtcbiAgICBldmVudC5kZWx0YVggPSBuYXRpdmVFdmVudC5kZWx0YVg7XG4gICAgZXZlbnQuZGVsdGFZID0gbmF0aXZlRXZlbnQuZGVsdGFZO1xuICAgIGV2ZW50LmRlbHRhWiA9IG5hdGl2ZUV2ZW50LmRlbHRhWjtcbiAgICBldmVudC5kZWx0YU1vZGUgPSBuYXRpdmVFdmVudC5kZWx0YU1vZGU7XG4gICAgdGhpcy5tYXBQb3NpdGlvblRvUG9pbnQoZXZlbnQuc2NyZWVuLCBuYXRpdmVFdmVudC5jbGllbnRYLCBuYXRpdmVFdmVudC5jbGllbnRZKTtcbiAgICBldmVudC5nbG9iYWwuY29weUZyb20oZXZlbnQuc2NyZWVuKTtcbiAgICBldmVudC5vZmZzZXQuY29weUZyb20oZXZlbnQuc2NyZWVuKTtcbiAgICBldmVudC5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgIGV2ZW50LnR5cGUgPSBuYXRpdmVFdmVudC50eXBlO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICBib290c3RyYXBFdmVudChldmVudCwgbmF0aXZlRXZlbnQpIHtcbiAgICBldmVudC5vcmlnaW5hbEV2ZW50ID0gbnVsbDtcbiAgICBldmVudC5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgIGV2ZW50LnBvaW50ZXJJZCA9IG5hdGl2ZUV2ZW50LnBvaW50ZXJJZDtcbiAgICBldmVudC53aWR0aCA9IG5hdGl2ZUV2ZW50LndpZHRoO1xuICAgIGV2ZW50LmhlaWdodCA9IG5hdGl2ZUV2ZW50LmhlaWdodDtcbiAgICBldmVudC5pc1ByaW1hcnkgPSBuYXRpdmVFdmVudC5pc1ByaW1hcnk7XG4gICAgZXZlbnQucG9pbnRlclR5cGUgPSBuYXRpdmVFdmVudC5wb2ludGVyVHlwZTtcbiAgICBldmVudC5wcmVzc3VyZSA9IG5hdGl2ZUV2ZW50LnByZXNzdXJlO1xuICAgIGV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZSA9IG5hdGl2ZUV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZTtcbiAgICBldmVudC50aWx0WCA9IG5hdGl2ZUV2ZW50LnRpbHRYO1xuICAgIGV2ZW50LnRpbHRZID0gbmF0aXZlRXZlbnQudGlsdFk7XG4gICAgZXZlbnQudHdpc3QgPSBuYXRpdmVFdmVudC50d2lzdDtcbiAgICB0aGlzLnRyYW5zZmVyTW91c2VEYXRhKGV2ZW50LCBuYXRpdmVFdmVudCk7XG4gICAgdGhpcy5tYXBQb3NpdGlvblRvUG9pbnQoZXZlbnQuc2NyZWVuLCBuYXRpdmVFdmVudC5jbGllbnRYLCBuYXRpdmVFdmVudC5jbGllbnRZKTtcbiAgICBldmVudC5nbG9iYWwuY29weUZyb20oZXZlbnQuc2NyZWVuKTtcbiAgICBldmVudC5vZmZzZXQuY29weUZyb20oZXZlbnQuc2NyZWVuKTtcbiAgICBldmVudC5pc1RydXN0ZWQgPSBuYXRpdmVFdmVudC5pc1RydXN0ZWQ7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IFwicG9pbnRlcmxlYXZlXCIpIHtcbiAgICAgIGV2ZW50LnR5cGUgPSBcInBvaW50ZXJvdXRcIjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUuc3RhcnRzV2l0aChcIm1vdXNlXCIpKSB7XG4gICAgICBldmVudC50eXBlID0gZXZlbnQudHlwZS5yZXBsYWNlKFwibW91c2VcIiwgXCJwb2ludGVyXCIpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZS5zdGFydHNXaXRoKFwidG91Y2hcIikpIHtcbiAgICAgIGV2ZW50LnR5cGUgPSBUT1VDSF9UT19QT0lOVEVSW2V2ZW50LnR5cGVdIHx8IGV2ZW50LnR5cGU7XG4gICAgfVxuICAgIHJldHVybiBldmVudDtcbiAgfVxuICB0cmFuc2Zlck1vdXNlRGF0YShldmVudCwgbmF0aXZlRXZlbnQpIHtcbiAgICBldmVudC5pc1RydXN0ZWQgPSBuYXRpdmVFdmVudC5pc1RydXN0ZWQ7XG4gICAgZXZlbnQuc3JjRWxlbWVudCA9IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQ7XG4gICAgZXZlbnQudGltZVN0YW1wID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgZXZlbnQudHlwZSA9IG5hdGl2ZUV2ZW50LnR5cGU7XG4gICAgZXZlbnQuYWx0S2V5ID0gbmF0aXZlRXZlbnQuYWx0S2V5O1xuICAgIGV2ZW50LmJ1dHRvbiA9IG5hdGl2ZUV2ZW50LmJ1dHRvbjtcbiAgICBldmVudC5idXR0b25zID0gbmF0aXZlRXZlbnQuYnV0dG9ucztcbiAgICBldmVudC5jbGllbnQueCA9IG5hdGl2ZUV2ZW50LmNsaWVudFg7XG4gICAgZXZlbnQuY2xpZW50LnkgPSBuYXRpdmVFdmVudC5jbGllbnRZO1xuICAgIGV2ZW50LmN0cmxLZXkgPSBuYXRpdmVFdmVudC5jdHJsS2V5O1xuICAgIGV2ZW50Lm1ldGFLZXkgPSBuYXRpdmVFdmVudC5tZXRhS2V5O1xuICAgIGV2ZW50Lm1vdmVtZW50LnggPSBuYXRpdmVFdmVudC5tb3ZlbWVudFg7XG4gICAgZXZlbnQubW92ZW1lbnQueSA9IG5hdGl2ZUV2ZW50Lm1vdmVtZW50WTtcbiAgICBldmVudC5wYWdlLnggPSBuYXRpdmVFdmVudC5wYWdlWDtcbiAgICBldmVudC5wYWdlLnkgPSBuYXRpdmVFdmVudC5wYWdlWTtcbiAgICBldmVudC5yZWxhdGVkVGFyZ2V0ID0gbnVsbDtcbiAgICBldmVudC5zaGlmdEtleSA9IG5hdGl2ZUV2ZW50LnNoaWZ0S2V5O1xuICB9XG59O1xubGV0IEV2ZW50U3lzdGVtID0gX0V2ZW50U3lzdGVtO1xuRXZlbnRTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICBuYW1lOiBcImV2ZW50c1wiLFxuICB0eXBlOiBbXG4gICAgY29yZS5FeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICAgIGNvcmUuRXh0ZW5zaW9uVHlwZS5DYW52YXNSZW5kZXJlclN5c3RlbVxuICBdXG59O1xuRXZlbnRTeXN0ZW0uZGVmYXVsdEV2ZW50RmVhdHVyZXMgPSB7XG4gIG1vdmU6IHRydWUsXG4gIGdsb2JhbE1vdmU6IHRydWUsXG4gIGNsaWNrOiB0cnVlLFxuICB3aGVlbDogdHJ1ZVxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQoRXZlbnRTeXN0ZW0pO1xuXG5leHBvcnRzLkV2ZW50U3lzdGVtID0gRXZlbnRTeXN0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudFN5c3RlbS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG5cbmNsYXNzIEV2ZW50c1RpY2tlckNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pbnRlcmFjdGlvbkZyZXF1ZW5jeSA9IDEwO1xuICAgIHRoaXMuX2RlbHRhVGltZSA9IDA7XG4gICAgdGhpcy5fZGlkTW92ZSA9IGZhbHNlO1xuICAgIHRoaXMudGlja2VyQWRkZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXVzZVVwZGF0ZSA9IHRydWU7XG4gIH1cbiAgaW5pdChldmVudHMpIHtcbiAgICB0aGlzLnJlbW92ZVRpY2tlckxpc3RlbmVyKCk7XG4gICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgdGhpcy5pbnRlcmFjdGlvbkZyZXF1ZW5jeSA9IDEwO1xuICAgIHRoaXMuX2RlbHRhVGltZSA9IDA7XG4gICAgdGhpcy5fZGlkTW92ZSA9IGZhbHNlO1xuICAgIHRoaXMudGlja2VyQWRkZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXVzZVVwZGF0ZSA9IHRydWU7XG4gIH1cbiAgZ2V0IHBhdXNlVXBkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXVzZVVwZGF0ZTtcbiAgfVxuICBzZXQgcGF1c2VVcGRhdGUocGF1c2VkKSB7XG4gICAgdGhpcy5fcGF1c2VVcGRhdGUgPSBwYXVzZWQ7XG4gIH1cbiAgYWRkVGlja2VyTGlzdGVuZXIoKSB7XG4gICAgaWYgKHRoaXMudGlja2VyQWRkZWQgfHwgIXRoaXMuZG9tRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb3JlLlRpY2tlci5zeXN0ZW0uYWRkKHRoaXMudGlja2VyVXBkYXRlLCB0aGlzLCBjb3JlLlVQREFURV9QUklPUklUWS5JTlRFUkFDVElPTik7XG4gICAgdGhpcy50aWNrZXJBZGRlZCA9IHRydWU7XG4gIH1cbiAgcmVtb3ZlVGlja2VyTGlzdGVuZXIoKSB7XG4gICAgaWYgKCF0aGlzLnRpY2tlckFkZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvcmUuVGlja2VyLnN5c3RlbS5yZW1vdmUodGhpcy50aWNrZXJVcGRhdGUsIHRoaXMpO1xuICAgIHRoaXMudGlja2VyQWRkZWQgPSBmYWxzZTtcbiAgfVxuICBwb2ludGVyTW92ZWQoKSB7XG4gICAgdGhpcy5fZGlkTW92ZSA9IHRydWU7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGlmICghdGhpcy5kb21FbGVtZW50IHx8IHRoaXMuX3BhdXNlVXBkYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9kaWRNb3ZlKSB7XG4gICAgICB0aGlzLl9kaWRNb3ZlID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJvb3RQb2ludGVyRXZlbnQgPSB0aGlzLmV2ZW50c1tcInJvb3RQb2ludGVyRXZlbnRcIl07XG4gICAgaWYgKHRoaXMuZXZlbnRzLnN1cHBvcnRzVG91Y2hFdmVudHMgJiYgcm9vdFBvaW50ZXJFdmVudC5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGdsb2JhbFRoaXMuZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgUG9pbnRlckV2ZW50KFwicG9pbnRlcm1vdmVcIiwge1xuICAgICAgY2xpZW50WDogcm9vdFBvaW50ZXJFdmVudC5jbGllbnRYLFxuICAgICAgY2xpZW50WTogcm9vdFBvaW50ZXJFdmVudC5jbGllbnRZXG4gICAgfSkpO1xuICB9XG4gIHRpY2tlclVwZGF0ZShkZWx0YVRpbWUpIHtcbiAgICB0aGlzLl9kZWx0YVRpbWUgKz0gZGVsdGFUaW1lO1xuICAgIGlmICh0aGlzLl9kZWx0YVRpbWUgPCB0aGlzLmludGVyYWN0aW9uRnJlcXVlbmN5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RlbHRhVGltZSA9IDA7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxufVxuY29uc3QgRXZlbnRzVGlja2VyID0gbmV3IEV2ZW50c1RpY2tlckNsYXNzKCk7XG5cbmV4cG9ydHMuRXZlbnRzVGlja2VyID0gRXZlbnRzVGlja2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnRUaWNrZXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xuXG5jbGFzcyBGZWRlcmF0ZWRFdmVudCB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICB0aGlzLmJ1YmJsZXMgPSB0cnVlO1xuICAgIHRoaXMuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmNvbXBvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG4gICAgdGhpcy5ldmVudFBoYXNlID0gRmVkZXJhdGVkRXZlbnQucHJvdG90eXBlLk5PTkU7XG4gICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5sYXllciA9IG5ldyBjb3JlLlBvaW50KCk7XG4gICAgdGhpcy5wYWdlID0gbmV3IGNvcmUuUG9pbnQoKTtcbiAgICB0aGlzLk5PTkUgPSAwO1xuICAgIHRoaXMuQ0FQVFVSSU5HX1BIQVNFID0gMTtcbiAgICB0aGlzLkFUX1RBUkdFVCA9IDI7XG4gICAgdGhpcy5CVUJCTElOR19QSEFTRSA9IDM7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgfVxuICBnZXQgbGF5ZXJYKCkge1xuICAgIHJldHVybiB0aGlzLmxheWVyLng7XG4gIH1cbiAgZ2V0IGxheWVyWSgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllci55O1xuICB9XG4gIGdldCBwYWdlWCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlLng7XG4gIH1cbiAgZ2V0IHBhZ2VZKCkge1xuICAgIHJldHVybiB0aGlzLnBhZ2UueTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb21wb3NlZFBhdGgoKSB7XG4gICAgaWYgKHRoaXMubWFuYWdlciAmJiAoIXRoaXMucGF0aCB8fCB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdICE9PSB0aGlzLnRhcmdldCkpIHtcbiAgICAgIHRoaXMucGF0aCA9IHRoaXMudGFyZ2V0ID8gdGhpcy5tYW5hZ2VyLnByb3BhZ2F0aW9uUGF0aCh0aGlzLnRhcmdldCkgOiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGF0aDtcbiAgfVxuICBpbml0RXZlbnQoX3R5cGUsIF9idWJibGVzLCBfY2FuY2VsYWJsZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImluaXRFdmVudCgpIGlzIGEgbGVnYWN5IERPTSBBUEkuIEl0IGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgRmVkZXJhdGVkIEV2ZW50cyBBUEkuXCIpO1xuICB9XG4gIGluaXRVSUV2ZW50KF90eXBlQXJnLCBfYnViYmxlc0FyZywgX2NhbmNlbGFibGVBcmcsIF92aWV3QXJnLCBfZGV0YWlsQXJnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5pdFVJRXZlbnQoKSBpcyBhIGxlZ2FjeSBET00gQVBJLiBJdCBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIEZlZGVyYXRlZCBFdmVudHMgQVBJLlwiKTtcbiAgfVxuICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICBpZiAodGhpcy5uYXRpdmVFdmVudCBpbnN0YW5jZW9mIEV2ZW50ICYmIHRoaXMubmF0aXZlRXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgdGhpcy5uYXRpdmVFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICB9XG4gIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcbiAgICB0aGlzLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkID0gdHJ1ZTtcbiAgfVxuICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuICB9XG59XG5cbmV4cG9ydHMuRmVkZXJhdGVkRXZlbnQgPSBGZWRlcmF0ZWRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZlZGVyYXRlZEV2ZW50LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GZWRlcmF0ZWRFdmVudE1hcC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgZGlzcGxheSA9IHJlcXVpcmUoJ0BwaXhpL2Rpc3BsYXknKTtcbnZhciBFdmVudFN5c3RlbSA9IHJlcXVpcmUoJy4vRXZlbnRTeXN0ZW0uanMnKTtcbnZhciBGZWRlcmF0ZWRFdmVudCA9IHJlcXVpcmUoJy4vRmVkZXJhdGVkRXZlbnQuanMnKTtcblxuZnVuY3Rpb24gY29udmVydEV2ZW50TW9kZVRvSW50ZXJhY3RpdmVNb2RlKG1vZGUpIHtcbiAgcmV0dXJuIG1vZGUgPT09IFwiZHluYW1pY1wiIHx8IG1vZGUgPT09IFwic3RhdGljXCI7XG59XG5jb25zdCBGZWRlcmF0ZWREaXNwbGF5T2JqZWN0ID0ge1xuICBvbmNsaWNrOiBudWxsLFxuICBvbm1vdXNlZG93bjogbnVsbCxcbiAgb25tb3VzZWVudGVyOiBudWxsLFxuICBvbm1vdXNlbGVhdmU6IG51bGwsXG4gIG9ubW91c2Vtb3ZlOiBudWxsLFxuICBvbmdsb2JhbG1vdXNlbW92ZTogbnVsbCxcbiAgb25tb3VzZW91dDogbnVsbCxcbiAgb25tb3VzZW92ZXI6IG51bGwsXG4gIG9ubW91c2V1cDogbnVsbCxcbiAgb25tb3VzZXVwb3V0c2lkZTogbnVsbCxcbiAgb25wb2ludGVyY2FuY2VsOiBudWxsLFxuICBvbnBvaW50ZXJkb3duOiBudWxsLFxuICBvbnBvaW50ZXJlbnRlcjogbnVsbCxcbiAgb25wb2ludGVybGVhdmU6IG51bGwsXG4gIG9ucG9pbnRlcm1vdmU6IG51bGwsXG4gIG9uZ2xvYmFscG9pbnRlcm1vdmU6IG51bGwsXG4gIG9ucG9pbnRlcm91dDogbnVsbCxcbiAgb25wb2ludGVyb3ZlcjogbnVsbCxcbiAgb25wb2ludGVydGFwOiBudWxsLFxuICBvbnBvaW50ZXJ1cDogbnVsbCxcbiAgb25wb2ludGVydXBvdXRzaWRlOiBudWxsLFxuICBvbnJpZ2h0Y2xpY2s6IG51bGwsXG4gIG9ucmlnaHRkb3duOiBudWxsLFxuICBvbnJpZ2h0dXA6IG51bGwsXG4gIG9ucmlnaHR1cG91dHNpZGU6IG51bGwsXG4gIG9udGFwOiBudWxsLFxuICBvbnRvdWNoY2FuY2VsOiBudWxsLFxuICBvbnRvdWNoZW5kOiBudWxsLFxuICBvbnRvdWNoZW5kb3V0c2lkZTogbnVsbCxcbiAgb250b3VjaG1vdmU6IG51bGwsXG4gIG9uZ2xvYmFsdG91Y2htb3ZlOiBudWxsLFxuICBvbnRvdWNoc3RhcnQ6IG51bGwsXG4gIG9ud2hlZWw6IG51bGwsXG4gIF9pbnRlcm5hbEludGVyYWN0aXZlOiB2b2lkIDAsXG4gIGdldCBpbnRlcmFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxJbnRlcmFjdGl2ZSA/PyBjb252ZXJ0RXZlbnRNb2RlVG9JbnRlcmFjdGl2ZU1vZGUoRXZlbnRTeXN0ZW0uRXZlbnRTeXN0ZW0uZGVmYXVsdEV2ZW50TW9kZSk7XG4gIH0sXG4gIHNldCBpbnRlcmFjdGl2ZSh2YWx1ZSkge1xuICAgIGNvcmUudXRpbHMuZGVwcmVjYXRpb24oXCI3LjIuMFwiLCBgU2V0dGluZyBpbnRlcmFjdGl2ZSBpcyBkZXByZWNhdGVkLCB1c2UgZXZlbnRNb2RlID0gJ25vbmUnLydwYXNzaXZlJy8nYXV0bycvJ3N0YXRpYycvJ2R5bmFtaWMnIGluc3RlYWQuYCk7XG4gICAgdGhpcy5faW50ZXJuYWxJbnRlcmFjdGl2ZSA9IHZhbHVlO1xuICAgIHRoaXMuZXZlbnRNb2RlID0gdmFsdWUgPyBcInN0YXRpY1wiIDogXCJhdXRvXCI7XG4gIH0sXG4gIF9pbnRlcm5hbEV2ZW50TW9kZTogdm9pZCAwLFxuICBnZXQgZXZlbnRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbEV2ZW50TW9kZSA/PyBFdmVudFN5c3RlbS5FdmVudFN5c3RlbS5kZWZhdWx0RXZlbnRNb2RlO1xuICB9LFxuICBzZXQgZXZlbnRNb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5faW50ZXJuYWxJbnRlcmFjdGl2ZSA9IGNvbnZlcnRFdmVudE1vZGVUb0ludGVyYWN0aXZlTW9kZSh2YWx1ZSk7XG4gICAgdGhpcy5faW50ZXJuYWxFdmVudE1vZGUgPSB2YWx1ZTtcbiAgfSxcbiAgaXNJbnRlcmFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudE1vZGUgPT09IFwic3RhdGljXCIgfHwgdGhpcy5ldmVudE1vZGUgPT09IFwiZHluYW1pY1wiO1xuICB9LFxuICBpbnRlcmFjdGl2ZUNoaWxkcmVuOiB0cnVlLFxuICBoaXRBcmVhOiBudWxsLFxuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2FwdHVyZSA9IHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIiAmJiBvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuY2FwdHVyZTtcbiAgICBjb25zdCBjb250ZXh0ID0gdHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIgPyB2b2lkIDAgOiBsaXN0ZW5lcjtcbiAgICB0eXBlID0gY2FwdHVyZSA/IGAke3R5cGV9Y2FwdHVyZWAgOiB0eXBlO1xuICAgIGxpc3RlbmVyID0gdHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIgPyBsaXN0ZW5lciA6IGxpc3RlbmVyLmhhbmRsZUV2ZW50O1xuICAgIHRoaXMub24odHlwZSwgbGlzdGVuZXIsIGNvbnRleHQpO1xuICB9LFxuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2FwdHVyZSA9IHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIiAmJiBvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuY2FwdHVyZTtcbiAgICBjb25zdCBjb250ZXh0ID0gdHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIgPyB2b2lkIDAgOiBsaXN0ZW5lcjtcbiAgICB0eXBlID0gY2FwdHVyZSA/IGAke3R5cGV9Y2FwdHVyZWAgOiB0eXBlO1xuICAgIGxpc3RlbmVyID0gdHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIgPyBsaXN0ZW5lciA6IGxpc3RlbmVyLmhhbmRsZUV2ZW50O1xuICAgIHRoaXMub2ZmKHR5cGUsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgfSxcbiAgZGlzcGF0Y2hFdmVudChlKSB7XG4gICAgaWYgKCEoZSBpbnN0YW5jZW9mIEZlZGVyYXRlZEV2ZW50LkZlZGVyYXRlZEV2ZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzcGxheU9iamVjdCBjYW5ub3QgcHJvcGFnYXRlIGV2ZW50cyBvdXRzaWRlIG9mIHRoZSBGZWRlcmF0ZWQgRXZlbnRzIEFQSVwiKTtcbiAgICB9XG4gICAgZS5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG4gICAgZS5wYXRoID0gbnVsbDtcbiAgICBlLnRhcmdldCA9IHRoaXM7XG4gICAgZS5tYW5hZ2VyLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgcmV0dXJuICFlLmRlZmF1bHRQcmV2ZW50ZWQ7XG4gIH1cbn07XG5kaXNwbGF5LkRpc3BsYXlPYmplY3QubWl4aW4oRmVkZXJhdGVkRGlzcGxheU9iamVjdCk7XG5cbmV4cG9ydHMuRmVkZXJhdGVkRGlzcGxheU9iamVjdCA9IEZlZGVyYXRlZERpc3BsYXlPYmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GZWRlcmF0ZWRFdmVudFRhcmdldC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgRmVkZXJhdGVkRXZlbnQgPSByZXF1aXJlKCcuL0ZlZGVyYXRlZEV2ZW50LmpzJyk7XG5cbmNsYXNzIEZlZGVyYXRlZE1vdXNlRXZlbnQgZXh0ZW5kcyBGZWRlcmF0ZWRFdmVudC5GZWRlcmF0ZWRFdmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jbGllbnQgPSBuZXcgY29yZS5Qb2ludCgpO1xuICAgIHRoaXMubW92ZW1lbnQgPSBuZXcgY29yZS5Qb2ludCgpO1xuICAgIHRoaXMub2Zmc2V0ID0gbmV3IGNvcmUuUG9pbnQoKTtcbiAgICB0aGlzLmdsb2JhbCA9IG5ldyBjb3JlLlBvaW50KCk7XG4gICAgdGhpcy5zY3JlZW4gPSBuZXcgY29yZS5Qb2ludCgpO1xuICB9XG4gIGdldCBjbGllbnRYKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC54O1xuICB9XG4gIGdldCBjbGllbnRZKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC55O1xuICB9XG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudFg7XG4gIH1cbiAgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50WTtcbiAgfVxuICBnZXQgbW92ZW1lbnRYKCkge1xuICAgIHJldHVybiB0aGlzLm1vdmVtZW50Lng7XG4gIH1cbiAgZ2V0IG1vdmVtZW50WSgpIHtcbiAgICByZXR1cm4gdGhpcy5tb3ZlbWVudC55O1xuICB9XG4gIGdldCBvZmZzZXRYKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldC54O1xuICB9XG4gIGdldCBvZmZzZXRZKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldC55O1xuICB9XG4gIGdldCBnbG9iYWxYKCkge1xuICAgIHJldHVybiB0aGlzLmdsb2JhbC54O1xuICB9XG4gIGdldCBnbG9iYWxZKCkge1xuICAgIHJldHVybiB0aGlzLmdsb2JhbC55O1xuICB9XG4gIGdldCBzY3JlZW5YKCkge1xuICAgIHJldHVybiB0aGlzLnNjcmVlbi54O1xuICB9XG4gIGdldCBzY3JlZW5ZKCkge1xuICAgIHJldHVybiB0aGlzLnNjcmVlbi55O1xuICB9XG4gIGdldExvY2FsUG9zaXRpb24oZGlzcGxheU9iamVjdCwgcG9pbnQsIGdsb2JhbFBvcykge1xuICAgIHJldHVybiBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShnbG9iYWxQb3MgfHwgdGhpcy5nbG9iYWwsIHBvaW50KTtcbiAgfVxuICBnZXRNb2RpZmllclN0YXRlKGtleSkge1xuICAgIHJldHVybiBcImdldE1vZGlmaWVyU3RhdGVcIiBpbiB0aGlzLm5hdGl2ZUV2ZW50ICYmIHRoaXMubmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXkpO1xuICB9XG4gIGluaXRNb3VzZUV2ZW50KF90eXBlQXJnLCBfY2FuQnViYmxlQXJnLCBfY2FuY2VsYWJsZUFyZywgX3ZpZXdBcmcsIF9kZXRhaWxBcmcsIF9zY3JlZW5YQXJnLCBfc2NyZWVuWUFyZywgX2NsaWVudFhBcmcsIF9jbGllbnRZQXJnLCBfY3RybEtleUFyZywgX2FsdEtleUFyZywgX3NoaWZ0S2V5QXJnLCBfbWV0YUtleUFyZywgX2J1dHRvbkFyZywgX3JlbGF0ZWRUYXJnZXRBcmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgfVxufVxuXG5leHBvcnRzLkZlZGVyYXRlZE1vdXNlRXZlbnQgPSBGZWRlcmF0ZWRNb3VzZUV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmVkZXJhdGVkTW91c2VFdmVudC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIEZlZGVyYXRlZE1vdXNlRXZlbnQgPSByZXF1aXJlKCcuL0ZlZGVyYXRlZE1vdXNlRXZlbnQuanMnKTtcblxuY2xhc3MgRmVkZXJhdGVkUG9pbnRlckV2ZW50IGV4dGVuZHMgRmVkZXJhdGVkTW91c2VFdmVudC5GZWRlcmF0ZWRNb3VzZUV2ZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5pc1ByaW1hcnkgPSBmYWxzZTtcbiAgfVxuICBnZXRDb2FsZXNjZWRFdmVudHMoKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gXCJwb2ludGVybW92ZVwiIHx8IHRoaXMudHlwZSA9PT0gXCJtb3VzZW1vdmVcIiB8fCB0aGlzLnR5cGUgPT09IFwidG91Y2htb3ZlXCIpIHtcbiAgICAgIHJldHVybiBbdGhpc107XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXRQcmVkaWN0ZWRFdmVudHMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0UHJlZGljdGVkRXZlbnRzIGlzIG5vdCBzdXBwb3J0ZWQhXCIpO1xuICB9XG59XG5cbmV4cG9ydHMuRmVkZXJhdGVkUG9pbnRlckV2ZW50ID0gRmVkZXJhdGVkUG9pbnRlckV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmVkZXJhdGVkUG9pbnRlckV2ZW50LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgRmVkZXJhdGVkTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vRmVkZXJhdGVkTW91c2VFdmVudC5qcycpO1xuXG5jbGFzcyBGZWRlcmF0ZWRXaGVlbEV2ZW50IGV4dGVuZHMgRmVkZXJhdGVkTW91c2VFdmVudC5GZWRlcmF0ZWRNb3VzZUV2ZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLkRPTV9ERUxUQV9QSVhFTCA9IDA7XG4gICAgdGhpcy5ET01fREVMVEFfTElORSA9IDE7XG4gICAgdGhpcy5ET01fREVMVEFfUEFHRSA9IDI7XG4gIH1cbn1cbkZlZGVyYXRlZFdoZWVsRXZlbnQuRE9NX0RFTFRBX1BJWEVMID0gMDtcbkZlZGVyYXRlZFdoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkUgPSAxO1xuRmVkZXJhdGVkV2hlZWxFdmVudC5ET01fREVMVEFfUEFHRSA9IDI7XG5cbmV4cG9ydHMuRmVkZXJhdGVkV2hlZWxFdmVudCA9IEZlZGVyYXRlZFdoZWVsRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GZWRlcmF0ZWRXaGVlbEV2ZW50LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgRXZlbnRCb3VuZGFyeSA9IHJlcXVpcmUoJy4vRXZlbnRCb3VuZGFyeS5qcycpO1xudmFyIEV2ZW50U3lzdGVtID0gcmVxdWlyZSgnLi9FdmVudFN5c3RlbS5qcycpO1xudmFyIEZlZGVyYXRlZEV2ZW50ID0gcmVxdWlyZSgnLi9GZWRlcmF0ZWRFdmVudC5qcycpO1xucmVxdWlyZSgnLi9GZWRlcmF0ZWRFdmVudE1hcC5qcycpO1xudmFyIEZlZGVyYXRlZEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9GZWRlcmF0ZWRFdmVudFRhcmdldC5qcycpO1xudmFyIEZlZGVyYXRlZE1vdXNlRXZlbnQgPSByZXF1aXJlKCcuL0ZlZGVyYXRlZE1vdXNlRXZlbnQuanMnKTtcbnZhciBGZWRlcmF0ZWRQb2ludGVyRXZlbnQgPSByZXF1aXJlKCcuL0ZlZGVyYXRlZFBvaW50ZXJFdmVudC5qcycpO1xudmFyIEZlZGVyYXRlZFdoZWVsRXZlbnQgPSByZXF1aXJlKCcuL0ZlZGVyYXRlZFdoZWVsRXZlbnQuanMnKTtcblxuXG5cbmV4cG9ydHMuRXZlbnRCb3VuZGFyeSA9IEV2ZW50Qm91bmRhcnkuRXZlbnRCb3VuZGFyeTtcbmV4cG9ydHMuRXZlbnRTeXN0ZW0gPSBFdmVudFN5c3RlbS5FdmVudFN5c3RlbTtcbmV4cG9ydHMuRmVkZXJhdGVkRXZlbnQgPSBGZWRlcmF0ZWRFdmVudC5GZWRlcmF0ZWRFdmVudDtcbmV4cG9ydHMuRmVkZXJhdGVkRGlzcGxheU9iamVjdCA9IEZlZGVyYXRlZEV2ZW50VGFyZ2V0LkZlZGVyYXRlZERpc3BsYXlPYmplY3Q7XG5leHBvcnRzLkZlZGVyYXRlZE1vdXNlRXZlbnQgPSBGZWRlcmF0ZWRNb3VzZUV2ZW50LkZlZGVyYXRlZE1vdXNlRXZlbnQ7XG5leHBvcnRzLkZlZGVyYXRlZFBvaW50ZXJFdmVudCA9IEZlZGVyYXRlZFBvaW50ZXJFdmVudC5GZWRlcmF0ZWRQb2ludGVyRXZlbnQ7XG5leHBvcnRzLkZlZGVyYXRlZFdoZWVsRXZlbnQgPSBGZWRlcmF0ZWRXaGVlbEV2ZW50LkZlZGVyYXRlZFdoZWVsRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIEV4dGVuc2lvblR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChFeHRlbnNpb25UeXBlMikgPT4ge1xuICBFeHRlbnNpb25UeXBlMltcIlJlbmRlcmVyXCJdID0gXCJyZW5kZXJlclwiO1xuICBFeHRlbnNpb25UeXBlMltcIkFwcGxpY2F0aW9uXCJdID0gXCJhcHBsaWNhdGlvblwiO1xuICBFeHRlbnNpb25UeXBlMltcIlJlbmRlcmVyU3lzdGVtXCJdID0gXCJyZW5kZXJlci13ZWJnbC1zeXN0ZW1cIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJSZW5kZXJlclBsdWdpblwiXSA9IFwicmVuZGVyZXItd2ViZ2wtcGx1Z2luXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiQ2FudmFzUmVuZGVyZXJTeXN0ZW1cIl0gPSBcInJlbmRlcmVyLWNhbnZhcy1zeXN0ZW1cIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJDYW52YXNSZW5kZXJlclBsdWdpblwiXSA9IFwicmVuZGVyZXItY2FudmFzLXBsdWdpblwiO1xuICBFeHRlbnNpb25UeXBlMltcIkFzc2V0XCJdID0gXCJhc3NldFwiO1xuICBFeHRlbnNpb25UeXBlMltcIkxvYWRQYXJzZXJcIl0gPSBcImxvYWQtcGFyc2VyXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiUmVzb2x2ZVBhcnNlclwiXSA9IFwicmVzb2x2ZS1wYXJzZXJcIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJDYWNoZVBhcnNlclwiXSA9IFwiY2FjaGUtcGFyc2VyXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiRGV0ZWN0aW9uUGFyc2VyXCJdID0gXCJkZXRlY3Rpb24tcGFyc2VyXCI7XG4gIHJldHVybiBFeHRlbnNpb25UeXBlMjtcbn0pKEV4dGVuc2lvblR5cGUgfHwge30pO1xuY29uc3Qgbm9ybWFsaXplRXh0ZW5zaW9uID0gKGV4dCkgPT4ge1xuICBpZiAodHlwZW9mIGV4dCA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBleHQgPT09IFwib2JqZWN0XCIgJiYgZXh0LmV4dGVuc2lvbikge1xuICAgIGlmICghZXh0LmV4dGVuc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXh0ZW5zaW9uIGNsYXNzIG11c3QgaGF2ZSBhbiBleHRlbnNpb24gb2JqZWN0XCIpO1xuICAgIH1cbiAgICBjb25zdCBtZXRhZGF0YSA9IHR5cGVvZiBleHQuZXh0ZW5zaW9uICE9PSBcIm9iamVjdFwiID8geyB0eXBlOiBleHQuZXh0ZW5zaW9uIH0gOiBleHQuZXh0ZW5zaW9uO1xuICAgIGV4dCA9IHsgLi4ubWV0YWRhdGEsIHJlZjogZXh0IH07XG4gIH1cbiAgaWYgKHR5cGVvZiBleHQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBleHQgPSB7IC4uLmV4dCB9O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZXh0ZW5zaW9uIHR5cGVcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBleHQudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGV4dC50eXBlID0gW2V4dC50eXBlXTtcbiAgfVxuICByZXR1cm4gZXh0O1xufTtcbmNvbnN0IG5vcm1hbGl6ZVByaW9yaXR5ID0gKGV4dCwgZGVmYXVsdFByaW9yaXR5KSA9PiBub3JtYWxpemVFeHRlbnNpb24oZXh0KS5wcmlvcml0eSA/PyBkZWZhdWx0UHJpb3JpdHk7XG5jb25zdCBleHRlbnNpb25zID0ge1xuICBfYWRkSGFuZGxlcnM6IHt9LFxuICBfcmVtb3ZlSGFuZGxlcnM6IHt9LFxuICBfcXVldWU6IHt9LFxuICByZW1vdmUoLi4uZXh0ZW5zaW9uczIpIHtcbiAgICBleHRlbnNpb25zMi5tYXAobm9ybWFsaXplRXh0ZW5zaW9uKS5mb3JFYWNoKChleHQpID0+IHtcbiAgICAgIGV4dC50eXBlLmZvckVhY2goKHR5cGUpID0+IHRoaXMuX3JlbW92ZUhhbmRsZXJzW3R5cGVdPy4oZXh0KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZCguLi5leHRlbnNpb25zMikge1xuICAgIGV4dGVuc2lvbnMyLm1hcChub3JtYWxpemVFeHRlbnNpb24pLmZvckVhY2goKGV4dCkgPT4ge1xuICAgICAgZXh0LnR5cGUuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuX2FkZEhhbmRsZXJzO1xuICAgICAgICBjb25zdCBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgICAgICBpZiAoIWhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICAgICAgcXVldWVbdHlwZV0gPSBxdWV1ZVt0eXBlXSB8fCBbXTtcbiAgICAgICAgICBxdWV1ZVt0eXBlXS5wdXNoKGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlcnNbdHlwZV0oZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGhhbmRsZSh0eXBlLCBvbkFkZCwgb25SZW1vdmUpIHtcbiAgICBjb25zdCBhZGRIYW5kbGVycyA9IHRoaXMuX2FkZEhhbmRsZXJzO1xuICAgIGNvbnN0IHJlbW92ZUhhbmRsZXJzID0gdGhpcy5fcmVtb3ZlSGFuZGxlcnM7XG4gICAgaWYgKGFkZEhhbmRsZXJzW3R5cGVdIHx8IHJlbW92ZUhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4dGVuc2lvbiB0eXBlICR7dHlwZX0gYWxyZWFkeSBoYXMgYSBoYW5kbGVyYCk7XG4gICAgfVxuICAgIGFkZEhhbmRsZXJzW3R5cGVdID0gb25BZGQ7XG4gICAgcmVtb3ZlSGFuZGxlcnNbdHlwZV0gPSBvblJlbW92ZTtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIGlmIChxdWV1ZVt0eXBlXSkge1xuICAgICAgcXVldWVbdHlwZV0uZm9yRWFjaCgoZXh0KSA9PiBvbkFkZChleHQpKTtcbiAgICAgIGRlbGV0ZSBxdWV1ZVt0eXBlXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGhhbmRsZUJ5TWFwKHR5cGUsIG1hcCkge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZSh0eXBlLCAoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBtYXBbZXh0ZW5zaW9uLm5hbWVdID0gZXh0ZW5zaW9uLnJlZjtcbiAgICB9LCAoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBkZWxldGUgbWFwW2V4dGVuc2lvbi5uYW1lXTtcbiAgICB9KTtcbiAgfSxcbiAgaGFuZGxlQnlMaXN0KHR5cGUsIGxpc3QsIGRlZmF1bHRQcmlvcml0eSA9IC0xKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlKHR5cGUsIChleHRlbnNpb24pID0+IHtcbiAgICAgIGlmIChsaXN0LmluY2x1ZGVzKGV4dGVuc2lvbi5yZWYpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxpc3QucHVzaChleHRlbnNpb24ucmVmKTtcbiAgICAgIGxpc3Quc29ydCgoYSwgYikgPT4gbm9ybWFsaXplUHJpb3JpdHkoYiwgZGVmYXVsdFByaW9yaXR5KSAtIG5vcm1hbGl6ZVByaW9yaXR5KGEsIGRlZmF1bHRQcmlvcml0eSkpO1xuICAgIH0sIChleHRlbnNpb24pID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGlzdC5pbmRleE9mKGV4dGVuc2lvbi5yZWYpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbmV4cG9ydHMuRXh0ZW5zaW9uVHlwZSA9IEV4dGVuc2lvblR5cGU7XG5leHBvcnRzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xuXG5jb25zdCBURU1QX1JFQ1QgPSBuZXcgY29yZS5SZWN0YW5nbGUoKTtcbmNvbnN0IEJZVEVTX1BFUl9QSVhFTCA9IDQ7XG5jb25zdCBfRXh0cmFjdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgYXN5bmMgaW1hZ2UodGFyZ2V0LCBmb3JtYXQsIHF1YWxpdHkpIHtcbiAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGltYWdlLnNyYyA9IGF3YWl0IHRoaXMuYmFzZTY0KHRhcmdldCwgZm9ybWF0LCBxdWFsaXR5KTtcbiAgICByZXR1cm4gaW1hZ2U7XG4gIH1cbiAgYXN5bmMgYmFzZTY0KHRhcmdldCwgZm9ybWF0LCBxdWFsaXR5KSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXModGFyZ2V0KTtcbiAgICBpZiAoY2FudmFzLnRvQmxvYiAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjYW52YXMudG9CbG9iKChibG9iKSA9PiB7XG4gICAgICAgICAgaWYgKCFibG9iKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiSUNhbnZhcy50b0Jsb2IgZmFpbGVkIVwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XG4gICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgICAgIH0sIGZvcm1hdCwgcXVhbGl0eSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGNhbnZhcy50b0RhdGFVUkwgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoZm9ybWF0LCBxdWFsaXR5KTtcbiAgICB9XG4gICAgaWYgKGNhbnZhcy5jb252ZXJ0VG9CbG9iICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBjYW52YXMuY29udmVydFRvQmxvYih7IHR5cGU6IGZvcm1hdCwgcXVhbGl0eSB9KTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXh0cmFjdC5iYXNlNjQoKSByZXF1aXJlcyBJQ2FudmFzLnRvRGF0YVVSTCwgSUNhbnZhcy50b0Jsb2IsIG9yIElDYW52YXMuY29udmVydFRvQmxvYiB0byBiZSBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBjYW52YXModGFyZ2V0LCBmcmFtZSkge1xuICAgIGNvbnN0IHsgcGl4ZWxzLCB3aWR0aCwgaGVpZ2h0LCBmbGlwWSB9ID0gdGhpcy5fcmF3UGl4ZWxzKHRhcmdldCwgZnJhbWUpO1xuICAgIGlmIChmbGlwWSkge1xuICAgICAgX0V4dHJhY3QuX2ZsaXBZKHBpeGVscywgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIF9FeHRyYWN0Ll91bnByZW11bHRpcGx5QWxwaGEocGl4ZWxzKTtcbiAgICBjb25zdCBjYW52YXNCdWZmZXIgPSBuZXcgY29yZS51dGlscy5DYW52YXNSZW5kZXJUYXJnZXQod2lkdGgsIGhlaWdodCwgMSk7XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gbmV3IEltYWdlRGF0YShuZXcgVWludDhDbGFtcGVkQXJyYXkocGl4ZWxzLmJ1ZmZlciksIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNhbnZhc0J1ZmZlci5jb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgIHJldHVybiBjYW52YXNCdWZmZXIuY2FudmFzO1xuICB9XG4gIHBpeGVscyh0YXJnZXQsIGZyYW1lKSB7XG4gICAgY29uc3QgeyBwaXhlbHMsIHdpZHRoLCBoZWlnaHQsIGZsaXBZIH0gPSB0aGlzLl9yYXdQaXhlbHModGFyZ2V0LCBmcmFtZSk7XG4gICAgaWYgKGZsaXBZKSB7XG4gICAgICBfRXh0cmFjdC5fZmxpcFkocGl4ZWxzLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgX0V4dHJhY3QuX3VucHJlbXVsdGlwbHlBbHBoYShwaXhlbHMpO1xuICAgIHJldHVybiBwaXhlbHM7XG4gIH1cbiAgX3Jhd1BpeGVscyh0YXJnZXQsIGZyYW1lKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIGlmICghcmVuZGVyZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBFeHRyYWN0IGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkXCIpO1xuICAgIH1cbiAgICBsZXQgcmVzb2x1dGlvbjtcbiAgICBsZXQgZmxpcFkgPSBmYWxzZTtcbiAgICBsZXQgcmVuZGVyVGV4dHVyZTtcbiAgICBsZXQgZ2VuZXJhdGVkID0gZmFsc2U7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIGNvcmUuUmVuZGVyVGV4dHVyZSkge1xuICAgICAgICByZW5kZXJUZXh0dXJlID0gdGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyVGV4dHVyZSA9IHJlbmRlcmVyLmdlbmVyYXRlVGV4dHVyZSh0YXJnZXQsIHtcbiAgICAgICAgICByZXNvbHV0aW9uOiByZW5kZXJlci5yZXNvbHV0aW9uLFxuICAgICAgICAgIG11bHRpc2FtcGxlOiByZW5kZXJlci5tdWx0aXNhbXBsZVxuICAgICAgICB9KTtcbiAgICAgICAgZ2VuZXJhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlbmRlclRleHR1cmUpIHtcbiAgICAgIHJlc29sdXRpb24gPSByZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlLnJlc29sdXRpb247XG4gICAgICBmcmFtZSA9IGZyYW1lID8/IHJlbmRlclRleHR1cmUuZnJhbWU7XG4gICAgICBmbGlwWSA9IGZhbHNlO1xuICAgICAgaWYgKCFnZW5lcmF0ZWQpIHtcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKHJlbmRlclRleHR1cmUpO1xuICAgICAgICBjb25zdCBmYm8gPSByZW5kZXJUZXh0dXJlLmZyYW1lYnVmZmVyLmdsRnJhbWVidWZmZXJzW3JlbmRlcmVyLkNPTlRFWFRfVUlEXTtcbiAgICAgICAgaWYgKGZiby5ibGl0RnJhbWVidWZmZXIpIHtcbiAgICAgICAgICByZW5kZXJlci5mcmFtZWJ1ZmZlci5iaW5kKGZiby5ibGl0RnJhbWVidWZmZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgICAgaWYgKCFmcmFtZSkge1xuICAgICAgICBmcmFtZSA9IFRFTVBfUkVDVDtcbiAgICAgICAgZnJhbWUud2lkdGggPSByZW5kZXJlci53aWR0aCAvIHJlc29sdXRpb247XG4gICAgICAgIGZyYW1lLmhlaWdodCA9IHJlbmRlcmVyLmhlaWdodCAvIHJlc29sdXRpb247XG4gICAgICB9XG4gICAgICBmbGlwWSA9IHRydWU7XG4gICAgICByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQoKTtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKGZyYW1lLndpZHRoICogcmVzb2x1dGlvbik7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZChmcmFtZS5oZWlnaHQgKiByZXNvbHV0aW9uKTtcbiAgICBjb25zdCBwaXhlbHMgPSBuZXcgVWludDhBcnJheShCWVRFU19QRVJfUElYRUwgKiB3aWR0aCAqIGhlaWdodCk7XG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nbDtcbiAgICBnbC5yZWFkUGl4ZWxzKE1hdGgucm91bmQoZnJhbWUueCAqIHJlc29sdXRpb24pLCBNYXRoLnJvdW5kKGZyYW1lLnkgKiByZXNvbHV0aW9uKSwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWxzKTtcbiAgICBpZiAoZ2VuZXJhdGVkKSB7XG4gICAgICByZW5kZXJUZXh0dXJlPy5kZXN0cm95KHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4geyBwaXhlbHMsIHdpZHRoLCBoZWlnaHQsIGZsaXBZIH07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgX2ZsaXBZKHBpeGVscywgd2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHcgPSB3aWR0aCA8PCAyO1xuICAgIGNvbnN0IGggPSBoZWlnaHQgPj4gMTtcbiAgICBjb25zdCB0ZW1wID0gbmV3IFVpbnQ4QXJyYXkodyk7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoOyB5KyspIHtcbiAgICAgIGNvbnN0IHQgPSB5ICogdztcbiAgICAgIGNvbnN0IGIgPSAoaGVpZ2h0IC0geSAtIDEpICogdztcbiAgICAgIHRlbXAuc2V0KHBpeGVscy5zdWJhcnJheSh0LCB0ICsgdykpO1xuICAgICAgcGl4ZWxzLmNvcHlXaXRoaW4odCwgYiwgYiArIHcpO1xuICAgICAgcGl4ZWxzLnNldCh0ZW1wLCBiKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIF91bnByZW11bHRpcGx5QWxwaGEocGl4ZWxzKSB7XG4gICAgaWYgKHBpeGVscyBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XG4gICAgICBwaXhlbHMgPSBuZXcgVWludDhBcnJheShwaXhlbHMuYnVmZmVyKTtcbiAgICB9XG4gICAgY29uc3QgbiA9IHBpeGVscy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpICs9IDQpIHtcbiAgICAgIGNvbnN0IGFscGhhID0gcGl4ZWxzW2kgKyAzXTtcbiAgICAgIGlmIChhbHBoYSAhPT0gMCkge1xuICAgICAgICBjb25zdCBhID0gMjU1LjAwMSAvIGFscGhhO1xuICAgICAgICBwaXhlbHNbaV0gPSBwaXhlbHNbaV0gKiBhICsgMC41O1xuICAgICAgICBwaXhlbHNbaSArIDFdID0gcGl4ZWxzW2kgKyAxXSAqIGEgKyAwLjU7XG4gICAgICAgIHBpeGVsc1tpICsgMl0gPSBwaXhlbHNbaSArIDJdICogYSArIDAuNTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5sZXQgRXh0cmFjdCA9IF9FeHRyYWN0O1xuRXh0cmFjdC5leHRlbnNpb24gPSB7XG4gIG5hbWU6IFwiZXh0cmFjdFwiLFxuICB0eXBlOiBjb3JlLkV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW1cbn07XG5jb3JlLmV4dGVuc2lvbnMuYWRkKEV4dHJhY3QpO1xuXG5leHBvcnRzLkV4dHJhY3QgPSBFeHRyYWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXh0cmFjdC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIEV4dHJhY3QgPSByZXF1aXJlKCcuL0V4dHJhY3QuanMnKTtcblxuXG5cbmV4cG9ydHMuRXh0cmFjdCA9IEV4dHJhY3QuRXh0cmFjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBhbHBoYSA9IHJlcXVpcmUoJy4vYWxwaGEuanMnKTtcblxuY2xhc3MgQWxwaGFGaWx0ZXIgZXh0ZW5kcyBjb3JlLkZpbHRlciB7XG4gIGNvbnN0cnVjdG9yKGFscGhhJDEgPSAxKSB7XG4gICAgc3VwZXIoY29yZS5kZWZhdWx0VmVydGV4LCBhbHBoYVtcImRlZmF1bHRcIl0sIHsgdUFscGhhOiAxIH0pO1xuICAgIHRoaXMuYWxwaGEgPSBhbHBoYSQxO1xuICB9XG4gIGdldCBhbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51QWxwaGE7XG4gIH1cbiAgc2V0IGFscGhhKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51QWxwaGEgPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnRzLkFscGhhRmlsdGVyID0gQWxwaGFGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BbHBoYUZpbHRlci5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIGZsb2F0IHVBbHBoYTtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHVBbHBoYTtcXG59XFxuXCI7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZnJhZ21lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbHBoYS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIEFscGhhRmlsdGVyID0gcmVxdWlyZSgnLi9BbHBoYUZpbHRlci5qcycpO1xuXG5cblxuZXhwb3J0cy5BbHBoYUZpbHRlciA9IEFscGhhRmlsdGVyLkFscGhhRmlsdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xudmFyIEJsdXJGaWx0ZXJQYXNzID0gcmVxdWlyZSgnLi9CbHVyRmlsdGVyUGFzcy5qcycpO1xuXG5jbGFzcyBCbHVyRmlsdGVyIGV4dGVuZHMgY29yZS5GaWx0ZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlbmd0aCA9IDgsIHF1YWxpdHkgPSA0LCByZXNvbHV0aW9uID0gY29yZS5GaWx0ZXIuZGVmYXVsdFJlc29sdXRpb24sIGtlcm5lbFNpemUgPSA1KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9yZXBlYXRFZGdlUGl4ZWxzID0gZmFsc2U7XG4gICAgdGhpcy5ibHVyWEZpbHRlciA9IG5ldyBCbHVyRmlsdGVyUGFzcy5CbHVyRmlsdGVyUGFzcyh0cnVlLCBzdHJlbmd0aCwgcXVhbGl0eSwgcmVzb2x1dGlvbiwga2VybmVsU2l6ZSk7XG4gICAgdGhpcy5ibHVyWUZpbHRlciA9IG5ldyBCbHVyRmlsdGVyUGFzcy5CbHVyRmlsdGVyUGFzcyhmYWxzZSwgc3RyZW5ndGgsIHF1YWxpdHksIHJlc29sdXRpb24sIGtlcm5lbFNpemUpO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgdGhpcy5xdWFsaXR5ID0gcXVhbGl0eTtcbiAgICB0aGlzLmJsdXIgPSBzdHJlbmd0aDtcbiAgICB0aGlzLnJlcGVhdEVkZ2VQaXhlbHMgPSBmYWxzZTtcbiAgfVxuICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICBjb25zdCB4U3RyZW5ndGggPSBNYXRoLmFicyh0aGlzLmJsdXJYRmlsdGVyLnN0cmVuZ3RoKTtcbiAgICBjb25zdCB5U3RyZW5ndGggPSBNYXRoLmFicyh0aGlzLmJsdXJZRmlsdGVyLnN0cmVuZ3RoKTtcbiAgICBpZiAoeFN0cmVuZ3RoICYmIHlTdHJlbmd0aCkge1xuICAgICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gZmlsdGVyTWFuYWdlci5nZXRGaWx0ZXJUZXh0dXJlKCk7XG4gICAgICB0aGlzLmJsdXJYRmlsdGVyLmFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCByZW5kZXJUYXJnZXQsIGNvcmUuQ0xFQVJfTU9ERVMuQ0xFQVIpO1xuICAgICAgdGhpcy5ibHVyWUZpbHRlci5hcHBseShmaWx0ZXJNYW5hZ2VyLCByZW5kZXJUYXJnZXQsIG91dHB1dCwgY2xlYXJNb2RlKTtcbiAgICAgIGZpbHRlck1hbmFnZXIucmV0dXJuRmlsdGVyVGV4dHVyZShyZW5kZXJUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoeVN0cmVuZ3RoKSB7XG4gICAgICB0aGlzLmJsdXJZRmlsdGVyLmFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmx1clhGaWx0ZXIuYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFkZGluZygpIHtcbiAgICBpZiAodGhpcy5fcmVwZWF0RWRnZVBpeGVscykge1xuICAgICAgdGhpcy5wYWRkaW5nID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYWRkaW5nID0gTWF0aC5tYXgoTWF0aC5hYnModGhpcy5ibHVyWEZpbHRlci5zdHJlbmd0aCksIE1hdGguYWJzKHRoaXMuYmx1cllGaWx0ZXIuc3RyZW5ndGgpKSAqIDI7XG4gICAgfVxuICB9XG4gIGdldCBibHVyKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLmJsdXI7XG4gIH1cbiAgc2V0IGJsdXIodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJYRmlsdGVyLmJsdXIgPSB0aGlzLmJsdXJZRmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZVBhZGRpbmcoKTtcbiAgfVxuICBnZXQgcXVhbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyWEZpbHRlci5xdWFsaXR5O1xuICB9XG4gIHNldCBxdWFsaXR5KHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyWEZpbHRlci5xdWFsaXR5ID0gdGhpcy5ibHVyWUZpbHRlci5xdWFsaXR5ID0gdmFsdWU7XG4gIH1cbiAgZ2V0IGJsdXJYKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLmJsdXI7XG4gIH1cbiAgc2V0IGJsdXJYKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyWEZpbHRlci5ibHVyID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVQYWRkaW5nKCk7XG4gIH1cbiAgZ2V0IGJsdXJZKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJZRmlsdGVyLmJsdXI7XG4gIH1cbiAgc2V0IGJsdXJZKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyWUZpbHRlci5ibHVyID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVQYWRkaW5nKCk7XG4gIH1cbiAgZ2V0IGJsZW5kTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyWUZpbHRlci5ibGVuZE1vZGU7XG4gIH1cbiAgc2V0IGJsZW5kTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuYmx1cllGaWx0ZXIuYmxlbmRNb2RlID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHJlcGVhdEVkZ2VQaXhlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcGVhdEVkZ2VQaXhlbHM7XG4gIH1cbiAgc2V0IHJlcGVhdEVkZ2VQaXhlbHModmFsdWUpIHtcbiAgICB0aGlzLl9yZXBlYXRFZGdlUGl4ZWxzID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVQYWRkaW5nKCk7XG4gIH1cbn1cblxuZXhwb3J0cy5CbHVyRmlsdGVyID0gQmx1ckZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJsdXJGaWx0ZXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xudmFyIGdlbmVyYXRlQmx1ckZyYWdTb3VyY2UgPSByZXF1aXJlKCcuL2dlbmVyYXRlQmx1ckZyYWdTb3VyY2UuanMnKTtcbnZhciBnZW5lcmF0ZUJsdXJWZXJ0U291cmNlID0gcmVxdWlyZSgnLi9nZW5lcmF0ZUJsdXJWZXJ0U291cmNlLmpzJyk7XG5cbmNsYXNzIEJsdXJGaWx0ZXJQYXNzIGV4dGVuZHMgY29yZS5GaWx0ZXIge1xuICBjb25zdHJ1Y3Rvcihob3Jpem9udGFsLCBzdHJlbmd0aCA9IDgsIHF1YWxpdHkgPSA0LCByZXNvbHV0aW9uID0gY29yZS5GaWx0ZXIuZGVmYXVsdFJlc29sdXRpb24sIGtlcm5lbFNpemUgPSA1KSB7XG4gICAgY29uc3QgdmVydFNyYyA9IGdlbmVyYXRlQmx1clZlcnRTb3VyY2UuZ2VuZXJhdGVCbHVyVmVydFNvdXJjZShrZXJuZWxTaXplLCBob3Jpem9udGFsKTtcbiAgICBjb25zdCBmcmFnU3JjID0gZ2VuZXJhdGVCbHVyRnJhZ1NvdXJjZS5nZW5lcmF0ZUJsdXJGcmFnU291cmNlKGtlcm5lbFNpemUpO1xuICAgIHN1cGVyKHZlcnRTcmMsIGZyYWdTcmMpO1xuICAgIHRoaXMuaG9yaXpvbnRhbCA9IGhvcml6b250YWw7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICB0aGlzLl9xdWFsaXR5ID0gMDtcbiAgICB0aGlzLnF1YWxpdHkgPSBxdWFsaXR5O1xuICAgIHRoaXMuYmx1ciA9IHN0cmVuZ3RoO1xuICB9XG4gIGFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSkge1xuICAgIGlmIChvdXRwdXQpIHtcbiAgICAgIGlmICh0aGlzLmhvcml6b250YWwpIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aCA9IDEgLyBvdXRwdXQud2lkdGggKiAob3V0cHV0LndpZHRoIC8gaW5wdXQud2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aCA9IDEgLyBvdXRwdXQuaGVpZ2h0ICogKG91dHB1dC5oZWlnaHQgLyBpbnB1dC5oZWlnaHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5ob3Jpem9udGFsKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuc3RyZW5ndGggPSAxIC8gZmlsdGVyTWFuYWdlci5yZW5kZXJlci53aWR0aCAqIChmaWx0ZXJNYW5hZ2VyLnJlbmRlcmVyLndpZHRoIC8gaW5wdXQud2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aCA9IDEgLyBmaWx0ZXJNYW5hZ2VyLnJlbmRlcmVyLmhlaWdodCAqIChmaWx0ZXJNYW5hZ2VyLnJlbmRlcmVyLmhlaWdodCAvIGlucHV0LmhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybXMuc3RyZW5ndGggKj0gdGhpcy5zdHJlbmd0aDtcbiAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoIC89IHRoaXMucGFzc2VzO1xuICAgIGlmICh0aGlzLnBhc3NlcyA9PT0gMSkge1xuICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZW5kZXJUYXJnZXQgPSBmaWx0ZXJNYW5hZ2VyLmdldEZpbHRlclRleHR1cmUoKTtcbiAgICAgIGNvbnN0IHJlbmRlcmVyID0gZmlsdGVyTWFuYWdlci5yZW5kZXJlcjtcbiAgICAgIGxldCBmbGlwID0gaW5wdXQ7XG4gICAgICBsZXQgZmxvcCA9IHJlbmRlclRhcmdldDtcbiAgICAgIHRoaXMuc3RhdGUuYmxlbmQgPSBmYWxzZTtcbiAgICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgZmxpcCwgZmxvcCwgY29yZS5DTEVBUl9NT0RFUy5DTEVBUik7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMucGFzc2VzIC0gMTsgaSsrKSB7XG4gICAgICAgIGZpbHRlck1hbmFnZXIuYmluZEFuZENsZWFyKGZsaXAsIGNvcmUuQ0xFQVJfTU9ERVMuQkxJVCk7XG4gICAgICAgIHRoaXMudW5pZm9ybXMudVNhbXBsZXIgPSBmbG9wO1xuICAgICAgICBjb25zdCB0ZW1wID0gZmxvcDtcbiAgICAgICAgZmxvcCA9IGZsaXA7XG4gICAgICAgIGZsaXAgPSB0ZW1wO1xuICAgICAgICByZW5kZXJlci5zaGFkZXIuYmluZCh0aGlzKTtcbiAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyg1KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUuYmxlbmQgPSB0cnVlO1xuICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBmbG9wLCBvdXRwdXQsIGNsZWFyTW9kZSk7XG4gICAgICBmaWx0ZXJNYW5hZ2VyLnJldHVybkZpbHRlclRleHR1cmUocmVuZGVyVGFyZ2V0KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGJsdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZW5ndGg7XG4gIH1cbiAgc2V0IGJsdXIodmFsdWUpIHtcbiAgICB0aGlzLnBhZGRpbmcgPSAxICsgTWF0aC5hYnModmFsdWUpICogMjtcbiAgICB0aGlzLnN0cmVuZ3RoID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHF1YWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1YWxpdHk7XG4gIH1cbiAgc2V0IHF1YWxpdHkodmFsdWUpIHtcbiAgICB0aGlzLl9xdWFsaXR5ID0gdmFsdWU7XG4gICAgdGhpcy5wYXNzZXMgPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnRzLkJsdXJGaWx0ZXJQYXNzID0gQmx1ckZpbHRlclBhc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CbHVyRmlsdGVyUGFzcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY29uc3QgR0FVU1NJQU5fVkFMVUVTID0ge1xuICA1OiBbMC4xNTMzODgsIDAuMjIxNDYxLCAwLjI1MDMwMV0sXG4gIDc6IFswLjA3MTMwMywgMC4xMzE1MTQsIDAuMTg5ODc5LCAwLjIxNDYwN10sXG4gIDk6IFswLjAyODUzMiwgMC4wNjcyMzQsIDAuMTI0MDA5LCAwLjE3OTA0NCwgMC4yMDIzNl0sXG4gIDExOiBbOTNlLTQsIDAuMDI4MDAyLCAwLjA2NTk4NCwgMC4xMjE3MDMsIDAuMTc1NzEzLCAwLjE5ODU5Nl0sXG4gIDEzOiBbMjQwNmUtNiwgOTI1NWUtNiwgMC4wMjc4NjcsIDAuMDY1NjY2LCAwLjEyMTExNywgMC4xNzQ4NjgsIDAuMTk3NjQxXSxcbiAgMTU6IFs0ODllLTYsIDI0MDNlLTYsIDkyNDZlLTYsIDAuMDI3ODQsIDAuMDY1NjAyLCAwLjEyMDk5OSwgMC4xNzQ2OTcsIDAuMTk3NDQ4XVxufTtcbmNvbnN0IGZyYWdUZW1wbGF0ZSA9IFtcbiAgXCJ2YXJ5aW5nIHZlYzIgdkJsdXJUZXhDb29yZHNbJXNpemUlXTtcIixcbiAgXCJ1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcIixcbiAgXCJ2b2lkIG1haW4odm9pZClcIixcbiAgXCJ7XCIsXG4gIFwiICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wKTtcIixcbiAgXCIgICAgJWJsdXIlXCIsXG4gIFwifVwiXG5dLmpvaW4oXCJcXG5cIik7XG5mdW5jdGlvbiBnZW5lcmF0ZUJsdXJGcmFnU291cmNlKGtlcm5lbFNpemUpIHtcbiAgY29uc3Qga2VybmVsID0gR0FVU1NJQU5fVkFMVUVTW2tlcm5lbFNpemVdO1xuICBjb25zdCBoYWxmTGVuZ3RoID0ga2VybmVsLmxlbmd0aDtcbiAgbGV0IGZyYWdTb3VyY2UgPSBmcmFnVGVtcGxhdGU7XG4gIGxldCBibHVyTG9vcCA9IFwiXCI7XG4gIGNvbnN0IHRlbXBsYXRlID0gXCJnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1slaW5kZXglXSkgKiAldmFsdWUlO1wiO1xuICBsZXQgdmFsdWU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmVsU2l6ZTsgaSsrKSB7XG4gICAgbGV0IGJsdXIgPSB0ZW1wbGF0ZS5yZXBsYWNlKFwiJWluZGV4JVwiLCBpLnRvU3RyaW5nKCkpO1xuICAgIHZhbHVlID0gaTtcbiAgICBpZiAoaSA+PSBoYWxmTGVuZ3RoKSB7XG4gICAgICB2YWx1ZSA9IGtlcm5lbFNpemUgLSBpIC0gMTtcbiAgICB9XG4gICAgYmx1ciA9IGJsdXIucmVwbGFjZShcIiV2YWx1ZSVcIiwga2VybmVsW3ZhbHVlXS50b1N0cmluZygpKTtcbiAgICBibHVyTG9vcCArPSBibHVyO1xuICAgIGJsdXJMb29wICs9IFwiXFxuXCI7XG4gIH1cbiAgZnJhZ1NvdXJjZSA9IGZyYWdTb3VyY2UucmVwbGFjZShcIiVibHVyJVwiLCBibHVyTG9vcCk7XG4gIGZyYWdTb3VyY2UgPSBmcmFnU291cmNlLnJlcGxhY2UoXCIlc2l6ZSVcIiwga2VybmVsU2l6ZS50b1N0cmluZygpKTtcbiAgcmV0dXJuIGZyYWdTb3VyY2U7XG59XG5cbmV4cG9ydHMuZ2VuZXJhdGVCbHVyRnJhZ1NvdXJjZSA9IGdlbmVyYXRlQmx1ckZyYWdTb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZUJsdXJGcmFnU291cmNlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jb25zdCB2ZXJ0VGVtcGxhdGUgPSBgXG4gICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuXG4gICAgdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XG5cbiAgICB1bmlmb3JtIGZsb2F0IHN0cmVuZ3RoO1xuXG4gICAgdmFyeWluZyB2ZWMyIHZCbHVyVGV4Q29vcmRzWyVzaXplJV07XG5cbiAgICB1bmlmb3JtIHZlYzQgaW5wdXRTaXplO1xuICAgIHVuaWZvcm0gdmVjNCBvdXRwdXRGcmFtZTtcblxuICAgIHZlYzQgZmlsdGVyVmVydGV4UG9zaXRpb24oIHZvaWQgKVxuICAgIHtcbiAgICAgICAgdmVjMiBwb3NpdGlvbiA9IGFWZXJ0ZXhQb3NpdGlvbiAqIG1heChvdXRwdXRGcmFtZS56dywgdmVjMigwLikpICsgb3V0cHV0RnJhbWUueHk7XG5cbiAgICAgICAgcmV0dXJuIHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xuICAgIH1cblxuICAgIHZlYzIgZmlsdGVyVGV4dHVyZUNvb3JkKCB2b2lkIClcbiAgICB7XG4gICAgICAgIHJldHVybiBhVmVydGV4UG9zaXRpb24gKiAob3V0cHV0RnJhbWUuencgKiBpbnB1dFNpemUuencpO1xuICAgIH1cblxuICAgIHZvaWQgbWFpbih2b2lkKVxuICAgIHtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbigpO1xuXG4gICAgICAgIHZlYzIgdGV4dHVyZUNvb3JkID0gZmlsdGVyVGV4dHVyZUNvb3JkKCk7XG4gICAgICAgICVibHVyJVxuICAgIH1gO1xuZnVuY3Rpb24gZ2VuZXJhdGVCbHVyVmVydFNvdXJjZShrZXJuZWxTaXplLCB4KSB7XG4gIGNvbnN0IGhhbGZMZW5ndGggPSBNYXRoLmNlaWwoa2VybmVsU2l6ZSAvIDIpO1xuICBsZXQgdmVydFNvdXJjZSA9IHZlcnRUZW1wbGF0ZTtcbiAgbGV0IGJsdXJMb29wID0gXCJcIjtcbiAgbGV0IHRlbXBsYXRlO1xuICBpZiAoeCkge1xuICAgIHRlbXBsYXRlID0gXCJ2Qmx1clRleENvb3Jkc1slaW5kZXglXSA9ICB0ZXh0dXJlQ29vcmQgKyB2ZWMyKCVzYW1wbGVJbmRleCUgKiBzdHJlbmd0aCwgMC4wKTtcIjtcbiAgfSBlbHNlIHtcbiAgICB0ZW1wbGF0ZSA9IFwidkJsdXJUZXhDb29yZHNbJWluZGV4JV0gPSAgdGV4dHVyZUNvb3JkICsgdmVjMigwLjAsICVzYW1wbGVJbmRleCUgKiBzdHJlbmd0aCk7XCI7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxTaXplOyBpKyspIHtcbiAgICBsZXQgYmx1ciA9IHRlbXBsYXRlLnJlcGxhY2UoXCIlaW5kZXglXCIsIGkudG9TdHJpbmcoKSk7XG4gICAgYmx1ciA9IGJsdXIucmVwbGFjZShcIiVzYW1wbGVJbmRleCVcIiwgYCR7aSAtIChoYWxmTGVuZ3RoIC0gMSl9LjBgKTtcbiAgICBibHVyTG9vcCArPSBibHVyO1xuICAgIGJsdXJMb29wICs9IFwiXFxuXCI7XG4gIH1cbiAgdmVydFNvdXJjZSA9IHZlcnRTb3VyY2UucmVwbGFjZShcIiVibHVyJVwiLCBibHVyTG9vcCk7XG4gIHZlcnRTb3VyY2UgPSB2ZXJ0U291cmNlLnJlcGxhY2UoXCIlc2l6ZSVcIiwga2VybmVsU2l6ZS50b1N0cmluZygpKTtcbiAgcmV0dXJuIHZlcnRTb3VyY2U7XG59XG5cbmV4cG9ydHMuZ2VuZXJhdGVCbHVyVmVydFNvdXJjZSA9IGdlbmVyYXRlQmx1clZlcnRTb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZUJsdXJWZXJ0U291cmNlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgQmx1ckZpbHRlciA9IHJlcXVpcmUoJy4vQmx1ckZpbHRlci5qcycpO1xudmFyIEJsdXJGaWx0ZXJQYXNzID0gcmVxdWlyZSgnLi9CbHVyRmlsdGVyUGFzcy5qcycpO1xuXG5cblxuZXhwb3J0cy5CbHVyRmlsdGVyID0gQmx1ckZpbHRlci5CbHVyRmlsdGVyO1xuZXhwb3J0cy5CbHVyRmlsdGVyUGFzcyA9IEJsdXJGaWx0ZXJQYXNzLkJsdXJGaWx0ZXJQYXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xudmFyIGNvbG9yTWF0cml4ID0gcmVxdWlyZSgnLi9jb2xvck1hdHJpeC5qcycpO1xuXG5jbGFzcyBDb2xvck1hdHJpeEZpbHRlciBleHRlbmRzIGNvcmUuRmlsdGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB7XG4gICAgICBtOiBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgMSxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMSxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMSxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMSxcbiAgICAgICAgMFxuICAgICAgXSksXG4gICAgICB1QWxwaGE6IDFcbiAgICB9O1xuICAgIHN1cGVyKGNvcmUuZGVmYXVsdEZpbHRlclZlcnRleCwgY29sb3JNYXRyaXhbXCJkZWZhdWx0XCJdLCB1bmlmb3Jtcyk7XG4gICAgdGhpcy5hbHBoYSA9IDE7XG4gIH1cbiAgX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSA9IGZhbHNlKSB7XG4gICAgbGV0IG5ld01hdHJpeCA9IG1hdHJpeDtcbiAgICBpZiAobXVsdGlwbHkpIHtcbiAgICAgIHRoaXMuX211bHRpcGx5KG5ld01hdHJpeCwgdGhpcy51bmlmb3Jtcy5tLCBtYXRyaXgpO1xuICAgICAgbmV3TWF0cml4ID0gdGhpcy5fY29sb3JNYXRyaXgobmV3TWF0cml4KTtcbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy5tID0gbmV3TWF0cml4O1xuICB9XG4gIF9tdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXSArIGFbMV0gKiBiWzVdICsgYVsyXSAqIGJbMTBdICsgYVszXSAqIGJbMTVdO1xuICAgIG91dFsxXSA9IGFbMF0gKiBiWzFdICsgYVsxXSAqIGJbNl0gKyBhWzJdICogYlsxMV0gKyBhWzNdICogYlsxNl07XG4gICAgb3V0WzJdID0gYVswXSAqIGJbMl0gKyBhWzFdICogYls3XSArIGFbMl0gKiBiWzEyXSArIGFbM10gKiBiWzE3XTtcbiAgICBvdXRbM10gPSBhWzBdICogYlszXSArIGFbMV0gKiBiWzhdICsgYVsyXSAqIGJbMTNdICsgYVszXSAqIGJbMThdO1xuICAgIG91dFs0XSA9IGFbMF0gKiBiWzRdICsgYVsxXSAqIGJbOV0gKyBhWzJdICogYlsxNF0gKyBhWzNdICogYlsxOV0gKyBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV0gKiBiWzBdICsgYVs2XSAqIGJbNV0gKyBhWzddICogYlsxMF0gKyBhWzhdICogYlsxNV07XG4gICAgb3V0WzZdID0gYVs1XSAqIGJbMV0gKyBhWzZdICogYls2XSArIGFbN10gKiBiWzExXSArIGFbOF0gKiBiWzE2XTtcbiAgICBvdXRbN10gPSBhWzVdICogYlsyXSArIGFbNl0gKiBiWzddICsgYVs3XSAqIGJbMTJdICsgYVs4XSAqIGJbMTddO1xuICAgIG91dFs4XSA9IGFbNV0gKiBiWzNdICsgYVs2XSAqIGJbOF0gKyBhWzddICogYlsxM10gKyBhWzhdICogYlsxOF07XG4gICAgb3V0WzldID0gYVs1XSAqIGJbNF0gKyBhWzZdICogYls5XSArIGFbN10gKiBiWzE0XSArIGFbOF0gKiBiWzE5XSArIGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdICogYlswXSArIGFbMTFdICogYls1XSArIGFbMTJdICogYlsxMF0gKyBhWzEzXSAqIGJbMTVdO1xuICAgIG91dFsxMV0gPSBhWzEwXSAqIGJbMV0gKyBhWzExXSAqIGJbNl0gKyBhWzEyXSAqIGJbMTFdICsgYVsxM10gKiBiWzE2XTtcbiAgICBvdXRbMTJdID0gYVsxMF0gKiBiWzJdICsgYVsxMV0gKiBiWzddICsgYVsxMl0gKiBiWzEyXSArIGFbMTNdICogYlsxN107XG4gICAgb3V0WzEzXSA9IGFbMTBdICogYlszXSArIGFbMTFdICogYls4XSArIGFbMTJdICogYlsxM10gKyBhWzEzXSAqIGJbMThdO1xuICAgIG91dFsxNF0gPSBhWzEwXSAqIGJbNF0gKyBhWzExXSAqIGJbOV0gKyBhWzEyXSAqIGJbMTRdICsgYVsxM10gKiBiWzE5XSArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XSAqIGJbMF0gKyBhWzE2XSAqIGJbNV0gKyBhWzE3XSAqIGJbMTBdICsgYVsxOF0gKiBiWzE1XTtcbiAgICBvdXRbMTZdID0gYVsxNV0gKiBiWzFdICsgYVsxNl0gKiBiWzZdICsgYVsxN10gKiBiWzExXSArIGFbMThdICogYlsxNl07XG4gICAgb3V0WzE3XSA9IGFbMTVdICogYlsyXSArIGFbMTZdICogYls3XSArIGFbMTddICogYlsxMl0gKyBhWzE4XSAqIGJbMTddO1xuICAgIG91dFsxOF0gPSBhWzE1XSAqIGJbM10gKyBhWzE2XSAqIGJbOF0gKyBhWzE3XSAqIGJbMTNdICsgYVsxOF0gKiBiWzE4XTtcbiAgICBvdXRbMTldID0gYVsxNV0gKiBiWzRdICsgYVsxNl0gKiBiWzldICsgYVsxN10gKiBiWzE0XSArIGFbMThdICogYlsxOV0gKyBhWzE5XTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIF9jb2xvck1hdHJpeChtYXRyaXgpIHtcbiAgICBjb25zdCBtID0gbmV3IEZsb2F0MzJBcnJheShtYXRyaXgpO1xuICAgIG1bNF0gLz0gMjU1O1xuICAgIG1bOV0gLz0gMjU1O1xuICAgIG1bMTRdIC89IDI1NTtcbiAgICBtWzE5XSAvPSAyNTU7XG4gICAgcmV0dXJuIG07XG4gIH1cbiAgYnJpZ2h0bmVzcyhiLCBtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIGIsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIGIsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIGIsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIHRpbnQoY29sb3IsIG11bHRpcGx5KSB7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gY29yZS5Db2xvci5zaGFyZWQuc2V0VmFsdWUoY29sb3IpLnRvQXJyYXkoKTtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICByLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBnLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBiLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICBncmV5c2NhbGUoc2NhbGUsIG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgc2NhbGUsXG4gICAgICBzY2FsZSxcbiAgICAgIHNjYWxlLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBzY2FsZSxcbiAgICAgIHNjYWxlLFxuICAgICAgc2NhbGUsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIHNjYWxlLFxuICAgICAgc2NhbGUsXG4gICAgICBzY2FsZSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgYmxhY2tBbmRXaGl0ZShtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIDAuMyxcbiAgICAgIDAuNixcbiAgICAgIDAuMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMC4zLFxuICAgICAgMC42LFxuICAgICAgMC4xLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLjMsXG4gICAgICAwLjYsXG4gICAgICAwLjEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIGh1ZShyb3RhdGlvbiwgbXVsdGlwbHkpIHtcbiAgICByb3RhdGlvbiA9IChyb3RhdGlvbiB8fCAwKSAvIDE4MCAqIE1hdGguUEk7XG4gICAgY29uc3QgY29zUiA9IE1hdGguY29zKHJvdGF0aW9uKTtcbiAgICBjb25zdCBzaW5SID0gTWF0aC5zaW4ocm90YXRpb24pO1xuICAgIGNvbnN0IHNxcnQgPSBNYXRoLnNxcnQ7XG4gICAgY29uc3QgdyA9IDEgLyAzO1xuICAgIGNvbnN0IHNxclcgPSBzcXJ0KHcpO1xuICAgIGNvbnN0IGEwMCA9IGNvc1IgKyAoMSAtIGNvc1IpICogdztcbiAgICBjb25zdCBhMDEgPSB3ICogKDEgLSBjb3NSKSAtIHNxclcgKiBzaW5SO1xuICAgIGNvbnN0IGEwMiA9IHcgKiAoMSAtIGNvc1IpICsgc3FyVyAqIHNpblI7XG4gICAgY29uc3QgYTEwID0gdyAqICgxIC0gY29zUikgKyBzcXJXICogc2luUjtcbiAgICBjb25zdCBhMTEgPSBjb3NSICsgdyAqICgxIC0gY29zUik7XG4gICAgY29uc3QgYTEyID0gdyAqICgxIC0gY29zUikgLSBzcXJXICogc2luUjtcbiAgICBjb25zdCBhMjAgPSB3ICogKDEgLSBjb3NSKSAtIHNxclcgKiBzaW5SO1xuICAgIGNvbnN0IGEyMSA9IHcgKiAoMSAtIGNvc1IpICsgc3FyVyAqIHNpblI7XG4gICAgY29uc3QgYTIyID0gY29zUiArIHcgKiAoMSAtIGNvc1IpO1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIGEwMCxcbiAgICAgIGEwMSxcbiAgICAgIGEwMixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgYTEwLFxuICAgICAgYTExLFxuICAgICAgYTEyLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBhMjAsXG4gICAgICBhMjEsXG4gICAgICBhMjIsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIGNvbnRyYXN0KGFtb3VudCwgbXVsdGlwbHkpIHtcbiAgICBjb25zdCB2ID0gKGFtb3VudCB8fCAwKSArIDE7XG4gICAgY29uc3QgbyA9IC0wLjUgKiAodiAtIDEpO1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIHYsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBvLFxuICAgICAgMCxcbiAgICAgIHYsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIG8sXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIHYsXG4gICAgICAwLFxuICAgICAgbyxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIHNhdHVyYXRlKGFtb3VudCA9IDAsIG11bHRpcGx5KSB7XG4gICAgY29uc3QgeCA9IGFtb3VudCAqIDIgLyAzICsgMTtcbiAgICBjb25zdCB5ID0gKHggLSAxKSAqIC0wLjU7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB5LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICB5LFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIHksXG4gICAgICB5LFxuICAgICAgeCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgZGVzYXR1cmF0ZSgpIHtcbiAgICB0aGlzLnNhdHVyYXRlKC0xKTtcbiAgfVxuICBuZWdhdGl2ZShtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIC0xLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAtMSxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLTEsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIHNlcGlhKG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgMC4zOTMsXG4gICAgICAwLjc2ODk5OTksXG4gICAgICAwLjE4ODk5OTk5LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLjM0OSxcbiAgICAgIDAuNjg1OTk5OSxcbiAgICAgIDAuMTY3OTk5OTksXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAuMjcyLFxuICAgICAgMC41MzM5OTk5LFxuICAgICAgMC4xMzA5OTk5OSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgdGVjaG5pY29sb3IobXVsdGlwbHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAxLjkxMjUyNzc4OTE0NTYwODMsXG4gICAgICAtMC44NTQ1MzQ0OTc2OTUxNjQ1LFxuICAgICAgLTAuMDkxNTU1MDg0ODI3NTU1ODUsXG4gICAgICAwLFxuICAgICAgMTEuNzkzNjAzNDM0Mzc3MzM3LFxuICAgICAgLTAuMzA4NzgzMzM4NTkyODA5NyxcbiAgICAgIDEuNzY1ODkwODU1NTQ1ODQyOCxcbiAgICAgIC0wLjEwNjAxNzQzMDc0NzIyMjQ1LFxuICAgICAgMCxcbiAgICAgIC03MC4zNTIwNTE2MTQ2MTM5OCxcbiAgICAgIC0wLjIzMTEwMzM3NzU0ODYxNixcbiAgICAgIC0wLjc1MDE4OTkxOTc0NDAyMTIsXG4gICAgICAxLjg0NzU5NzgxNjEwODE4OSxcbiAgICAgIDAsXG4gICAgICAzMC45NTA5NDA4Njk0OTExMzgsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICBwb2xhcm9pZChtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIDEuNDM4LFxuICAgICAgLTAuMDYyLFxuICAgICAgLTAuMDYyLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAtMC4xMjIsXG4gICAgICAxLjM3OCxcbiAgICAgIC0wLjEyMixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLTAuMDE2LFxuICAgICAgLTAuMDE2LFxuICAgICAgMS40ODMsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIHRvQkdSKG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAga29kYWNocm9tZShtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIDEuMTI4NTU4MjM5NjU5MzUyNSxcbiAgICAgIC0wLjM5NjczODIyODM2MDEzNDgsXG4gICAgICAtMC4wMzk5MjU1OTE3MjkyMTc5MyxcbiAgICAgIDAsXG4gICAgICA2My43Mjk1ODc2MjE5NjUwMixcbiAgICAgIC0wLjE2NDA0MzM5OTYyMjQ0NjE2LFxuICAgICAgMS4wODM1MjUxNTY2MjkxMzA0LFxuICAgICAgLTAuMDU0OTg4MDUxMTU2MzMxMzIsXG4gICAgICAwLFxuICAgICAgMjQuNzMyNDA3ODk2NzA2MjAzLFxuICAgICAgLTAuMTY3ODYwMTA3MDYxNTU3NjMsXG4gICAgICAtMC41NjAzNDE2Mjc3Njk1MjQ4LFxuICAgICAgMS42MDE0ODUwNzYxOTY0OTQzLFxuICAgICAgMCxcbiAgICAgIDM1LjYyOTgyODA3NDYwOTQ2LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgYnJvd25pKG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgMC41OTk3MDIzNDk4MTU5NzE1LFxuICAgICAgMC4zNDU1MzI0MzA0ODM5MTI2MyxcbiAgICAgIC0wLjI3MDgyOTg2NzQ1MzgwNDIsXG4gICAgICAwLFxuICAgICAgNDcuNDMxOTI4NTU2MDA4NzMsXG4gICAgICAtMC4wMzc3MDMyNDk4Mzc3ODMxNTcsXG4gICAgICAwLjg2MDk1Nzc1ODc5OTI2NDEsXG4gICAgICAwLjE1MDU5NTUyMzg4NDU5OTEzLFxuICAgICAgMCxcbiAgICAgIC0zNi45Njg0MTQ5ODMxOTEyNyxcbiAgICAgIDAuMjQxMTM2MzUxMjgxNTMzMzUsXG4gICAgICAtMC4wNzQ0MTAzNzkwODQyMjQ5MixcbiAgICAgIDAuNDQ5NzIxODIwNjQ4NzcxNTMsXG4gICAgICAwLFxuICAgICAgLTcuNTYyMDc1Mjc3NTkxMjgzLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgdmludGFnZShtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIDAuNjI3OTM0NTYzNTYwNTk5NCxcbiAgICAgIDAuMzIwMjE4MzQyMDgxOTM2NyxcbiAgICAgIC0wLjAzOTY1NDA4MjExMzEyNDUzLFxuICAgICAgMCxcbiAgICAgIDkuNjUxMjg1ODM1Mjk0MTIzLFxuICAgICAgMC4wMjU3ODM5NzcwNDgwODg2OCxcbiAgICAgIDAuNjQ0MTE4ODY0NDM3NDc3MSxcbiAgICAgIDAuMDMyNTkxMjc2MTYxNDkyOTQsXG4gICAgICAwLFxuICAgICAgNy40NjI4MjkxNzY0NzA1OTEsXG4gICAgICAwLjA0NjYwNTU1NTY3ODI3MTksXG4gICAgICAtMC4wODUxMjMyOTg3MjQ3ODkxLFxuICAgICAgMC41MjQxNjQ4MDE4NzAwNDY1LFxuICAgICAgMCxcbiAgICAgIDUuMTU5MTkwNTg4MjM1Mjk2LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgY29sb3JUb25lKGRlc2F0dXJhdGlvbiwgdG9uZWQsIGxpZ2h0Q29sb3IsIGRhcmtDb2xvciwgbXVsdGlwbHkpIHtcbiAgICBkZXNhdHVyYXRpb24gPSBkZXNhdHVyYXRpb24gfHwgMC4yO1xuICAgIHRvbmVkID0gdG9uZWQgfHwgMC4xNTtcbiAgICBsaWdodENvbG9yID0gbGlnaHRDb2xvciB8fCAxNjc3MDQzMjtcbiAgICBkYXJrQ29sb3IgPSBkYXJrQ29sb3IgfHwgMzM3NTEwNDtcbiAgICBjb25zdCB0ZW1wID0gY29yZS5Db2xvci5zaGFyZWQ7XG4gICAgY29uc3QgW2xSLCBsRywgbEJdID0gdGVtcC5zZXRWYWx1ZShsaWdodENvbG9yKS50b0FycmF5KCk7XG4gICAgY29uc3QgW2RSLCBkRywgZEJdID0gdGVtcC5zZXRWYWx1ZShkYXJrQ29sb3IpLnRvQXJyYXkoKTtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAwLjMsXG4gICAgICAwLjU5LFxuICAgICAgMC4xMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgbFIsXG4gICAgICBsRyxcbiAgICAgIGxCLFxuICAgICAgZGVzYXR1cmF0aW9uLFxuICAgICAgMCxcbiAgICAgIGRSLFxuICAgICAgZEcsXG4gICAgICBkQixcbiAgICAgIHRvbmVkLFxuICAgICAgMCxcbiAgICAgIGxSIC0gZFIsXG4gICAgICBsRyAtIGRHLFxuICAgICAgbEIgLSBkQixcbiAgICAgIDAsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIG5pZ2h0KGludGVuc2l0eSwgbXVsdGlwbHkpIHtcbiAgICBpbnRlbnNpdHkgPSBpbnRlbnNpdHkgfHwgMC4xO1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIGludGVuc2l0eSAqIC0yLFxuICAgICAgLWludGVuc2l0eSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC1pbnRlbnNpdHksXG4gICAgICAwLFxuICAgICAgaW50ZW5zaXR5LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgaW50ZW5zaXR5LFxuICAgICAgaW50ZW5zaXR5ICogMixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgcHJlZGF0b3IoYW1vdW50LCBtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIDExLjIyNDEzMDYzMDQ5MzE2NCAqIGFtb3VudCxcbiAgICAgIC00Ljc5NDQ4Njk5OTUxMTcxOSAqIGFtb3VudCxcbiAgICAgIC0yLjg3NDYxMTg1NDU1MzIyMjcgKiBhbW91bnQsXG4gICAgICAwICogYW1vdW50LFxuICAgICAgMC40MDM0MjQzODIyMDk3Nzc4MyAqIGFtb3VudCxcbiAgICAgIC0zLjYzMzA2OTc1MzY0Njg1MDYgKiBhbW91bnQsXG4gICAgICA5LjE5MzE1NzE5NjA0NDkyMiAqIGFtb3VudCxcbiAgICAgIC0yLjk1MTgxMDgzNjc5MTk5MiAqIGFtb3VudCxcbiAgICAgIDAgKiBhbW91bnQsXG4gICAgICAtMS4zMTYxMzUwNDg4NjYyNzIgKiBhbW91bnQsXG4gICAgICAtMy4yMTg0MTk3OTAyNjc5NDQzICogYW1vdW50LFxuICAgICAgLTQuMjM3NTAzMDUxNzU3ODEyNSAqIGFtb3VudCxcbiAgICAgIDcuNDc2NDQ4MDU5MDgyMDMxICogYW1vdW50LFxuICAgICAgMCAqIGFtb3VudCxcbiAgICAgIDAuODA0NDQ1OTIyMzc0NzI1MyAqIGFtb3VudCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIGxzZChtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIDIsXG4gICAgICAtMC40LFxuICAgICAgMC41LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAtMC41LFxuICAgICAgMixcbiAgICAgIC0wLjQsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC0wLjQsXG4gICAgICAtMC41LFxuICAgICAgMyxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBmYWxzZSk7XG4gIH1cbiAgZ2V0IG1hdHJpeCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5tO1xuICB9XG4gIHNldCBtYXRyaXgodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm0gPSB2YWx1ZTtcbiAgfVxuICBnZXQgYWxwaGEoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUFscGhhO1xuICB9XG4gIHNldCBhbHBoYSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudUFscGhhID0gdmFsdWU7XG4gIH1cbn1cbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5ncmF5c2NhbGUgPSBDb2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUuZ3JleXNjYWxlO1xuXG5leHBvcnRzLkNvbG9yTWF0cml4RmlsdGVyID0gQ29sb3JNYXRyaXhGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvck1hdHJpeEZpbHRlci5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIGZsb2F0IG1bMjBdO1xcbnVuaWZvcm0gZmxvYXQgdUFscGhhO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgdmVjNCBjID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXG5cXG4gICAgaWYgKHVBbHBoYSA9PSAwLjApIHtcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGM7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgLy8gVW4tcHJlbXVsdGlwbHkgYWxwaGEgYmVmb3JlIGFwcGx5aW5nIHRoZSBjb2xvciBtYXRyaXguIFNlZSBpc3N1ZSAjMzUzOS5cXG4gICAgaWYgKGMuYSA+IDAuMCkge1xcbiAgICAgIGMucmdiIC89IGMuYTtcXG4gICAgfVxcblxcbiAgICB2ZWM0IHJlc3VsdDtcXG5cXG4gICAgcmVzdWx0LnIgPSAobVswXSAqIGMucik7XFxuICAgICAgICByZXN1bHQuciArPSAobVsxXSAqIGMuZyk7XFxuICAgICAgICByZXN1bHQuciArPSAobVsyXSAqIGMuYik7XFxuICAgICAgICByZXN1bHQuciArPSAobVszXSAqIGMuYSk7XFxuICAgICAgICByZXN1bHQuciArPSBtWzRdO1xcblxcbiAgICByZXN1bHQuZyA9IChtWzVdICogYy5yKTtcXG4gICAgICAgIHJlc3VsdC5nICs9IChtWzZdICogYy5nKTtcXG4gICAgICAgIHJlc3VsdC5nICs9IChtWzddICogYy5iKTtcXG4gICAgICAgIHJlc3VsdC5nICs9IChtWzhdICogYy5hKTtcXG4gICAgICAgIHJlc3VsdC5nICs9IG1bOV07XFxuXFxuICAgIHJlc3VsdC5iID0gKG1bMTBdICogYy5yKTtcXG4gICAgICAgcmVzdWx0LmIgKz0gKG1bMTFdICogYy5nKTtcXG4gICAgICAgcmVzdWx0LmIgKz0gKG1bMTJdICogYy5iKTtcXG4gICAgICAgcmVzdWx0LmIgKz0gKG1bMTNdICogYy5hKTtcXG4gICAgICAgcmVzdWx0LmIgKz0gbVsxNF07XFxuXFxuICAgIHJlc3VsdC5hID0gKG1bMTVdICogYy5yKTtcXG4gICAgICAgcmVzdWx0LmEgKz0gKG1bMTZdICogYy5nKTtcXG4gICAgICAgcmVzdWx0LmEgKz0gKG1bMTddICogYy5iKTtcXG4gICAgICAgcmVzdWx0LmEgKz0gKG1bMThdICogYy5hKTtcXG4gICAgICAgcmVzdWx0LmEgKz0gbVsxOV07XFxuXFxuICAgIHZlYzMgcmdiID0gbWl4KGMucmdiLCByZXN1bHQucmdiLCB1QWxwaGEpO1xcblxcbiAgICAvLyBQcmVtdWx0aXBseSBhbHBoYSBhZ2Fpbi5cXG4gICAgcmdiICo9IHJlc3VsdC5hO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHJnYiwgcmVzdWx0LmEpO1xcbn1cXG5cIjtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmcmFnbWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbG9yTWF0cml4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgQ29sb3JNYXRyaXhGaWx0ZXIgPSByZXF1aXJlKCcuL0NvbG9yTWF0cml4RmlsdGVyLmpzJyk7XG5cblxuXG5leHBvcnRzLkNvbG9yTWF0cml4RmlsdGVyID0gQ29sb3JNYXRyaXhGaWx0ZXIuQ29sb3JNYXRyaXhGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgZGlzcGxhY2VtZW50JDEgPSByZXF1aXJlKCcuL2Rpc3BsYWNlbWVudC5qcycpO1xudmFyIGRpc3BsYWNlbWVudCA9IHJlcXVpcmUoJy4vZGlzcGxhY2VtZW50Mi5qcycpO1xuXG5jbGFzcyBEaXNwbGFjZW1lbnRGaWx0ZXIgZXh0ZW5kcyBjb3JlLkZpbHRlciB7XG4gIGNvbnN0cnVjdG9yKHNwcml0ZSwgc2NhbGUpIHtcbiAgICBjb25zdCBtYXNrTWF0cml4ID0gbmV3IGNvcmUuTWF0cml4KCk7XG4gICAgc3ByaXRlLnJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICBzdXBlcihkaXNwbGFjZW1lbnRbXCJkZWZhdWx0XCJdLCBkaXNwbGFjZW1lbnQkMVtcImRlZmF1bHRcIl0sIHtcbiAgICAgIG1hcFNhbXBsZXI6IHNwcml0ZS5fdGV4dHVyZSxcbiAgICAgIGZpbHRlck1hdHJpeDogbWFza01hdHJpeCxcbiAgICAgIHNjYWxlOiB7IHg6IDEsIHk6IDEgfSxcbiAgICAgIHJvdGF0aW9uOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAxXSlcbiAgICB9KTtcbiAgICB0aGlzLm1hc2tTcHJpdGUgPSBzcHJpdGU7XG4gICAgdGhpcy5tYXNrTWF0cml4ID0gbWFza01hdHJpeDtcbiAgICBpZiAoc2NhbGUgPT09IG51bGwgfHwgc2NhbGUgPT09IHZvaWQgMCkge1xuICAgICAgc2NhbGUgPSAyMDtcbiAgICB9XG4gICAgdGhpcy5zY2FsZSA9IG5ldyBjb3JlLlBvaW50KHNjYWxlLCBzY2FsZSk7XG4gIH1cbiAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5maWx0ZXJNYXRyaXggPSBmaWx0ZXJNYW5hZ2VyLmNhbGN1bGF0ZVNwcml0ZU1hdHJpeCh0aGlzLm1hc2tNYXRyaXgsIHRoaXMubWFza1Nwcml0ZSk7XG4gICAgdGhpcy51bmlmb3Jtcy5zY2FsZS54ID0gdGhpcy5zY2FsZS54O1xuICAgIHRoaXMudW5pZm9ybXMuc2NhbGUueSA9IHRoaXMuc2NhbGUueTtcbiAgICBjb25zdCB3dCA9IHRoaXMubWFza1Nwcml0ZS53b3JsZFRyYW5zZm9ybTtcbiAgICBjb25zdCBsZW5YID0gTWF0aC5zcXJ0KHd0LmEgKiB3dC5hICsgd3QuYiAqIHd0LmIpO1xuICAgIGNvbnN0IGxlblkgPSBNYXRoLnNxcnQod3QuYyAqIHd0LmMgKyB3dC5kICogd3QuZCk7XG4gICAgaWYgKGxlblggIT09IDAgJiYgbGVuWSAhPT0gMCkge1xuICAgICAgdGhpcy51bmlmb3Jtcy5yb3RhdGlvblswXSA9IHd0LmEgLyBsZW5YO1xuICAgICAgdGhpcy51bmlmb3Jtcy5yb3RhdGlvblsxXSA9IHd0LmIgLyBsZW5YO1xuICAgICAgdGhpcy51bmlmb3Jtcy5yb3RhdGlvblsyXSA9IHd0LmMgLyBsZW5ZO1xuICAgICAgdGhpcy51bmlmb3Jtcy5yb3RhdGlvblszXSA9IHd0LmQgLyBsZW5ZO1xuICAgIH1cbiAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSk7XG4gIH1cbiAgZ2V0IG1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5tYXBTYW1wbGVyO1xuICB9XG4gIHNldCBtYXAodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm1hcFNhbXBsZXIgPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnRzLkRpc3BsYWNlbWVudEZpbHRlciA9IERpc3BsYWNlbWVudEZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpc3BsYWNlbWVudEZpbHRlci5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzIgdkZpbHRlckNvb3JkO1xcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gdmVjMiBzY2FsZTtcXG51bmlmb3JtIG1hdDIgcm90YXRpb247XFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSBzYW1wbGVyMkQgbWFwU2FtcGxlcjtcXG5cXG51bmlmb3JtIGhpZ2hwIHZlYzQgaW5wdXRTaXplO1xcbnVuaWZvcm0gdmVjNCBpbnB1dENsYW1wO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gIHZlYzQgbWFwID0gIHRleHR1cmUyRChtYXBTYW1wbGVyLCB2RmlsdGVyQ29vcmQpO1xcblxcbiAgbWFwIC09IDAuNTtcXG4gIG1hcC54eSA9IHNjYWxlICogaW5wdXRTaXplLnp3ICogKHJvdGF0aW9uICogbWFwLnh5KTtcXG5cXG4gIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgY2xhbXAodmVjMih2VGV4dHVyZUNvb3JkLnggKyBtYXAueCwgdlRleHR1cmVDb29yZC55ICsgbWFwLnkpLCBpbnB1dENsYW1wLnh5LCBpbnB1dENsYW1wLnp3KSk7XFxufVxcblwiO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZyYWdtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzcGxhY2VtZW50LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgdmVydGV4ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxudW5pZm9ybSBtYXQzIGZpbHRlck1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzIgdkZpbHRlckNvb3JkO1xcblxcbnVuaWZvcm0gdmVjNCBpbnB1dFNpemU7XFxudW5pZm9ybSB2ZWM0IG91dHB1dEZyYW1lO1xcblxcbnZlYzQgZmlsdGVyVmVydGV4UG9zaXRpb24oIHZvaWQgKVxcbntcXG4gICAgdmVjMiBwb3NpdGlvbiA9IGFWZXJ0ZXhQb3NpdGlvbiAqIG1heChvdXRwdXRGcmFtZS56dywgdmVjMigwLikpICsgb3V0cHV0RnJhbWUueHk7XFxuXFxuICAgIHJldHVybiB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhwb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXG59XFxuXFxudmVjMiBmaWx0ZXJUZXh0dXJlQ29vcmQoIHZvaWQgKVxcbntcXG4gICAgcmV0dXJuIGFWZXJ0ZXhQb3NpdGlvbiAqIChvdXRwdXRGcmFtZS56dyAqIGlucHV0U2l6ZS56dyk7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG5cXHRnbF9Qb3NpdGlvbiA9IGZpbHRlclZlcnRleFBvc2l0aW9uKCk7XFxuXFx0dlRleHR1cmVDb29yZCA9IGZpbHRlclRleHR1cmVDb29yZCgpO1xcblxcdHZGaWx0ZXJDb29yZCA9ICggZmlsdGVyTWF0cml4ICogdmVjMyggdlRleHR1cmVDb29yZCwgMS4wKSAgKS54eTtcXG59XFxuXCI7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdmVydGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzcGxhY2VtZW50Mi5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIERpc3BsYWNlbWVudEZpbHRlciA9IHJlcXVpcmUoJy4vRGlzcGxhY2VtZW50RmlsdGVyLmpzJyk7XG5cblxuXG5leHBvcnRzLkRpc3BsYWNlbWVudEZpbHRlciA9IERpc3BsYWNlbWVudEZpbHRlci5EaXNwbGFjZW1lbnRGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgZnhhYSQxID0gcmVxdWlyZSgnLi9meGFhLmpzJyk7XG52YXIgZnhhYSA9IHJlcXVpcmUoJy4vZnhhYTIuanMnKTtcblxuY2xhc3MgRlhBQUZpbHRlciBleHRlbmRzIGNvcmUuRmlsdGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoZnhhYVtcImRlZmF1bHRcIl0sIGZ4YWEkMVtcImRlZmF1bHRcIl0pO1xuICB9XG59XG5cbmV4cG9ydHMuRlhBQUZpbHRlciA9IEZYQUFGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GWEFBRmlsdGVyLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZnJhZ21lbnQgPSBcInZhcnlpbmcgdmVjMiB2X3JnYk5XO1xcbnZhcnlpbmcgdmVjMiB2X3JnYk5FO1xcbnZhcnlpbmcgdmVjMiB2X3JnYlNXO1xcbnZhcnlpbmcgdmVjMiB2X3JnYlNFO1xcbnZhcnlpbmcgdmVjMiB2X3JnYk07XFxuXFxudmFyeWluZyB2ZWMyIHZGcmFnQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSBoaWdocCB2ZWM0IGlucHV0U2l6ZTtcXG5cXG5cXG4vKipcXG4gQmFzaWMgRlhBQSBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiB0aGUgY29kZSBvbiBnZWVrczNkLmNvbSB3aXRoIHRoZVxcbiBtb2RpZmljYXRpb24gdGhhdCB0aGUgdGV4dHVyZTJETG9kIHN0dWZmIHdhcyByZW1vdmVkIHNpbmNlIGl0J3NcXG4gdW5zdXBwb3J0ZWQgYnkgV2ViR0wuXFxuXFxuIC0tXFxuXFxuIEZyb206XFxuIGh0dHBzOi8vZ2l0aHViLmNvbS9taXRzdWhpa28vd2ViZ2wtbWVpbmNyYWZ0XFxuXFxuIENvcHlyaWdodCAoYykgMjAxMSBieSBBcm1pbiBSb25hY2hlci5cXG5cXG4gU29tZSByaWdodHMgcmVzZXJ2ZWQuXFxuXFxuIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxcbiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXFxuIG1ldDpcXG5cXG4gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxcbiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXFxuXFxuICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxcbiBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xcbiBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcXG4gd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxcblxcbiAqIFRoZSBuYW1lcyBvZiB0aGUgY29udHJpYnV0b3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yXFxuIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xcbiBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXFxuXFxuIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcXG4gXFxcIkFTIElTXFxcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcXG4gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXFxuIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXFxuIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxcbiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXFxuIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxcbiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcXG4gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxcbiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcXG4gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cXG4gKi9cXG5cXG4jaWZuZGVmIEZYQUFfUkVEVUNFX01JTlxcbiNkZWZpbmUgRlhBQV9SRURVQ0VfTUlOICAgKDEuMC8gMTI4LjApXFxuI2VuZGlmXFxuI2lmbmRlZiBGWEFBX1JFRFVDRV9NVUxcXG4jZGVmaW5lIEZYQUFfUkVEVUNFX01VTCAgICgxLjAgLyA4LjApXFxuI2VuZGlmXFxuI2lmbmRlZiBGWEFBX1NQQU5fTUFYXFxuI2RlZmluZSBGWEFBX1NQQU5fTUFYICAgICA4LjBcXG4jZW5kaWZcXG5cXG4vL29wdGltaXplZCB2ZXJzaW9uIGZvciBtb2JpbGUsIHdoZXJlIGRlcGVuZGVudFxcbi8vdGV4dHVyZSByZWFkcyBjYW4gYmUgYSBib3R0bGVuZWNrXFxudmVjNCBmeGFhKHNhbXBsZXIyRCB0ZXgsIHZlYzIgZnJhZ0Nvb3JkLCB2ZWMyIGludmVyc2VWUCxcXG4gICAgICAgICAgdmVjMiB2X3JnYk5XLCB2ZWMyIHZfcmdiTkUsXFxuICAgICAgICAgIHZlYzIgdl9yZ2JTVywgdmVjMiB2X3JnYlNFLFxcbiAgICAgICAgICB2ZWMyIHZfcmdiTSkge1xcbiAgICB2ZWM0IGNvbG9yO1xcbiAgICB2ZWMzIHJnYk5XID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JOVykueHl6O1xcbiAgICB2ZWMzIHJnYk5FID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JORSkueHl6O1xcbiAgICB2ZWMzIHJnYlNXID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JTVykueHl6O1xcbiAgICB2ZWMzIHJnYlNFID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JTRSkueHl6O1xcbiAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JNKTtcXG4gICAgdmVjMyByZ2JNICA9IHRleENvbG9yLnh5ejtcXG4gICAgdmVjMyBsdW1hID0gdmVjMygwLjI5OSwgMC41ODcsIDAuMTE0KTtcXG4gICAgZmxvYXQgbHVtYU5XID0gZG90KHJnYk5XLCBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYU5FID0gZG90KHJnYk5FLCBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYVNXID0gZG90KHJnYlNXLCBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYVNFID0gZG90KHJnYlNFLCBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYU0gID0gZG90KHJnYk0sICBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYU1pbiA9IG1pbihsdW1hTSwgbWluKG1pbihsdW1hTlcsIGx1bWFORSksIG1pbihsdW1hU1csIGx1bWFTRSkpKTtcXG4gICAgZmxvYXQgbHVtYU1heCA9IG1heChsdW1hTSwgbWF4KG1heChsdW1hTlcsIGx1bWFORSksIG1heChsdW1hU1csIGx1bWFTRSkpKTtcXG5cXG4gICAgbWVkaXVtcCB2ZWMyIGRpcjtcXG4gICAgZGlyLnggPSAtKChsdW1hTlcgKyBsdW1hTkUpIC0gKGx1bWFTVyArIGx1bWFTRSkpO1xcbiAgICBkaXIueSA9ICAoKGx1bWFOVyArIGx1bWFTVykgLSAobHVtYU5FICsgbHVtYVNFKSk7XFxuXFxuICAgIGZsb2F0IGRpclJlZHVjZSA9IG1heCgobHVtYU5XICsgbHVtYU5FICsgbHVtYVNXICsgbHVtYVNFKSAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoMC4yNSAqIEZYQUFfUkVEVUNFX01VTCksIEZYQUFfUkVEVUNFX01JTik7XFxuXFxuICAgIGZsb2F0IHJjcERpck1pbiA9IDEuMCAvIChtaW4oYWJzKGRpci54KSwgYWJzKGRpci55KSkgKyBkaXJSZWR1Y2UpO1xcbiAgICBkaXIgPSBtaW4odmVjMihGWEFBX1NQQU5fTUFYLCBGWEFBX1NQQU5fTUFYKSxcXG4gICAgICAgICAgICAgIG1heCh2ZWMyKC1GWEFBX1NQQU5fTUFYLCAtRlhBQV9TUEFOX01BWCksXFxuICAgICAgICAgICAgICAgICAgZGlyICogcmNwRGlyTWluKSkgKiBpbnZlcnNlVlA7XFxuXFxuICAgIHZlYzMgcmdiQSA9IDAuNSAqIChcXG4gICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIGludmVyc2VWUCArIGRpciAqICgxLjAgLyAzLjAgLSAwLjUpKS54eXogK1xcbiAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogKDIuMCAvIDMuMCAtIDAuNSkpLnh5eik7XFxuICAgIHZlYzMgcmdiQiA9IHJnYkEgKiAwLjUgKyAwLjI1ICogKFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAtMC41KS54eXogK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAwLjUpLnh5eik7XFxuXFxuICAgIGZsb2F0IGx1bWFCID0gZG90KHJnYkIsIGx1bWEpO1xcbiAgICBpZiAoKGx1bWFCIDwgbHVtYU1pbikgfHwgKGx1bWFCID4gbHVtYU1heCkpXFxuICAgICAgICBjb2xvciA9IHZlYzQocmdiQSwgdGV4Q29sb3IuYSk7XFxuICAgIGVsc2VcXG4gICAgICAgIGNvbG9yID0gdmVjNChyZ2JCLCB0ZXhDb2xvci5hKTtcXG4gICAgcmV0dXJuIGNvbG9yO1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuICAgICAgdmVjNCBjb2xvcjtcXG5cXG4gICAgICBjb2xvciA9IGZ4YWEodVNhbXBsZXIsIHZGcmFnQ29vcmQsIGlucHV0U2l6ZS56dywgdl9yZ2JOVywgdl9yZ2JORSwgdl9yZ2JTVywgdl9yZ2JTRSwgdl9yZ2JNKTtcXG5cXG4gICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG59XFxuXCI7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZnJhZ21lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1meGFhLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgdmVydGV4ID0gXCJcXG5hdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZfcmdiTlc7XFxudmFyeWluZyB2ZWMyIHZfcmdiTkU7XFxudmFyeWluZyB2ZWMyIHZfcmdiU1c7XFxudmFyeWluZyB2ZWMyIHZfcmdiU0U7XFxudmFyeWluZyB2ZWMyIHZfcmdiTTtcXG5cXG52YXJ5aW5nIHZlYzIgdkZyYWdDb29yZDtcXG5cXG51bmlmb3JtIHZlYzQgaW5wdXRTaXplO1xcbnVuaWZvcm0gdmVjNCBvdXRwdXRGcmFtZTtcXG5cXG52ZWM0IGZpbHRlclZlcnRleFBvc2l0aW9uKCB2b2lkIClcXG57XFxuICAgIHZlYzIgcG9zaXRpb24gPSBhVmVydGV4UG9zaXRpb24gKiBtYXgob3V0cHV0RnJhbWUuencsIHZlYzIoMC4pKSArIG91dHB1dEZyYW1lLnh5O1xcblxcbiAgICByZXR1cm4gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMocG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxufVxcblxcbnZvaWQgdGV4Y29vcmRzKHZlYzIgZnJhZ0Nvb3JkLCB2ZWMyIGludmVyc2VWUCxcXG4gICAgICAgICAgICAgICBvdXQgdmVjMiB2X3JnYk5XLCBvdXQgdmVjMiB2X3JnYk5FLFxcbiAgICAgICAgICAgICAgIG91dCB2ZWMyIHZfcmdiU1csIG91dCB2ZWMyIHZfcmdiU0UsXFxuICAgICAgICAgICAgICAgb3V0IHZlYzIgdl9yZ2JNKSB7XFxuICAgIHZfcmdiTlcgPSAoZnJhZ0Nvb3JkICsgdmVjMigtMS4wLCAtMS4wKSkgKiBpbnZlcnNlVlA7XFxuICAgIHZfcmdiTkUgPSAoZnJhZ0Nvb3JkICsgdmVjMigxLjAsIC0xLjApKSAqIGludmVyc2VWUDtcXG4gICAgdl9yZ2JTVyA9IChmcmFnQ29vcmQgKyB2ZWMyKC0xLjAsIDEuMCkpICogaW52ZXJzZVZQO1xcbiAgICB2X3JnYlNFID0gKGZyYWdDb29yZCArIHZlYzIoMS4wLCAxLjApKSAqIGludmVyc2VWUDtcXG4gICAgdl9yZ2JNID0gdmVjMihmcmFnQ29vcmQgKiBpbnZlcnNlVlApO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcbiAgIGdsX1Bvc2l0aW9uID0gZmlsdGVyVmVydGV4UG9zaXRpb24oKTtcXG5cXG4gICB2RnJhZ0Nvb3JkID0gYVZlcnRleFBvc2l0aW9uICogb3V0cHV0RnJhbWUuenc7XFxuXFxuICAgdGV4Y29vcmRzKHZGcmFnQ29vcmQsIGlucHV0U2l6ZS56dywgdl9yZ2JOVywgdl9yZ2JORSwgdl9yZ2JTVywgdl9yZ2JTRSwgdl9yZ2JNKTtcXG59XFxuXCI7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdmVydGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnhhYTIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBGWEFBRmlsdGVyID0gcmVxdWlyZSgnLi9GWEFBRmlsdGVyLmpzJyk7XG5cblxuXG5leHBvcnRzLkZYQUFGaWx0ZXIgPSBGWEFBRmlsdGVyLkZYQUFGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgbm9pc2UgPSByZXF1aXJlKCcuL25vaXNlLmpzJyk7XG5cbmNsYXNzIE5vaXNlRmlsdGVyIGV4dGVuZHMgY29yZS5GaWx0ZXIge1xuICBjb25zdHJ1Y3Rvcihub2lzZSQxID0gMC41LCBzZWVkID0gTWF0aC5yYW5kb20oKSkge1xuICAgIHN1cGVyKGNvcmUuZGVmYXVsdEZpbHRlclZlcnRleCwgbm9pc2VbXCJkZWZhdWx0XCJdLCB7XG4gICAgICB1Tm9pc2U6IDAsXG4gICAgICB1U2VlZDogMFxuICAgIH0pO1xuICAgIHRoaXMubm9pc2UgPSBub2lzZSQxO1xuICAgIHRoaXMuc2VlZCA9IHNlZWQ7XG4gIH1cbiAgZ2V0IG5vaXNlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVOb2lzZTtcbiAgfVxuICBzZXQgbm9pc2UodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVOb2lzZSA9IHZhbHVlO1xuICB9XG4gIGdldCBzZWVkKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVTZWVkO1xuICB9XG4gIHNldCBzZWVkKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51U2VlZCA9IHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydHMuTm9pc2VGaWx0ZXIgPSBOb2lzZUZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5vaXNlRmlsdGVyLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgTm9pc2VGaWx0ZXIgPSByZXF1aXJlKCcuL05vaXNlRmlsdGVyLmpzJyk7XG5cblxuXG5leHBvcnRzLk5vaXNlRmlsdGVyID0gTm9pc2VGaWx0ZXIuTm9pc2VGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGZyYWdtZW50ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG51bmlmb3JtIGZsb2F0IHVOb2lzZTtcXG51bmlmb3JtIGZsb2F0IHVTZWVkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcblxcbmZsb2F0IHJhbmQodmVjMiBjbylcXG57XFxuICAgIHJldHVybiBmcmFjdChzaW4oZG90KGNvLnh5LCB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMpO1xcbn1cXG5cXG52b2lkIG1haW4oKVxcbntcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuICAgIGZsb2F0IHJhbmRvbVZhbHVlID0gcmFuZChnbF9GcmFnQ29vcmQueHkgKiB1U2VlZCk7XFxuICAgIGZsb2F0IGRpZmYgPSAocmFuZG9tVmFsdWUgLSAwLjUpICogdU5vaXNlO1xcblxcbiAgICAvLyBVbi1wcmVtdWx0aXBseSBhbHBoYSBiZWZvcmUgYXBwbHlpbmcgdGhlIGNvbG9yIG1hdHJpeC4gU2VlIGlzc3VlICMzNTM5LlxcbiAgICBpZiAoY29sb3IuYSA+IDAuMCkge1xcbiAgICAgICAgY29sb3IucmdiIC89IGNvbG9yLmE7XFxuICAgIH1cXG5cXG4gICAgY29sb3IuciArPSBkaWZmO1xcbiAgICBjb2xvci5nICs9IGRpZmY7XFxuICAgIGNvbG9yLmIgKz0gZGlmZjtcXG5cXG4gICAgLy8gUHJlbXVsdGlwbHkgYWxwaGEgYWdhaW4uXFxuICAgIGNvbG9yLnJnYiAqPSBjb2xvci5hO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG59XFxuXCI7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZnJhZ21lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2lzZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgZGlzcGxheSA9IHJlcXVpcmUoJ0BwaXhpL2Rpc3BsYXknKTtcbnZhciBfY29uc3QgPSByZXF1aXJlKCcuL2NvbnN0LmpzJyk7XG52YXIgR3JhcGhpY3NHZW9tZXRyeSA9IHJlcXVpcmUoJy4vR3JhcGhpY3NHZW9tZXRyeS5qcycpO1xudmFyIEZpbGxTdHlsZSA9IHJlcXVpcmUoJy4vc3R5bGVzL0ZpbGxTdHlsZS5qcycpO1xudmFyIExpbmVTdHlsZSA9IHJlcXVpcmUoJy4vc3R5bGVzL0xpbmVTdHlsZS5qcycpO1xucmVxdWlyZSgnLi91dGlscy9pbmRleC5qcycpO1xudmFyIFF1YWRyYXRpY1V0aWxzID0gcmVxdWlyZSgnLi91dGlscy9RdWFkcmF0aWNVdGlscy5qcycpO1xudmFyIEJlemllclV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9CZXppZXJVdGlscy5qcycpO1xudmFyIEFyY1V0aWxzID0gcmVxdWlyZSgnLi91dGlscy9BcmNVdGlscy5qcycpO1xuXG5jb25zdCBERUZBVUxUX1NIQURFUlMgPSB7fTtcbmNvbnN0IF9HcmFwaGljcyA9IGNsYXNzIGV4dGVuZHMgZGlzcGxheS5Db250YWluZXIge1xuICBjb25zdHJ1Y3RvcihnZW9tZXRyeSA9IG51bGwpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcbiAgICB0aGlzLnBsdWdpbk5hbWUgPSBcImJhdGNoXCI7XG4gICAgdGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XG4gICAgdGhpcy5iYXRjaGVzID0gW107XG4gICAgdGhpcy5iYXRjaFRpbnQgPSAtMTtcbiAgICB0aGlzLmJhdGNoRGlydHkgPSAtMTtcbiAgICB0aGlzLnZlcnRleERhdGEgPSBudWxsO1xuICAgIHRoaXMuX2ZpbGxTdHlsZSA9IG5ldyBGaWxsU3R5bGUuRmlsbFN0eWxlKCk7XG4gICAgdGhpcy5fbGluZVN0eWxlID0gbmV3IExpbmVTdHlsZS5MaW5lU3R5bGUoKTtcbiAgICB0aGlzLl9tYXRyaXggPSBudWxsO1xuICAgIHRoaXMuX2hvbGVNb2RlID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZSA9IGNvcmUuU3RhdGUuZm9yMmQoKTtcbiAgICB0aGlzLl9nZW9tZXRyeSA9IGdlb21ldHJ5IHx8IG5ldyBHcmFwaGljc0dlb21ldHJ5LkdyYXBoaWNzR2VvbWV0cnkoKTtcbiAgICB0aGlzLl9nZW9tZXRyeS5yZWZDb3VudCsrO1xuICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gLTE7XG4gICAgdGhpcy5fdGludENvbG9yID0gbmV3IGNvcmUuQ29sb3IoMTY3NzcyMTUpO1xuICAgIHRoaXMuYmxlbmRNb2RlID0gY29yZS5CTEVORF9NT0RFUy5OT1JNQUw7XG4gIH1cbiAgZ2V0IGdlb21ldHJ5KCkge1xuICAgIHJldHVybiB0aGlzLl9nZW9tZXRyeTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICB0aGlzLmZpbmlzaFBvbHkoKTtcbiAgICByZXR1cm4gbmV3IF9HcmFwaGljcyh0aGlzLl9nZW9tZXRyeSk7XG4gIH1cbiAgc2V0IGJsZW5kTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuc3RhdGUuYmxlbmRNb2RlID0gdmFsdWU7XG4gIH1cbiAgZ2V0IGJsZW5kTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5ibGVuZE1vZGU7XG4gIH1cbiAgZ2V0IHRpbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbnRDb2xvci52YWx1ZTtcbiAgfVxuICBzZXQgdGludCh2YWx1ZSkge1xuICAgIHRoaXMuX3RpbnRDb2xvci5zZXRWYWx1ZSh2YWx1ZSk7XG4gIH1cbiAgZ2V0IGZpbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGxTdHlsZTtcbiAgfVxuICBnZXQgbGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGluZVN0eWxlO1xuICB9XG4gIGxpbmVTdHlsZShvcHRpb25zID0gbnVsbCwgY29sb3IgPSAwLCBhbHBoYSwgYWxpZ25tZW50ID0gMC41LCBuYXRpdmUgPSBmYWxzZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgb3B0aW9ucyA9IHsgd2lkdGg6IG9wdGlvbnMsIGNvbG9yLCBhbHBoYSwgYWxpZ25tZW50LCBuYXRpdmUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGluZVRleHR1cmVTdHlsZShvcHRpb25zKTtcbiAgfVxuICBsaW5lVGV4dHVyZVN0eWxlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZhdWx0TGluZVN0eWxlT3B0aW9ucyA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgdGV4dHVyZTogY29yZS5UZXh0dXJlLldISVRFLFxuICAgICAgY29sb3I6IG9wdGlvbnM/LnRleHR1cmUgPyAxNjc3NzIxNSA6IDAsXG4gICAgICBtYXRyaXg6IG51bGwsXG4gICAgICBhbGlnbm1lbnQ6IDAuNSxcbiAgICAgIG5hdGl2ZTogZmFsc2UsXG4gICAgICBjYXA6IF9jb25zdC5MSU5FX0NBUC5CVVRULFxuICAgICAgam9pbjogX2NvbnN0LkxJTkVfSk9JTi5NSVRFUixcbiAgICAgIG1pdGVyTGltaXQ6IDEwXG4gICAgfTtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0TGluZVN0eWxlT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgdGhpcy5ub3JtYWxpemVDb2xvcihvcHRpb25zKTtcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aCkge1xuICAgICAgdGhpcy5zdGFydFBvbHkoKTtcbiAgICB9XG4gICAgY29uc3QgdmlzaWJsZSA9IG9wdGlvbnMud2lkdGggPiAwICYmIG9wdGlvbnMuYWxwaGEgPiAwO1xuICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgdGhpcy5fbGluZVN0eWxlLnJlc2V0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLm1hdHJpeCkge1xuICAgICAgICBvcHRpb25zLm1hdHJpeCA9IG9wdGlvbnMubWF0cml4LmNsb25lKCk7XG4gICAgICAgIG9wdGlvbnMubWF0cml4LmludmVydCgpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9saW5lU3R5bGUsIHsgdmlzaWJsZSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RhcnRQb2x5KCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKSB7XG4gICAgICBjb25zdCBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cztcbiAgICAgIGNvbnN0IGxlbiA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICAgIHRoaXMuZHJhd1NoYXBlKHRoaXMuY3VycmVudFBhdGgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbmV3IGNvcmUuUG9seWdvbigpO1xuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmNsb3NlU3Ryb2tlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3VycmVudFBhdGgucG9pbnRzLnB1c2gocG9pbnRzW2xlbiAtIDJdLCBwb2ludHNbbGVuIC0gMV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbmV3IGNvcmUuUG9seWdvbigpO1xuICAgICAgdGhpcy5jdXJyZW50UGF0aC5jbG9zZVN0cm9rZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBmaW5pc2hQb2x5KCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoID4gMikge1xuICAgICAgICB0aGlzLmRyYXdTaGFwZSh0aGlzLmN1cnJlbnRQYXRoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBtb3ZlVG8oeCwgeSkge1xuICAgIHRoaXMuc3RhcnRQb2x5KCk7XG4gICAgdGhpcy5jdXJyZW50UGF0aC5wb2ludHNbMF0gPSB4O1xuICAgIHRoaXMuY3VycmVudFBhdGgucG9pbnRzWzFdID0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaW5lVG8oeCwgeSkge1xuICAgIGlmICghdGhpcy5jdXJyZW50UGF0aCkge1xuICAgICAgdGhpcy5tb3ZlVG8oMCwgMCk7XG4gICAgfVxuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzO1xuICAgIGNvbnN0IGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcbiAgICBjb25zdCBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGZyb21YICE9PSB4IHx8IGZyb21ZICE9PSB5KSB7XG4gICAgICBwb2ludHMucHVzaCh4LCB5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX2luaXRDdXJ2ZSh4ID0gMCwgeSA9IDApIHtcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGgucG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cyA9IFt4LCB5XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tb3ZlVG8oeCwgeSk7XG4gICAgfVxuICB9XG4gIHF1YWRyYXRpY0N1cnZlVG8oY3BYLCBjcFksIHRvWCwgdG9ZKSB7XG4gICAgdGhpcy5faW5pdEN1cnZlKCk7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5wb2ludHM7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMubW92ZVRvKDAsIDApO1xuICAgIH1cbiAgICBRdWFkcmF0aWNVdGlscy5RdWFkcmF0aWNVdGlscy5jdXJ2ZVRvKGNwWCwgY3BZLCB0b1gsIHRvWSwgcG9pbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBiZXppZXJDdXJ2ZVRvKGNwWCwgY3BZLCBjcFgyLCBjcFkyLCB0b1gsIHRvWSkge1xuICAgIHRoaXMuX2luaXRDdXJ2ZSgpO1xuICAgIEJlemllclV0aWxzLkJlemllclV0aWxzLmN1cnZlVG8oY3BYLCBjcFksIGNwWDIsIGNwWTIsIHRvWCwgdG9ZLCB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuICAgIHRoaXMuX2luaXRDdXJ2ZSh4MSwgeTEpO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzO1xuICAgIGNvbnN0IHJlc3VsdCA9IEFyY1V0aWxzLkFyY1V0aWxzLmN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cywgcG9pbnRzKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBjb25zdCB7IGN4LCBjeSwgcmFkaXVzOiByYWRpdXMyLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSB9ID0gcmVzdWx0O1xuICAgICAgdGhpcy5hcmMoY3gsIGN5LCByYWRpdXMyLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFyYyhjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UgPSBmYWxzZSkge1xuICAgIGlmIChzdGFydEFuZ2xlID09PSBlbmRBbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICghYW50aWNsb2Nrd2lzZSAmJiBlbmRBbmdsZSA8PSBzdGFydEFuZ2xlKSB7XG4gICAgICBlbmRBbmdsZSArPSBjb3JlLlBJXzI7XG4gICAgfSBlbHNlIGlmIChhbnRpY2xvY2t3aXNlICYmIHN0YXJ0QW5nbGUgPD0gZW5kQW5nbGUpIHtcbiAgICAgIHN0YXJ0QW5nbGUgKz0gY29yZS5QSV8yO1xuICAgIH1cbiAgICBjb25zdCBzd2VlcCA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcbiAgICBpZiAoc3dlZXAgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFggPSBjeCArIE1hdGguY29zKHN0YXJ0QW5nbGUpICogcmFkaXVzO1xuICAgIGNvbnN0IHN0YXJ0WSA9IGN5ICsgTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByYWRpdXM7XG4gICAgY29uc3QgZXBzID0gdGhpcy5fZ2VvbWV0cnkuY2xvc2VQb2ludEVwcztcbiAgICBsZXQgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aCA/IHRoaXMuY3VycmVudFBhdGgucG9pbnRzIDogbnVsbDtcbiAgICBpZiAocG9pbnRzKSB7XG4gICAgICBjb25zdCB4RGlmZiA9IE1hdGguYWJzKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0gLSBzdGFydFgpO1xuICAgICAgY29uc3QgeURpZmYgPSBNYXRoLmFicyhwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIC0gc3RhcnRZKTtcbiAgICAgIGlmICh4RGlmZiA8IGVwcyAmJiB5RGlmZiA8IGVwcykge1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9pbnRzLnB1c2goc3RhcnRYLCBzdGFydFkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1vdmVUbyhzdGFydFgsIHN0YXJ0WSk7XG4gICAgICBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cztcbiAgICB9XG4gICAgQXJjVXRpbHMuQXJjVXRpbHMuYXJjKHN0YXJ0WCwgc3RhcnRZLCBjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIHBvaW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmVnaW5GaWxsKGNvbG9yID0gMCwgYWxwaGEpIHtcbiAgICByZXR1cm4gdGhpcy5iZWdpblRleHR1cmVGaWxsKHsgdGV4dHVyZTogY29yZS5UZXh0dXJlLldISVRFLCBjb2xvciwgYWxwaGEgfSk7XG4gIH1cbiAgbm9ybWFsaXplQ29sb3Iob3B0aW9ucykge1xuICAgIGNvbnN0IHRlbXAgPSBjb3JlLkNvbG9yLnNoYXJlZC5zZXRWYWx1ZShvcHRpb25zLmNvbG9yID8/IDApO1xuICAgIG9wdGlvbnMuY29sb3IgPSB0ZW1wLnRvTnVtYmVyKCk7XG4gICAgb3B0aW9ucy5hbHBoYSA/PyAob3B0aW9ucy5hbHBoYSA9IHRlbXAuYWxwaGEpO1xuICB9XG4gIGJlZ2luVGV4dHVyZUZpbGwob3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgdGV4dHVyZTogY29yZS5UZXh0dXJlLldISVRFLFxuICAgICAgY29sb3I6IDE2Nzc3MjE1LFxuICAgICAgbWF0cml4OiBudWxsXG4gICAgfTtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgdGhpcy5ub3JtYWxpemVDb2xvcihvcHRpb25zKTtcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aCkge1xuICAgICAgdGhpcy5zdGFydFBvbHkoKTtcbiAgICB9XG4gICAgY29uc3QgdmlzaWJsZSA9IG9wdGlvbnMuYWxwaGEgPiAwO1xuICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgdGhpcy5fZmlsbFN0eWxlLnJlc2V0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLm1hdHJpeCkge1xuICAgICAgICBvcHRpb25zLm1hdHJpeCA9IG9wdGlvbnMubWF0cml4LmNsb25lKCk7XG4gICAgICAgIG9wdGlvbnMubWF0cml4LmludmVydCgpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9maWxsU3R5bGUsIHsgdmlzaWJsZSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZW5kRmlsbCgpIHtcbiAgICB0aGlzLmZpbmlzaFBvbHkoKTtcbiAgICB0aGlzLl9maWxsU3R5bGUucmVzZXQoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkcmF3UmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhd1NoYXBlKG5ldyBjb3JlLlJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XG4gIH1cbiAgZHJhd1JvdW5kZWRSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuICAgIHJldHVybiB0aGlzLmRyYXdTaGFwZShuZXcgY29yZS5Sb3VuZGVkUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykpO1xuICB9XG4gIGRyYXdDaXJjbGUoeCwgeSwgcmFkaXVzKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhd1NoYXBlKG5ldyBjb3JlLkNpcmNsZSh4LCB5LCByYWRpdXMpKTtcbiAgfVxuICBkcmF3RWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhd1NoYXBlKG5ldyBjb3JlLkVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICB9XG4gIGRyYXdQb2x5Z29uKC4uLnBhdGgpIHtcbiAgICBsZXQgcG9pbnRzO1xuICAgIGxldCBjbG9zZVN0cm9rZSA9IHRydWU7XG4gICAgY29uc3QgcG9seSA9IHBhdGhbMF07XG4gICAgaWYgKHBvbHkucG9pbnRzKSB7XG4gICAgICBjbG9zZVN0cm9rZSA9IHBvbHkuY2xvc2VTdHJva2U7XG4gICAgICBwb2ludHMgPSBwb2x5LnBvaW50cztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGF0aFswXSkpIHtcbiAgICAgIHBvaW50cyA9IHBhdGhbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cyA9IHBhdGg7XG4gICAgfVxuICAgIGNvbnN0IHNoYXBlID0gbmV3IGNvcmUuUG9seWdvbihwb2ludHMpO1xuICAgIHNoYXBlLmNsb3NlU3Ryb2tlID0gY2xvc2VTdHJva2U7XG4gICAgdGhpcy5kcmF3U2hhcGUoc2hhcGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRyYXdTaGFwZShzaGFwZSkge1xuICAgIGlmICghdGhpcy5faG9sZU1vZGUpIHtcbiAgICAgIHRoaXMuX2dlb21ldHJ5LmRyYXdTaGFwZShzaGFwZSwgdGhpcy5fZmlsbFN0eWxlLmNsb25lKCksIHRoaXMuX2xpbmVTdHlsZS5jbG9uZSgpLCB0aGlzLl9tYXRyaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9nZW9tZXRyeS5kcmF3SG9sZShzaGFwZSwgdGhpcy5fbWF0cml4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fZ2VvbWV0cnkuY2xlYXIoKTtcbiAgICB0aGlzLl9saW5lU3R5bGUucmVzZXQoKTtcbiAgICB0aGlzLl9maWxsU3R5bGUucmVzZXQoKTtcbiAgICB0aGlzLl9ib3VuZHNJRCsrO1xuICAgIHRoaXMuX21hdHJpeCA9IG51bGw7XG4gICAgdGhpcy5faG9sZU1vZGUgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRQYXRoID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpc0Zhc3RSZWN0KCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9nZW9tZXRyeS5ncmFwaGljc0RhdGE7XG4gICAgcmV0dXJuIGRhdGEubGVuZ3RoID09PSAxICYmIGRhdGFbMF0uc2hhcGUudHlwZSA9PT0gY29yZS5TSEFQRVMuUkVDVCAmJiAhZGF0YVswXS5tYXRyaXggJiYgIWRhdGFbMF0uaG9sZXMubGVuZ3RoICYmICEoZGF0YVswXS5saW5lU3R5bGUudmlzaWJsZSAmJiBkYXRhWzBdLmxpbmVTdHlsZS53aWR0aCk7XG4gIH1cbiAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgIHRoaXMuZmluaXNoUG9seSgpO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5fZ2VvbWV0cnk7XG4gICAgZ2VvbWV0cnkudXBkYXRlQmF0Y2hlcygpO1xuICAgIGlmIChnZW9tZXRyeS5iYXRjaGFibGUpIHtcbiAgICAgIGlmICh0aGlzLmJhdGNoRGlydHkgIT09IGdlb21ldHJ5LmJhdGNoRGlydHkpIHtcbiAgICAgICAgdGhpcy5fcG9wdWxhdGVCYXRjaGVzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXJCYXRjaGVkKHJlbmRlcmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyZXIuYmF0Y2guZmx1c2goKTtcbiAgICAgIHRoaXMuX3JlbmRlckRpcmVjdChyZW5kZXJlcik7XG4gICAgfVxuICB9XG4gIF9wb3B1bGF0ZUJhdGNoZXMoKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeTtcbiAgICBjb25zdCBibGVuZE1vZGUgPSB0aGlzLmJsZW5kTW9kZTtcbiAgICBjb25zdCBsZW4gPSBnZW9tZXRyeS5iYXRjaGVzLmxlbmd0aDtcbiAgICB0aGlzLmJhdGNoVGludCA9IC0xO1xuICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gLTE7XG4gICAgdGhpcy5iYXRjaERpcnR5ID0gZ2VvbWV0cnkuYmF0Y2hEaXJ0eTtcbiAgICB0aGlzLmJhdGNoZXMubGVuZ3RoID0gbGVuO1xuICAgIHRoaXMudmVydGV4RGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZ2VvbWV0cnkucG9pbnRzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBnSSA9IGdlb21ldHJ5LmJhdGNoZXNbaV07XG4gICAgICBjb25zdCBjb2xvciA9IGdJLnN0eWxlLmNvbG9yO1xuICAgICAgY29uc3QgdmVydGV4RGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy52ZXJ0ZXhEYXRhLmJ1ZmZlciwgZ0kuYXR0cmliU3RhcnQgKiA0ICogMiwgZ0kuYXR0cmliU2l6ZSAqIDIpO1xuICAgICAgY29uc3QgdXZzID0gbmV3IEZsb2F0MzJBcnJheShnZW9tZXRyeS51dnNGbG9hdDMyLmJ1ZmZlciwgZ0kuYXR0cmliU3RhcnQgKiA0ICogMiwgZ0kuYXR0cmliU2l6ZSAqIDIpO1xuICAgICAgY29uc3QgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShnZW9tZXRyeS5pbmRpY2VzVWludDE2LmJ1ZmZlciwgZ0kuc3RhcnQgKiAyLCBnSS5zaXplKTtcbiAgICAgIGNvbnN0IGJhdGNoID0ge1xuICAgICAgICB2ZXJ0ZXhEYXRhLFxuICAgICAgICBibGVuZE1vZGUsXG4gICAgICAgIGluZGljZXMsXG4gICAgICAgIHV2cyxcbiAgICAgICAgX2JhdGNoUkdCOiBjb3JlLkNvbG9yLnNoYXJlZC5zZXRWYWx1ZShjb2xvcikudG9SZ2JBcnJheSgpLFxuICAgICAgICBfdGludFJHQjogY29sb3IsXG4gICAgICAgIF90ZXh0dXJlOiBnSS5zdHlsZS50ZXh0dXJlLFxuICAgICAgICBhbHBoYTogZ0kuc3R5bGUuYWxwaGEsXG4gICAgICAgIHdvcmxkQWxwaGE6IDFcbiAgICAgIH07XG4gICAgICB0aGlzLmJhdGNoZXNbaV0gPSBiYXRjaDtcbiAgICB9XG4gIH1cbiAgX3JlbmRlckJhdGNoZWQocmVuZGVyZXIpIHtcbiAgICBpZiAoIXRoaXMuYmF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVuZGVyZXIuYmF0Y2guc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2luc1t0aGlzLnBsdWdpbk5hbWVdKTtcbiAgICB0aGlzLmNhbGN1bGF0ZVZlcnRpY2VzKCk7XG4gICAgdGhpcy5jYWxjdWxhdGVUaW50cygpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5iYXRjaGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLmJhdGNoZXNbaV07XG4gICAgICBiYXRjaC53b3JsZEFscGhhID0gdGhpcy53b3JsZEFscGhhICogYmF0Y2guYWxwaGE7XG4gICAgICByZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0ucmVuZGVyKGJhdGNoKTtcbiAgICB9XG4gIH1cbiAgX3JlbmRlckRpcmVjdChyZW5kZXJlcikge1xuICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuX3Jlc29sdmVEaXJlY3RTaGFkZXIocmVuZGVyZXIpO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5fZ2VvbWV0cnk7XG4gICAgY29uc3Qgd29ybGRBbHBoYSA9IHRoaXMud29ybGRBbHBoYTtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHNoYWRlci51bmlmb3JtcztcbiAgICBjb25zdCBkcmF3Q2FsbHMgPSBnZW9tZXRyeS5kcmF3Q2FsbHM7XG4gICAgdW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXggPSB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICBjb3JlLkNvbG9yLnNoYXJlZC5zZXRWYWx1ZSh0aGlzLl90aW50Q29sb3IpLnByZW11bHRpcGx5KHdvcmxkQWxwaGEpLnRvQXJyYXkodW5pZm9ybXMudGludCk7XG4gICAgcmVuZGVyZXIuc2hhZGVyLmJpbmQoc2hhZGVyKTtcbiAgICByZW5kZXJlci5nZW9tZXRyeS5iaW5kKGdlb21ldHJ5LCBzaGFkZXIpO1xuICAgIHJlbmRlcmVyLnN0YXRlLnNldCh0aGlzLnN0YXRlKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGRyYXdDYWxscy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMuX3JlbmRlckRyYXdDYWxsRGlyZWN0KHJlbmRlcmVyLCBnZW9tZXRyeS5kcmF3Q2FsbHNbaV0pO1xuICAgIH1cbiAgfVxuICBfcmVuZGVyRHJhd0NhbGxEaXJlY3QocmVuZGVyZXIsIGRyYXdDYWxsKSB7XG4gICAgY29uc3QgeyB0ZXhBcnJheSwgdHlwZSwgc2l6ZSwgc3RhcnQgfSA9IGRyYXdDYWxsO1xuICAgIGNvbnN0IGdyb3VwVGV4dHVyZUNvdW50ID0gdGV4QXJyYXkuY291bnQ7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBncm91cFRleHR1cmVDb3VudDsgaisrKSB7XG4gICAgICByZW5kZXJlci50ZXh0dXJlLmJpbmQodGV4QXJyYXkuZWxlbWVudHNbal0sIGopO1xuICAgIH1cbiAgICByZW5kZXJlci5nZW9tZXRyeS5kcmF3KHR5cGUsIHNpemUsIHN0YXJ0KTtcbiAgfVxuICBfcmVzb2x2ZURpcmVjdFNoYWRlcihyZW5kZXJlcikge1xuICAgIGxldCBzaGFkZXIgPSB0aGlzLnNoYWRlcjtcbiAgICBjb25zdCBwbHVnaW5OYW1lID0gdGhpcy5wbHVnaW5OYW1lO1xuICAgIGlmICghc2hhZGVyKSB7XG4gICAgICBpZiAoIURFRkFVTFRfU0hBREVSU1twbHVnaW5OYW1lXSkge1xuICAgICAgICBjb25zdCB7IG1heFRleHR1cmVzIH0gPSByZW5kZXJlci5wbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgICBjb25zdCBzYW1wbGVWYWx1ZXMgPSBuZXcgSW50MzJBcnJheShtYXhUZXh0dXJlcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4VGV4dHVyZXM7IGkrKykge1xuICAgICAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdW5pZm9ybXMgPSB7XG4gICAgICAgICAgdGludDogbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMSwgMV0pLFxuICAgICAgICAgIHRyYW5zbGF0aW9uTWF0cml4OiBuZXcgY29yZS5NYXRyaXgoKSxcbiAgICAgICAgICBkZWZhdWx0OiBjb3JlLlVuaWZvcm1Hcm91cC5mcm9tKHsgdVNhbXBsZXJzOiBzYW1wbGVWYWx1ZXMgfSwgdHJ1ZSlcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IHJlbmRlcmVyLnBsdWdpbnNbcGx1Z2luTmFtZV0uX3NoYWRlci5wcm9ncmFtO1xuICAgICAgICBERUZBVUxUX1NIQURFUlNbcGx1Z2luTmFtZV0gPSBuZXcgY29yZS5TaGFkZXIocHJvZ3JhbSwgdW5pZm9ybXMpO1xuICAgICAgfVxuICAgICAgc2hhZGVyID0gREVGQVVMVF9TSEFERVJTW3BsdWdpbk5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gc2hhZGVyO1xuICB9XG4gIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgdGhpcy5maW5pc2hQb2x5KCk7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeTtcbiAgICBpZiAoIWdlb21ldHJ5LmdyYXBoaWNzRGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZIH0gPSBnZW9tZXRyeS5ib3VuZHM7XG4gICAgdGhpcy5fYm91bmRzLmFkZEZyYW1lKHRoaXMudHJhbnNmb3JtLCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKTtcbiAgfVxuICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UocG9pbnQsIF9HcmFwaGljcy5fVEVNUF9QT0lOVCk7XG4gICAgcmV0dXJuIHRoaXMuX2dlb21ldHJ5LmNvbnRhaW5zUG9pbnQoX0dyYXBoaWNzLl9URU1QX1BPSU5UKTtcbiAgfVxuICBjYWxjdWxhdGVUaW50cygpIHtcbiAgICBpZiAodGhpcy5iYXRjaFRpbnQgIT09IHRoaXMudGludCkge1xuICAgICAgdGhpcy5iYXRjaFRpbnQgPSB0aGlzLl90aW50Q29sb3IudG9OdW1iZXIoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5iYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJhdGNoID0gdGhpcy5iYXRjaGVzW2ldO1xuICAgICAgICBiYXRjaC5fdGludFJHQiA9IGNvcmUuQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHRoaXMuX3RpbnRDb2xvcikubXVsdGlwbHkoYmF0Y2guX2JhdGNoUkdCKS50b0xpdHRsZUVuZGlhbk51bWJlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxjdWxhdGVWZXJ0aWNlcygpIHtcbiAgICBjb25zdCB3dElEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQ7XG4gICAgaWYgKHRoaXMuX3RyYW5zZm9ybUlEID09PSB3dElEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gd3RJRDtcbiAgICBjb25zdCB3dCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgIGNvbnN0IGEgPSB3dC5hO1xuICAgIGNvbnN0IGIgPSB3dC5iO1xuICAgIGNvbnN0IGMgPSB3dC5jO1xuICAgIGNvbnN0IGQgPSB3dC5kO1xuICAgIGNvbnN0IHR4ID0gd3QudHg7XG4gICAgY29uc3QgdHkgPSB3dC50eTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZ2VvbWV0cnkucG9pbnRzO1xuICAgIGNvbnN0IHZlcnRleERhdGEgPSB0aGlzLnZlcnRleERhdGE7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHggPSBkYXRhW2ldO1xuICAgICAgY29uc3QgeSA9IGRhdGFbaSArIDFdO1xuICAgICAgdmVydGV4RGF0YVtjb3VudCsrXSA9IGEgKiB4ICsgYyAqIHkgKyB0eDtcbiAgICAgIHZlcnRleERhdGFbY291bnQrK10gPSBkICogeSArIGIgKiB4ICsgdHk7XG4gICAgfVxuICB9XG4gIGNsb3NlUGF0aCgpIHtcbiAgICBjb25zdCBjdXJyZW50UGF0aCA9IHRoaXMuY3VycmVudFBhdGg7XG4gICAgaWYgKGN1cnJlbnRQYXRoKSB7XG4gICAgICBjdXJyZW50UGF0aC5jbG9zZVN0cm9rZSA9IHRydWU7XG4gICAgICB0aGlzLmZpbmlzaFBvbHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0TWF0cml4KG1hdHJpeCkge1xuICAgIHRoaXMuX21hdHJpeCA9IG1hdHJpeDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBiZWdpbkhvbGUoKSB7XG4gICAgdGhpcy5maW5pc2hQb2x5KCk7XG4gICAgdGhpcy5faG9sZU1vZGUgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGVuZEhvbGUoKSB7XG4gICAgdGhpcy5maW5pc2hQb2x5KCk7XG4gICAgdGhpcy5faG9sZU1vZGUgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICB0aGlzLl9nZW9tZXRyeS5yZWZDb3VudC0tO1xuICAgIGlmICh0aGlzLl9nZW9tZXRyeS5yZWZDb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5fZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLl9tYXRyaXggPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xuICAgIHRoaXMuX2xpbmVTdHlsZS5kZXN0cm95KCk7XG4gICAgdGhpcy5fbGluZVN0eWxlID0gbnVsbDtcbiAgICB0aGlzLl9maWxsU3R5bGUuZGVzdHJveSgpO1xuICAgIHRoaXMuX2ZpbGxTdHlsZSA9IG51bGw7XG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBudWxsO1xuICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcbiAgICB0aGlzLnZlcnRleERhdGEgPSBudWxsO1xuICAgIHRoaXMuYmF0Y2hlcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuYmF0Y2hlcyA9IG51bGw7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgfVxufTtcbmxldCBHcmFwaGljcyA9IF9HcmFwaGljcztcbkdyYXBoaWNzLmN1cnZlcyA9IF9jb25zdC5jdXJ2ZXM7XG5HcmFwaGljcy5fVEVNUF9QT0lOVCA9IG5ldyBjb3JlLlBvaW50KCk7XG5cbmV4cG9ydHMuR3JhcGhpY3MgPSBHcmFwaGljcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jbGFzcyBHcmFwaGljc0RhdGEge1xuICBjb25zdHJ1Y3RvcihzaGFwZSwgZmlsbFN0eWxlID0gbnVsbCwgbGluZVN0eWxlID0gbnVsbCwgbWF0cml4ID0gbnVsbCkge1xuICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgdGhpcy5ob2xlcyA9IFtdO1xuICAgIHRoaXMuc2hhcGUgPSBzaGFwZTtcbiAgICB0aGlzLmxpbmVTdHlsZSA9IGxpbmVTdHlsZTtcbiAgICB0aGlzLmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICB0aGlzLm1hdHJpeCA9IG1hdHJpeDtcbiAgICB0aGlzLnR5cGUgPSBzaGFwZS50eXBlO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgR3JhcGhpY3NEYXRhKHRoaXMuc2hhcGUsIHRoaXMuZmlsbFN0eWxlLCB0aGlzLmxpbmVTdHlsZSwgdGhpcy5tYXRyaXgpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zaGFwZSA9IG51bGw7XG4gICAgdGhpcy5ob2xlcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuaG9sZXMgPSBudWxsO1xuICAgIHRoaXMucG9pbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5wb2ludHMgPSBudWxsO1xuICAgIHRoaXMubGluZVN0eWxlID0gbnVsbDtcbiAgICB0aGlzLmZpbGxTdHlsZSA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0cy5HcmFwaGljc0RhdGEgPSBHcmFwaGljc0RhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljc0RhdGEuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xudmFyIGRpc3BsYXkgPSByZXF1aXJlKCdAcGl4aS9kaXNwbGF5Jyk7XG52YXIgR3JhcGhpY3NEYXRhID0gcmVxdWlyZSgnLi9HcmFwaGljc0RhdGEuanMnKTtcbnZhciBpbmRleCA9IHJlcXVpcmUoJy4vdXRpbHMvaW5kZXguanMnKTtcbnZhciBCYXRjaFBhcnQgPSByZXF1aXJlKCcuL3V0aWxzL0JhdGNoUGFydC5qcycpO1xudmFyIGJ1aWxkUG9seSA9IHJlcXVpcmUoJy4vdXRpbHMvYnVpbGRQb2x5LmpzJyk7XG52YXIgYnVpbGRMaW5lID0gcmVxdWlyZSgnLi91dGlscy9idWlsZExpbmUuanMnKTtcblxuY29uc3QgdG1wUG9pbnQgPSBuZXcgY29yZS5Qb2ludCgpO1xuY29uc3QgX0dyYXBoaWNzR2VvbWV0cnkgPSBjbGFzcyBleHRlbmRzIGNvcmUuQmF0Y2hHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jbG9zZVBvaW50RXBzID0gMWUtNDtcbiAgICB0aGlzLmJvdW5kc1BhZGRpbmcgPSAwO1xuICAgIHRoaXMudXZzRmxvYXQzMiA9IG51bGw7XG4gICAgdGhpcy5pbmRpY2VzVWludDE2ID0gbnVsbDtcbiAgICB0aGlzLmJhdGNoYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgdGhpcy5jb2xvcnMgPSBbXTtcbiAgICB0aGlzLnV2cyA9IFtdO1xuICAgIHRoaXMuaW5kaWNlcyA9IFtdO1xuICAgIHRoaXMudGV4dHVyZUlkcyA9IFtdO1xuICAgIHRoaXMuZ3JhcGhpY3NEYXRhID0gW107XG4gICAgdGhpcy5kcmF3Q2FsbHMgPSBbXTtcbiAgICB0aGlzLmJhdGNoRGlydHkgPSAtMTtcbiAgICB0aGlzLmJhdGNoZXMgPSBbXTtcbiAgICB0aGlzLmRpcnR5ID0gMDtcbiAgICB0aGlzLmNhY2hlRGlydHkgPSAtMTtcbiAgICB0aGlzLmNsZWFyRGlydHkgPSAwO1xuICAgIHRoaXMuc2hhcGVJbmRleCA9IDA7XG4gICAgdGhpcy5fYm91bmRzID0gbmV3IGRpc3BsYXkuQm91bmRzKCk7XG4gICAgdGhpcy5ib3VuZHNEaXJ0eSA9IC0xO1xuICB9XG4gIGdldCBib3VuZHMoKSB7XG4gICAgdGhpcy51cGRhdGVCYXRjaGVzKCk7XG4gICAgaWYgKHRoaXMuYm91bmRzRGlydHkgIT09IHRoaXMuZGlydHkpIHtcbiAgICAgIHRoaXMuYm91bmRzRGlydHkgPSB0aGlzLmRpcnR5O1xuICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2JvdW5kcztcbiAgfVxuICBpbnZhbGlkYXRlKCkge1xuICAgIHRoaXMuYm91bmRzRGlydHkgPSAtMTtcbiAgICB0aGlzLmRpcnR5Kys7XG4gICAgdGhpcy5iYXRjaERpcnR5Kys7XG4gICAgdGhpcy5zaGFwZUluZGV4ID0gMDtcbiAgICB0aGlzLnBvaW50cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuY29sb3JzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy51dnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmluZGljZXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnRleHR1cmVJZHMubGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZHJhd0NhbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmRyYXdDYWxsc1tpXS50ZXhBcnJheS5jbGVhcigpO1xuICAgICAgaW5kZXguRFJBV19DQUxMX1BPT0wucHVzaCh0aGlzLmRyYXdDYWxsc1tpXSk7XG4gICAgfVxuICAgIHRoaXMuZHJhd0NhbGxzLmxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGJhdGNoUGFydCA9IHRoaXMuYmF0Y2hlc1tpXTtcbiAgICAgIGJhdGNoUGFydC5yZXNldCgpO1xuICAgICAgaW5kZXguQkFUQ0hfUE9PTC5wdXNoKGJhdGNoUGFydCk7XG4gICAgfVxuICAgIHRoaXMuYmF0Y2hlcy5sZW5ndGggPSAwO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGlmICh0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIHRoaXMuY2xlYXJEaXJ0eSsrO1xuICAgICAgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZHJhd1NoYXBlKHNoYXBlLCBmaWxsU3R5bGUgPSBudWxsLCBsaW5lU3R5bGUgPSBudWxsLCBtYXRyaXggPSBudWxsKSB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBHcmFwaGljc0RhdGEuR3JhcGhpY3NEYXRhKHNoYXBlLCBmaWxsU3R5bGUsIGxpbmVTdHlsZSwgbWF0cml4KTtcbiAgICB0aGlzLmdyYXBoaWNzRGF0YS5wdXNoKGRhdGEpO1xuICAgIHRoaXMuZGlydHkrKztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkcmF3SG9sZShzaGFwZSwgbWF0cml4ID0gbnVsbCkge1xuICAgIGlmICghdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IG5ldyBHcmFwaGljc0RhdGEuR3JhcGhpY3NEYXRhKHNoYXBlLCBudWxsLCBudWxsLCBtYXRyaXgpO1xuICAgIGNvbnN0IGxhc3RTaGFwZSA9IHRoaXMuZ3JhcGhpY3NEYXRhW3RoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCAtIDFdO1xuICAgIGRhdGEubGluZVN0eWxlID0gbGFzdFNoYXBlLmxpbmVTdHlsZTtcbiAgICBsYXN0U2hhcGUuaG9sZXMucHVzaChkYXRhKTtcbiAgICB0aGlzLmRpcnR5Kys7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgdGhpcy5ncmFwaGljc0RhdGFbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLnBvaW50cy5sZW5ndGggPSAwO1xuICAgIHRoaXMucG9pbnRzID0gbnVsbDtcbiAgICB0aGlzLmNvbG9ycy5sZW5ndGggPSAwO1xuICAgIHRoaXMuY29sb3JzID0gbnVsbDtcbiAgICB0aGlzLnV2cy5sZW5ndGggPSAwO1xuICAgIHRoaXMudXZzID0gbnVsbDtcbiAgICB0aGlzLmluZGljZXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmluZGljZXMgPSBudWxsO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5ncmFwaGljc0RhdGEgPSBudWxsO1xuICAgIHRoaXMuZHJhd0NhbGxzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5kcmF3Q2FsbHMgPSBudWxsO1xuICAgIHRoaXMuYmF0Y2hlcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuYmF0Y2hlcyA9IG51bGw7XG4gICAgdGhpcy5fYm91bmRzID0gbnVsbDtcbiAgfVxuICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgY29uc3QgZ3JhcGhpY3NEYXRhID0gdGhpcy5ncmFwaGljc0RhdGE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmFwaGljc0RhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBncmFwaGljc0RhdGFbaV07XG4gICAgICBpZiAoIWRhdGEuZmlsbFN0eWxlLnZpc2libGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5zaGFwZSkge1xuICAgICAgICBpZiAoZGF0YS5tYXRyaXgpIHtcbiAgICAgICAgICBkYXRhLm1hdHJpeC5hcHBseUludmVyc2UocG9pbnQsIHRtcFBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0bXBQb2ludC5jb3B5RnJvbShwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuc2hhcGUuY29udGFpbnModG1wUG9pbnQueCwgdG1wUG9pbnQueSkpIHtcbiAgICAgICAgICBsZXQgaGl0SG9sZSA9IGZhbHNlO1xuICAgICAgICAgIGlmIChkYXRhLmhvbGVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgZGF0YS5ob2xlcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgaG9sZSA9IGRhdGEuaG9sZXNbaTJdO1xuICAgICAgICAgICAgICBpZiAoaG9sZS5zaGFwZS5jb250YWlucyh0bXBQb2ludC54LCB0bXBQb2ludC55KSkge1xuICAgICAgICAgICAgICAgIGhpdEhvbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaGl0SG9sZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB1cGRhdGVCYXRjaGVzKCkge1xuICAgIGlmICghdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoKSB7XG4gICAgICB0aGlzLmJhdGNoYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy52YWxpZGF0ZUJhdGNoaW5nKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jYWNoZURpcnR5ID0gdGhpcy5kaXJ0eTtcbiAgICBjb25zdCB1dnMgPSB0aGlzLnV2cztcbiAgICBjb25zdCBncmFwaGljc0RhdGEgPSB0aGlzLmdyYXBoaWNzRGF0YTtcbiAgICBsZXQgYmF0Y2hQYXJ0ID0gbnVsbDtcbiAgICBsZXQgY3VycmVudFN0eWxlID0gbnVsbDtcbiAgICBpZiAodGhpcy5iYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGJhdGNoUGFydCA9IHRoaXMuYmF0Y2hlc1t0aGlzLmJhdGNoZXMubGVuZ3RoIC0gMV07XG4gICAgICBjdXJyZW50U3R5bGUgPSBiYXRjaFBhcnQuc3R5bGU7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSB0aGlzLnNoYXBlSW5kZXg7IGkgPCBncmFwaGljc0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuc2hhcGVJbmRleCsrO1xuICAgICAgY29uc3QgZGF0YSA9IGdyYXBoaWNzRGF0YVtpXTtcbiAgICAgIGNvbnN0IGZpbGxTdHlsZSA9IGRhdGEuZmlsbFN0eWxlO1xuICAgICAgY29uc3QgbGluZVN0eWxlID0gZGF0YS5saW5lU3R5bGU7XG4gICAgICBjb25zdCBjb21tYW5kID0gaW5kZXguRklMTF9DT01NQU5EU1tkYXRhLnR5cGVdO1xuICAgICAgY29tbWFuZC5idWlsZChkYXRhKTtcbiAgICAgIGlmIChkYXRhLm1hdHJpeCkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybVBvaW50cyhkYXRhLnBvaW50cywgZGF0YS5tYXRyaXgpO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxTdHlsZS52aXNpYmxlIHx8IGxpbmVTdHlsZS52aXNpYmxlKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc0hvbGVzKGRhdGEuaG9sZXMpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAyOyBqKyspIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBqID09PSAwID8gZmlsbFN0eWxlIDogbGluZVN0eWxlO1xuICAgICAgICBpZiAoIXN0eWxlLnZpc2libGUpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IG5leHRUZXh0dXJlID0gc3R5bGUudGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgICAgY29uc3QgaW5kZXgyID0gdGhpcy5pbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYXR0cmliSW5kZXggPSB0aGlzLnBvaW50cy5sZW5ndGggLyAyO1xuICAgICAgICBuZXh0VGV4dHVyZS53cmFwTW9kZSA9IGNvcmUuV1JBUF9NT0RFUy5SRVBFQVQ7XG4gICAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wcm9jZXNzRmlsbChkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnByb2Nlc3NMaW5lKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnBvaW50cy5sZW5ndGggLyAyIC0gYXR0cmliSW5kZXg7XG4gICAgICAgIGlmIChzaXplID09PSAwKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoYmF0Y2hQYXJ0ICYmICF0aGlzLl9jb21wYXJlU3R5bGVzKGN1cnJlbnRTdHlsZSwgc3R5bGUpKSB7XG4gICAgICAgICAgYmF0Y2hQYXJ0LmVuZChpbmRleDIsIGF0dHJpYkluZGV4KTtcbiAgICAgICAgICBiYXRjaFBhcnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYmF0Y2hQYXJ0KSB7XG4gICAgICAgICAgYmF0Y2hQYXJ0ID0gaW5kZXguQkFUQ0hfUE9PTC5wb3AoKSB8fCBuZXcgQmF0Y2hQYXJ0LkJhdGNoUGFydCgpO1xuICAgICAgICAgIGJhdGNoUGFydC5iZWdpbihzdHlsZSwgaW5kZXgyLCBhdHRyaWJJbmRleCk7XG4gICAgICAgICAgdGhpcy5iYXRjaGVzLnB1c2goYmF0Y2hQYXJ0KTtcbiAgICAgICAgICBjdXJyZW50U3R5bGUgPSBzdHlsZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFV2cyh0aGlzLnBvaW50cywgdXZzLCBzdHlsZS50ZXh0dXJlLCBhdHRyaWJJbmRleCwgc2l6ZSwgc3R5bGUubWF0cml4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW5kZXgkMSA9IHRoaXMuaW5kaWNlcy5sZW5ndGg7XG4gICAgY29uc3QgYXR0cmliID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcbiAgICBpZiAoYmF0Y2hQYXJ0KSB7XG4gICAgICBiYXRjaFBhcnQuZW5kKGluZGV4JDEsIGF0dHJpYik7XG4gICAgfVxuICAgIGlmICh0aGlzLmJhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmJhdGNoYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5lZWQzMiA9IGF0dHJpYiA+IDY1NTM1O1xuICAgIGlmICh0aGlzLmluZGljZXNVaW50MTYgJiYgdGhpcy5pbmRpY2VzLmxlbmd0aCA9PT0gdGhpcy5pbmRpY2VzVWludDE2Lmxlbmd0aCAmJiBuZWVkMzIgPT09IHRoaXMuaW5kaWNlc1VpbnQxNi5CWVRFU19QRVJfRUxFTUVOVCA+IDIpIHtcbiAgICAgIHRoaXMuaW5kaWNlc1VpbnQxNi5zZXQodGhpcy5pbmRpY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbmRpY2VzVWludDE2ID0gbmVlZDMyID8gbmV3IFVpbnQzMkFycmF5KHRoaXMuaW5kaWNlcykgOiBuZXcgVWludDE2QXJyYXkodGhpcy5pbmRpY2VzKTtcbiAgICB9XG4gICAgdGhpcy5iYXRjaGFibGUgPSB0aGlzLmlzQmF0Y2hhYmxlKCk7XG4gICAgaWYgKHRoaXMuYmF0Y2hhYmxlKSB7XG4gICAgICB0aGlzLnBhY2tCYXRjaGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYnVpbGREcmF3Q2FsbHMoKTtcbiAgICB9XG4gIH1cbiAgX2NvbXBhcmVTdHlsZXMoc3R5bGVBLCBzdHlsZUIpIHtcbiAgICBpZiAoIXN0eWxlQSB8fCAhc3R5bGVCKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdHlsZUEudGV4dHVyZS5iYXNlVGV4dHVyZSAhPT0gc3R5bGVCLnRleHR1cmUuYmFzZVRleHR1cmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0eWxlQS5jb2xvciArIHN0eWxlQS5hbHBoYSAhPT0gc3R5bGVCLmNvbG9yICsgc3R5bGVCLmFscGhhKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghIXN0eWxlQS5uYXRpdmUgIT09ICEhc3R5bGVCLm5hdGl2ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YWxpZGF0ZUJhdGNoaW5nKCkge1xuICAgIGlmICh0aGlzLmRpcnR5ID09PSB0aGlzLmNhY2hlRGlydHkgfHwgIXRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ3JhcGhpY3NEYXRhW2ldO1xuICAgICAgY29uc3QgZmlsbCA9IGRhdGEuZmlsbFN0eWxlO1xuICAgICAgY29uc3QgbGluZSA9IGRhdGEubGluZVN0eWxlO1xuICAgICAgaWYgKGZpbGwgJiYgIWZpbGwudGV4dHVyZS5iYXNlVGV4dHVyZS52YWxpZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGxpbmUgJiYgIWxpbmUudGV4dHVyZS5iYXNlVGV4dHVyZS52YWxpZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBwYWNrQmF0Y2hlcygpIHtcbiAgICB0aGlzLmJhdGNoRGlydHkrKztcbiAgICB0aGlzLnV2c0Zsb2F0MzIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudXZzKTtcbiAgICBjb25zdCBiYXRjaGVzID0gdGhpcy5iYXRjaGVzO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gYmF0Y2hlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGJhdGNoID0gYmF0Y2hlc1tpXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmF0Y2guc2l6ZTsgaisrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gYmF0Y2guc3RhcnQgKyBqO1xuICAgICAgICB0aGlzLmluZGljZXNVaW50MTZbaW5kZXhdID0gdGhpcy5pbmRpY2VzVWludDE2W2luZGV4XSAtIGJhdGNoLmF0dHJpYlN0YXJ0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpc0JhdGNoYWJsZSgpIHtcbiAgICBpZiAodGhpcy5wb2ludHMubGVuZ3RoID4gNjU1MzUgKiAyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGJhdGNoZXMgPSB0aGlzLmJhdGNoZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYmF0Y2hlc1tpXS5zdHlsZS5uYXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wb2ludHMubGVuZ3RoIDwgX0dyYXBoaWNzR2VvbWV0cnkuQkFUQ0hBQkxFX1NJWkUgKiAyO1xuICB9XG4gIGJ1aWxkRHJhd0NhbGxzKCkge1xuICAgIGxldCBUSUNLID0gKytjb3JlLkJhc2VUZXh0dXJlLl9nbG9iYWxCYXRjaDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZHJhd0NhbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmRyYXdDYWxsc1tpXS50ZXhBcnJheS5jbGVhcigpO1xuICAgICAgaW5kZXguRFJBV19DQUxMX1BPT0wucHVzaCh0aGlzLmRyYXdDYWxsc1tpXSk7XG4gICAgfVxuICAgIHRoaXMuZHJhd0NhbGxzLmxlbmd0aCA9IDA7XG4gICAgY29uc3QgY29sb3JzID0gdGhpcy5jb2xvcnM7XG4gICAgY29uc3QgdGV4dHVyZUlkcyA9IHRoaXMudGV4dHVyZUlkcztcbiAgICBsZXQgY3VycmVudEdyb3VwID0gaW5kZXguRFJBV19DQUxMX1BPT0wucG9wKCk7XG4gICAgaWYgKCFjdXJyZW50R3JvdXApIHtcbiAgICAgIGN1cnJlbnRHcm91cCA9IG5ldyBjb3JlLkJhdGNoRHJhd0NhbGwoKTtcbiAgICAgIGN1cnJlbnRHcm91cC50ZXhBcnJheSA9IG5ldyBjb3JlLkJhdGNoVGV4dHVyZUFycmF5KCk7XG4gICAgfVxuICAgIGN1cnJlbnRHcm91cC50ZXhBcnJheS5jb3VudCA9IDA7XG4gICAgY3VycmVudEdyb3VwLnN0YXJ0ID0gMDtcbiAgICBjdXJyZW50R3JvdXAuc2l6ZSA9IDA7XG4gICAgY3VycmVudEdyb3VwLnR5cGUgPSBjb3JlLkRSQVdfTU9ERVMuVFJJQU5HTEVTO1xuICAgIGxldCB0ZXh0dXJlQ291bnQgPSAwO1xuICAgIGxldCBjdXJyZW50VGV4dHVyZSA9IG51bGw7XG4gICAgbGV0IHRleHR1cmVJZCA9IDA7XG4gICAgbGV0IG5hdGl2ZSA9IGZhbHNlO1xuICAgIGxldCBkcmF3TW9kZSA9IGNvcmUuRFJBV19NT0RFUy5UUklBTkdMRVM7XG4gICAgbGV0IGluZGV4JDEgPSAwO1xuICAgIHRoaXMuZHJhd0NhbGxzLnB1c2goY3VycmVudEdyb3VwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuYmF0Y2hlc1tpXTtcbiAgICAgIGNvbnN0IG1heFRleHR1cmVzID0gODtcbiAgICAgIGNvbnN0IHN0eWxlID0gZGF0YS5zdHlsZTtcbiAgICAgIGNvbnN0IG5leHRUZXh0dXJlID0gc3R5bGUudGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgIGlmIChuYXRpdmUgIT09ICEhc3R5bGUubmF0aXZlKSB7XG4gICAgICAgIG5hdGl2ZSA9ICEhc3R5bGUubmF0aXZlO1xuICAgICAgICBkcmF3TW9kZSA9IG5hdGl2ZSA/IGNvcmUuRFJBV19NT0RFUy5MSU5FUyA6IGNvcmUuRFJBV19NT0RFUy5UUklBTkdMRVM7XG4gICAgICAgIGN1cnJlbnRUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgdGV4dHVyZUNvdW50ID0gbWF4VGV4dHVyZXM7XG4gICAgICAgIFRJQ0srKztcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50VGV4dHVyZSAhPT0gbmV4dFRleHR1cmUpIHtcbiAgICAgICAgY3VycmVudFRleHR1cmUgPSBuZXh0VGV4dHVyZTtcbiAgICAgICAgaWYgKG5leHRUZXh0dXJlLl9iYXRjaEVuYWJsZWQgIT09IFRJQ0spIHtcbiAgICAgICAgICBpZiAodGV4dHVyZUNvdW50ID09PSBtYXhUZXh0dXJlcykge1xuICAgICAgICAgICAgVElDSysrO1xuICAgICAgICAgICAgdGV4dHVyZUNvdW50ID0gMDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50R3JvdXAuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgY3VycmVudEdyb3VwID0gaW5kZXguRFJBV19DQUxMX1BPT0wucG9wKCk7XG4gICAgICAgICAgICAgIGlmICghY3VycmVudEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEdyb3VwID0gbmV3IGNvcmUuQmF0Y2hEcmF3Q2FsbCgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC50ZXhBcnJheSA9IG5ldyBjb3JlLkJhdGNoVGV4dHVyZUFycmF5KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5kcmF3Q2FsbHMucHVzaChjdXJyZW50R3JvdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEdyb3VwLnN0YXJ0ID0gaW5kZXgkMTtcbiAgICAgICAgICAgIGN1cnJlbnRHcm91cC5zaXplID0gMDtcbiAgICAgICAgICAgIGN1cnJlbnRHcm91cC50ZXhBcnJheS5jb3VudCA9IDA7XG4gICAgICAgICAgICBjdXJyZW50R3JvdXAudHlwZSA9IGRyYXdNb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0VGV4dHVyZS50b3VjaGVkID0gMTtcbiAgICAgICAgICBuZXh0VGV4dHVyZS5fYmF0Y2hFbmFibGVkID0gVElDSztcbiAgICAgICAgICBuZXh0VGV4dHVyZS5fYmF0Y2hMb2NhdGlvbiA9IHRleHR1cmVDb3VudDtcbiAgICAgICAgICBuZXh0VGV4dHVyZS53cmFwTW9kZSA9IGNvcmUuV1JBUF9NT0RFUy5SRVBFQVQ7XG4gICAgICAgICAgY3VycmVudEdyb3VwLnRleEFycmF5LmVsZW1lbnRzW2N1cnJlbnRHcm91cC50ZXhBcnJheS5jb3VudCsrXSA9IG5leHRUZXh0dXJlO1xuICAgICAgICAgIHRleHR1cmVDb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdXJyZW50R3JvdXAuc2l6ZSArPSBkYXRhLnNpemU7XG4gICAgICBpbmRleCQxICs9IGRhdGEuc2l6ZTtcbiAgICAgIHRleHR1cmVJZCA9IG5leHRUZXh0dXJlLl9iYXRjaExvY2F0aW9uO1xuICAgICAgdGhpcy5hZGRDb2xvcnMoY29sb3JzLCBzdHlsZS5jb2xvciwgc3R5bGUuYWxwaGEsIGRhdGEuYXR0cmliU2l6ZSwgZGF0YS5hdHRyaWJTdGFydCk7XG4gICAgICB0aGlzLmFkZFRleHR1cmVJZHModGV4dHVyZUlkcywgdGV4dHVyZUlkLCBkYXRhLmF0dHJpYlNpemUsIGRhdGEuYXR0cmliU3RhcnQpO1xuICAgIH1cbiAgICBjb3JlLkJhc2VUZXh0dXJlLl9nbG9iYWxCYXRjaCA9IFRJQ0s7XG4gICAgdGhpcy5wYWNrQXR0cmlidXRlcygpO1xuICB9XG4gIHBhY2tBdHRyaWJ1dGVzKCkge1xuICAgIGNvbnN0IHZlcnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3QgdXZzID0gdGhpcy51dnM7XG4gICAgY29uc3QgY29sb3JzID0gdGhpcy5jb2xvcnM7XG4gICAgY29uc3QgdGV4dHVyZUlkcyA9IHRoaXMudGV4dHVyZUlkcztcbiAgICBjb25zdCBnbFBvaW50cyA9IG5ldyBBcnJheUJ1ZmZlcih2ZXJ0cy5sZW5ndGggKiAzICogNCk7XG4gICAgY29uc3QgZjMyID0gbmV3IEZsb2F0MzJBcnJheShnbFBvaW50cyk7XG4gICAgY29uc3QgdTMyID0gbmV3IFVpbnQzMkFycmF5KGdsUG9pbnRzKTtcbiAgICBsZXQgcCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIGYzMltwKytdID0gdmVydHNbaSAqIDJdO1xuICAgICAgZjMyW3ArK10gPSB2ZXJ0c1tpICogMiArIDFdO1xuICAgICAgZjMyW3ArK10gPSB1dnNbaSAqIDJdO1xuICAgICAgZjMyW3ArK10gPSB1dnNbaSAqIDIgKyAxXTtcbiAgICAgIHUzMltwKytdID0gY29sb3JzW2ldO1xuICAgICAgZjMyW3ArK10gPSB0ZXh0dXJlSWRzW2ldO1xuICAgIH1cbiAgICB0aGlzLl9idWZmZXIudXBkYXRlKGdsUG9pbnRzKTtcbiAgICB0aGlzLl9pbmRleEJ1ZmZlci51cGRhdGUodGhpcy5pbmRpY2VzVWludDE2KTtcbiAgfVxuICBwcm9jZXNzRmlsbChkYXRhKSB7XG4gICAgaWYgKGRhdGEuaG9sZXMubGVuZ3RoKSB7XG4gICAgICBidWlsZFBvbHkuYnVpbGRQb2x5LnRyaWFuZ3VsYXRlKGRhdGEsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb21tYW5kID0gaW5kZXguRklMTF9DT01NQU5EU1tkYXRhLnR5cGVdO1xuICAgICAgY29tbWFuZC50cmlhbmd1bGF0ZShkYXRhLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgcHJvY2Vzc0xpbmUoZGF0YSkge1xuICAgIGJ1aWxkTGluZS5idWlsZExpbmUoZGF0YSwgdGhpcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmhvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidWlsZExpbmUuYnVpbGRMaW5lKGRhdGEuaG9sZXNbaV0sIHRoaXMpO1xuICAgIH1cbiAgfVxuICBwcm9jZXNzSG9sZXMoaG9sZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBob2xlID0gaG9sZXNbaV07XG4gICAgICBjb25zdCBjb21tYW5kID0gaW5kZXguRklMTF9DT01NQU5EU1tob2xlLnR5cGVdO1xuICAgICAgY29tbWFuZC5idWlsZChob2xlKTtcbiAgICAgIGlmIChob2xlLm1hdHJpeCkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybVBvaW50cyhob2xlLnBvaW50cywgaG9sZS5tYXRyaXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgY29uc3QgYm91bmRzID0gdGhpcy5fYm91bmRzO1xuICAgIGJvdW5kcy5jbGVhcigpO1xuICAgIGJvdW5kcy5hZGRWZXJ0ZXhEYXRhKHRoaXMucG9pbnRzLCAwLCB0aGlzLnBvaW50cy5sZW5ndGgpO1xuICAgIGJvdW5kcy5wYWQodGhpcy5ib3VuZHNQYWRkaW5nLCB0aGlzLmJvdW5kc1BhZGRpbmcpO1xuICB9XG4gIHRyYW5zZm9ybVBvaW50cyhwb2ludHMsIG1hdHJpeCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgY29uc3QgeCA9IHBvaW50c1tpICogMl07XG4gICAgICBjb25zdCB5ID0gcG9pbnRzW2kgKiAyICsgMV07XG4gICAgICBwb2ludHNbaSAqIDJdID0gbWF0cml4LmEgKiB4ICsgbWF0cml4LmMgKiB5ICsgbWF0cml4LnR4O1xuICAgICAgcG9pbnRzW2kgKiAyICsgMV0gPSBtYXRyaXguYiAqIHggKyBtYXRyaXguZCAqIHkgKyBtYXRyaXgudHk7XG4gICAgfVxuICB9XG4gIGFkZENvbG9ycyhjb2xvcnMsIGNvbG9yLCBhbHBoYSwgc2l6ZSwgb2Zmc2V0ID0gMCkge1xuICAgIGNvbnN0IGJnciA9IGNvcmUuQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGNvbG9yKS50b0xpdHRsZUVuZGlhbk51bWJlcigpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGNvcmUuQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGJncikudG9QcmVtdWx0aXBsaWVkKGFscGhhKTtcbiAgICBjb2xvcnMubGVuZ3RoID0gTWF0aC5tYXgoY29sb3JzLmxlbmd0aCwgb2Zmc2V0ICsgc2l6ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIGNvbG9yc1tvZmZzZXQgKyBpXSA9IHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgYWRkVGV4dHVyZUlkcyh0ZXh0dXJlSWRzLCBpZCwgc2l6ZSwgb2Zmc2V0ID0gMCkge1xuICAgIHRleHR1cmVJZHMubGVuZ3RoID0gTWF0aC5tYXgodGV4dHVyZUlkcy5sZW5ndGgsIG9mZnNldCArIHNpemUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICB0ZXh0dXJlSWRzW29mZnNldCArIGldID0gaWQ7XG4gICAgfVxuICB9XG4gIGFkZFV2cyh2ZXJ0cywgdXZzLCB0ZXh0dXJlLCBzdGFydCwgc2l6ZSwgbWF0cml4ID0gbnVsbCkge1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgdXZzU3RhcnQgPSB1dnMubGVuZ3RoO1xuICAgIGNvbnN0IGZyYW1lID0gdGV4dHVyZS5mcmFtZTtcbiAgICB3aGlsZSAoaW5kZXggPCBzaXplKSB7XG4gICAgICBsZXQgeCA9IHZlcnRzWyhzdGFydCArIGluZGV4KSAqIDJdO1xuICAgICAgbGV0IHkgPSB2ZXJ0c1soc3RhcnQgKyBpbmRleCkgKiAyICsgMV07XG4gICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgIGNvbnN0IG54ID0gbWF0cml4LmEgKiB4ICsgbWF0cml4LmMgKiB5ICsgbWF0cml4LnR4O1xuICAgICAgICB5ID0gbWF0cml4LmIgKiB4ICsgbWF0cml4LmQgKiB5ICsgbWF0cml4LnR5O1xuICAgICAgICB4ID0gbng7XG4gICAgICB9XG4gICAgICBpbmRleCsrO1xuICAgICAgdXZzLnB1c2goeCAvIGZyYW1lLndpZHRoLCB5IC8gZnJhbWUuaGVpZ2h0KTtcbiAgICB9XG4gICAgY29uc3QgYmFzZVRleHR1cmUgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgIGlmIChmcmFtZS53aWR0aCA8IGJhc2VUZXh0dXJlLndpZHRoIHx8IGZyYW1lLmhlaWdodCA8IGJhc2VUZXh0dXJlLmhlaWdodCkge1xuICAgICAgdGhpcy5hZGp1c3RVdnModXZzLCB0ZXh0dXJlLCB1dnNTdGFydCwgc2l6ZSk7XG4gICAgfVxuICB9XG4gIGFkanVzdFV2cyh1dnMsIHRleHR1cmUsIHN0YXJ0LCBzaXplKSB7XG4gICAgY29uc3QgYmFzZVRleHR1cmUgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgIGNvbnN0IGVwcyA9IDFlLTY7XG4gICAgY29uc3QgZmluaXNoID0gc3RhcnQgKyBzaXplICogMjtcbiAgICBjb25zdCBmcmFtZSA9IHRleHR1cmUuZnJhbWU7XG4gICAgY29uc3Qgc2NhbGVYID0gZnJhbWUud2lkdGggLyBiYXNlVGV4dHVyZS53aWR0aDtcbiAgICBjb25zdCBzY2FsZVkgPSBmcmFtZS5oZWlnaHQgLyBiYXNlVGV4dHVyZS5oZWlnaHQ7XG4gICAgbGV0IG9mZnNldFggPSBmcmFtZS54IC8gZnJhbWUud2lkdGg7XG4gICAgbGV0IG9mZnNldFkgPSBmcmFtZS55IC8gZnJhbWUuaGVpZ2h0O1xuICAgIGxldCBtaW5YID0gTWF0aC5mbG9vcih1dnNbc3RhcnRdICsgZXBzKTtcbiAgICBsZXQgbWluWSA9IE1hdGguZmxvb3IodXZzW3N0YXJ0ICsgMV0gKyBlcHMpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydCArIDI7IGkgPCBmaW5pc2g7IGkgKz0gMikge1xuICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIE1hdGguZmxvb3IodXZzW2ldICsgZXBzKSk7XG4gICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgTWF0aC5mbG9vcih1dnNbaSArIDFdICsgZXBzKSk7XG4gICAgfVxuICAgIG9mZnNldFggLT0gbWluWDtcbiAgICBvZmZzZXRZIC09IG1pblk7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZmluaXNoOyBpICs9IDIpIHtcbiAgICAgIHV2c1tpXSA9ICh1dnNbaV0gKyBvZmZzZXRYKSAqIHNjYWxlWDtcbiAgICAgIHV2c1tpICsgMV0gPSAodXZzW2kgKyAxXSArIG9mZnNldFkpICogc2NhbGVZO1xuICAgIH1cbiAgfVxufTtcbmxldCBHcmFwaGljc0dlb21ldHJ5ID0gX0dyYXBoaWNzR2VvbWV0cnk7XG5HcmFwaGljc0dlb21ldHJ5LkJBVENIQUJMRV9TSVpFID0gMTAwO1xuXG5leHBvcnRzLkdyYXBoaWNzR2VvbWV0cnkgPSBHcmFwaGljc0dlb21ldHJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhpY3NHZW9tZXRyeS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIExJTkVfSk9JTiA9IC8qIEBfX1BVUkVfXyAqLyAoKExJTkVfSk9JTjIpID0+IHtcbiAgTElORV9KT0lOMltcIk1JVEVSXCJdID0gXCJtaXRlclwiO1xuICBMSU5FX0pPSU4yW1wiQkVWRUxcIl0gPSBcImJldmVsXCI7XG4gIExJTkVfSk9JTjJbXCJST1VORFwiXSA9IFwicm91bmRcIjtcbiAgcmV0dXJuIExJTkVfSk9JTjI7XG59KShMSU5FX0pPSU4gfHwge30pO1xudmFyIExJTkVfQ0FQID0gLyogQF9fUFVSRV9fICovICgoTElORV9DQVAyKSA9PiB7XG4gIExJTkVfQ0FQMltcIkJVVFRcIl0gPSBcImJ1dHRcIjtcbiAgTElORV9DQVAyW1wiUk9VTkRcIl0gPSBcInJvdW5kXCI7XG4gIExJTkVfQ0FQMltcIlNRVUFSRVwiXSA9IFwic3F1YXJlXCI7XG4gIHJldHVybiBMSU5FX0NBUDI7XG59KShMSU5FX0NBUCB8fCB7fSk7XG5jb25zdCBjdXJ2ZXMgPSB7XG4gIGFkYXB0aXZlOiB0cnVlLFxuICBtYXhMZW5ndGg6IDEwLFxuICBtaW5TZWdtZW50czogOCxcbiAgbWF4U2VnbWVudHM6IDIwNDgsXG4gIGVwc2lsb246IDFlLTQsXG4gIF9zZWdtZW50c0NvdW50KGxlbmd0aCwgZGVmYXVsdFNlZ21lbnRzID0gMjApIHtcbiAgICBpZiAoIXRoaXMuYWRhcHRpdmUgfHwgIWxlbmd0aCB8fCBpc05hTihsZW5ndGgpKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFNlZ21lbnRzO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gTWF0aC5jZWlsKGxlbmd0aCAvIHRoaXMubWF4TGVuZ3RoKTtcbiAgICBpZiAocmVzdWx0IDwgdGhpcy5taW5TZWdtZW50cykge1xuICAgICAgcmVzdWx0ID0gdGhpcy5taW5TZWdtZW50cztcbiAgICB9IGVsc2UgaWYgKHJlc3VsdCA+IHRoaXMubWF4U2VnbWVudHMpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMubWF4U2VnbWVudHM7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5jb25zdCBHUkFQSElDU19DVVJWRVMgPSBjdXJ2ZXM7XG5cbmV4cG9ydHMuR1JBUEhJQ1NfQ1VSVkVTID0gR1JBUEhJQ1NfQ1VSVkVTO1xuZXhwb3J0cy5MSU5FX0NBUCA9IExJTkVfQ0FQO1xuZXhwb3J0cy5MSU5FX0pPSU4gPSBMSU5FX0pPSU47XG5leHBvcnRzLmN1cnZlcyA9IGN1cnZlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgaW5kZXggPSByZXF1aXJlKCcuL3V0aWxzL2luZGV4LmpzJyk7XG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi9jb25zdC5qcycpO1xudmFyIEdyYXBoaWNzID0gcmVxdWlyZSgnLi9HcmFwaGljcy5qcycpO1xudmFyIEdyYXBoaWNzRGF0YSA9IHJlcXVpcmUoJy4vR3JhcGhpY3NEYXRhLmpzJyk7XG52YXIgR3JhcGhpY3NHZW9tZXRyeSA9IHJlcXVpcmUoJy4vR3JhcGhpY3NHZW9tZXRyeS5qcycpO1xudmFyIEZpbGxTdHlsZSA9IHJlcXVpcmUoJy4vc3R5bGVzL0ZpbGxTdHlsZS5qcycpO1xudmFyIExpbmVTdHlsZSA9IHJlcXVpcmUoJy4vc3R5bGVzL0xpbmVTdHlsZS5qcycpO1xudmFyIGJ1aWxkUG9seSA9IHJlcXVpcmUoJy4vdXRpbHMvYnVpbGRQb2x5LmpzJyk7XG52YXIgYnVpbGRDaXJjbGUgPSByZXF1aXJlKCcuL3V0aWxzL2J1aWxkQ2lyY2xlLmpzJyk7XG52YXIgYnVpbGRSZWN0YW5nbGUgPSByZXF1aXJlKCcuL3V0aWxzL2J1aWxkUmVjdGFuZ2xlLmpzJyk7XG52YXIgYnVpbGRSb3VuZGVkUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi91dGlscy9idWlsZFJvdW5kZWRSZWN0YW5nbGUuanMnKTtcbnZhciBidWlsZExpbmUgPSByZXF1aXJlKCcuL3V0aWxzL2J1aWxkTGluZS5qcycpO1xudmFyIEFyY1V0aWxzID0gcmVxdWlyZSgnLi91dGlscy9BcmNVdGlscy5qcycpO1xudmFyIEJlemllclV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9CZXppZXJVdGlscy5qcycpO1xudmFyIFF1YWRyYXRpY1V0aWxzID0gcmVxdWlyZSgnLi91dGlscy9RdWFkcmF0aWNVdGlscy5qcycpO1xudmFyIEJhdGNoUGFydCA9IHJlcXVpcmUoJy4vdXRpbHMvQmF0Y2hQYXJ0LmpzJyk7XG5cbmNvbnN0IGdyYXBoaWNzVXRpbHMgPSB7XG4gIGJ1aWxkUG9seTogYnVpbGRQb2x5LmJ1aWxkUG9seSxcbiAgYnVpbGRDaXJjbGU6IGJ1aWxkQ2lyY2xlLmJ1aWxkQ2lyY2xlLFxuICBidWlsZFJlY3RhbmdsZTogYnVpbGRSZWN0YW5nbGUuYnVpbGRSZWN0YW5nbGUsXG4gIGJ1aWxkUm91bmRlZFJlY3RhbmdsZTogYnVpbGRSb3VuZGVkUmVjdGFuZ2xlLmJ1aWxkUm91bmRlZFJlY3RhbmdsZSxcbiAgYnVpbGRMaW5lOiBidWlsZExpbmUuYnVpbGRMaW5lLFxuICBBcmNVdGlsczogQXJjVXRpbHMuQXJjVXRpbHMsXG4gIEJlemllclV0aWxzOiBCZXppZXJVdGlscy5CZXppZXJVdGlscyxcbiAgUXVhZHJhdGljVXRpbHM6IFF1YWRyYXRpY1V0aWxzLlF1YWRyYXRpY1V0aWxzLFxuICBCYXRjaFBhcnQ6IEJhdGNoUGFydC5CYXRjaFBhcnQsXG4gIEZJTExfQ09NTUFORFM6IGluZGV4LkZJTExfQ09NTUFORFMsXG4gIEJBVENIX1BPT0w6IGluZGV4LkJBVENIX1BPT0wsXG4gIERSQVdfQ0FMTF9QT09MOiBpbmRleC5EUkFXX0NBTExfUE9PTFxufTtcblxuZXhwb3J0cy5HUkFQSElDU19DVVJWRVMgPSBfY29uc3QuR1JBUEhJQ1NfQ1VSVkVTO1xuZXhwb3J0cy5MSU5FX0NBUCA9IF9jb25zdC5MSU5FX0NBUDtcbmV4cG9ydHMuTElORV9KT0lOID0gX2NvbnN0LkxJTkVfSk9JTjtcbmV4cG9ydHMuY3VydmVzID0gX2NvbnN0LmN1cnZlcztcbmV4cG9ydHMuR3JhcGhpY3MgPSBHcmFwaGljcy5HcmFwaGljcztcbmV4cG9ydHMuR3JhcGhpY3NEYXRhID0gR3JhcGhpY3NEYXRhLkdyYXBoaWNzRGF0YTtcbmV4cG9ydHMuR3JhcGhpY3NHZW9tZXRyeSA9IEdyYXBoaWNzR2VvbWV0cnkuR3JhcGhpY3NHZW9tZXRyeTtcbmV4cG9ydHMuRmlsbFN0eWxlID0gRmlsbFN0eWxlLkZpbGxTdHlsZTtcbmV4cG9ydHMuTGluZVN0eWxlID0gTGluZVN0eWxlLkxpbmVTdHlsZTtcbmV4cG9ydHMuZ3JhcGhpY3NVdGlscyA9IGdyYXBoaWNzVXRpbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG5cbmNsYXNzIEZpbGxTdHlsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29sb3IgPSAxNjc3NzIxNTtcbiAgICB0aGlzLmFscGhhID0gMTtcbiAgICB0aGlzLnRleHR1cmUgPSBjb3JlLlRleHR1cmUuV0hJVEU7XG4gICAgdGhpcy5tYXRyaXggPSBudWxsO1xuICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBvYmogPSBuZXcgRmlsbFN0eWxlKCk7XG4gICAgb2JqLmNvbG9yID0gdGhpcy5jb2xvcjtcbiAgICBvYmouYWxwaGEgPSB0aGlzLmFscGhhO1xuICAgIG9iai50ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgIG9iai5tYXRyaXggPSB0aGlzLm1hdHJpeDtcbiAgICBvYmoudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuY29sb3IgPSAxNjc3NzIxNTtcbiAgICB0aGlzLmFscGhhID0gMTtcbiAgICB0aGlzLnRleHR1cmUgPSBjb3JlLlRleHR1cmUuV0hJVEU7XG4gICAgdGhpcy5tYXRyaXggPSBudWxsO1xuICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcbiAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0cy5GaWxsU3R5bGUgPSBGaWxsU3R5bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWxsU3R5bGUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi9jb25zdC5qcycpO1xudmFyIEZpbGxTdHlsZSA9IHJlcXVpcmUoJy4vRmlsbFN0eWxlLmpzJyk7XG5cbmNsYXNzIExpbmVTdHlsZSBleHRlbmRzIEZpbGxTdHlsZS5GaWxsU3R5bGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIHRoaXMuYWxpZ25tZW50ID0gMC41O1xuICAgIHRoaXMubmF0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5jYXAgPSBfY29uc3QuTElORV9DQVAuQlVUVDtcbiAgICB0aGlzLmpvaW4gPSBfY29uc3QuTElORV9KT0lOLk1JVEVSO1xuICAgIHRoaXMubWl0ZXJMaW1pdCA9IDEwO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IG9iaiA9IG5ldyBMaW5lU3R5bGUoKTtcbiAgICBvYmouY29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIG9iai5hbHBoYSA9IHRoaXMuYWxwaGE7XG4gICAgb2JqLnRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgb2JqLm1hdHJpeCA9IHRoaXMubWF0cml4O1xuICAgIG9iai52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuICAgIG9iai53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgb2JqLmFsaWdubWVudCA9IHRoaXMuYWxpZ25tZW50O1xuICAgIG9iai5uYXRpdmUgPSB0aGlzLm5hdGl2ZTtcbiAgICBvYmouY2FwID0gdGhpcy5jYXA7XG4gICAgb2JqLmpvaW4gPSB0aGlzLmpvaW47XG4gICAgb2JqLm1pdGVyTGltaXQgPSB0aGlzLm1pdGVyTGltaXQ7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICByZXNldCgpIHtcbiAgICBzdXBlci5yZXNldCgpO1xuICAgIHRoaXMuY29sb3IgPSAwO1xuICAgIHRoaXMuYWxpZ25tZW50ID0gMC41O1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIHRoaXMubmF0aXZlID0gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0cy5MaW5lU3R5bGUgPSBMaW5lU3R5bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5lU3R5bGUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xudmFyIF9jb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0LmpzJyk7XG5cbmNsYXNzIEFyY1V0aWxzIHtcbiAgc3RhdGljIGN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cywgcG9pbnRzKSB7XG4gICAgY29uc3QgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICAgIGNvbnN0IGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBhMSA9IGZyb21ZIC0geTE7XG4gICAgY29uc3QgYjEgPSBmcm9tWCAtIHgxO1xuICAgIGNvbnN0IGEyID0geTIgLSB5MTtcbiAgICBjb25zdCBiMiA9IHgyIC0geDE7XG4gICAgY29uc3QgbW0gPSBNYXRoLmFicyhhMSAqIGIyIC0gYjEgKiBhMik7XG4gICAgaWYgKG1tIDwgMWUtOCB8fCByYWRpdXMgPT09IDApIHtcbiAgICAgIGlmIChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdICE9PSB4MSB8fCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdICE9PSB5MSkge1xuICAgICAgICBwb2ludHMucHVzaCh4MSwgeTEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGRkID0gYTEgKiBhMSArIGIxICogYjE7XG4gICAgY29uc3QgY2MgPSBhMiAqIGEyICsgYjIgKiBiMjtcbiAgICBjb25zdCB0dCA9IGExICogYTIgKyBiMSAqIGIyO1xuICAgIGNvbnN0IGsxID0gcmFkaXVzICogTWF0aC5zcXJ0KGRkKSAvIG1tO1xuICAgIGNvbnN0IGsyID0gcmFkaXVzICogTWF0aC5zcXJ0KGNjKSAvIG1tO1xuICAgIGNvbnN0IGoxID0gazEgKiB0dCAvIGRkO1xuICAgIGNvbnN0IGoyID0gazIgKiB0dCAvIGNjO1xuICAgIGNvbnN0IGN4ID0gazEgKiBiMiArIGsyICogYjE7XG4gICAgY29uc3QgY3kgPSBrMSAqIGEyICsgazIgKiBhMTtcbiAgICBjb25zdCBweCA9IGIxICogKGsyICsgajEpO1xuICAgIGNvbnN0IHB5ID0gYTEgKiAoazIgKyBqMSk7XG4gICAgY29uc3QgcXggPSBiMiAqIChrMSArIGoyKTtcbiAgICBjb25zdCBxeSA9IGEyICogKGsxICsgajIpO1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBNYXRoLmF0YW4yKHB5IC0gY3ksIHB4IC0gY3gpO1xuICAgIGNvbnN0IGVuZEFuZ2xlID0gTWF0aC5hdGFuMihxeSAtIGN5LCBxeCAtIGN4KTtcbiAgICByZXR1cm4ge1xuICAgICAgY3g6IGN4ICsgeDEsXG4gICAgICBjeTogY3kgKyB5MSxcbiAgICAgIHJhZGl1cyxcbiAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSxcbiAgICAgIGFudGljbG9ja3dpc2U6IGIxICogYTIgPiBiMiAqIGExXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgYXJjKF9zdGFydFgsIF9zdGFydFksIGN4LCBjeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgX2FudGljbG9ja3dpc2UsIHBvaW50cykge1xuICAgIGNvbnN0IHN3ZWVwID0gZW5kQW5nbGUgLSBzdGFydEFuZ2xlO1xuICAgIGNvbnN0IG4gPSBfY29uc3QuY3VydmVzLl9zZWdtZW50c0NvdW50KE1hdGguYWJzKHN3ZWVwKSAqIHJhZGl1cywgTWF0aC5jZWlsKE1hdGguYWJzKHN3ZWVwKSAvIGNvcmUuUElfMikgKiA0MCk7XG4gICAgY29uc3QgdGhldGEgPSBzd2VlcCAvIChuICogMik7XG4gICAgY29uc3QgdGhldGEyID0gdGhldGEgKiAyO1xuICAgIGNvbnN0IGNUaGV0YSA9IE1hdGguY29zKHRoZXRhKTtcbiAgICBjb25zdCBzVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XG4gICAgY29uc3Qgc2VnTWludXMgPSBuIC0gMTtcbiAgICBjb25zdCByZW1haW5kZXIgPSBzZWdNaW51cyAlIDEgLyBzZWdNaW51cztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBzZWdNaW51czsgKytpKSB7XG4gICAgICBjb25zdCByZWFsID0gaSArIHJlbWFpbmRlciAqIGk7XG4gICAgICBjb25zdCBhbmdsZSA9IHRoZXRhICsgc3RhcnRBbmdsZSArIHRoZXRhMiAqIHJlYWw7XG4gICAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgY29uc3QgcyA9IC1NYXRoLnNpbihhbmdsZSk7XG4gICAgICBwb2ludHMucHVzaCgoY1RoZXRhICogYyArIHNUaGV0YSAqIHMpICogcmFkaXVzICsgY3gsIChjVGhldGEgKiAtcyArIHNUaGV0YSAqIGMpICogcmFkaXVzICsgY3kpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLkFyY1V0aWxzID0gQXJjVXRpbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcmNVdGlscy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY2xhc3MgQmF0Y2hQYXJ0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG4gIGJlZ2luKHN0eWxlLCBzdGFydEluZGV4LCBhdHRyaWJTdGFydCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0SW5kZXg7XG4gICAgdGhpcy5hdHRyaWJTdGFydCA9IGF0dHJpYlN0YXJ0O1xuICB9XG4gIGVuZChlbmRJbmRleCwgZW5kQXR0cmliKSB7XG4gICAgdGhpcy5hdHRyaWJTaXplID0gZW5kQXR0cmliIC0gdGhpcy5hdHRyaWJTdGFydDtcbiAgICB0aGlzLnNpemUgPSBlbmRJbmRleCAtIHRoaXMuc3RhcnQ7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zdHlsZSA9IG51bGw7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLmF0dHJpYlN0YXJ0ID0gMDtcbiAgICB0aGlzLmF0dHJpYlNpemUgPSAwO1xuICB9XG59XG5cbmV4cG9ydHMuQmF0Y2hQYXJ0ID0gQmF0Y2hQYXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hQYXJ0LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QuanMnKTtcblxuY2xhc3MgQmV6aWVyVXRpbHMge1xuICBzdGF0aWMgY3VydmVMZW5ndGgoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1kpIHtcbiAgICBjb25zdCBuID0gMTA7XG4gICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgbGV0IHQgPSAwO1xuICAgIGxldCB0MiA9IDA7XG4gICAgbGV0IHQzID0gMDtcbiAgICBsZXQgbnQgPSAwO1xuICAgIGxldCBudDIgPSAwO1xuICAgIGxldCBudDMgPSAwO1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeSA9IDA7XG4gICAgbGV0IGR4ID0gMDtcbiAgICBsZXQgZHkgPSAwO1xuICAgIGxldCBwcmV2WCA9IGZyb21YO1xuICAgIGxldCBwcmV2WSA9IGZyb21ZO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IG47ICsraSkge1xuICAgICAgdCA9IGkgLyBuO1xuICAgICAgdDIgPSB0ICogdDtcbiAgICAgIHQzID0gdDIgKiB0O1xuICAgICAgbnQgPSAxIC0gdDtcbiAgICAgIG50MiA9IG50ICogbnQ7XG4gICAgICBudDMgPSBudDIgKiBudDtcbiAgICAgIHggPSBudDMgKiBmcm9tWCArIDMgKiBudDIgKiB0ICogY3BYICsgMyAqIG50ICogdDIgKiBjcFgyICsgdDMgKiB0b1g7XG4gICAgICB5ID0gbnQzICogZnJvbVkgKyAzICogbnQyICogdCAqIGNwWSArIDMgKiBudCAqIHQyICogY3BZMiArIHQzICogdG9ZO1xuICAgICAgZHggPSBwcmV2WCAtIHg7XG4gICAgICBkeSA9IHByZXZZIC0geTtcbiAgICAgIHByZXZYID0geDtcbiAgICAgIHByZXZZID0geTtcbiAgICAgIHJlc3VsdCArPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyBjdXJ2ZVRvKGNwWCwgY3BZLCBjcFgyLCBjcFkyLCB0b1gsIHRvWSwgcG9pbnRzKSB7XG4gICAgY29uc3QgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICAgIGNvbnN0IGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgICBwb2ludHMubGVuZ3RoIC09IDI7XG4gICAgY29uc3QgbiA9IF9jb25zdC5jdXJ2ZXMuX3NlZ21lbnRzQ291bnQoQmV6aWVyVXRpbHMuY3VydmVMZW5ndGgoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1kpKTtcbiAgICBsZXQgZHQgPSAwO1xuICAgIGxldCBkdDIgPSAwO1xuICAgIGxldCBkdDMgPSAwO1xuICAgIGxldCB0MiA9IDA7XG4gICAgbGV0IHQzID0gMDtcbiAgICBwb2ludHMucHVzaChmcm9tWCwgZnJvbVkpO1xuICAgIGZvciAobGV0IGkgPSAxLCBqID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgIGogPSBpIC8gbjtcbiAgICAgIGR0ID0gMSAtIGo7XG4gICAgICBkdDIgPSBkdCAqIGR0O1xuICAgICAgZHQzID0gZHQyICogZHQ7XG4gICAgICB0MiA9IGogKiBqO1xuICAgICAgdDMgPSB0MiAqIGo7XG4gICAgICBwb2ludHMucHVzaChkdDMgKiBmcm9tWCArIDMgKiBkdDIgKiBqICogY3BYICsgMyAqIGR0ICogdDIgKiBjcFgyICsgdDMgKiB0b1gsIGR0MyAqIGZyb21ZICsgMyAqIGR0MiAqIGogKiBjcFkgKyAzICogZHQgKiB0MiAqIGNwWTIgKyB0MyAqIHRvWSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuQmV6aWVyVXRpbHMgPSBCZXppZXJVdGlscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJlemllclV0aWxzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QuanMnKTtcblxuY2xhc3MgUXVhZHJhdGljVXRpbHMge1xuICBzdGF0aWMgY3VydmVMZW5ndGgoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgdG9YLCB0b1kpIHtcbiAgICBjb25zdCBheCA9IGZyb21YIC0gMiAqIGNwWCArIHRvWDtcbiAgICBjb25zdCBheSA9IGZyb21ZIC0gMiAqIGNwWSArIHRvWTtcbiAgICBjb25zdCBieCA9IDIgKiBjcFggLSAyICogZnJvbVg7XG4gICAgY29uc3QgYnkgPSAyICogY3BZIC0gMiAqIGZyb21ZO1xuICAgIGNvbnN0IGEgPSA0ICogKGF4ICogYXggKyBheSAqIGF5KTtcbiAgICBjb25zdCBiID0gNCAqIChheCAqIGJ4ICsgYXkgKiBieSk7XG4gICAgY29uc3QgYyA9IGJ4ICogYnggKyBieSAqIGJ5O1xuICAgIGNvbnN0IHMgPSAyICogTWF0aC5zcXJ0KGEgKyBiICsgYyk7XG4gICAgY29uc3QgYTIgPSBNYXRoLnNxcnQoYSk7XG4gICAgY29uc3QgYTMyID0gMiAqIGEgKiBhMjtcbiAgICBjb25zdCBjMiA9IDIgKiBNYXRoLnNxcnQoYyk7XG4gICAgY29uc3QgYmEgPSBiIC8gYTI7XG4gICAgcmV0dXJuIChhMzIgKiBzICsgYTIgKiBiICogKHMgLSBjMikgKyAoNCAqIGMgKiBhIC0gYiAqIGIpICogTWF0aC5sb2coKDIgKiBhMiArIGJhICsgcykgLyAoYmEgKyBjMikpKSAvICg0ICogYTMyKTtcbiAgfVxuICBzdGF0aWMgY3VydmVUbyhjcFgsIGNwWSwgdG9YLCB0b1ksIHBvaW50cykge1xuICAgIGNvbnN0IGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcbiAgICBjb25zdCBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgbiA9IF9jb25zdC5jdXJ2ZXMuX3NlZ21lbnRzQ291bnQoUXVhZHJhdGljVXRpbHMuY3VydmVMZW5ndGgoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgdG9YLCB0b1kpKTtcbiAgICBsZXQgeGEgPSAwO1xuICAgIGxldCB5YSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbjsgKytpKSB7XG4gICAgICBjb25zdCBqID0gaSAvIG47XG4gICAgICB4YSA9IGZyb21YICsgKGNwWCAtIGZyb21YKSAqIGo7XG4gICAgICB5YSA9IGZyb21ZICsgKGNwWSAtIGZyb21ZKSAqIGo7XG4gICAgICBwb2ludHMucHVzaCh4YSArIChjcFggKyAodG9YIC0gY3BYKSAqIGogLSB4YSkgKiBqLCB5YSArIChjcFkgKyAodG9ZIC0gY3BZKSAqIGogLSB5YSkgKiBqKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5RdWFkcmF0aWNVdGlscyA9IFF1YWRyYXRpY1V0aWxzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVhZHJhdGljVXRpbHMuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xuXG5jb25zdCBidWlsZENpcmNsZSA9IHtcbiAgYnVpbGQoZ3JhcGhpY3NEYXRhKSB7XG4gICAgY29uc3QgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcbiAgICBsZXQgeDtcbiAgICBsZXQgeTtcbiAgICBsZXQgZHg7XG4gICAgbGV0IGR5O1xuICAgIGxldCByeDtcbiAgICBsZXQgcnk7XG4gICAgaWYgKGdyYXBoaWNzRGF0YS50eXBlID09PSBjb3JlLlNIQVBFUy5DSVJDKSB7XG4gICAgICBjb25zdCBjaXJjbGUgPSBncmFwaGljc0RhdGEuc2hhcGU7XG4gICAgICB4ID0gY2lyY2xlLng7XG4gICAgICB5ID0gY2lyY2xlLnk7XG4gICAgICByeCA9IHJ5ID0gY2lyY2xlLnJhZGl1cztcbiAgICAgIGR4ID0gZHkgPSAwO1xuICAgIH0gZWxzZSBpZiAoZ3JhcGhpY3NEYXRhLnR5cGUgPT09IGNvcmUuU0hBUEVTLkVMSVApIHtcbiAgICAgIGNvbnN0IGVsbGlwc2UgPSBncmFwaGljc0RhdGEuc2hhcGU7XG4gICAgICB4ID0gZWxsaXBzZS54O1xuICAgICAgeSA9IGVsbGlwc2UueTtcbiAgICAgIHJ4ID0gZWxsaXBzZS53aWR0aDtcbiAgICAgIHJ5ID0gZWxsaXBzZS5oZWlnaHQ7XG4gICAgICBkeCA9IGR5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgcm91bmRlZFJlY3QgPSBncmFwaGljc0RhdGEuc2hhcGU7XG4gICAgICBjb25zdCBoYWxmV2lkdGggPSByb3VuZGVkUmVjdC53aWR0aCAvIDI7XG4gICAgICBjb25zdCBoYWxmSGVpZ2h0ID0gcm91bmRlZFJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgIHggPSByb3VuZGVkUmVjdC54ICsgaGFsZldpZHRoO1xuICAgICAgeSA9IHJvdW5kZWRSZWN0LnkgKyBoYWxmSGVpZ2h0O1xuICAgICAgcnggPSByeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHJvdW5kZWRSZWN0LnJhZGl1cywgTWF0aC5taW4oaGFsZldpZHRoLCBoYWxmSGVpZ2h0KSkpO1xuICAgICAgZHggPSBoYWxmV2lkdGggLSByeDtcbiAgICAgIGR5ID0gaGFsZkhlaWdodCAtIHJ5O1xuICAgIH1cbiAgICBpZiAoIShyeCA+PSAwICYmIHJ5ID49IDAgJiYgZHggPj0gMCAmJiBkeSA+PSAwKSkge1xuICAgICAgcG9pbnRzLmxlbmd0aCA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG4gPSBNYXRoLmNlaWwoMi4zICogTWF0aC5zcXJ0KHJ4ICsgcnkpKTtcbiAgICBjb25zdCBtID0gbiAqIDggKyAoZHggPyA0IDogMCkgKyAoZHkgPyA0IDogMCk7XG4gICAgcG9pbnRzLmxlbmd0aCA9IG07XG4gICAgaWYgKG0gPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIHBvaW50cy5sZW5ndGggPSA4O1xuICAgICAgcG9pbnRzWzBdID0gcG9pbnRzWzZdID0geCArIGR4O1xuICAgICAgcG9pbnRzWzFdID0gcG9pbnRzWzNdID0geSArIGR5O1xuICAgICAgcG9pbnRzWzJdID0gcG9pbnRzWzRdID0geCAtIGR4O1xuICAgICAgcG9pbnRzWzVdID0gcG9pbnRzWzddID0geSAtIGR5O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgajEgPSAwO1xuICAgIGxldCBqMiA9IG4gKiA0ICsgKGR4ID8gMiA6IDApICsgMjtcbiAgICBsZXQgajMgPSBqMjtcbiAgICBsZXQgajQgPSBtO1xuICAgIHtcbiAgICAgIGNvbnN0IHgwID0gZHggKyByeDtcbiAgICAgIGNvbnN0IHkwID0gZHk7XG4gICAgICBjb25zdCB4MSA9IHggKyB4MDtcbiAgICAgIGNvbnN0IHgyID0geCAtIHgwO1xuICAgICAgY29uc3QgeTEgPSB5ICsgeTA7XG4gICAgICBwb2ludHNbajErK10gPSB4MTtcbiAgICAgIHBvaW50c1tqMSsrXSA9IHkxO1xuICAgICAgcG9pbnRzWy0tajJdID0geTE7XG4gICAgICBwb2ludHNbLS1qMl0gPSB4MjtcbiAgICAgIGlmIChkeSkge1xuICAgICAgICBjb25zdCB5MiA9IHkgLSB5MDtcbiAgICAgICAgcG9pbnRzW2ozKytdID0geDI7XG4gICAgICAgIHBvaW50c1tqMysrXSA9IHkyO1xuICAgICAgICBwb2ludHNbLS1qNF0gPSB5MjtcbiAgICAgICAgcG9pbnRzWy0tajRdID0geDE7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICBjb25zdCBhID0gTWF0aC5QSSAvIDIgKiAoaSAvIG4pO1xuICAgICAgY29uc3QgeDAgPSBkeCArIE1hdGguY29zKGEpICogcng7XG4gICAgICBjb25zdCB5MCA9IGR5ICsgTWF0aC5zaW4oYSkgKiByeTtcbiAgICAgIGNvbnN0IHgxID0geCArIHgwO1xuICAgICAgY29uc3QgeDIgPSB4IC0geDA7XG4gICAgICBjb25zdCB5MSA9IHkgKyB5MDtcbiAgICAgIGNvbnN0IHkyID0geSAtIHkwO1xuICAgICAgcG9pbnRzW2oxKytdID0geDE7XG4gICAgICBwb2ludHNbajErK10gPSB5MTtcbiAgICAgIHBvaW50c1stLWoyXSA9IHkxO1xuICAgICAgcG9pbnRzWy0tajJdID0geDI7XG4gICAgICBwb2ludHNbajMrK10gPSB4MjtcbiAgICAgIHBvaW50c1tqMysrXSA9IHkyO1xuICAgICAgcG9pbnRzWy0tajRdID0geTI7XG4gICAgICBwb2ludHNbLS1qNF0gPSB4MTtcbiAgICB9XG4gICAge1xuICAgICAgY29uc3QgeDAgPSBkeDtcbiAgICAgIGNvbnN0IHkwID0gZHkgKyByeTtcbiAgICAgIGNvbnN0IHgxID0geCArIHgwO1xuICAgICAgY29uc3QgeDIgPSB4IC0geDA7XG4gICAgICBjb25zdCB5MSA9IHkgKyB5MDtcbiAgICAgIGNvbnN0IHkyID0geSAtIHkwO1xuICAgICAgcG9pbnRzW2oxKytdID0geDE7XG4gICAgICBwb2ludHNbajErK10gPSB5MTtcbiAgICAgIHBvaW50c1stLWo0XSA9IHkyO1xuICAgICAgcG9pbnRzWy0tajRdID0geDE7XG4gICAgICBpZiAoZHgpIHtcbiAgICAgICAgcG9pbnRzW2oxKytdID0geDI7XG4gICAgICAgIHBvaW50c1tqMSsrXSA9IHkxO1xuICAgICAgICBwb2ludHNbLS1qNF0gPSB5MjtcbiAgICAgICAgcG9pbnRzWy0tajRdID0geDI7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICB0cmlhbmd1bGF0ZShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpIHtcbiAgICBjb25zdCBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuICAgIGNvbnN0IHZlcnRzID0gZ3JhcGhpY3NHZW9tZXRyeS5wb2ludHM7XG4gICAgY29uc3QgaW5kaWNlcyA9IGdyYXBoaWNzR2VvbWV0cnkuaW5kaWNlcztcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgdmVydFBvcyA9IHZlcnRzLmxlbmd0aCAvIDI7XG4gICAgY29uc3QgY2VudGVyID0gdmVydFBvcztcbiAgICBsZXQgeDtcbiAgICBsZXQgeTtcbiAgICBpZiAoZ3JhcGhpY3NEYXRhLnR5cGUgIT09IGNvcmUuU0hBUEVTLlJSRUMpIHtcbiAgICAgIGNvbnN0IGNpcmNsZSA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcbiAgICAgIHggPSBjaXJjbGUueDtcbiAgICAgIHkgPSBjaXJjbGUueTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgcm91bmRlZFJlY3QgPSBncmFwaGljc0RhdGEuc2hhcGU7XG4gICAgICB4ID0gcm91bmRlZFJlY3QueCArIHJvdW5kZWRSZWN0LndpZHRoIC8gMjtcbiAgICAgIHkgPSByb3VuZGVkUmVjdC55ICsgcm91bmRlZFJlY3QuaGVpZ2h0IC8gMjtcbiAgICB9XG4gICAgY29uc3QgbWF0cml4ID0gZ3JhcGhpY3NEYXRhLm1hdHJpeDtcbiAgICB2ZXJ0cy5wdXNoKGdyYXBoaWNzRGF0YS5tYXRyaXggPyBtYXRyaXguYSAqIHggKyBtYXRyaXguYyAqIHkgKyBtYXRyaXgudHggOiB4LCBncmFwaGljc0RhdGEubWF0cml4ID8gbWF0cml4LmIgKiB4ICsgbWF0cml4LmQgKiB5ICsgbWF0cml4LnR5IDogeSk7XG4gICAgdmVydFBvcysrO1xuICAgIHZlcnRzLnB1c2gocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgIGZvciAobGV0IGkgPSAyOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICB2ZXJ0cy5wdXNoKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSk7XG4gICAgICBpbmRpY2VzLnB1c2godmVydFBvcysrLCBjZW50ZXIsIHZlcnRQb3MpO1xuICAgIH1cbiAgICBpbmRpY2VzLnB1c2goY2VudGVyICsgMSwgY2VudGVyLCB2ZXJ0UG9zKTtcbiAgfVxufTtcblxuZXhwb3J0cy5idWlsZENpcmNsZSA9IGJ1aWxkQ2lyY2xlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRDaXJjbGUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xudmFyIF9jb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0LmpzJyk7XG5cbmZ1bmN0aW9uIHNxdWFyZSh4LCB5LCBueCwgbnksIGlubmVyV2VpZ2h0LCBvdXRlcldlaWdodCwgY2xvY2t3aXNlLCB2ZXJ0cykge1xuICBjb25zdCBpeCA9IHggLSBueCAqIGlubmVyV2VpZ2h0O1xuICBjb25zdCBpeSA9IHkgLSBueSAqIGlubmVyV2VpZ2h0O1xuICBjb25zdCBveCA9IHggKyBueCAqIG91dGVyV2VpZ2h0O1xuICBjb25zdCBveSA9IHkgKyBueSAqIG91dGVyV2VpZ2h0O1xuICBsZXQgZXh4O1xuICBsZXQgZXl5O1xuICBpZiAoY2xvY2t3aXNlKSB7XG4gICAgZXh4ID0gbnk7XG4gICAgZXl5ID0gLW54O1xuICB9IGVsc2Uge1xuICAgIGV4eCA9IC1ueTtcbiAgICBleXkgPSBueDtcbiAgfVxuICBjb25zdCBlaXggPSBpeCArIGV4eDtcbiAgY29uc3QgZWl5ID0gaXkgKyBleXk7XG4gIGNvbnN0IGVveCA9IG94ICsgZXh4O1xuICBjb25zdCBlb3kgPSBveSArIGV5eTtcbiAgdmVydHMucHVzaChlaXgsIGVpeSwgZW94LCBlb3kpO1xuICByZXR1cm4gMjtcbn1cbmZ1bmN0aW9uIHJvdW5kKGN4LCBjeSwgc3gsIHN5LCBleCwgZXksIHZlcnRzLCBjbG9ja3dpc2UpIHtcbiAgY29uc3QgY3gycDB4ID0gc3ggLSBjeDtcbiAgY29uc3QgY3kycDB5ID0gc3kgLSBjeTtcbiAgbGV0IGFuZ2xlMCA9IE1hdGguYXRhbjIoY3gycDB4LCBjeTJwMHkpO1xuICBsZXQgYW5nbGUxID0gTWF0aC5hdGFuMihleCAtIGN4LCBleSAtIGN5KTtcbiAgaWYgKGNsb2Nrd2lzZSAmJiBhbmdsZTAgPCBhbmdsZTEpIHtcbiAgICBhbmdsZTAgKz0gTWF0aC5QSSAqIDI7XG4gIH0gZWxzZSBpZiAoIWNsb2Nrd2lzZSAmJiBhbmdsZTAgPiBhbmdsZTEpIHtcbiAgICBhbmdsZTEgKz0gTWF0aC5QSSAqIDI7XG4gIH1cbiAgbGV0IHN0YXJ0QW5nbGUgPSBhbmdsZTA7XG4gIGNvbnN0IGFuZ2xlRGlmZiA9IGFuZ2xlMSAtIGFuZ2xlMDtcbiAgY29uc3QgYWJzQW5nbGVEaWZmID0gTWF0aC5hYnMoYW5nbGVEaWZmKTtcbiAgY29uc3QgcmFkaXVzID0gTWF0aC5zcXJ0KGN4MnAweCAqIGN4MnAweCArIGN5MnAweSAqIGN5MnAweSk7XG4gIGNvbnN0IHNlZ0NvdW50ID0gKDE1ICogYWJzQW5nbGVEaWZmICogTWF0aC5zcXJ0KHJhZGl1cykgLyBNYXRoLlBJID4+IDApICsgMTtcbiAgY29uc3QgYW5nbGVJbmMgPSBhbmdsZURpZmYgLyBzZWdDb3VudDtcbiAgc3RhcnRBbmdsZSArPSBhbmdsZUluYztcbiAgaWYgKGNsb2Nrd2lzZSkge1xuICAgIHZlcnRzLnB1c2goY3gsIGN5LCBzeCwgc3kpO1xuICAgIGZvciAobGV0IGkgPSAxLCBhbmdsZSA9IHN0YXJ0QW5nbGU7IGkgPCBzZWdDb3VudDsgaSsrLCBhbmdsZSArPSBhbmdsZUluYykge1xuICAgICAgdmVydHMucHVzaChjeCwgY3ksIGN4ICsgTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzLCBjeSArIE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyk7XG4gICAgfVxuICAgIHZlcnRzLnB1c2goY3gsIGN5LCBleCwgZXkpO1xuICB9IGVsc2Uge1xuICAgIHZlcnRzLnB1c2goc3gsIHN5LCBjeCwgY3kpO1xuICAgIGZvciAobGV0IGkgPSAxLCBhbmdsZSA9IHN0YXJ0QW5nbGU7IGkgPCBzZWdDb3VudDsgaSsrLCBhbmdsZSArPSBhbmdsZUluYykge1xuICAgICAgdmVydHMucHVzaChjeCArIE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cywgY3kgKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMsIGN4LCBjeSk7XG4gICAgfVxuICAgIHZlcnRzLnB1c2goZXgsIGV5LCBjeCwgY3kpO1xuICB9XG4gIHJldHVybiBzZWdDb3VudCAqIDI7XG59XG5mdW5jdGlvbiBidWlsZE5vbk5hdGl2ZUxpbmUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XG4gIGNvbnN0IHNoYXBlID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICBsZXQgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cyB8fCBzaGFwZS5wb2ludHMuc2xpY2UoKTtcbiAgY29uc3QgZXBzID0gZ3JhcGhpY3NHZW9tZXRyeS5jbG9zZVBvaW50RXBzO1xuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzdHlsZSA9IGdyYXBoaWNzRGF0YS5saW5lU3R5bGU7XG4gIGNvbnN0IGZpcnN0UG9pbnQgPSBuZXcgY29yZS5Qb2ludChwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gIGNvbnN0IGxhc3RQb2ludCA9IG5ldyBjb3JlLlBvaW50KHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuICBjb25zdCBjbG9zZWRTaGFwZSA9IHNoYXBlLnR5cGUgIT09IGNvcmUuU0hBUEVTLlBPTFkgfHwgc2hhcGUuY2xvc2VTdHJva2U7XG4gIGNvbnN0IGNsb3NlZFBhdGggPSBNYXRoLmFicyhmaXJzdFBvaW50LnggLSBsYXN0UG9pbnQueCkgPCBlcHMgJiYgTWF0aC5hYnMoZmlyc3RQb2ludC55IC0gbGFzdFBvaW50LnkpIDwgZXBzO1xuICBpZiAoY2xvc2VkU2hhcGUpIHtcbiAgICBwb2ludHMgPSBwb2ludHMuc2xpY2UoKTtcbiAgICBpZiAoY2xvc2VkUGF0aCkge1xuICAgICAgcG9pbnRzLnBvcCgpO1xuICAgICAgcG9pbnRzLnBvcCgpO1xuICAgICAgbGFzdFBvaW50LnNldChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKTtcbiAgICB9XG4gICAgY29uc3QgbWlkUG9pbnRYID0gKGZpcnN0UG9pbnQueCArIGxhc3RQb2ludC54KSAqIDAuNTtcbiAgICBjb25zdCBtaWRQb2ludFkgPSAobGFzdFBvaW50LnkgKyBmaXJzdFBvaW50LnkpICogMC41O1xuICAgIHBvaW50cy51bnNoaWZ0KG1pZFBvaW50WCwgbWlkUG9pbnRZKTtcbiAgICBwb2ludHMucHVzaChtaWRQb2ludFgsIG1pZFBvaW50WSk7XG4gIH1cbiAgY29uc3QgdmVydHMgPSBncmFwaGljc0dlb21ldHJ5LnBvaW50cztcbiAgY29uc3QgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCAvIDI7XG4gIGxldCBpbmRleENvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgaW5kZXhTdGFydCA9IHZlcnRzLmxlbmd0aCAvIDI7XG4gIGNvbnN0IHdpZHRoID0gc3R5bGUud2lkdGggLyAyO1xuICBjb25zdCB3aWR0aFNxdWFyZWQgPSB3aWR0aCAqIHdpZHRoO1xuICBjb25zdCBtaXRlckxpbWl0U3F1YXJlZCA9IHN0eWxlLm1pdGVyTGltaXQgKiBzdHlsZS5taXRlckxpbWl0O1xuICBsZXQgeDAgPSBwb2ludHNbMF07XG4gIGxldCB5MCA9IHBvaW50c1sxXTtcbiAgbGV0IHgxID0gcG9pbnRzWzJdO1xuICBsZXQgeTEgPSBwb2ludHNbM107XG4gIGxldCB4MiA9IDA7XG4gIGxldCB5MiA9IDA7XG4gIGxldCBwZXJweCA9IC0oeTAgLSB5MSk7XG4gIGxldCBwZXJweSA9IHgwIC0geDE7XG4gIGxldCBwZXJwMXggPSAwO1xuICBsZXQgcGVycDF5ID0gMDtcbiAgbGV0IGRpc3QgPSBNYXRoLnNxcnQocGVycHggKiBwZXJweCArIHBlcnB5ICogcGVycHkpO1xuICBwZXJweCAvPSBkaXN0O1xuICBwZXJweSAvPSBkaXN0O1xuICBwZXJweCAqPSB3aWR0aDtcbiAgcGVycHkgKj0gd2lkdGg7XG4gIGNvbnN0IHJhdGlvID0gc3R5bGUuYWxpZ25tZW50O1xuICBjb25zdCBpbm5lcldlaWdodCA9ICgxIC0gcmF0aW8pICogMjtcbiAgY29uc3Qgb3V0ZXJXZWlnaHQgPSByYXRpbyAqIDI7XG4gIGlmICghY2xvc2VkU2hhcGUpIHtcbiAgICBpZiAoc3R5bGUuY2FwID09PSBfY29uc3QuTElORV9DQVAuUk9VTkQpIHtcbiAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoeDAgLSBwZXJweCAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSwgeTAgLSBwZXJweSAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSwgeDAgLSBwZXJweCAqIGlubmVyV2VpZ2h0LCB5MCAtIHBlcnB5ICogaW5uZXJXZWlnaHQsIHgwICsgcGVycHggKiBvdXRlcldlaWdodCwgeTAgKyBwZXJweSAqIG91dGVyV2VpZ2h0LCB2ZXJ0cywgdHJ1ZSkgKyAyO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuY2FwID09PSBfY29uc3QuTElORV9DQVAuU1FVQVJFKSB7XG4gICAgICBpbmRleENvdW50ICs9IHNxdWFyZSh4MCwgeTAsIHBlcnB4LCBwZXJweSwgaW5uZXJXZWlnaHQsIG91dGVyV2VpZ2h0LCB0cnVlLCB2ZXJ0cyk7XG4gICAgfVxuICB9XG4gIHZlcnRzLnB1c2goeDAgLSBwZXJweCAqIGlubmVyV2VpZ2h0LCB5MCAtIHBlcnB5ICogaW5uZXJXZWlnaHQsIHgwICsgcGVycHggKiBvdXRlcldlaWdodCwgeTAgKyBwZXJweSAqIG91dGVyV2VpZ2h0KTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGggLSAxOyArK2kpIHtcbiAgICB4MCA9IHBvaW50c1soaSAtIDEpICogMl07XG4gICAgeTAgPSBwb2ludHNbKGkgLSAxKSAqIDIgKyAxXTtcbiAgICB4MSA9IHBvaW50c1tpICogMl07XG4gICAgeTEgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICB4MiA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgeTIgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICBwZXJweCA9IC0oeTAgLSB5MSk7XG4gICAgcGVycHkgPSB4MCAtIHgxO1xuICAgIGRpc3QgPSBNYXRoLnNxcnQocGVycHggKiBwZXJweCArIHBlcnB5ICogcGVycHkpO1xuICAgIHBlcnB4IC89IGRpc3Q7XG4gICAgcGVycHkgLz0gZGlzdDtcbiAgICBwZXJweCAqPSB3aWR0aDtcbiAgICBwZXJweSAqPSB3aWR0aDtcbiAgICBwZXJwMXggPSAtKHkxIC0geTIpO1xuICAgIHBlcnAxeSA9IHgxIC0geDI7XG4gICAgZGlzdCA9IE1hdGguc3FydChwZXJwMXggKiBwZXJwMXggKyBwZXJwMXkgKiBwZXJwMXkpO1xuICAgIHBlcnAxeCAvPSBkaXN0O1xuICAgIHBlcnAxeSAvPSBkaXN0O1xuICAgIHBlcnAxeCAqPSB3aWR0aDtcbiAgICBwZXJwMXkgKj0gd2lkdGg7XG4gICAgY29uc3QgZHgwID0geDEgLSB4MDtcbiAgICBjb25zdCBkeTAgPSB5MCAtIHkxO1xuICAgIGNvbnN0IGR4MSA9IHgxIC0geDI7XG4gICAgY29uc3QgZHkxID0geTIgLSB5MTtcbiAgICBjb25zdCBkb3QgPSBkeDAgKiBkeDEgKyBkeTAgKiBkeTE7XG4gICAgY29uc3QgY3Jvc3MgPSBkeTAgKiBkeDEgLSBkeTEgKiBkeDA7XG4gICAgY29uc3QgY2xvY2t3aXNlID0gY3Jvc3MgPCAwO1xuICAgIGlmIChNYXRoLmFicyhjcm9zcykgPCAxZS0zICogTWF0aC5hYnMoZG90KSkge1xuICAgICAgdmVydHMucHVzaCh4MSAtIHBlcnB4ICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycHkgKiBpbm5lcldlaWdodCwgeDEgKyBwZXJweCAqIG91dGVyV2VpZ2h0LCB5MSArIHBlcnB5ICogb3V0ZXJXZWlnaHQpO1xuICAgICAgaWYgKGRvdCA+PSAwKSB7XG4gICAgICAgIGlmIChzdHlsZS5qb2luID09PSBfY29uc3QuTElORV9KT0lOLlJPVU5EKSB7XG4gICAgICAgICAgaW5kZXhDb3VudCArPSByb3VuZCh4MSwgeTEsIHgxIC0gcGVycHggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJweSAqIGlubmVyV2VpZ2h0LCB4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnAxeSAqIGlubmVyV2VpZ2h0LCB2ZXJ0cywgZmFsc2UpICsgNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRleENvdW50ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgdmVydHMucHVzaCh4MSAtIHBlcnAxeCAqIG91dGVyV2VpZ2h0LCB5MSAtIHBlcnAxeSAqIG91dGVyV2VpZ2h0LCB4MSArIHBlcnAxeCAqIGlubmVyV2VpZ2h0LCB5MSArIHBlcnAxeSAqIGlubmVyV2VpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBjMSA9ICgtcGVycHggKyB4MCkgKiAoLXBlcnB5ICsgeTEpIC0gKC1wZXJweCArIHgxKSAqICgtcGVycHkgKyB5MCk7XG4gICAgY29uc3QgYzIgPSAoLXBlcnAxeCArIHgyKSAqICgtcGVycDF5ICsgeTEpIC0gKC1wZXJwMXggKyB4MSkgKiAoLXBlcnAxeSArIHkyKTtcbiAgICBjb25zdCBweCA9IChkeDAgKiBjMiAtIGR4MSAqIGMxKSAvIGNyb3NzO1xuICAgIGNvbnN0IHB5ID0gKGR5MSAqIGMxIC0gZHkwICogYzIpIC8gY3Jvc3M7XG4gICAgY29uc3QgcGRpc3QgPSAocHggLSB4MSkgKiAocHggLSB4MSkgKyAocHkgLSB5MSkgKiAocHkgLSB5MSk7XG4gICAgY29uc3QgaW14ID0geDEgKyAocHggLSB4MSkgKiBpbm5lcldlaWdodDtcbiAgICBjb25zdCBpbXkgPSB5MSArIChweSAtIHkxKSAqIGlubmVyV2VpZ2h0O1xuICAgIGNvbnN0IG9teCA9IHgxIC0gKHB4IC0geDEpICogb3V0ZXJXZWlnaHQ7XG4gICAgY29uc3Qgb215ID0geTEgLSAocHkgLSB5MSkgKiBvdXRlcldlaWdodDtcbiAgICBjb25zdCBzbWFsbGVySW5zaWRlU2VnbWVudFNxID0gTWF0aC5taW4oZHgwICogZHgwICsgZHkwICogZHkwLCBkeDEgKiBkeDEgKyBkeTEgKiBkeTEpO1xuICAgIGNvbnN0IGluc2lkZVdlaWdodCA9IGNsb2Nrd2lzZSA/IGlubmVyV2VpZ2h0IDogb3V0ZXJXZWlnaHQ7XG4gICAgY29uc3Qgc21hbGxlckluc2lkZURpYWdvbmFsU3EgPSBzbWFsbGVySW5zaWRlU2VnbWVudFNxICsgaW5zaWRlV2VpZ2h0ICogaW5zaWRlV2VpZ2h0ICogd2lkdGhTcXVhcmVkO1xuICAgIGNvbnN0IGluc2lkZU1pdGVyT2sgPSBwZGlzdCA8PSBzbWFsbGVySW5zaWRlRGlhZ29uYWxTcTtcbiAgICBsZXQgam9pbiA9IHN0eWxlLmpvaW47XG4gICAgaWYgKGpvaW4gPT09IF9jb25zdC5MSU5FX0pPSU4uTUlURVIgJiYgcGRpc3QgLyB3aWR0aFNxdWFyZWQgPiBtaXRlckxpbWl0U3F1YXJlZCkge1xuICAgICAgam9pbiA9IF9jb25zdC5MSU5FX0pPSU4uQkVWRUw7XG4gICAgfVxuICAgIGlmIChpbnNpZGVNaXRlck9rKSB7XG4gICAgICBzd2l0Y2ggKGpvaW4pIHtcbiAgICAgICAgY2FzZSBfY29uc3QuTElORV9KT0lOLk1JVEVSOiB7XG4gICAgICAgICAgdmVydHMucHVzaChpbXgsIGlteSwgb214LCBvbXkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgX2NvbnN0LkxJTkVfSk9JTi5CRVZFTDoge1xuICAgICAgICAgIGlmIChjbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIHZlcnRzLnB1c2goaW14LCBpbXksIHgxICsgcGVycHggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJweSAqIG91dGVyV2VpZ2h0LCBpbXgsIGlteSwgeDEgKyBwZXJwMXggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJwMXkgKiBvdXRlcldlaWdodCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlcnRzLnB1c2goeDEgLSBwZXJweCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnB5ICogaW5uZXJXZWlnaHQsIG9teCwgb215LCB4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnAxeSAqIGlubmVyV2VpZ2h0LCBvbXgsIG9teSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluZGV4Q291bnQgKz0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIF9jb25zdC5MSU5FX0pPSU4uUk9VTkQ6IHtcbiAgICAgICAgICBpZiAoY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKGlteCwgaW15LCB4MSArIHBlcnB4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycHkgKiBvdXRlcldlaWdodCk7XG4gICAgICAgICAgICBpbmRleENvdW50ICs9IHJvdW5kKHgxLCB5MSwgeDEgKyBwZXJweCAqIG91dGVyV2VpZ2h0LCB5MSArIHBlcnB5ICogb3V0ZXJXZWlnaHQsIHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQsIHZlcnRzLCB0cnVlKSArIDQ7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKGlteCwgaW15LCB4MSArIHBlcnAxeCAqIG91dGVyV2VpZ2h0LCB5MSArIHBlcnAxeSAqIG91dGVyV2VpZ2h0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmVydHMucHVzaCh4MSAtIHBlcnB4ICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycHkgKiBpbm5lcldlaWdodCwgb214LCBvbXkpO1xuICAgICAgICAgICAgaW5kZXhDb3VudCArPSByb3VuZCh4MSwgeTEsIHgxIC0gcGVycHggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJweSAqIGlubmVyV2VpZ2h0LCB4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnAxeSAqIGlubmVyV2VpZ2h0LCB2ZXJ0cywgZmFsc2UpICsgNDtcbiAgICAgICAgICAgIHZlcnRzLnB1c2goeDEgLSBwZXJwMXggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJwMXkgKiBpbm5lcldlaWdodCwgb214LCBvbXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2ZXJ0cy5wdXNoKHgxIC0gcGVycHggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJweSAqIGlubmVyV2VpZ2h0LCB4MSArIHBlcnB4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycHkgKiBvdXRlcldlaWdodCk7XG4gICAgICBzd2l0Y2ggKGpvaW4pIHtcbiAgICAgICAgY2FzZSBfY29uc3QuTElORV9KT0lOLk1JVEVSOiB7XG4gICAgICAgICAgaWYgKGNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgdmVydHMucHVzaChvbXgsIG9teSwgb214LCBvbXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKGlteCwgaW15LCBpbXgsIGlteSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluZGV4Q291bnQgKz0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIF9jb25zdC5MSU5FX0pPSU4uUk9VTkQ6IHtcbiAgICAgICAgICBpZiAoY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICBpbmRleENvdW50ICs9IHJvdW5kKHgxLCB5MSwgeDEgKyBwZXJweCAqIG91dGVyV2VpZ2h0LCB5MSArIHBlcnB5ICogb3V0ZXJXZWlnaHQsIHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQsIHZlcnRzLCB0cnVlKSArIDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoeDEsIHkxLCB4MSAtIHBlcnB4ICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycHkgKiBpbm5lcldlaWdodCwgeDEgLSBwZXJwMXggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJwMXkgKiBpbm5lcldlaWdodCwgdmVydHMsIGZhbHNlKSArIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2ZXJ0cy5wdXNoKHgxIC0gcGVycDF4ICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycDF5ICogaW5uZXJXZWlnaHQsIHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQpO1xuICAgICAgaW5kZXhDb3VudCArPSAyO1xuICAgIH1cbiAgfVxuICB4MCA9IHBvaW50c1sobGVuZ3RoIC0gMikgKiAyXTtcbiAgeTAgPSBwb2ludHNbKGxlbmd0aCAtIDIpICogMiArIDFdO1xuICB4MSA9IHBvaW50c1sobGVuZ3RoIC0gMSkgKiAyXTtcbiAgeTEgPSBwb2ludHNbKGxlbmd0aCAtIDEpICogMiArIDFdO1xuICBwZXJweCA9IC0oeTAgLSB5MSk7XG4gIHBlcnB5ID0geDAgLSB4MTtcbiAgZGlzdCA9IE1hdGguc3FydChwZXJweCAqIHBlcnB4ICsgcGVycHkgKiBwZXJweSk7XG4gIHBlcnB4IC89IGRpc3Q7XG4gIHBlcnB5IC89IGRpc3Q7XG4gIHBlcnB4ICo9IHdpZHRoO1xuICBwZXJweSAqPSB3aWR0aDtcbiAgdmVydHMucHVzaCh4MSAtIHBlcnB4ICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycHkgKiBpbm5lcldlaWdodCwgeDEgKyBwZXJweCAqIG91dGVyV2VpZ2h0LCB5MSArIHBlcnB5ICogb3V0ZXJXZWlnaHQpO1xuICBpZiAoIWNsb3NlZFNoYXBlKSB7XG4gICAgaWYgKHN0eWxlLmNhcCA9PT0gX2NvbnN0LkxJTkVfQ0FQLlJPVU5EKSB7XG4gICAgICBpbmRleENvdW50ICs9IHJvdW5kKHgxIC0gcGVycHggKiAoaW5uZXJXZWlnaHQgLSBvdXRlcldlaWdodCkgKiAwLjUsIHkxIC0gcGVycHkgKiAoaW5uZXJXZWlnaHQgLSBvdXRlcldlaWdodCkgKiAwLjUsIHgxIC0gcGVycHggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJweSAqIGlubmVyV2VpZ2h0LCB4MSArIHBlcnB4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycHkgKiBvdXRlcldlaWdodCwgdmVydHMsIGZhbHNlKSArIDI7XG4gICAgfSBlbHNlIGlmIChzdHlsZS5jYXAgPT09IF9jb25zdC5MSU5FX0NBUC5TUVVBUkUpIHtcbiAgICAgIGluZGV4Q291bnQgKz0gc3F1YXJlKHgxLCB5MSwgcGVycHgsIHBlcnB5LCBpbm5lcldlaWdodCwgb3V0ZXJXZWlnaHQsIGZhbHNlLCB2ZXJ0cyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGluZGljZXMgPSBncmFwaGljc0dlb21ldHJ5LmluZGljZXM7XG4gIGNvbnN0IGVwczIgPSBfY29uc3QuY3VydmVzLmVwc2lsb24gKiBfY29uc3QuY3VydmVzLmVwc2lsb247XG4gIGZvciAobGV0IGkgPSBpbmRleFN0YXJ0OyBpIDwgaW5kZXhDb3VudCArIGluZGV4U3RhcnQgLSAyOyArK2kpIHtcbiAgICB4MCA9IHZlcnRzW2kgKiAyXTtcbiAgICB5MCA9IHZlcnRzW2kgKiAyICsgMV07XG4gICAgeDEgPSB2ZXJ0c1soaSArIDEpICogMl07XG4gICAgeTEgPSB2ZXJ0c1soaSArIDEpICogMiArIDFdO1xuICAgIHgyID0gdmVydHNbKGkgKyAyKSAqIDJdO1xuICAgIHkyID0gdmVydHNbKGkgKyAyKSAqIDIgKyAxXTtcbiAgICBpZiAoTWF0aC5hYnMoeDAgKiAoeTEgLSB5MikgKyB4MSAqICh5MiAtIHkwKSArIHgyICogKHkwIC0geTEpKSA8IGVwczIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpbmRpY2VzLnB1c2goaSwgaSArIDEsIGkgKyAyKTtcbiAgfVxufVxuZnVuY3Rpb24gYnVpbGROYXRpdmVMaW5lKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IHNoYXBlID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICBjb25zdCBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzIHx8IHNoYXBlLnBvaW50cztcbiAgY29uc3QgY2xvc2VkU2hhcGUgPSBzaGFwZS50eXBlICE9PSBjb3JlLlNIQVBFUy5QT0xZIHx8IHNoYXBlLmNsb3NlU3Ryb2tlO1xuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm47XG4gIGNvbnN0IHZlcnRzID0gZ3JhcGhpY3NHZW9tZXRyeS5wb2ludHM7XG4gIGNvbnN0IGluZGljZXMgPSBncmFwaGljc0dlb21ldHJ5LmluZGljZXM7XG4gIGNvbnN0IGxlbmd0aCA9IHBvaW50cy5sZW5ndGggLyAyO1xuICBjb25zdCBzdGFydEluZGV4ID0gdmVydHMubGVuZ3RoIC8gMjtcbiAgbGV0IGN1cnJlbnRJbmRleCA9IHN0YXJ0SW5kZXg7XG4gIHZlcnRzLnB1c2gocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2ZXJ0cy5wdXNoKHBvaW50c1tpICogMl0sIHBvaW50c1tpICogMiArIDFdKTtcbiAgICBpbmRpY2VzLnB1c2goY3VycmVudEluZGV4LCBjdXJyZW50SW5kZXggKyAxKTtcbiAgICBjdXJyZW50SW5kZXgrKztcbiAgfVxuICBpZiAoY2xvc2VkU2hhcGUpIHtcbiAgICBpbmRpY2VzLnB1c2goY3VycmVudEluZGV4LCBzdGFydEluZGV4KTtcbiAgfVxufVxuZnVuY3Rpb24gYnVpbGRMaW5lKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xuICBpZiAoZ3JhcGhpY3NEYXRhLmxpbmVTdHlsZS5uYXRpdmUpIHtcbiAgICBidWlsZE5hdGl2ZUxpbmUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KTtcbiAgfSBlbHNlIHtcbiAgICBidWlsZE5vbk5hdGl2ZUxpbmUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KTtcbiAgfVxufVxuXG5leHBvcnRzLmJ1aWxkTGluZSA9IGJ1aWxkTGluZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkTGluZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG5cbmZ1bmN0aW9uIGZpeE9yaWVudGF0aW9uKHBvaW50cywgaG9sZSA9IGZhbHNlKSB7XG4gIGNvbnN0IG0gPSBwb2ludHMubGVuZ3RoO1xuICBpZiAobSA8IDYpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGFyZWEgPSAwO1xuICBmb3IgKGxldCBpID0gMCwgeDEgPSBwb2ludHNbbSAtIDJdLCB5MSA9IHBvaW50c1ttIC0gMV07IGkgPCBtOyBpICs9IDIpIHtcbiAgICBjb25zdCB4MiA9IHBvaW50c1tpXTtcbiAgICBjb25zdCB5MiA9IHBvaW50c1tpICsgMV07XG4gICAgYXJlYSArPSAoeDIgLSB4MSkgKiAoeTIgKyB5MSk7XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIGlmICghaG9sZSAmJiBhcmVhID4gMCB8fCBob2xlICYmIGFyZWEgPD0gMCkge1xuICAgIGNvbnN0IG4gPSBtIC8gMjtcbiAgICBmb3IgKGxldCBpID0gbiArIG4gJSAyOyBpIDwgbTsgaSArPSAyKSB7XG4gICAgICBjb25zdCBpMSA9IG0gLSBpIC0gMjtcbiAgICAgIGNvbnN0IGkyID0gbSAtIGkgLSAxO1xuICAgICAgY29uc3QgaTMgPSBpO1xuICAgICAgY29uc3QgaTQgPSBpICsgMTtcbiAgICAgIFtwb2ludHNbaTFdLCBwb2ludHNbaTNdXSA9IFtwb2ludHNbaTNdLCBwb2ludHNbaTFdXTtcbiAgICAgIFtwb2ludHNbaTJdLCBwb2ludHNbaTRdXSA9IFtwb2ludHNbaTRdLCBwb2ludHNbaTJdXTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IGJ1aWxkUG9seSA9IHtcbiAgYnVpbGQoZ3JhcGhpY3NEYXRhKSB7XG4gICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IGdyYXBoaWNzRGF0YS5zaGFwZS5wb2ludHMuc2xpY2UoKTtcbiAgfSxcbiAgdHJpYW5ndWxhdGUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XG4gICAgbGV0IHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG4gICAgY29uc3QgaG9sZXMgPSBncmFwaGljc0RhdGEuaG9sZXM7XG4gICAgY29uc3QgdmVydHMgPSBncmFwaGljc0dlb21ldHJ5LnBvaW50cztcbiAgICBjb25zdCBpbmRpY2VzID0gZ3JhcGhpY3NHZW9tZXRyeS5pbmRpY2VzO1xuICAgIGlmIChwb2ludHMubGVuZ3RoID49IDYpIHtcbiAgICAgIGZpeE9yaWVudGF0aW9uKHBvaW50cywgZmFsc2UpO1xuICAgICAgY29uc3QgaG9sZUFycmF5ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGhvbGUgPSBob2xlc1tpXTtcbiAgICAgICAgZml4T3JpZW50YXRpb24oaG9sZS5wb2ludHMsIHRydWUpO1xuICAgICAgICBob2xlQXJyYXkucHVzaChwb2ludHMubGVuZ3RoIC8gMik7XG4gICAgICAgIHBvaW50cyA9IHBvaW50cy5jb25jYXQoaG9sZS5wb2ludHMpO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJpYW5nbGVzID0gY29yZS51dGlscy5lYXJjdXQocG9pbnRzLCBob2xlQXJyYXksIDIpO1xuICAgICAgaWYgKCF0cmlhbmdsZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdmVydFBvcyA9IHZlcnRzLmxlbmd0aCAvIDI7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2ldICsgdmVydFBvcyk7XG4gICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDFdICsgdmVydFBvcyk7XG4gICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDJdICsgdmVydFBvcyk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2ZXJ0cy5wdXNoKHBvaW50c1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnRzLmJ1aWxkUG9seSA9IGJ1aWxkUG9seTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkUG9seS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY29uc3QgYnVpbGRSZWN0YW5nbGUgPSB7XG4gIGJ1aWxkKGdyYXBoaWNzRGF0YSkge1xuICAgIGNvbnN0IHJlY3REYXRhID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICAgIGNvbnN0IHggPSByZWN0RGF0YS54O1xuICAgIGNvbnN0IHkgPSByZWN0RGF0YS55O1xuICAgIGNvbnN0IHdpZHRoID0gcmVjdERhdGEud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gcmVjdERhdGEuaGVpZ2h0O1xuICAgIGNvbnN0IHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG4gICAgcG9pbnRzLmxlbmd0aCA9IDA7XG4gICAgaWYgKCEod2lkdGggPj0gMCAmJiBoZWlnaHQgPj0gMCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcG9pbnRzLnB1c2goeCwgeSwgeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQpO1xuICB9LFxuICB0cmlhbmd1bGF0ZShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpIHtcbiAgICBjb25zdCBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuICAgIGNvbnN0IHZlcnRzID0gZ3JhcGhpY3NHZW9tZXRyeS5wb2ludHM7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmVydFBvcyA9IHZlcnRzLmxlbmd0aCAvIDI7XG4gICAgdmVydHMucHVzaChwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHBvaW50c1s2XSwgcG9pbnRzWzddLCBwb2ludHNbNF0sIHBvaW50c1s1XSk7XG4gICAgZ3JhcGhpY3NHZW9tZXRyeS5pbmRpY2VzLnB1c2godmVydFBvcywgdmVydFBvcyArIDEsIHZlcnRQb3MgKyAyLCB2ZXJ0UG9zICsgMSwgdmVydFBvcyArIDIsIHZlcnRQb3MgKyAzKTtcbiAgfVxufTtcblxuZXhwb3J0cy5idWlsZFJlY3RhbmdsZSA9IGJ1aWxkUmVjdGFuZ2xlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRSZWN0YW5nbGUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBidWlsZENpcmNsZSA9IHJlcXVpcmUoJy4vYnVpbGRDaXJjbGUuanMnKTtcblxuY29uc3QgYnVpbGRSb3VuZGVkUmVjdGFuZ2xlID0ge1xuICBidWlsZChncmFwaGljc0RhdGEpIHtcbiAgICBidWlsZENpcmNsZS5idWlsZENpcmNsZS5idWlsZChncmFwaGljc0RhdGEpO1xuICB9LFxuICB0cmlhbmd1bGF0ZShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpIHtcbiAgICBidWlsZENpcmNsZS5idWlsZENpcmNsZS50cmlhbmd1bGF0ZShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpO1xuICB9XG59O1xuXG5leHBvcnRzLmJ1aWxkUm91bmRlZFJlY3RhbmdsZSA9IGJ1aWxkUm91bmRlZFJlY3RhbmdsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkUm91bmRlZFJlY3RhbmdsZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgYnVpbGRDaXJjbGUgPSByZXF1aXJlKCcuL2J1aWxkQ2lyY2xlLmpzJyk7XG52YXIgYnVpbGRQb2x5ID0gcmVxdWlyZSgnLi9idWlsZFBvbHkuanMnKTtcbnZhciBidWlsZFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4vYnVpbGRSZWN0YW5nbGUuanMnKTtcbnZhciBidWlsZFJvdW5kZWRSZWN0YW5nbGUgPSByZXF1aXJlKCcuL2J1aWxkUm91bmRlZFJlY3RhbmdsZS5qcycpO1xudmFyIEFyY1V0aWxzID0gcmVxdWlyZSgnLi9BcmNVdGlscy5qcycpO1xudmFyIEJhdGNoUGFydCA9IHJlcXVpcmUoJy4vQmF0Y2hQYXJ0LmpzJyk7XG52YXIgQmV6aWVyVXRpbHMgPSByZXF1aXJlKCcuL0JlemllclV0aWxzLmpzJyk7XG52YXIgYnVpbGRMaW5lID0gcmVxdWlyZSgnLi9idWlsZExpbmUuanMnKTtcbnZhciBRdWFkcmF0aWNVdGlscyA9IHJlcXVpcmUoJy4vUXVhZHJhdGljVXRpbHMuanMnKTtcblxuY29uc3QgRklMTF9DT01NQU5EUyA9IHtcbiAgW2NvcmUuU0hBUEVTLlBPTFldOiBidWlsZFBvbHkuYnVpbGRQb2x5LFxuICBbY29yZS5TSEFQRVMuQ0lSQ106IGJ1aWxkQ2lyY2xlLmJ1aWxkQ2lyY2xlLFxuICBbY29yZS5TSEFQRVMuRUxJUF06IGJ1aWxkQ2lyY2xlLmJ1aWxkQ2lyY2xlLFxuICBbY29yZS5TSEFQRVMuUkVDVF06IGJ1aWxkUmVjdGFuZ2xlLmJ1aWxkUmVjdGFuZ2xlLFxuICBbY29yZS5TSEFQRVMuUlJFQ106IGJ1aWxkUm91bmRlZFJlY3RhbmdsZS5idWlsZFJvdW5kZWRSZWN0YW5nbGVcbn07XG5jb25zdCBCQVRDSF9QT09MID0gW107XG5jb25zdCBEUkFXX0NBTExfUE9PTCA9IFtdO1xuXG5leHBvcnRzLmJ1aWxkQ2lyY2xlID0gYnVpbGRDaXJjbGUuYnVpbGRDaXJjbGU7XG5leHBvcnRzLmJ1aWxkUG9seSA9IGJ1aWxkUG9seS5idWlsZFBvbHk7XG5leHBvcnRzLmJ1aWxkUmVjdGFuZ2xlID0gYnVpbGRSZWN0YW5nbGUuYnVpbGRSZWN0YW5nbGU7XG5leHBvcnRzLmJ1aWxkUm91bmRlZFJlY3RhbmdsZSA9IGJ1aWxkUm91bmRlZFJlY3RhbmdsZS5idWlsZFJvdW5kZWRSZWN0YW5nbGU7XG5leHBvcnRzLkFyY1V0aWxzID0gQXJjVXRpbHMuQXJjVXRpbHM7XG5leHBvcnRzLkJhdGNoUGFydCA9IEJhdGNoUGFydC5CYXRjaFBhcnQ7XG5leHBvcnRzLkJlemllclV0aWxzID0gQmV6aWVyVXRpbHMuQmV6aWVyVXRpbHM7XG5leHBvcnRzLmJ1aWxkTGluZSA9IGJ1aWxkTGluZS5idWlsZExpbmU7XG5leHBvcnRzLlF1YWRyYXRpY1V0aWxzID0gUXVhZHJhdGljVXRpbHMuUXVhZHJhdGljVXRpbHM7XG5leHBvcnRzLkJBVENIX1BPT0wgPSBCQVRDSF9QT09MO1xuZXhwb3J0cy5EUkFXX0NBTExfUE9PTCA9IERSQVdfQ0FMTF9QT09MO1xuZXhwb3J0cy5GSUxMX0NPTU1BTkRTID0gRklMTF9DT01NQU5EUztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JUG9pbnQuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlQb2ludERhdGEuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuL2NvbnN0LmpzJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50LmpzJyk7XG5cbmNsYXNzIE1hdHJpeCB7XG4gIGNvbnN0cnVjdG9yKGEgPSAxLCBiID0gMCwgYyA9IDAsIGQgPSAxLCB0eCA9IDAsIHR5ID0gMCkge1xuICAgIHRoaXMuYXJyYXkgPSBudWxsO1xuICAgIHRoaXMuYSA9IGE7XG4gICAgdGhpcy5iID0gYjtcbiAgICB0aGlzLmMgPSBjO1xuICAgIHRoaXMuZCA9IGQ7XG4gICAgdGhpcy50eCA9IHR4O1xuICAgIHRoaXMudHkgPSB0eTtcbiAgfVxuICBmcm9tQXJyYXkoYXJyYXkpIHtcbiAgICB0aGlzLmEgPSBhcnJheVswXTtcbiAgICB0aGlzLmIgPSBhcnJheVsxXTtcbiAgICB0aGlzLmMgPSBhcnJheVszXTtcbiAgICB0aGlzLmQgPSBhcnJheVs0XTtcbiAgICB0aGlzLnR4ID0gYXJyYXlbMl07XG4gICAgdGhpcy50eSA9IGFycmF5WzVdO1xuICB9XG4gIHNldChhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgICB0aGlzLmEgPSBhO1xuICAgIHRoaXMuYiA9IGI7XG4gICAgdGhpcy5jID0gYztcbiAgICB0aGlzLmQgPSBkO1xuICAgIHRoaXMudHggPSB0eDtcbiAgICB0aGlzLnR5ID0gdHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdG9BcnJheSh0cmFuc3Bvc2UsIG91dCkge1xuICAgIGlmICghdGhpcy5hcnJheSkge1xuICAgICAgdGhpcy5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7XG4gICAgfVxuICAgIGNvbnN0IGFycmF5ID0gb3V0IHx8IHRoaXMuYXJyYXk7XG4gICAgaWYgKHRyYW5zcG9zZSkge1xuICAgICAgYXJyYXlbMF0gPSB0aGlzLmE7XG4gICAgICBhcnJheVsxXSA9IHRoaXMuYjtcbiAgICAgIGFycmF5WzJdID0gMDtcbiAgICAgIGFycmF5WzNdID0gdGhpcy5jO1xuICAgICAgYXJyYXlbNF0gPSB0aGlzLmQ7XG4gICAgICBhcnJheVs1XSA9IDA7XG4gICAgICBhcnJheVs2XSA9IHRoaXMudHg7XG4gICAgICBhcnJheVs3XSA9IHRoaXMudHk7XG4gICAgICBhcnJheVs4XSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycmF5WzBdID0gdGhpcy5hO1xuICAgICAgYXJyYXlbMV0gPSB0aGlzLmM7XG4gICAgICBhcnJheVsyXSA9IHRoaXMudHg7XG4gICAgICBhcnJheVszXSA9IHRoaXMuYjtcbiAgICAgIGFycmF5WzRdID0gdGhpcy5kO1xuICAgICAgYXJyYXlbNV0gPSB0aGlzLnR5O1xuICAgICAgYXJyYXlbNl0gPSAwO1xuICAgICAgYXJyYXlbN10gPSAwO1xuICAgICAgYXJyYXlbOF0gPSAxO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgYXBwbHkocG9zLCBuZXdQb3MpIHtcbiAgICBuZXdQb3MgPSBuZXdQb3MgfHwgbmV3IFBvaW50LlBvaW50KCk7XG4gICAgY29uc3QgeCA9IHBvcy54O1xuICAgIGNvbnN0IHkgPSBwb3MueTtcbiAgICBuZXdQb3MueCA9IHRoaXMuYSAqIHggKyB0aGlzLmMgKiB5ICsgdGhpcy50eDtcbiAgICBuZXdQb3MueSA9IHRoaXMuYiAqIHggKyB0aGlzLmQgKiB5ICsgdGhpcy50eTtcbiAgICByZXR1cm4gbmV3UG9zO1xuICB9XG4gIGFwcGx5SW52ZXJzZShwb3MsIG5ld1Bvcykge1xuICAgIG5ld1BvcyA9IG5ld1BvcyB8fCBuZXcgUG9pbnQuUG9pbnQoKTtcbiAgICBjb25zdCBpZCA9IDEgLyAodGhpcy5hICogdGhpcy5kICsgdGhpcy5jICogLXRoaXMuYik7XG4gICAgY29uc3QgeCA9IHBvcy54O1xuICAgIGNvbnN0IHkgPSBwb3MueTtcbiAgICBuZXdQb3MueCA9IHRoaXMuZCAqIGlkICogeCArIC10aGlzLmMgKiBpZCAqIHkgKyAodGhpcy50eSAqIHRoaXMuYyAtIHRoaXMudHggKiB0aGlzLmQpICogaWQ7XG4gICAgbmV3UG9zLnkgPSB0aGlzLmEgKiBpZCAqIHkgKyAtdGhpcy5iICogaWQgKiB4ICsgKC10aGlzLnR5ICogdGhpcy5hICsgdGhpcy50eCAqIHRoaXMuYikgKiBpZDtcbiAgICByZXR1cm4gbmV3UG9zO1xuICB9XG4gIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgdGhpcy50eCArPSB4O1xuICAgIHRoaXMudHkgKz0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzY2FsZSh4LCB5KSB7XG4gICAgdGhpcy5hICo9IHg7XG4gICAgdGhpcy5kICo9IHk7XG4gICAgdGhpcy5jICo9IHg7XG4gICAgdGhpcy5iICo9IHk7XG4gICAgdGhpcy50eCAqPSB4O1xuICAgIHRoaXMudHkgKj0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByb3RhdGUoYW5nbGUpIHtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIGNvbnN0IGExID0gdGhpcy5hO1xuICAgIGNvbnN0IGMxID0gdGhpcy5jO1xuICAgIGNvbnN0IHR4MSA9IHRoaXMudHg7XG4gICAgdGhpcy5hID0gYTEgKiBjb3MgLSB0aGlzLmIgKiBzaW47XG4gICAgdGhpcy5iID0gYTEgKiBzaW4gKyB0aGlzLmIgKiBjb3M7XG4gICAgdGhpcy5jID0gYzEgKiBjb3MgLSB0aGlzLmQgKiBzaW47XG4gICAgdGhpcy5kID0gYzEgKiBzaW4gKyB0aGlzLmQgKiBjb3M7XG4gICAgdGhpcy50eCA9IHR4MSAqIGNvcyAtIHRoaXMudHkgKiBzaW47XG4gICAgdGhpcy50eSA9IHR4MSAqIHNpbiArIHRoaXMudHkgKiBjb3M7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXBwZW5kKG1hdHJpeCkge1xuICAgIGNvbnN0IGExID0gdGhpcy5hO1xuICAgIGNvbnN0IGIxID0gdGhpcy5iO1xuICAgIGNvbnN0IGMxID0gdGhpcy5jO1xuICAgIGNvbnN0IGQxID0gdGhpcy5kO1xuICAgIHRoaXMuYSA9IG1hdHJpeC5hICogYTEgKyBtYXRyaXguYiAqIGMxO1xuICAgIHRoaXMuYiA9IG1hdHJpeC5hICogYjEgKyBtYXRyaXguYiAqIGQxO1xuICAgIHRoaXMuYyA9IG1hdHJpeC5jICogYTEgKyBtYXRyaXguZCAqIGMxO1xuICAgIHRoaXMuZCA9IG1hdHJpeC5jICogYjEgKyBtYXRyaXguZCAqIGQxO1xuICAgIHRoaXMudHggPSBtYXRyaXgudHggKiBhMSArIG1hdHJpeC50eSAqIGMxICsgdGhpcy50eDtcbiAgICB0aGlzLnR5ID0gbWF0cml4LnR4ICogYjEgKyBtYXRyaXgudHkgKiBkMSArIHRoaXMudHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0VHJhbnNmb3JtKHgsIHksIHBpdm90WCwgcGl2b3RZLCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHNrZXdYLCBza2V3WSkge1xuICAgIHRoaXMuYSA9IE1hdGguY29zKHJvdGF0aW9uICsgc2tld1kpICogc2NhbGVYO1xuICAgIHRoaXMuYiA9IE1hdGguc2luKHJvdGF0aW9uICsgc2tld1kpICogc2NhbGVYO1xuICAgIHRoaXMuYyA9IC1NYXRoLnNpbihyb3RhdGlvbiAtIHNrZXdYKSAqIHNjYWxlWTtcbiAgICB0aGlzLmQgPSBNYXRoLmNvcyhyb3RhdGlvbiAtIHNrZXdYKSAqIHNjYWxlWTtcbiAgICB0aGlzLnR4ID0geCAtIChwaXZvdFggKiB0aGlzLmEgKyBwaXZvdFkgKiB0aGlzLmMpO1xuICAgIHRoaXMudHkgPSB5IC0gKHBpdm90WCAqIHRoaXMuYiArIHBpdm90WSAqIHRoaXMuZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcHJlcGVuZChtYXRyaXgpIHtcbiAgICBjb25zdCB0eDEgPSB0aGlzLnR4O1xuICAgIGlmIChtYXRyaXguYSAhPT0gMSB8fCBtYXRyaXguYiAhPT0gMCB8fCBtYXRyaXguYyAhPT0gMCB8fCBtYXRyaXguZCAhPT0gMSkge1xuICAgICAgY29uc3QgYTEgPSB0aGlzLmE7XG4gICAgICBjb25zdCBjMSA9IHRoaXMuYztcbiAgICAgIHRoaXMuYSA9IGExICogbWF0cml4LmEgKyB0aGlzLmIgKiBtYXRyaXguYztcbiAgICAgIHRoaXMuYiA9IGExICogbWF0cml4LmIgKyB0aGlzLmIgKiBtYXRyaXguZDtcbiAgICAgIHRoaXMuYyA9IGMxICogbWF0cml4LmEgKyB0aGlzLmQgKiBtYXRyaXguYztcbiAgICAgIHRoaXMuZCA9IGMxICogbWF0cml4LmIgKyB0aGlzLmQgKiBtYXRyaXguZDtcbiAgICB9XG4gICAgdGhpcy50eCA9IHR4MSAqIG1hdHJpeC5hICsgdGhpcy50eSAqIG1hdHJpeC5jICsgbWF0cml4LnR4O1xuICAgIHRoaXMudHkgPSB0eDEgKiBtYXRyaXguYiArIHRoaXMudHkgKiBtYXRyaXguZCArIG1hdHJpeC50eTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkZWNvbXBvc2UodHJhbnNmb3JtKSB7XG4gICAgY29uc3QgYSA9IHRoaXMuYTtcbiAgICBjb25zdCBiID0gdGhpcy5iO1xuICAgIGNvbnN0IGMgPSB0aGlzLmM7XG4gICAgY29uc3QgZCA9IHRoaXMuZDtcbiAgICBjb25zdCBwaXZvdCA9IHRyYW5zZm9ybS5waXZvdDtcbiAgICBjb25zdCBza2V3WCA9IC1NYXRoLmF0YW4yKC1jLCBkKTtcbiAgICBjb25zdCBza2V3WSA9IE1hdGguYXRhbjIoYiwgYSk7XG4gICAgY29uc3QgZGVsdGEgPSBNYXRoLmFicyhza2V3WCArIHNrZXdZKTtcbiAgICBpZiAoZGVsdGEgPCAxZS01IHx8IE1hdGguYWJzKF9jb25zdC5QSV8yIC0gZGVsdGEpIDwgMWUtNSkge1xuICAgICAgdHJhbnNmb3JtLnJvdGF0aW9uID0gc2tld1k7XG4gICAgICB0cmFuc2Zvcm0uc2tldy54ID0gdHJhbnNmb3JtLnNrZXcueSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zZm9ybS5yb3RhdGlvbiA9IDA7XG4gICAgICB0cmFuc2Zvcm0uc2tldy54ID0gc2tld1g7XG4gICAgICB0cmFuc2Zvcm0uc2tldy55ID0gc2tld1k7XG4gICAgfVxuICAgIHRyYW5zZm9ybS5zY2FsZS54ID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgIHRyYW5zZm9ybS5zY2FsZS55ID0gTWF0aC5zcXJ0KGMgKiBjICsgZCAqIGQpO1xuICAgIHRyYW5zZm9ybS5wb3NpdGlvbi54ID0gdGhpcy50eCArIChwaXZvdC54ICogYSArIHBpdm90LnkgKiBjKTtcbiAgICB0cmFuc2Zvcm0ucG9zaXRpb24ueSA9IHRoaXMudHkgKyAocGl2b3QueCAqIGIgKyBwaXZvdC55ICogZCk7XG4gICAgcmV0dXJuIHRyYW5zZm9ybTtcbiAgfVxuICBpbnZlcnQoKSB7XG4gICAgY29uc3QgYTEgPSB0aGlzLmE7XG4gICAgY29uc3QgYjEgPSB0aGlzLmI7XG4gICAgY29uc3QgYzEgPSB0aGlzLmM7XG4gICAgY29uc3QgZDEgPSB0aGlzLmQ7XG4gICAgY29uc3QgdHgxID0gdGhpcy50eDtcbiAgICBjb25zdCBuID0gYTEgKiBkMSAtIGIxICogYzE7XG4gICAgdGhpcy5hID0gZDEgLyBuO1xuICAgIHRoaXMuYiA9IC1iMSAvIG47XG4gICAgdGhpcy5jID0gLWMxIC8gbjtcbiAgICB0aGlzLmQgPSBhMSAvIG47XG4gICAgdGhpcy50eCA9IChjMSAqIHRoaXMudHkgLSBkMSAqIHR4MSkgLyBuO1xuICAgIHRoaXMudHkgPSAtKGExICogdGhpcy50eSAtIGIxICogdHgxKSAvIG47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWRlbnRpdHkoKSB7XG4gICAgdGhpcy5hID0gMTtcbiAgICB0aGlzLmIgPSAwO1xuICAgIHRoaXMuYyA9IDA7XG4gICAgdGhpcy5kID0gMTtcbiAgICB0aGlzLnR4ID0gMDtcbiAgICB0aGlzLnR5ID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgbWF0cml4LmEgPSB0aGlzLmE7XG4gICAgbWF0cml4LmIgPSB0aGlzLmI7XG4gICAgbWF0cml4LmMgPSB0aGlzLmM7XG4gICAgbWF0cml4LmQgPSB0aGlzLmQ7XG4gICAgbWF0cml4LnR4ID0gdGhpcy50eDtcbiAgICBtYXRyaXgudHkgPSB0aGlzLnR5O1xuICAgIHJldHVybiBtYXRyaXg7XG4gIH1cbiAgY29weVRvKG1hdHJpeCkge1xuICAgIG1hdHJpeC5hID0gdGhpcy5hO1xuICAgIG1hdHJpeC5iID0gdGhpcy5iO1xuICAgIG1hdHJpeC5jID0gdGhpcy5jO1xuICAgIG1hdHJpeC5kID0gdGhpcy5kO1xuICAgIG1hdHJpeC50eCA9IHRoaXMudHg7XG4gICAgbWF0cml4LnR5ID0gdGhpcy50eTtcbiAgICByZXR1cm4gbWF0cml4O1xuICB9XG4gIGNvcHlGcm9tKG1hdHJpeCkge1xuICAgIHRoaXMuYSA9IG1hdHJpeC5hO1xuICAgIHRoaXMuYiA9IG1hdHJpeC5iO1xuICAgIHRoaXMuYyA9IG1hdHJpeC5jO1xuICAgIHRoaXMuZCA9IG1hdHJpeC5kO1xuICAgIHRoaXMudHggPSBtYXRyaXgudHg7XG4gICAgdGhpcy50eSA9IG1hdHJpeC50eTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtAcGl4aS9tYXRoOk1hdHJpeCBhPSR7dGhpcy5hfSBiPSR7dGhpcy5ifSBjPSR7dGhpcy5jfSBkPSR7dGhpcy5kfSB0eD0ke3RoaXMudHh9IHR5PSR7dGhpcy50eX1dYDtcbiAgfVxuICBzdGF0aWMgZ2V0IElERU5USVRZKCkge1xuICAgIHJldHVybiBuZXcgTWF0cml4KCk7XG4gIH1cbiAgc3RhdGljIGdldCBURU1QX01BVFJJWCgpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeCgpO1xuICB9XG59XG5cbmV4cG9ydHMuTWF0cml4ID0gTWF0cml4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWF0cml4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jbGFzcyBPYnNlcnZhYmxlUG9pbnQge1xuICBjb25zdHJ1Y3RvcihjYiwgc2NvcGUsIHggPSAwLCB5ID0gMCkge1xuICAgIHRoaXMuX3ggPSB4O1xuICAgIHRoaXMuX3kgPSB5O1xuICAgIHRoaXMuY2IgPSBjYjtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gIH1cbiAgY2xvbmUoY2IgPSB0aGlzLmNiLCBzY29wZSA9IHRoaXMuc2NvcGUpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVQb2ludChjYiwgc2NvcGUsIHRoaXMuX3gsIHRoaXMuX3kpO1xuICB9XG4gIHNldCh4ID0gMCwgeSA9IHgpIHtcbiAgICBpZiAodGhpcy5feCAhPT0geCB8fCB0aGlzLl95ICE9PSB5KSB7XG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgdGhpcy5jYi5jYWxsKHRoaXMuc2NvcGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb3B5RnJvbShwKSB7XG4gICAgaWYgKHRoaXMuX3ggIT09IHAueCB8fCB0aGlzLl95ICE9PSBwLnkpIHtcbiAgICAgIHRoaXMuX3ggPSBwLng7XG4gICAgICB0aGlzLl95ID0gcC55O1xuICAgICAgdGhpcy5jYi5jYWxsKHRoaXMuc2NvcGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb3B5VG8ocCkge1xuICAgIHAuc2V0KHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgIHJldHVybiBwO1xuICB9XG4gIGVxdWFscyhwKSB7XG4gICAgcmV0dXJuIHAueCA9PT0gdGhpcy5feCAmJiBwLnkgPT09IHRoaXMuX3k7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbQHBpeGkvbWF0aDpPYnNlcnZhYmxlUG9pbnQgeD0kezB9IHk9JHswfSBzY29wZT0ke3RoaXMuc2NvcGV9XWA7XG4gIH1cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3g7XG4gIH1cbiAgc2V0IHgodmFsdWUpIHtcbiAgICBpZiAodGhpcy5feCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX3ggPSB2YWx1ZTtcbiAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3k7XG4gIH1cbiAgc2V0IHkodmFsdWUpIHtcbiAgICBpZiAodGhpcy5feSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX3kgPSB2YWx1ZTtcbiAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5PYnNlcnZhYmxlUG9pbnQgPSBPYnNlcnZhYmxlUG9pbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZhYmxlUG9pbnQuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNsYXNzIFBvaW50IHtcbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwKSB7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcbiAgfVxuICBjb3B5RnJvbShwKSB7XG4gICAgdGhpcy5zZXQocC54LCBwLnkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNvcHlUbyhwKSB7XG4gICAgcC5zZXQodGhpcy54LCB0aGlzLnkpO1xuICAgIHJldHVybiBwO1xuICB9XG4gIGVxdWFscyhwKSB7XG4gICAgcmV0dXJuIHAueCA9PT0gdGhpcy54ICYmIHAueSA9PT0gdGhpcy55O1xuICB9XG4gIHNldCh4ID0gMCwgeSA9IHgpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbQHBpeGkvbWF0aDpQb2ludCB4PSR7dGhpcy54fSB5PSR7dGhpcy55fV1gO1xuICB9XG59XG5cbmV4cG9ydHMuUG9pbnQgPSBQb2ludDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvaW50LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgTWF0cml4ID0gcmVxdWlyZSgnLi9NYXRyaXguanMnKTtcbnZhciBPYnNlcnZhYmxlUG9pbnQgPSByZXF1aXJlKCcuL09ic2VydmFibGVQb2ludC5qcycpO1xuXG5jb25zdCBfVHJhbnNmb3JtID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtID0gbmV3IE1hdHJpeC5NYXRyaXgoKTtcbiAgICB0aGlzLmxvY2FsVHJhbnNmb3JtID0gbmV3IE1hdHJpeC5NYXRyaXgoKTtcbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IE9ic2VydmFibGVQb2ludC5PYnNlcnZhYmxlUG9pbnQodGhpcy5vbkNoYW5nZSwgdGhpcywgMCwgMCk7XG4gICAgdGhpcy5zY2FsZSA9IG5ldyBPYnNlcnZhYmxlUG9pbnQuT2JzZXJ2YWJsZVBvaW50KHRoaXMub25DaGFuZ2UsIHRoaXMsIDEsIDEpO1xuICAgIHRoaXMucGl2b3QgPSBuZXcgT2JzZXJ2YWJsZVBvaW50Lk9ic2VydmFibGVQb2ludCh0aGlzLm9uQ2hhbmdlLCB0aGlzLCAwLCAwKTtcbiAgICB0aGlzLnNrZXcgPSBuZXcgT2JzZXJ2YWJsZVBvaW50Lk9ic2VydmFibGVQb2ludCh0aGlzLnVwZGF0ZVNrZXcsIHRoaXMsIDAsIDApO1xuICAgIHRoaXMuX3JvdGF0aW9uID0gMDtcbiAgICB0aGlzLl9jeCA9IDE7XG4gICAgdGhpcy5fc3ggPSAwO1xuICAgIHRoaXMuX2N5ID0gMDtcbiAgICB0aGlzLl9zeSA9IDE7XG4gICAgdGhpcy5fbG9jYWxJRCA9IDA7XG4gICAgdGhpcy5fY3VycmVudExvY2FsSUQgPSAwO1xuICAgIHRoaXMuX3dvcmxkSUQgPSAwO1xuICAgIHRoaXMuX3BhcmVudElEID0gMDtcbiAgfVxuICBvbkNoYW5nZSgpIHtcbiAgICB0aGlzLl9sb2NhbElEKys7XG4gIH1cbiAgdXBkYXRlU2tldygpIHtcbiAgICB0aGlzLl9jeCA9IE1hdGguY29zKHRoaXMuX3JvdGF0aW9uICsgdGhpcy5za2V3LnkpO1xuICAgIHRoaXMuX3N4ID0gTWF0aC5zaW4odGhpcy5fcm90YXRpb24gKyB0aGlzLnNrZXcueSk7XG4gICAgdGhpcy5fY3kgPSAtTWF0aC5zaW4odGhpcy5fcm90YXRpb24gLSB0aGlzLnNrZXcueCk7XG4gICAgdGhpcy5fc3kgPSBNYXRoLmNvcyh0aGlzLl9yb3RhdGlvbiAtIHRoaXMuc2tldy54KTtcbiAgICB0aGlzLl9sb2NhbElEKys7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbQHBpeGkvbWF0aDpUcmFuc2Zvcm0gcG9zaXRpb249KCR7dGhpcy5wb3NpdGlvbi54fSwgJHt0aGlzLnBvc2l0aW9uLnl9KSByb3RhdGlvbj0ke3RoaXMucm90YXRpb259IHNjYWxlPSgke3RoaXMuc2NhbGUueH0sICR7dGhpcy5zY2FsZS55fSkgc2tldz0oJHt0aGlzLnNrZXcueH0sICR7dGhpcy5za2V3Lnl9KSBdYDtcbiAgfVxuICB1cGRhdGVMb2NhbFRyYW5zZm9ybSgpIHtcbiAgICBjb25zdCBsdCA9IHRoaXMubG9jYWxUcmFuc2Zvcm07XG4gICAgaWYgKHRoaXMuX2xvY2FsSUQgIT09IHRoaXMuX2N1cnJlbnRMb2NhbElEKSB7XG4gICAgICBsdC5hID0gdGhpcy5fY3ggKiB0aGlzLnNjYWxlLng7XG4gICAgICBsdC5iID0gdGhpcy5fc3ggKiB0aGlzLnNjYWxlLng7XG4gICAgICBsdC5jID0gdGhpcy5fY3kgKiB0aGlzLnNjYWxlLnk7XG4gICAgICBsdC5kID0gdGhpcy5fc3kgKiB0aGlzLnNjYWxlLnk7XG4gICAgICBsdC50eCA9IHRoaXMucG9zaXRpb24ueCAtICh0aGlzLnBpdm90LnggKiBsdC5hICsgdGhpcy5waXZvdC55ICogbHQuYyk7XG4gICAgICBsdC50eSA9IHRoaXMucG9zaXRpb24ueSAtICh0aGlzLnBpdm90LnggKiBsdC5iICsgdGhpcy5waXZvdC55ICogbHQuZCk7XG4gICAgICB0aGlzLl9jdXJyZW50TG9jYWxJRCA9IHRoaXMuX2xvY2FsSUQ7XG4gICAgICB0aGlzLl9wYXJlbnRJRCA9IC0xO1xuICAgIH1cbiAgfVxuICB1cGRhdGVUcmFuc2Zvcm0ocGFyZW50VHJhbnNmb3JtKSB7XG4gICAgY29uc3QgbHQgPSB0aGlzLmxvY2FsVHJhbnNmb3JtO1xuICAgIGlmICh0aGlzLl9sb2NhbElEICE9PSB0aGlzLl9jdXJyZW50TG9jYWxJRCkge1xuICAgICAgbHQuYSA9IHRoaXMuX2N4ICogdGhpcy5zY2FsZS54O1xuICAgICAgbHQuYiA9IHRoaXMuX3N4ICogdGhpcy5zY2FsZS54O1xuICAgICAgbHQuYyA9IHRoaXMuX2N5ICogdGhpcy5zY2FsZS55O1xuICAgICAgbHQuZCA9IHRoaXMuX3N5ICogdGhpcy5zY2FsZS55O1xuICAgICAgbHQudHggPSB0aGlzLnBvc2l0aW9uLnggLSAodGhpcy5waXZvdC54ICogbHQuYSArIHRoaXMucGl2b3QueSAqIGx0LmMpO1xuICAgICAgbHQudHkgPSB0aGlzLnBvc2l0aW9uLnkgLSAodGhpcy5waXZvdC54ICogbHQuYiArIHRoaXMucGl2b3QueSAqIGx0LmQpO1xuICAgICAgdGhpcy5fY3VycmVudExvY2FsSUQgPSB0aGlzLl9sb2NhbElEO1xuICAgICAgdGhpcy5fcGFyZW50SUQgPSAtMTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3BhcmVudElEICE9PSBwYXJlbnRUcmFuc2Zvcm0uX3dvcmxkSUQpIHtcbiAgICAgIGNvbnN0IHB0ID0gcGFyZW50VHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgICAgY29uc3Qgd3QgPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuICAgICAgd3QuYSA9IGx0LmEgKiBwdC5hICsgbHQuYiAqIHB0LmM7XG4gICAgICB3dC5iID0gbHQuYSAqIHB0LmIgKyBsdC5iICogcHQuZDtcbiAgICAgIHd0LmMgPSBsdC5jICogcHQuYSArIGx0LmQgKiBwdC5jO1xuICAgICAgd3QuZCA9IGx0LmMgKiBwdC5iICsgbHQuZCAqIHB0LmQ7XG4gICAgICB3dC50eCA9IGx0LnR4ICogcHQuYSArIGx0LnR5ICogcHQuYyArIHB0LnR4O1xuICAgICAgd3QudHkgPSBsdC50eCAqIHB0LmIgKyBsdC50eSAqIHB0LmQgKyBwdC50eTtcbiAgICAgIHRoaXMuX3BhcmVudElEID0gcGFyZW50VHJhbnNmb3JtLl93b3JsZElEO1xuICAgICAgdGhpcy5fd29ybGRJRCsrO1xuICAgIH1cbiAgfVxuICBzZXRGcm9tTWF0cml4KG1hdHJpeCkge1xuICAgIG1hdHJpeC5kZWNvbXBvc2UodGhpcyk7XG4gICAgdGhpcy5fbG9jYWxJRCsrO1xuICB9XG4gIGdldCByb3RhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcm90YXRpb247XG4gIH1cbiAgc2V0IHJvdGF0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3JvdGF0aW9uICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fcm90YXRpb24gPSB2YWx1ZTtcbiAgICAgIHRoaXMudXBkYXRlU2tldygpO1xuICAgIH1cbiAgfVxufTtcbmxldCBUcmFuc2Zvcm0gPSBfVHJhbnNmb3JtO1xuVHJhbnNmb3JtLklERU5USVRZID0gbmV3IF9UcmFuc2Zvcm0oKTtcblxuZXhwb3J0cy5UcmFuc2Zvcm0gPSBUcmFuc2Zvcm07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmFuc2Zvcm0uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNvbnN0IFBJXzIgPSBNYXRoLlBJICogMjtcbmNvbnN0IFJBRF9UT19ERUcgPSAxODAgLyBNYXRoLlBJO1xuY29uc3QgREVHX1RPX1JBRCA9IE1hdGguUEkgLyAxODA7XG52YXIgU0hBUEVTID0gLyogQF9fUFVSRV9fICovICgoU0hBUEVTMikgPT4ge1xuICBTSEFQRVMyW1NIQVBFUzJbXCJQT0xZXCJdID0gMF0gPSBcIlBPTFlcIjtcbiAgU0hBUEVTMltTSEFQRVMyW1wiUkVDVFwiXSA9IDFdID0gXCJSRUNUXCI7XG4gIFNIQVBFUzJbU0hBUEVTMltcIkNJUkNcIl0gPSAyXSA9IFwiQ0lSQ1wiO1xuICBTSEFQRVMyW1NIQVBFUzJbXCJFTElQXCJdID0gM10gPSBcIkVMSVBcIjtcbiAgU0hBUEVTMltTSEFQRVMyW1wiUlJFQ1wiXSA9IDRdID0gXCJSUkVDXCI7XG4gIHJldHVybiBTSEFQRVMyO1xufSkoU0hBUEVTIHx8IHt9KTtcblxuZXhwb3J0cy5ERUdfVE9fUkFEID0gREVHX1RPX1JBRDtcbmV4cG9ydHMuUElfMiA9IFBJXzI7XG5leHBvcnRzLlJBRF9UT19ERUcgPSBSQURfVE9fREVHO1xuZXhwb3J0cy5TSEFQRVMgPSBTSEFQRVM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIE1hdHJpeCA9IHJlcXVpcmUoJy4vTWF0cml4LmpzJyk7XG5cbmNvbnN0IHV4ID0gWzEsIDEsIDAsIC0xLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIC0xLCAtMSwgLTEsIDAsIDFdO1xuY29uc3QgdXkgPSBbMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMV07XG5jb25zdCB2eCA9IFswLCAtMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xXTtcbmNvbnN0IHZ5ID0gWzEsIDEsIDAsIC0xLCAtMSwgLTEsIDAsIDEsIC0xLCAtMSwgMCwgMSwgMSwgMSwgMCwgLTFdO1xuY29uc3Qgcm90YXRpb25DYXlsZXkgPSBbXTtcbmNvbnN0IHJvdGF0aW9uTWF0cmljZXMgPSBbXTtcbmNvbnN0IHNpZ251bSA9IE1hdGguc2lnbjtcbmZ1bmN0aW9uIGluaXQoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGNvbnN0IHJvdyA9IFtdO1xuICAgIHJvdGF0aW9uQ2F5bGV5LnB1c2gocm93KTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyBqKyspIHtcbiAgICAgIGNvbnN0IF91eCA9IHNpZ251bSh1eFtpXSAqIHV4W2pdICsgdnhbaV0gKiB1eVtqXSk7XG4gICAgICBjb25zdCBfdXkgPSBzaWdudW0odXlbaV0gKiB1eFtqXSArIHZ5W2ldICogdXlbal0pO1xuICAgICAgY29uc3QgX3Z4ID0gc2lnbnVtKHV4W2ldICogdnhbal0gKyB2eFtpXSAqIHZ5W2pdKTtcbiAgICAgIGNvbnN0IF92eSA9IHNpZ251bSh1eVtpXSAqIHZ4W2pdICsgdnlbaV0gKiB2eVtqXSk7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IDE2OyBrKyspIHtcbiAgICAgICAgaWYgKHV4W2tdID09PSBfdXggJiYgdXlba10gPT09IF91eSAmJiB2eFtrXSA9PT0gX3Z4ICYmIHZ5W2tdID09PSBfdnkpIHtcbiAgICAgICAgICByb3cucHVzaChrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBjb25zdCBtYXQgPSBuZXcgTWF0cml4Lk1hdHJpeCgpO1xuICAgIG1hdC5zZXQodXhbaV0sIHV5W2ldLCB2eFtpXSwgdnlbaV0sIDAsIDApO1xuICAgIHJvdGF0aW9uTWF0cmljZXMucHVzaChtYXQpO1xuICB9XG59XG5pbml0KCk7XG5jb25zdCBncm91cEQ4ID0ge1xuICBFOiAwLFxuICBTRTogMSxcbiAgUzogMixcbiAgU1c6IDMsXG4gIFc6IDQsXG4gIE5XOiA1LFxuICBOOiA2LFxuICBORTogNyxcbiAgTUlSUk9SX1ZFUlRJQ0FMOiA4LFxuICBNQUlOX0RJQUdPTkFMOiAxMCxcbiAgTUlSUk9SX0hPUklaT05UQUw6IDEyLFxuICBSRVZFUlNFX0RJQUdPTkFMOiAxNCxcbiAgdVg6IChpbmQpID0+IHV4W2luZF0sXG4gIHVZOiAoaW5kKSA9PiB1eVtpbmRdLFxuICB2WDogKGluZCkgPT4gdnhbaW5kXSxcbiAgdlk6IChpbmQpID0+IHZ5W2luZF0sXG4gIGludjogKHJvdGF0aW9uKSA9PiB7XG4gICAgaWYgKHJvdGF0aW9uICYgOCkge1xuICAgICAgcmV0dXJuIHJvdGF0aW9uICYgMTU7XG4gICAgfVxuICAgIHJldHVybiAtcm90YXRpb24gJiA3O1xuICB9LFxuICBhZGQ6IChyb3RhdGlvblNlY29uZCwgcm90YXRpb25GaXJzdCkgPT4gcm90YXRpb25DYXlsZXlbcm90YXRpb25TZWNvbmRdW3JvdGF0aW9uRmlyc3RdLFxuICBzdWI6IChyb3RhdGlvblNlY29uZCwgcm90YXRpb25GaXJzdCkgPT4gcm90YXRpb25DYXlsZXlbcm90YXRpb25TZWNvbmRdW2dyb3VwRDguaW52KHJvdGF0aW9uRmlyc3QpXSxcbiAgcm90YXRlMTgwOiAocm90YXRpb24pID0+IHJvdGF0aW9uIF4gNCxcbiAgaXNWZXJ0aWNhbDogKHJvdGF0aW9uKSA9PiAocm90YXRpb24gJiAzKSA9PT0gMixcbiAgYnlEaXJlY3Rpb246IChkeCwgZHkpID0+IHtcbiAgICBpZiAoTWF0aC5hYnMoZHgpICogMiA8PSBNYXRoLmFicyhkeSkpIHtcbiAgICAgIGlmIChkeSA+PSAwKSB7XG4gICAgICAgIHJldHVybiBncm91cEQ4LlM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXBEOC5OO1xuICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoZHkpICogMiA8PSBNYXRoLmFicyhkeCkpIHtcbiAgICAgIGlmIChkeCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwRDguRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncm91cEQ4Llc7XG4gICAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICAgIGlmIChkeCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwRDguU0U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXBEOC5TVztcbiAgICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgICAgcmV0dXJuIGdyb3VwRDguTkU7XG4gICAgfVxuICAgIHJldHVybiBncm91cEQ4Lk5XO1xuICB9LFxuICBtYXRyaXhBcHBlbmRSb3RhdGlvbkludjogKG1hdHJpeCwgcm90YXRpb24sIHR4ID0gMCwgdHkgPSAwKSA9PiB7XG4gICAgY29uc3QgbWF0ID0gcm90YXRpb25NYXRyaWNlc1tncm91cEQ4Lmludihyb3RhdGlvbildO1xuICAgIG1hdC50eCA9IHR4O1xuICAgIG1hdC50eSA9IHR5O1xuICAgIG1hdHJpeC5hcHBlbmQobWF0KTtcbiAgfVxufTtcblxuZXhwb3J0cy5ncm91cEQ4ID0gZ3JvdXBEODtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyb3VwRDguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBDaXJjbGUgPSByZXF1aXJlKCcuL3NoYXBlcy9DaXJjbGUuanMnKTtcbnZhciBFbGxpcHNlID0gcmVxdWlyZSgnLi9zaGFwZXMvRWxsaXBzZS5qcycpO1xudmFyIFBvbHlnb24gPSByZXF1aXJlKCcuL3NoYXBlcy9Qb2x5Z29uLmpzJyk7XG52YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9zaGFwZXMvUmVjdGFuZ2xlLmpzJyk7XG52YXIgUm91bmRlZFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4vc2hhcGVzL1JvdW5kZWRSZWN0YW5nbGUuanMnKTtcbnZhciBncm91cEQ4ID0gcmVxdWlyZSgnLi9ncm91cEQ4LmpzJyk7XG5yZXF1aXJlKCcuL0lQb2ludC5qcycpO1xucmVxdWlyZSgnLi9JUG9pbnREYXRhLmpzJyk7XG52YXIgTWF0cml4ID0gcmVxdWlyZSgnLi9NYXRyaXguanMnKTtcbnZhciBPYnNlcnZhYmxlUG9pbnQgPSByZXF1aXJlKCcuL09ic2VydmFibGVQb2ludC5qcycpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9Qb2ludC5qcycpO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtLmpzJyk7XG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi9jb25zdC5qcycpO1xuXG5cblxuZXhwb3J0cy5DaXJjbGUgPSBDaXJjbGUuQ2lyY2xlO1xuZXhwb3J0cy5FbGxpcHNlID0gRWxsaXBzZS5FbGxpcHNlO1xuZXhwb3J0cy5Qb2x5Z29uID0gUG9seWdvbi5Qb2x5Z29uO1xuZXhwb3J0cy5SZWN0YW5nbGUgPSBSZWN0YW5nbGUuUmVjdGFuZ2xlO1xuZXhwb3J0cy5Sb3VuZGVkUmVjdGFuZ2xlID0gUm91bmRlZFJlY3RhbmdsZS5Sb3VuZGVkUmVjdGFuZ2xlO1xuZXhwb3J0cy5ncm91cEQ4ID0gZ3JvdXBEOC5ncm91cEQ4O1xuZXhwb3J0cy5NYXRyaXggPSBNYXRyaXguTWF0cml4O1xuZXhwb3J0cy5PYnNlcnZhYmxlUG9pbnQgPSBPYnNlcnZhYmxlUG9pbnQuT2JzZXJ2YWJsZVBvaW50O1xuZXhwb3J0cy5Qb2ludCA9IFBvaW50LlBvaW50O1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSBUcmFuc2Zvcm0uVHJhbnNmb3JtO1xuZXhwb3J0cy5ERUdfVE9fUkFEID0gX2NvbnN0LkRFR19UT19SQUQ7XG5leHBvcnRzLlBJXzIgPSBfY29uc3QuUElfMjtcbmV4cG9ydHMuUkFEX1RPX0RFRyA9IF9jb25zdC5SQURfVE9fREVHO1xuZXhwb3J0cy5TSEFQRVMgPSBfY29uc3QuU0hBUEVTO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuLi9jb25zdC5qcycpO1xudmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4vUmVjdGFuZ2xlLmpzJyk7XG5cbmNsYXNzIENpcmNsZSB7XG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgcmFkaXVzID0gMCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgICB0aGlzLnR5cGUgPSBfY29uc3QuU0hBUEVTLkNJUkM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBDaXJjbGUodGhpcy54LCB0aGlzLnksIHRoaXMucmFkaXVzKTtcbiAgfVxuICBjb250YWlucyh4LCB5KSB7XG4gICAgaWYgKHRoaXMucmFkaXVzIDw9IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcjIgPSB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xuICAgIGxldCBkeCA9IHRoaXMueCAtIHg7XG4gICAgbGV0IGR5ID0gdGhpcy55IC0geTtcbiAgICBkeCAqPSBkeDtcbiAgICBkeSAqPSBkeTtcbiAgICByZXR1cm4gZHggKyBkeSA8PSByMjtcbiAgfVxuICBnZXRCb3VuZHMoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUuUmVjdGFuZ2xlKHRoaXMueCAtIHRoaXMucmFkaXVzLCB0aGlzLnkgLSB0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMgKiAyLCB0aGlzLnJhZGl1cyAqIDIpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgW0BwaXhpL21hdGg6Q2lyY2xlIHg9JHt0aGlzLnh9IHk9JHt0aGlzLnl9IHJhZGl1cz0ke3RoaXMucmFkaXVzfV1gO1xuICB9XG59XG5cbmV4cG9ydHMuQ2lyY2xlID0gQ2lyY2xlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2lyY2xlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QuanMnKTtcbnZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuL1JlY3RhbmdsZS5qcycpO1xuXG5jbGFzcyBFbGxpcHNlIHtcbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCBoYWxmV2lkdGggPSAwLCBoYWxmSGVpZ2h0ID0gMCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLndpZHRoID0gaGFsZldpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGFsZkhlaWdodDtcbiAgICB0aGlzLnR5cGUgPSBfY29uc3QuU0hBUEVTLkVMSVA7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBFbGxpcHNlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gIH1cbiAgY29udGFpbnMoeCwgeSkge1xuICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgbm9ybXggPSAoeCAtIHRoaXMueCkgLyB0aGlzLndpZHRoO1xuICAgIGxldCBub3JteSA9ICh5IC0gdGhpcy55KSAvIHRoaXMuaGVpZ2h0O1xuICAgIG5vcm14ICo9IG5vcm14O1xuICAgIG5vcm15ICo9IG5vcm15O1xuICAgIHJldHVybiBub3JteCArIG5vcm15IDw9IDE7XG4gIH1cbiAgZ2V0Qm91bmRzKCkge1xuICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlLlJlY3RhbmdsZSh0aGlzLnggLSB0aGlzLndpZHRoLCB0aGlzLnkgLSB0aGlzLmhlaWdodCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgW0BwaXhpL21hdGg6RWxsaXBzZSB4PSR7dGhpcy54fSB5PSR7dGhpcy55fSB3aWR0aD0ke3RoaXMud2lkdGh9IGhlaWdodD0ke3RoaXMuaGVpZ2h0fV1gO1xuICB9XG59XG5cbmV4cG9ydHMuRWxsaXBzZSA9IEVsbGlwc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbGxpcHNlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QuanMnKTtcblxuY2xhc3MgUG9seWdvbiB7XG4gIGNvbnN0cnVjdG9yKC4uLnBvaW50cykge1xuICAgIGxldCBmbGF0ID0gQXJyYXkuaXNBcnJheShwb2ludHNbMF0pID8gcG9pbnRzWzBdIDogcG9pbnRzO1xuICAgIGlmICh0eXBlb2YgZmxhdFswXSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3QgcCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gZmxhdC5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIHAucHVzaChmbGF0W2ldLngsIGZsYXRbaV0ueSk7XG4gICAgICB9XG4gICAgICBmbGF0ID0gcDtcbiAgICB9XG4gICAgdGhpcy5wb2ludHMgPSBmbGF0O1xuICAgIHRoaXMudHlwZSA9IF9jb25zdC5TSEFQRVMuUE9MWTtcbiAgICB0aGlzLmNsb3NlU3Ryb2tlID0gdHJ1ZTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cy5zbGljZSgpO1xuICAgIGNvbnN0IHBvbHlnb24gPSBuZXcgUG9seWdvbihwb2ludHMpO1xuICAgIHBvbHlnb24uY2xvc2VTdHJva2UgPSB0aGlzLmNsb3NlU3Ryb2tlO1xuICAgIHJldHVybiBwb2x5Z29uO1xuICB9XG4gIGNvbnRhaW5zKHgsIHkpIHtcbiAgICBsZXQgaW5zaWRlID0gZmFsc2U7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IGxlbmd0aCAtIDE7IGkgPCBsZW5ndGg7IGogPSBpKyspIHtcbiAgICAgIGNvbnN0IHhpID0gdGhpcy5wb2ludHNbaSAqIDJdO1xuICAgICAgY29uc3QgeWkgPSB0aGlzLnBvaW50c1tpICogMiArIDFdO1xuICAgICAgY29uc3QgeGogPSB0aGlzLnBvaW50c1tqICogMl07XG4gICAgICBjb25zdCB5aiA9IHRoaXMucG9pbnRzW2ogKiAyICsgMV07XG4gICAgICBjb25zdCBpbnRlcnNlY3QgPSB5aSA+IHkgIT09IHlqID4geSAmJiB4IDwgKHhqIC0geGkpICogKCh5IC0geWkpIC8gKHlqIC0geWkpKSArIHhpO1xuICAgICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zaWRlO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgW0BwaXhpL21hdGg6UG9seWdvbmNsb3NlU3Ryb2tlPSR7dGhpcy5jbG9zZVN0cm9rZX1wb2ludHM9JHt0aGlzLnBvaW50cy5yZWR1Y2UoKHBvaW50c0Rlc2MsIGN1cnJlbnRQb2ludCkgPT4gYCR7cG9pbnRzRGVzY30sICR7Y3VycmVudFBvaW50fWAsIFwiXCIpfV1gO1xuICB9XG59XG5cbmV4cG9ydHMuUG9seWdvbiA9IFBvbHlnb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2x5Z29uLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QuanMnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4uL1BvaW50LmpzJyk7XG5cbmNvbnN0IHRlbXBQb2ludHMgPSBbbmV3IFBvaW50LlBvaW50KCksIG5ldyBQb2ludC5Qb2ludCgpLCBuZXcgUG9pbnQuUG9pbnQoKSwgbmV3IFBvaW50LlBvaW50KCldO1xuY2xhc3MgUmVjdGFuZ2xlIHtcbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB3aWR0aCA9IDAsIGhlaWdodCA9IDApIHtcbiAgICB0aGlzLnggPSBOdW1iZXIoeCk7XG4gICAgdGhpcy55ID0gTnVtYmVyKHkpO1xuICAgIHRoaXMud2lkdGggPSBOdW1iZXIod2lkdGgpO1xuICAgIHRoaXMuaGVpZ2h0ID0gTnVtYmVyKGhlaWdodCk7XG4gICAgdGhpcy50eXBlID0gX2NvbnN0LlNIQVBFUy5SRUNUO1xuICB9XG4gIGdldCBsZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLng7XG4gIH1cbiAgZ2V0IHJpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xuICB9XG4gIGdldCB0b3AoKSB7XG4gICAgcmV0dXJuIHRoaXMueTtcbiAgfVxuICBnZXQgYm90dG9tKCkge1xuICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbiAgfVxuICBzdGF0aWMgZ2V0IEVNUFRZKCkge1xuICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKDAsIDAsIDAsIDApO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gIH1cbiAgY29weUZyb20ocmVjdGFuZ2xlKSB7XG4gICAgdGhpcy54ID0gcmVjdGFuZ2xlLng7XG4gICAgdGhpcy55ID0gcmVjdGFuZ2xlLnk7XG4gICAgdGhpcy53aWR0aCA9IHJlY3RhbmdsZS53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHJlY3RhbmdsZS5oZWlnaHQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY29weVRvKHJlY3RhbmdsZSkge1xuICAgIHJlY3RhbmdsZS54ID0gdGhpcy54O1xuICAgIHJlY3RhbmdsZS55ID0gdGhpcy55O1xuICAgIHJlY3RhbmdsZS53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgcmVjdGFuZ2xlLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIHJldHVybiByZWN0YW5nbGU7XG4gIH1cbiAgY29udGFpbnMoeCwgeSkge1xuICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoeCA+PSB0aGlzLnggJiYgeCA8IHRoaXMueCArIHRoaXMud2lkdGgpIHtcbiAgICAgIGlmICh5ID49IHRoaXMueSAmJiB5IDwgdGhpcy55ICsgdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpbnRlcnNlY3RzKG90aGVyLCB0cmFuc2Zvcm0pIHtcbiAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgY29uc3QgeDAyID0gdGhpcy54IDwgb3RoZXIueCA/IG90aGVyLnggOiB0aGlzLng7XG4gICAgICBjb25zdCB4MTIgPSB0aGlzLnJpZ2h0ID4gb3RoZXIucmlnaHQgPyBvdGhlci5yaWdodCA6IHRoaXMucmlnaHQ7XG4gICAgICBpZiAoeDEyIDw9IHgwMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCB5MDIgPSB0aGlzLnkgPCBvdGhlci55ID8gb3RoZXIueSA6IHRoaXMueTtcbiAgICAgIGNvbnN0IHkxMiA9IHRoaXMuYm90dG9tID4gb3RoZXIuYm90dG9tID8gb3RoZXIuYm90dG9tIDogdGhpcy5ib3R0b207XG4gICAgICByZXR1cm4geTEyID4geTAyO1xuICAgIH1cbiAgICBjb25zdCB4MCA9IHRoaXMubGVmdDtcbiAgICBjb25zdCB4MSA9IHRoaXMucmlnaHQ7XG4gICAgY29uc3QgeTAgPSB0aGlzLnRvcDtcbiAgICBjb25zdCB5MSA9IHRoaXMuYm90dG9tO1xuICAgIGlmICh4MSA8PSB4MCB8fCB5MSA8PSB5MCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBsdCA9IHRlbXBQb2ludHNbMF0uc2V0KG90aGVyLmxlZnQsIG90aGVyLnRvcCk7XG4gICAgY29uc3QgbGIgPSB0ZW1wUG9pbnRzWzFdLnNldChvdGhlci5sZWZ0LCBvdGhlci5ib3R0b20pO1xuICAgIGNvbnN0IHJ0ID0gdGVtcFBvaW50c1syXS5zZXQob3RoZXIucmlnaHQsIG90aGVyLnRvcCk7XG4gICAgY29uc3QgcmIgPSB0ZW1wUG9pbnRzWzNdLnNldChvdGhlci5yaWdodCwgb3RoZXIuYm90dG9tKTtcbiAgICBpZiAocnQueCA8PSBsdC54IHx8IGxiLnkgPD0gbHQueSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzID0gTWF0aC5zaWduKHRyYW5zZm9ybS5hICogdHJhbnNmb3JtLmQgLSB0cmFuc2Zvcm0uYiAqIHRyYW5zZm9ybS5jKTtcbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cmFuc2Zvcm0uYXBwbHkobHQsIGx0KTtcbiAgICB0cmFuc2Zvcm0uYXBwbHkobGIsIGxiKTtcbiAgICB0cmFuc2Zvcm0uYXBwbHkocnQsIHJ0KTtcbiAgICB0cmFuc2Zvcm0uYXBwbHkocmIsIHJiKTtcbiAgICBpZiAoTWF0aC5tYXgobHQueCwgbGIueCwgcnQueCwgcmIueCkgPD0geDAgfHwgTWF0aC5taW4obHQueCwgbGIueCwgcnQueCwgcmIueCkgPj0geDEgfHwgTWF0aC5tYXgobHQueSwgbGIueSwgcnQueSwgcmIueSkgPD0geTAgfHwgTWF0aC5taW4obHQueSwgbGIueSwgcnQueSwgcmIueSkgPj0geTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbnggPSBzICogKGxiLnkgLSBsdC55KTtcbiAgICBjb25zdCBueSA9IHMgKiAobHQueCAtIGxiLngpO1xuICAgIGNvbnN0IG4wMCA9IG54ICogeDAgKyBueSAqIHkwO1xuICAgIGNvbnN0IG4xMCA9IG54ICogeDEgKyBueSAqIHkwO1xuICAgIGNvbnN0IG4wMSA9IG54ICogeDAgKyBueSAqIHkxO1xuICAgIGNvbnN0IG4xMSA9IG54ICogeDEgKyBueSAqIHkxO1xuICAgIGlmIChNYXRoLm1heChuMDAsIG4xMCwgbjAxLCBuMTEpIDw9IG54ICogbHQueCArIG55ICogbHQueSB8fCBNYXRoLm1pbihuMDAsIG4xMCwgbjAxLCBuMTEpID49IG54ICogcmIueCArIG55ICogcmIueSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBteCA9IHMgKiAobHQueSAtIHJ0LnkpO1xuICAgIGNvbnN0IG15ID0gcyAqIChydC54IC0gbHQueCk7XG4gICAgY29uc3QgbTAwID0gbXggKiB4MCArIG15ICogeTA7XG4gICAgY29uc3QgbTEwID0gbXggKiB4MSArIG15ICogeTA7XG4gICAgY29uc3QgbTAxID0gbXggKiB4MCArIG15ICogeTE7XG4gICAgY29uc3QgbTExID0gbXggKiB4MSArIG15ICogeTE7XG4gICAgaWYgKE1hdGgubWF4KG0wMCwgbTEwLCBtMDEsIG0xMSkgPD0gbXggKiBsdC54ICsgbXkgKiBsdC55IHx8IE1hdGgubWluKG0wMCwgbTEwLCBtMDEsIG0xMSkgPj0gbXggKiByYi54ICsgbXkgKiByYi55KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHBhZChwYWRkaW5nWCA9IDAsIHBhZGRpbmdZID0gcGFkZGluZ1gpIHtcbiAgICB0aGlzLnggLT0gcGFkZGluZ1g7XG4gICAgdGhpcy55IC09IHBhZGRpbmdZO1xuICAgIHRoaXMud2lkdGggKz0gcGFkZGluZ1ggKiAyO1xuICAgIHRoaXMuaGVpZ2h0ICs9IHBhZGRpbmdZICogMjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmaXQocmVjdGFuZ2xlKSB7XG4gICAgY29uc3QgeDEgPSBNYXRoLm1heCh0aGlzLngsIHJlY3RhbmdsZS54KTtcbiAgICBjb25zdCB4MiA9IE1hdGgubWluKHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3RhbmdsZS54ICsgcmVjdGFuZ2xlLndpZHRoKTtcbiAgICBjb25zdCB5MSA9IE1hdGgubWF4KHRoaXMueSwgcmVjdGFuZ2xlLnkpO1xuICAgIGNvbnN0IHkyID0gTWF0aC5taW4odGhpcy55ICsgdGhpcy5oZWlnaHQsIHJlY3RhbmdsZS55ICsgcmVjdGFuZ2xlLmhlaWdodCk7XG4gICAgdGhpcy54ID0geDE7XG4gICAgdGhpcy53aWR0aCA9IE1hdGgubWF4KHgyIC0geDEsIDApO1xuICAgIHRoaXMueSA9IHkxO1xuICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgoeTIgLSB5MSwgMCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2VpbChyZXNvbHV0aW9uID0gMSwgZXBzID0gMWUtMykge1xuICAgIGNvbnN0IHgyID0gTWF0aC5jZWlsKCh0aGlzLnggKyB0aGlzLndpZHRoIC0gZXBzKSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICBjb25zdCB5MiA9IE1hdGguY2VpbCgodGhpcy55ICsgdGhpcy5oZWlnaHQgLSBlcHMpICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuICAgIHRoaXMueCA9IE1hdGguZmxvb3IoKHRoaXMueCArIGVwcykgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG4gICAgdGhpcy55ID0gTWF0aC5mbG9vcigodGhpcy55ICsgZXBzKSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICB0aGlzLndpZHRoID0geDIgLSB0aGlzLng7XG4gICAgdGhpcy5oZWlnaHQgPSB5MiAtIHRoaXMueTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBlbmxhcmdlKHJlY3RhbmdsZSkge1xuICAgIGNvbnN0IHgxID0gTWF0aC5taW4odGhpcy54LCByZWN0YW5nbGUueCk7XG4gICAgY29uc3QgeDIgPSBNYXRoLm1heCh0aGlzLnggKyB0aGlzLndpZHRoLCByZWN0YW5nbGUueCArIHJlY3RhbmdsZS53aWR0aCk7XG4gICAgY29uc3QgeTEgPSBNYXRoLm1pbih0aGlzLnksIHJlY3RhbmdsZS55KTtcbiAgICBjb25zdCB5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0YW5nbGUueSArIHJlY3RhbmdsZS5oZWlnaHQpO1xuICAgIHRoaXMueCA9IHgxO1xuICAgIHRoaXMud2lkdGggPSB4MiAtIHgxO1xuICAgIHRoaXMueSA9IHkxO1xuICAgIHRoaXMuaGVpZ2h0ID0geTIgLSB5MTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtAcGl4aS9tYXRoOlJlY3RhbmdsZSB4PSR7dGhpcy54fSB5PSR7dGhpcy55fSB3aWR0aD0ke3RoaXMud2lkdGh9IGhlaWdodD0ke3RoaXMuaGVpZ2h0fV1gO1xuICB9XG59XG5cbmV4cG9ydHMuUmVjdGFuZ2xlID0gUmVjdGFuZ2xlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVjdGFuZ2xlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QuanMnKTtcblxuY2xhc3MgUm91bmRlZFJlY3RhbmdsZSB7XG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgd2lkdGggPSAwLCBoZWlnaHQgPSAwLCByYWRpdXMgPSAyMCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgdGhpcy50eXBlID0gX2NvbnN0LlNIQVBFUy5SUkVDO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUm91bmRlZFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMucmFkaXVzKTtcbiAgfVxuICBjb250YWlucyh4LCB5KSB7XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh4ID49IHRoaXMueCAmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGgpIHtcbiAgICAgIGlmICh5ID49IHRoaXMueSAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMucmFkaXVzLCBNYXRoLm1pbih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkgLyAyKSk7XG4gICAgICAgIGlmICh5ID49IHRoaXMueSArIHJhZGl1cyAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0IC0gcmFkaXVzIHx8IHggPj0gdGhpcy54ICsgcmFkaXVzICYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aCAtIHJhZGl1cykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkeCA9IHggLSAodGhpcy54ICsgcmFkaXVzKTtcbiAgICAgICAgbGV0IGR5ID0geSAtICh0aGlzLnkgKyByYWRpdXMpO1xuICAgICAgICBjb25zdCByYWRpdXMyID0gcmFkaXVzICogcmFkaXVzO1xuICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGR4ID0geCAtICh0aGlzLnggKyB0aGlzLndpZHRoIC0gcmFkaXVzKTtcbiAgICAgICAgaWYgKGR4ICogZHggKyBkeSAqIGR5IDw9IHJhZGl1czIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBkeSA9IHkgLSAodGhpcy55ICsgdGhpcy5oZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGR4ID0geCAtICh0aGlzLnggKyByYWRpdXMpO1xuICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtAcGl4aS9tYXRoOlJvdW5kZWRSZWN0YW5nbGUgeD0ke3RoaXMueH0geT0ke3RoaXMueX13aWR0aD0ke3RoaXMud2lkdGh9IGhlaWdodD0ke3RoaXMuaGVpZ2h0fSByYWRpdXM9JHt0aGlzLnJhZGl1c31dYDtcbiAgfVxufVxuXG5leHBvcnRzLlJvdW5kZWRSZWN0YW5nbGUgPSBSb3VuZGVkUmVjdGFuZ2xlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Um91bmRlZFJlY3RhbmdsZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgU2ltcGxlUGxhbmUgPSByZXF1aXJlKCcuL1NpbXBsZVBsYW5lLmpzJyk7XG5cbmNvbnN0IERFRkFVTFRfQk9SREVSX1NJWkUgPSAxMDtcbmNsYXNzIE5pbmVTbGljZVBsYW5lIGV4dGVuZHMgU2ltcGxlUGxhbmUuU2ltcGxlUGxhbmUge1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlLCBsZWZ0V2lkdGgsIHRvcEhlaWdodCwgcmlnaHRXaWR0aCwgYm90dG9tSGVpZ2h0KSB7XG4gICAgc3VwZXIoY29yZS5UZXh0dXJlLldISVRFLCA0LCA0KTtcbiAgICB0aGlzLl9vcmlnV2lkdGggPSB0ZXh0dXJlLm9yaWcud2lkdGg7XG4gICAgdGhpcy5fb3JpZ0hlaWdodCA9IHRleHR1cmUub3JpZy5oZWlnaHQ7XG4gICAgdGhpcy5fd2lkdGggPSB0aGlzLl9vcmlnV2lkdGg7XG4gICAgdGhpcy5faGVpZ2h0ID0gdGhpcy5fb3JpZ0hlaWdodDtcbiAgICB0aGlzLl9sZWZ0V2lkdGggPSBsZWZ0V2lkdGggPz8gdGV4dHVyZS5kZWZhdWx0Qm9yZGVycz8ubGVmdCA/PyBERUZBVUxUX0JPUkRFUl9TSVpFO1xuICAgIHRoaXMuX3JpZ2h0V2lkdGggPSByaWdodFdpZHRoID8/IHRleHR1cmUuZGVmYXVsdEJvcmRlcnM/LnJpZ2h0ID8/IERFRkFVTFRfQk9SREVSX1NJWkU7XG4gICAgdGhpcy5fdG9wSGVpZ2h0ID0gdG9wSGVpZ2h0ID8/IHRleHR1cmUuZGVmYXVsdEJvcmRlcnM/LnRvcCA/PyBERUZBVUxUX0JPUkRFUl9TSVpFO1xuICAgIHRoaXMuX2JvdHRvbUhlaWdodCA9IGJvdHRvbUhlaWdodCA/PyB0ZXh0dXJlLmRlZmF1bHRCb3JkZXJzPy5ib3R0b20gPz8gREVGQVVMVF9CT1JERVJfU0laRTtcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuICB9XG4gIHRleHR1cmVVcGRhdGVkKCkge1xuICAgIHRoaXMuX3RleHR1cmVJRCA9IHRoaXMuc2hhZGVyLnRleHR1cmUuX3VwZGF0ZUlEO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICBnZXQgdmVydGljZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuZ2V0QnVmZmVyKFwiYVZlcnRleFBvc2l0aW9uXCIpLmRhdGE7XG4gIH1cbiAgc2V0IHZlcnRpY2VzKHZhbHVlKSB7XG4gICAgdGhpcy5nZW9tZXRyeS5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIikuZGF0YSA9IHZhbHVlO1xuICB9XG4gIHVwZGF0ZUhvcml6b250YWxWZXJ0aWNlcygpIHtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9nZXRNaW5TY2FsZSgpO1xuICAgIHZlcnRpY2VzWzldID0gdmVydGljZXNbMTFdID0gdmVydGljZXNbMTNdID0gdmVydGljZXNbMTVdID0gdGhpcy5fdG9wSGVpZ2h0ICogc2NhbGU7XG4gICAgdmVydGljZXNbMTddID0gdmVydGljZXNbMTldID0gdmVydGljZXNbMjFdID0gdmVydGljZXNbMjNdID0gdGhpcy5faGVpZ2h0IC0gdGhpcy5fYm90dG9tSGVpZ2h0ICogc2NhbGU7XG4gICAgdmVydGljZXNbMjVdID0gdmVydGljZXNbMjddID0gdmVydGljZXNbMjldID0gdmVydGljZXNbMzFdID0gdGhpcy5faGVpZ2h0O1xuICB9XG4gIHVwZGF0ZVZlcnRpY2FsVmVydGljZXMoKSB7XG4gICAgY29uc3QgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fZ2V0TWluU2NhbGUoKTtcbiAgICB2ZXJ0aWNlc1syXSA9IHZlcnRpY2VzWzEwXSA9IHZlcnRpY2VzWzE4XSA9IHZlcnRpY2VzWzI2XSA9IHRoaXMuX2xlZnRXaWR0aCAqIHNjYWxlO1xuICAgIHZlcnRpY2VzWzRdID0gdmVydGljZXNbMTJdID0gdmVydGljZXNbMjBdID0gdmVydGljZXNbMjhdID0gdGhpcy5fd2lkdGggLSB0aGlzLl9yaWdodFdpZHRoICogc2NhbGU7XG4gICAgdmVydGljZXNbNl0gPSB2ZXJ0aWNlc1sxNF0gPSB2ZXJ0aWNlc1syMl0gPSB2ZXJ0aWNlc1szMF0gPSB0aGlzLl93aWR0aDtcbiAgfVxuICBfZ2V0TWluU2NhbGUoKSB7XG4gICAgY29uc3QgdyA9IHRoaXMuX2xlZnRXaWR0aCArIHRoaXMuX3JpZ2h0V2lkdGg7XG4gICAgY29uc3Qgc2NhbGVXID0gdGhpcy5fd2lkdGggPiB3ID8gMSA6IHRoaXMuX3dpZHRoIC8gdztcbiAgICBjb25zdCBoID0gdGhpcy5fdG9wSGVpZ2h0ICsgdGhpcy5fYm90dG9tSGVpZ2h0O1xuICAgIGNvbnN0IHNjYWxlSCA9IHRoaXMuX2hlaWdodCA+IGggPyAxIDogdGhpcy5faGVpZ2h0IC8gaDtcbiAgICBjb25zdCBzY2FsZSA9IE1hdGgubWluKHNjYWxlVywgc2NhbGVIKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICBnZXQgbGVmdFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9sZWZ0V2lkdGg7XG4gIH1cbiAgc2V0IGxlZnRXaWR0aCh2YWx1ZSkge1xuICAgIHRoaXMuX2xlZnRXaWR0aCA9IHZhbHVlO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICBnZXQgcmlnaHRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmlnaHRXaWR0aDtcbiAgfVxuICBzZXQgcmlnaHRXaWR0aCh2YWx1ZSkge1xuICAgIHRoaXMuX3JpZ2h0V2lkdGggPSB2YWx1ZTtcbiAgICB0aGlzLl9yZWZyZXNoKCk7XG4gIH1cbiAgZ2V0IHRvcEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdG9wSGVpZ2h0O1xuICB9XG4gIHNldCB0b3BIZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLl90b3BIZWlnaHQgPSB2YWx1ZTtcbiAgICB0aGlzLl9yZWZyZXNoKCk7XG4gIH1cbiAgZ2V0IGJvdHRvbUhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYm90dG9tSGVpZ2h0O1xuICB9XG4gIHNldCBib3R0b21IZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLl9ib3R0b21IZWlnaHQgPSB2YWx1ZTtcbiAgICB0aGlzLl9yZWZyZXNoKCk7XG4gIH1cbiAgX3JlZnJlc2goKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IHRoaXMudGV4dHVyZTtcbiAgICBjb25zdCB1dnMgPSB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMV0uZGF0YTtcbiAgICB0aGlzLl9vcmlnV2lkdGggPSB0ZXh0dXJlLm9yaWcud2lkdGg7XG4gICAgdGhpcy5fb3JpZ0hlaWdodCA9IHRleHR1cmUub3JpZy5oZWlnaHQ7XG4gICAgY29uc3QgX3V2dyA9IDEgLyB0aGlzLl9vcmlnV2lkdGg7XG4gICAgY29uc3QgX3V2aCA9IDEgLyB0aGlzLl9vcmlnSGVpZ2h0O1xuICAgIHV2c1swXSA9IHV2c1s4XSA9IHV2c1sxNl0gPSB1dnNbMjRdID0gMDtcbiAgICB1dnNbMV0gPSB1dnNbM10gPSB1dnNbNV0gPSB1dnNbN10gPSAwO1xuICAgIHV2c1s2XSA9IHV2c1sxNF0gPSB1dnNbMjJdID0gdXZzWzMwXSA9IDE7XG4gICAgdXZzWzI1XSA9IHV2c1syN10gPSB1dnNbMjldID0gdXZzWzMxXSA9IDE7XG4gICAgdXZzWzJdID0gdXZzWzEwXSA9IHV2c1sxOF0gPSB1dnNbMjZdID0gX3V2dyAqIHRoaXMuX2xlZnRXaWR0aDtcbiAgICB1dnNbNF0gPSB1dnNbMTJdID0gdXZzWzIwXSA9IHV2c1syOF0gPSAxIC0gX3V2dyAqIHRoaXMuX3JpZ2h0V2lkdGg7XG4gICAgdXZzWzldID0gdXZzWzExXSA9IHV2c1sxM10gPSB1dnNbMTVdID0gX3V2aCAqIHRoaXMuX3RvcEhlaWdodDtcbiAgICB1dnNbMTddID0gdXZzWzE5XSA9IHV2c1syMV0gPSB1dnNbMjNdID0gMSAtIF91dmggKiB0aGlzLl9ib3R0b21IZWlnaHQ7XG4gICAgdGhpcy51cGRhdGVIb3Jpem9udGFsVmVydGljZXMoKTtcbiAgICB0aGlzLnVwZGF0ZVZlcnRpY2FsVmVydGljZXMoKTtcbiAgICB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMF0udXBkYXRlKCk7XG4gICAgdGhpcy5nZW9tZXRyeS5idWZmZXJzWzFdLnVwZGF0ZSgpO1xuICB9XG59XG5cbmV4cG9ydHMuTmluZVNsaWNlUGxhbmUgPSBOaW5lU2xpY2VQbGFuZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5pbmVTbGljZVBsYW5lLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBtZXNoID0gcmVxdWlyZSgnQHBpeGkvbWVzaCcpO1xuXG5jbGFzcyBTaW1wbGVNZXNoIGV4dGVuZHMgbWVzaC5NZXNoIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZSA9IGNvcmUuVGV4dHVyZS5FTVBUWSwgdmVydGljZXMsIHV2cywgaW5kaWNlcywgZHJhd01vZGUpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBtZXNoLk1lc2hHZW9tZXRyeSh2ZXJ0aWNlcywgdXZzLCBpbmRpY2VzKTtcbiAgICBnZW9tZXRyeS5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIikuc3RhdGljID0gZmFsc2U7XG4gICAgY29uc3QgbWVzaE1hdGVyaWFsID0gbmV3IG1lc2guTWVzaE1hdGVyaWFsKHRleHR1cmUpO1xuICAgIHN1cGVyKGdlb21ldHJ5LCBtZXNoTWF0ZXJpYWwsIG51bGwsIGRyYXdNb2RlKTtcbiAgICB0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xuICB9XG4gIGdldCB2ZXJ0aWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIikuZGF0YTtcbiAgfVxuICBzZXQgdmVydGljZXModmFsdWUpIHtcbiAgICB0aGlzLmdlb21ldHJ5LmdldEJ1ZmZlcihcImFWZXJ0ZXhQb3NpdGlvblwiKS5kYXRhID0gdmFsdWU7XG4gIH1cbiAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgIGlmICh0aGlzLmF1dG9VcGRhdGUpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuZ2V0QnVmZmVyKFwiYVZlcnRleFBvc2l0aW9uXCIpLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBzdXBlci5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxufVxuXG5leHBvcnRzLlNpbXBsZU1lc2ggPSBTaW1wbGVNZXNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2ltcGxlTWVzaC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgbWVzaCA9IHJlcXVpcmUoJ0BwaXhpL21lc2gnKTtcbnZhciBQbGFuZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi9nZW9tZXRyeS9QbGFuZUdlb21ldHJ5LmpzJyk7XG5cbmNsYXNzIFNpbXBsZVBsYW5lIGV4dGVuZHMgbWVzaC5NZXNoIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZSwgdmVydGljZXNYLCB2ZXJ0aWNlc1kpIHtcbiAgICBjb25zdCBwbGFuZUdlb21ldHJ5ID0gbmV3IFBsYW5lR2VvbWV0cnkuUGxhbmVHZW9tZXRyeSh0ZXh0dXJlLndpZHRoLCB0ZXh0dXJlLmhlaWdodCwgdmVydGljZXNYLCB2ZXJ0aWNlc1kpO1xuICAgIGNvbnN0IG1lc2hNYXRlcmlhbCA9IG5ldyBtZXNoLk1lc2hNYXRlcmlhbChjb3JlLlRleHR1cmUuV0hJVEUpO1xuICAgIHN1cGVyKHBsYW5lR2VvbWV0cnksIG1lc2hNYXRlcmlhbCk7XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICB0aGlzLmF1dG9SZXNpemUgPSB0cnVlO1xuICB9XG4gIHRleHR1cmVVcGRhdGVkKCkge1xuICAgIHRoaXMuX3RleHR1cmVJRCA9IHRoaXMuc2hhZGVyLnRleHR1cmUuX3VwZGF0ZUlEO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuc2hhZGVyLnRleHR1cmU7XG4gICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZSAmJiAoZ2VvbWV0cnkud2lkdGggIT09IHdpZHRoIHx8IGdlb21ldHJ5LmhlaWdodCAhPT0gaGVpZ2h0KSkge1xuICAgICAgZ2VvbWV0cnkud2lkdGggPSB0aGlzLnNoYWRlci50ZXh0dXJlLndpZHRoO1xuICAgICAgZ2VvbWV0cnkuaGVpZ2h0ID0gdGhpcy5zaGFkZXIudGV4dHVyZS5oZWlnaHQ7XG4gICAgICBnZW9tZXRyeS5idWlsZCgpO1xuICAgIH1cbiAgfVxuICBzZXQgdGV4dHVyZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnNoYWRlci50ZXh0dXJlID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNoYWRlci50ZXh0dXJlID0gdmFsdWU7XG4gICAgdGhpcy5fdGV4dHVyZUlEID0gLTE7XG4gICAgaWYgKHZhbHVlLmJhc2VUZXh0dXJlLnZhbGlkKSB7XG4gICAgICB0aGlzLnRleHR1cmVVcGRhdGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlLm9uY2UoXCJ1cGRhdGVcIiwgdGhpcy50ZXh0dXJlVXBkYXRlZCwgdGhpcyk7XG4gICAgfVxuICB9XG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnNoYWRlci50ZXh0dXJlO1xuICB9XG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICBpZiAodGhpcy5fdGV4dHVyZUlEICE9PSB0aGlzLnNoYWRlci50ZXh0dXJlLl91cGRhdGVJRCkge1xuICAgICAgdGhpcy50ZXh0dXJlVXBkYXRlZCgpO1xuICAgIH1cbiAgICBzdXBlci5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICB0aGlzLnNoYWRlci50ZXh0dXJlLm9mZihcInVwZGF0ZVwiLCB0aGlzLnRleHR1cmVVcGRhdGVkLCB0aGlzKTtcbiAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydHMuU2ltcGxlUGxhbmUgPSBTaW1wbGVQbGFuZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpbXBsZVBsYW5lLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBtZXNoID0gcmVxdWlyZSgnQHBpeGkvbWVzaCcpO1xudmFyIFJvcGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4vZ2VvbWV0cnkvUm9wZUdlb21ldHJ5LmpzJyk7XG5cbmNsYXNzIFNpbXBsZVJvcGUgZXh0ZW5kcyBtZXNoLk1lc2gge1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlLCBwb2ludHMsIHRleHR1cmVTY2FsZSA9IDApIHtcbiAgICBjb25zdCByb3BlR2VvbWV0cnkgPSBuZXcgUm9wZUdlb21ldHJ5LlJvcGVHZW9tZXRyeSh0ZXh0dXJlLmhlaWdodCwgcG9pbnRzLCB0ZXh0dXJlU2NhbGUpO1xuICAgIGNvbnN0IG1lc2hNYXRlcmlhbCA9IG5ldyBtZXNoLk1lc2hNYXRlcmlhbCh0ZXh0dXJlKTtcbiAgICBpZiAodGV4dHVyZVNjYWxlID4gMCkge1xuICAgICAgdGV4dHVyZS5iYXNlVGV4dHVyZS53cmFwTW9kZSA9IGNvcmUuV1JBUF9NT0RFUy5SRVBFQVQ7XG4gICAgfVxuICAgIHN1cGVyKHJvcGVHZW9tZXRyeSwgbWVzaE1hdGVyaWFsKTtcbiAgICB0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xuICB9XG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG4gICAgaWYgKHRoaXMuYXV0b1VwZGF0ZSB8fCBnZW9tZXRyeS5fd2lkdGggIT09IHRoaXMuc2hhZGVyLnRleHR1cmUuaGVpZ2h0KSB7XG4gICAgICBnZW9tZXRyeS5fd2lkdGggPSB0aGlzLnNoYWRlci50ZXh0dXJlLmhlaWdodDtcbiAgICAgIGdlb21ldHJ5LnVwZGF0ZSgpO1xuICAgIH1cbiAgICBzdXBlci5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxufVxuXG5leHBvcnRzLlNpbXBsZVJvcGUgPSBTaW1wbGVSb3BlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2ltcGxlUm9wZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIG1lc2ggPSByZXF1aXJlKCdAcGl4aS9tZXNoJyk7XG5cbmNsYXNzIFBsYW5lR2VvbWV0cnkgZXh0ZW5kcyBtZXNoLk1lc2hHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKHdpZHRoID0gMTAwLCBoZWlnaHQgPSAxMDAsIHNlZ1dpZHRoID0gMTAsIHNlZ0hlaWdodCA9IDEwKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNlZ1dpZHRoID0gc2VnV2lkdGg7XG4gICAgdGhpcy5zZWdIZWlnaHQgPSBzZWdIZWlnaHQ7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuYnVpbGQoKTtcbiAgfVxuICBidWlsZCgpIHtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMuc2VnV2lkdGggKiB0aGlzLnNlZ0hlaWdodDtcbiAgICBjb25zdCB2ZXJ0cyA9IFtdO1xuICAgIGNvbnN0IHV2cyA9IFtdO1xuICAgIGNvbnN0IGluZGljZXMgPSBbXTtcbiAgICBjb25zdCBzZWdtZW50c1ggPSB0aGlzLnNlZ1dpZHRoIC0gMTtcbiAgICBjb25zdCBzZWdtZW50c1kgPSB0aGlzLnNlZ0hlaWdodCAtIDE7XG4gICAgY29uc3Qgc2l6ZVggPSB0aGlzLndpZHRoIC8gc2VnbWVudHNYO1xuICAgIGNvbnN0IHNpemVZID0gdGhpcy5oZWlnaHQgLyBzZWdtZW50c1k7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gaSAlIHRoaXMuc2VnV2lkdGg7XG4gICAgICBjb25zdCB5ID0gaSAvIHRoaXMuc2VnV2lkdGggfCAwO1xuICAgICAgdmVydHMucHVzaCh4ICogc2l6ZVgsIHkgKiBzaXplWSk7XG4gICAgICB1dnMucHVzaCh4IC8gc2VnbWVudHNYLCB5IC8gc2VnbWVudHNZKTtcbiAgICB9XG4gICAgY29uc3QgdG90YWxTdWIgPSBzZWdtZW50c1ggKiBzZWdtZW50c1k7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbFN1YjsgaSsrKSB7XG4gICAgICBjb25zdCB4cG9zID0gaSAlIHNlZ21lbnRzWDtcbiAgICAgIGNvbnN0IHlwb3MgPSBpIC8gc2VnbWVudHNYIHwgMDtcbiAgICAgIGNvbnN0IHZhbHVlID0geXBvcyAqIHRoaXMuc2VnV2lkdGggKyB4cG9zO1xuICAgICAgY29uc3QgdmFsdWUyID0geXBvcyAqIHRoaXMuc2VnV2lkdGggKyB4cG9zICsgMTtcbiAgICAgIGNvbnN0IHZhbHVlMyA9ICh5cG9zICsgMSkgKiB0aGlzLnNlZ1dpZHRoICsgeHBvcztcbiAgICAgIGNvbnN0IHZhbHVlNCA9ICh5cG9zICsgMSkgKiB0aGlzLnNlZ1dpZHRoICsgeHBvcyArIDE7XG4gICAgICBpbmRpY2VzLnB1c2godmFsdWUsIHZhbHVlMiwgdmFsdWUzLCB2YWx1ZTIsIHZhbHVlNCwgdmFsdWUzKTtcbiAgICB9XG4gICAgdGhpcy5idWZmZXJzWzBdLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRzKTtcbiAgICB0aGlzLmJ1ZmZlcnNbMV0uZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodXZzKTtcbiAgICB0aGlzLmluZGV4QnVmZmVyLmRhdGEgPSBuZXcgVWludDE2QXJyYXkoaW5kaWNlcyk7XG4gICAgdGhpcy5idWZmZXJzWzBdLnVwZGF0ZSgpO1xuICAgIHRoaXMuYnVmZmVyc1sxXS51cGRhdGUoKTtcbiAgICB0aGlzLmluZGV4QnVmZmVyLnVwZGF0ZSgpO1xuICB9XG59XG5cbmV4cG9ydHMuUGxhbmVHZW9tZXRyeSA9IFBsYW5lR2VvbWV0cnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QbGFuZUdlb21ldHJ5LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbWVzaCA9IHJlcXVpcmUoJ0BwaXhpL21lc2gnKTtcblxuY2xhc3MgUm9wZUdlb21ldHJ5IGV4dGVuZHMgbWVzaC5NZXNoR2VvbWV0cnkge1xuICBjb25zdHJ1Y3Rvcih3aWR0aCA9IDIwMCwgcG9pbnRzLCB0ZXh0dXJlU2NhbGUgPSAwKSB7XG4gICAgc3VwZXIobmV3IEZsb2F0MzJBcnJheShwb2ludHMubGVuZ3RoICogNCksIG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpLCBuZXcgVWludDE2QXJyYXkoKHBvaW50cy5sZW5ndGggLSAxKSAqIDYpKTtcbiAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMudGV4dHVyZVNjYWxlID0gdGV4dHVyZVNjYWxlO1xuICAgIHRoaXMuYnVpbGQoKTtcbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICB9XG4gIGJ1aWxkKCkge1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGlmICghcG9pbnRzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHZlcnRleEJ1ZmZlciA9IHRoaXMuZ2V0QnVmZmVyKFwiYVZlcnRleFBvc2l0aW9uXCIpO1xuICAgIGNvbnN0IHV2QnVmZmVyID0gdGhpcy5nZXRCdWZmZXIoXCJhVGV4dHVyZUNvb3JkXCIpO1xuICAgIGNvbnN0IGluZGV4QnVmZmVyID0gdGhpcy5nZXRJbmRleCgpO1xuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmVydGV4QnVmZmVyLmRhdGEubGVuZ3RoIC8gNCAhPT0gcG9pbnRzLmxlbmd0aCkge1xuICAgICAgdmVydGV4QnVmZmVyLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiA0KTtcbiAgICAgIHV2QnVmZmVyLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiA0KTtcbiAgICAgIGluZGV4QnVmZmVyLmRhdGEgPSBuZXcgVWludDE2QXJyYXkoKHBvaW50cy5sZW5ndGggLSAxKSAqIDYpO1xuICAgIH1cbiAgICBjb25zdCB1dnMgPSB1dkJ1ZmZlci5kYXRhO1xuICAgIGNvbnN0IGluZGljZXMgPSBpbmRleEJ1ZmZlci5kYXRhO1xuICAgIHV2c1swXSA9IDA7XG4gICAgdXZzWzFdID0gMDtcbiAgICB1dnNbMl0gPSAwO1xuICAgIHV2c1szXSA9IDE7XG4gICAgbGV0IGFtb3VudCA9IDA7XG4gICAgbGV0IHByZXYgPSBwb2ludHNbMF07XG4gICAgY29uc3QgdGV4dHVyZVdpZHRoID0gdGhpcy5fd2lkdGggKiB0aGlzLnRleHR1cmVTY2FsZTtcbiAgICBjb25zdCB0b3RhbCA9IHBvaW50cy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGkgKiA0O1xuICAgICAgaWYgKHRoaXMudGV4dHVyZVNjYWxlID4gMCkge1xuICAgICAgICBjb25zdCBkeCA9IHByZXYueCAtIHBvaW50c1tpXS54O1xuICAgICAgICBjb25zdCBkeSA9IHByZXYueSAtIHBvaW50c1tpXS55O1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIHByZXYgPSBwb2ludHNbaV07XG4gICAgICAgIGFtb3VudCArPSBkaXN0YW5jZSAvIHRleHR1cmVXaWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFtb3VudCA9IGkgLyAodG90YWwgLSAxKTtcbiAgICAgIH1cbiAgICAgIHV2c1tpbmRleF0gPSBhbW91bnQ7XG4gICAgICB1dnNbaW5kZXggKyAxXSA9IDA7XG4gICAgICB1dnNbaW5kZXggKyAyXSA9IGFtb3VudDtcbiAgICAgIHV2c1tpbmRleCArIDNdID0gMTtcbiAgICB9XG4gICAgbGV0IGluZGV4Q291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWwgLSAxOyBpKyspIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gaSAqIDI7XG4gICAgICBpbmRpY2VzW2luZGV4Q291bnQrK10gPSBpbmRleDtcbiAgICAgIGluZGljZXNbaW5kZXhDb3VudCsrXSA9IGluZGV4ICsgMTtcbiAgICAgIGluZGljZXNbaW5kZXhDb3VudCsrXSA9IGluZGV4ICsgMjtcbiAgICAgIGluZGljZXNbaW5kZXhDb3VudCsrXSA9IGluZGV4ICsgMjtcbiAgICAgIGluZGljZXNbaW5kZXhDb3VudCsrXSA9IGluZGV4ICsgMTtcbiAgICAgIGluZGljZXNbaW5kZXhDb3VudCsrXSA9IGluZGV4ICsgMztcbiAgICB9XG4gICAgdXZCdWZmZXIudXBkYXRlKCk7XG4gICAgaW5kZXhCdWZmZXIudXBkYXRlKCk7XG4gICAgdGhpcy51cGRhdGVWZXJ0aWNlcygpO1xuICB9XG4gIHVwZGF0ZVZlcnRpY2VzKCkge1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbGFzdFBvaW50ID0gcG9pbnRzWzBdO1xuICAgIGxldCBuZXh0UG9pbnQ7XG4gICAgbGV0IHBlcnBYID0gMDtcbiAgICBsZXQgcGVycFkgPSAwO1xuICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy5idWZmZXJzWzBdLmRhdGE7XG4gICAgY29uc3QgdG90YWwgPSBwb2ludHMubGVuZ3RoO1xuICAgIGNvbnN0IGhhbGZXaWR0aCA9IHRoaXMudGV4dHVyZVNjYWxlID4gMCA/IHRoaXMudGV4dHVyZVNjYWxlICogdGhpcy5fd2lkdGggLyAyIDogdGhpcy5fd2lkdGggLyAyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWw7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBpbmRleCA9IGkgKiA0O1xuICAgICAgaWYgKGkgPCBwb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICBuZXh0UG9pbnQgPSBwb2ludHNbaSArIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dFBvaW50ID0gcG9pbnQ7XG4gICAgICB9XG4gICAgICBwZXJwWSA9IC0obmV4dFBvaW50LnggLSBsYXN0UG9pbnQueCk7XG4gICAgICBwZXJwWCA9IG5leHRQb2ludC55IC0gbGFzdFBvaW50Lnk7XG4gICAgICBsZXQgcmF0aW8gPSAoMSAtIGkgLyAodG90YWwgLSAxKSkgKiAxMDtcbiAgICAgIGlmIChyYXRpbyA+IDEpIHtcbiAgICAgICAgcmF0aW8gPSAxO1xuICAgICAgfVxuICAgICAgY29uc3QgcGVycExlbmd0aCA9IE1hdGguc3FydChwZXJwWCAqIHBlcnBYICsgcGVycFkgKiBwZXJwWSk7XG4gICAgICBpZiAocGVycExlbmd0aCA8IDFlLTYpIHtcbiAgICAgICAgcGVycFggPSAwO1xuICAgICAgICBwZXJwWSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZXJwWCAvPSBwZXJwTGVuZ3RoO1xuICAgICAgICBwZXJwWSAvPSBwZXJwTGVuZ3RoO1xuICAgICAgICBwZXJwWCAqPSBoYWxmV2lkdGg7XG4gICAgICAgIHBlcnBZICo9IGhhbGZXaWR0aDtcbiAgICAgIH1cbiAgICAgIHZlcnRpY2VzW2luZGV4XSA9IHBvaW50LnggKyBwZXJwWDtcbiAgICAgIHZlcnRpY2VzW2luZGV4ICsgMV0gPSBwb2ludC55ICsgcGVycFk7XG4gICAgICB2ZXJ0aWNlc1tpbmRleCArIDJdID0gcG9pbnQueCAtIHBlcnBYO1xuICAgICAgdmVydGljZXNbaW5kZXggKyAzXSA9IHBvaW50LnkgLSBwZXJwWTtcbiAgICAgIGxhc3RQb2ludCA9IHBvaW50O1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlcnNbMF0udXBkYXRlKCk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGlmICh0aGlzLnRleHR1cmVTY2FsZSA+IDApIHtcbiAgICAgIHRoaXMuYnVpbGQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGVWZXJ0aWNlcygpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLlJvcGVHZW9tZXRyeSA9IFJvcGVHZW9tZXRyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJvcGVHZW9tZXRyeS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIFBsYW5lR2VvbWV0cnkgPSByZXF1aXJlKCcuL2dlb21ldHJ5L1BsYW5lR2VvbWV0cnkuanMnKTtcbnZhciBSb3BlR2VvbWV0cnkgPSByZXF1aXJlKCcuL2dlb21ldHJ5L1JvcGVHZW9tZXRyeS5qcycpO1xudmFyIE5pbmVTbGljZVBsYW5lID0gcmVxdWlyZSgnLi9OaW5lU2xpY2VQbGFuZS5qcycpO1xudmFyIFNpbXBsZU1lc2ggPSByZXF1aXJlKCcuL1NpbXBsZU1lc2guanMnKTtcbnZhciBTaW1wbGVQbGFuZSA9IHJlcXVpcmUoJy4vU2ltcGxlUGxhbmUuanMnKTtcbnZhciBTaW1wbGVSb3BlID0gcmVxdWlyZSgnLi9TaW1wbGVSb3BlLmpzJyk7XG5cblxuXG5leHBvcnRzLlBsYW5lR2VvbWV0cnkgPSBQbGFuZUdlb21ldHJ5LlBsYW5lR2VvbWV0cnk7XG5leHBvcnRzLlJvcGVHZW9tZXRyeSA9IFJvcGVHZW9tZXRyeS5Sb3BlR2VvbWV0cnk7XG5leHBvcnRzLk5pbmVTbGljZVBsYW5lID0gTmluZVNsaWNlUGxhbmUuTmluZVNsaWNlUGxhbmU7XG5leHBvcnRzLlNpbXBsZU1lc2ggPSBTaW1wbGVNZXNoLlNpbXBsZU1lc2g7XG5leHBvcnRzLlNpbXBsZVBsYW5lID0gU2ltcGxlUGxhbmUuU2ltcGxlUGxhbmU7XG5leHBvcnRzLlNpbXBsZVJvcGUgPSBTaW1wbGVSb3BlLlNpbXBsZVJvcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgZGlzcGxheSA9IHJlcXVpcmUoJ0BwaXhpL2Rpc3BsYXknKTtcbnZhciBNZXNoQmF0Y2hVdnMgPSByZXF1aXJlKCcuL01lc2hCYXRjaFV2cy5qcycpO1xuXG5jb25zdCB0ZW1wUG9pbnQgPSBuZXcgY29yZS5Qb2ludCgpO1xuY29uc3QgdGVtcFBvbHlnb24gPSBuZXcgY29yZS5Qb2x5Z29uKCk7XG5jb25zdCBfTWVzaCA9IGNsYXNzIGV4dGVuZHMgZGlzcGxheS5Db250YWluZXIge1xuICBjb25zdHJ1Y3RvcihnZW9tZXRyeSwgc2hhZGVyLCBzdGF0ZSwgZHJhd01vZGUgPSBjb3JlLkRSQVdfTU9ERVMuVFJJQU5HTEVTKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgdGhpcy5zaGFkZXIgPSBzaGFkZXI7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlIHx8IGNvcmUuU3RhdGUuZm9yMmQoKTtcbiAgICB0aGlzLmRyYXdNb2RlID0gZHJhd01vZGU7XG4gICAgdGhpcy5zdGFydCA9IDA7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgICB0aGlzLnV2cyA9IG51bGw7XG4gICAgdGhpcy5pbmRpY2VzID0gbnVsbDtcbiAgICB0aGlzLnZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDEpO1xuICAgIHRoaXMudmVydGV4RGlydHkgPSAtMTtcbiAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IC0xO1xuICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gY29yZS5zZXR0aW5ncy5ST1VORF9QSVhFTFM7XG4gICAgdGhpcy5iYXRjaFV2cyA9IG51bGw7XG4gIH1cbiAgZ2V0IGdlb21ldHJ5KCkge1xuICAgIHJldHVybiB0aGlzLl9nZW9tZXRyeTtcbiAgfVxuICBzZXQgZ2VvbWV0cnkodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fZ2VvbWV0cnkgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9nZW9tZXRyeSkge1xuICAgICAgdGhpcy5fZ2VvbWV0cnkucmVmQ291bnQtLTtcbiAgICAgIGlmICh0aGlzLl9nZW9tZXRyeS5yZWZDb3VudCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2dlb21ldHJ5ID0gdmFsdWU7XG4gICAgaWYgKHRoaXMuX2dlb21ldHJ5KSB7XG4gICAgICB0aGlzLl9nZW9tZXRyeS5yZWZDb3VudCsrO1xuICAgIH1cbiAgICB0aGlzLnZlcnRleERpcnR5ID0gLTE7XG4gIH1cbiAgZ2V0IHV2QnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMV07XG4gIH1cbiAgZ2V0IHZlcnRpY2VzQnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMF07XG4gIH1cbiAgc2V0IG1hdGVyaWFsKHZhbHVlKSB7XG4gICAgdGhpcy5zaGFkZXIgPSB2YWx1ZTtcbiAgfVxuICBnZXQgbWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hhZGVyO1xuICB9XG4gIHNldCBibGVuZE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IHZhbHVlO1xuICB9XG4gIGdldCBibGVuZE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuYmxlbmRNb2RlO1xuICB9XG4gIHNldCByb3VuZFBpeGVscyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9yb3VuZFBpeGVscyAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gLTE7XG4gICAgfVxuICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHJvdW5kUGl4ZWxzKCkge1xuICAgIHJldHVybiB0aGlzLl9yb3VuZFBpeGVscztcbiAgfVxuICBnZXQgdGludCgpIHtcbiAgICByZXR1cm4gXCJ0aW50XCIgaW4gdGhpcy5zaGFkZXIgPyB0aGlzLnNoYWRlci50aW50IDogbnVsbDtcbiAgfVxuICBzZXQgdGludCh2YWx1ZSkge1xuICAgIHRoaXMuc2hhZGVyLnRpbnQgPSB2YWx1ZTtcbiAgfVxuICBnZXQgdGludFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnNoYWRlci50aW50VmFsdWU7XG4gIH1cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIFwidGV4dHVyZVwiIGluIHRoaXMuc2hhZGVyID8gdGhpcy5zaGFkZXIudGV4dHVyZSA6IG51bGw7XG4gIH1cbiAgc2V0IHRleHR1cmUodmFsdWUpIHtcbiAgICB0aGlzLnNoYWRlci50ZXh0dXJlID0gdmFsdWU7XG4gIH1cbiAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS5idWZmZXJzWzBdLmRhdGE7XG4gICAgY29uc3Qgc2hhZGVyID0gdGhpcy5zaGFkZXI7XG4gICAgaWYgKHNoYWRlci5iYXRjaGFibGUgJiYgdGhpcy5kcmF3TW9kZSA9PT0gY29yZS5EUkFXX01PREVTLlRSSUFOR0xFUyAmJiB2ZXJ0aWNlcy5sZW5ndGggPCBfTWVzaC5CQVRDSEFCTEVfU0laRSAqIDIpIHtcbiAgICAgIHRoaXMuX3JlbmRlclRvQmF0Y2gocmVuZGVyZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZW5kZXJEZWZhdWx0KHJlbmRlcmVyKTtcbiAgICB9XG4gIH1cbiAgX3JlbmRlckRlZmF1bHQocmVuZGVyZXIpIHtcbiAgICBjb25zdCBzaGFkZXIgPSB0aGlzLnNoYWRlcjtcbiAgICBzaGFkZXIuYWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG4gICAgaWYgKHNoYWRlci51cGRhdGUpIHtcbiAgICAgIHNoYWRlci51cGRhdGUoKTtcbiAgICB9XG4gICAgcmVuZGVyZXIuYmF0Y2guZmx1c2goKTtcbiAgICBzaGFkZXIudW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXggPSB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybS50b0FycmF5KHRydWUpO1xuICAgIHJlbmRlcmVyLnNoYWRlci5iaW5kKHNoYWRlcik7XG4gICAgcmVuZGVyZXIuc3RhdGUuc2V0KHRoaXMuc3RhdGUpO1xuICAgIHJlbmRlcmVyLmdlb21ldHJ5LmJpbmQodGhpcy5nZW9tZXRyeSwgc2hhZGVyKTtcbiAgICByZW5kZXJlci5nZW9tZXRyeS5kcmF3KHRoaXMuZHJhd01vZGUsIHRoaXMuc2l6ZSwgdGhpcy5zdGFydCwgdGhpcy5nZW9tZXRyeS5pbnN0YW5jZUNvdW50KTtcbiAgfVxuICBfcmVuZGVyVG9CYXRjaChyZW5kZXJlcikge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICBjb25zdCBzaGFkZXIgPSB0aGlzLnNoYWRlcjtcbiAgICBpZiAoc2hhZGVyLnV2TWF0cml4KSB7XG4gICAgICBzaGFkZXIudXZNYXRyaXgudXBkYXRlKCk7XG4gICAgICB0aGlzLmNhbGN1bGF0ZVV2cygpO1xuICAgIH1cbiAgICB0aGlzLmNhbGN1bGF0ZVZlcnRpY2VzKCk7XG4gICAgdGhpcy5pbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXhCdWZmZXIuZGF0YTtcbiAgICB0aGlzLl90aW50UkdCID0gc2hhZGVyLl90aW50UkdCO1xuICAgIHRoaXMuX3RleHR1cmUgPSBzaGFkZXIudGV4dHVyZTtcbiAgICBjb25zdCBwbHVnaW5OYW1lID0gdGhpcy5tYXRlcmlhbC5wbHVnaW5OYW1lO1xuICAgIHJlbmRlcmVyLmJhdGNoLnNldE9iamVjdFJlbmRlcmVyKHJlbmRlcmVyLnBsdWdpbnNbcGx1Z2luTmFtZV0pO1xuICAgIHJlbmRlcmVyLnBsdWdpbnNbcGx1Z2luTmFtZV0ucmVuZGVyKHRoaXMpO1xuICB9XG4gIGNhbGN1bGF0ZVZlcnRpY2VzKCkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICBjb25zdCB2ZXJ0aWNlc0J1ZmZlciA9IGdlb21ldHJ5LmJ1ZmZlcnNbMF07XG4gICAgY29uc3QgdmVydGljZXMgPSB2ZXJ0aWNlc0J1ZmZlci5kYXRhO1xuICAgIGNvbnN0IHZlcnRleERpcnR5SWQgPSB2ZXJ0aWNlc0J1ZmZlci5fdXBkYXRlSUQ7XG4gICAgaWYgKHZlcnRleERpcnR5SWQgPT09IHRoaXMudmVydGV4RGlydHkgJiYgdGhpcy5fdHJhbnNmb3JtSUQgPT09IHRoaXMudHJhbnNmb3JtLl93b3JsZElEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQ7XG4gICAgaWYgKHRoaXMudmVydGV4RGF0YS5sZW5ndGggIT09IHZlcnRpY2VzLmxlbmd0aCkge1xuICAgICAgdGhpcy52ZXJ0ZXhEYXRhID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcy5sZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCB3dCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgIGNvbnN0IGEgPSB3dC5hO1xuICAgIGNvbnN0IGIgPSB3dC5iO1xuICAgIGNvbnN0IGMgPSB3dC5jO1xuICAgIGNvbnN0IGQgPSB3dC5kO1xuICAgIGNvbnN0IHR4ID0gd3QudHg7XG4gICAgY29uc3QgdHkgPSB3dC50eTtcbiAgICBjb25zdCB2ZXJ0ZXhEYXRhID0gdGhpcy52ZXJ0ZXhEYXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGV4RGF0YS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSB2ZXJ0aWNlc1tpICogMl07XG4gICAgICBjb25zdCB5ID0gdmVydGljZXNbaSAqIDIgKyAxXTtcbiAgICAgIHZlcnRleERhdGFbaSAqIDJdID0gYSAqIHggKyBjICogeSArIHR4O1xuICAgICAgdmVydGV4RGF0YVtpICogMiArIDFdID0gYiAqIHggKyBkICogeSArIHR5O1xuICAgIH1cbiAgICBpZiAodGhpcy5fcm91bmRQaXhlbHMpIHtcbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPSBjb3JlLnNldHRpbmdzLlJFU09MVVRJT047XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleERhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmVydGV4RGF0YVtpXSA9IE1hdGgucm91bmQodmVydGV4RGF0YVtpXSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy52ZXJ0ZXhEaXJ0eSA9IHZlcnRleERpcnR5SWQ7XG4gIH1cbiAgY2FsY3VsYXRlVXZzKCkge1xuICAgIGNvbnN0IGdlb21VdnMgPSB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMV07XG4gICAgY29uc3Qgc2hhZGVyID0gdGhpcy5zaGFkZXI7XG4gICAgaWYgKCFzaGFkZXIudXZNYXRyaXguaXNTaW1wbGUpIHtcbiAgICAgIGlmICghdGhpcy5iYXRjaFV2cykge1xuICAgICAgICB0aGlzLmJhdGNoVXZzID0gbmV3IE1lc2hCYXRjaFV2cy5NZXNoQmF0Y2hVdnMoZ2VvbVV2cywgc2hhZGVyLnV2TWF0cml4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYmF0Y2hVdnMudXBkYXRlKCk7XG4gICAgICB0aGlzLnV2cyA9IHRoaXMuYmF0Y2hVdnMuZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51dnMgPSBnZW9tVXZzLmRhdGE7XG4gICAgfVxuICB9XG4gIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpO1xuICAgIHRoaXMuX2JvdW5kcy5hZGRWZXJ0ZXhEYXRhKHRoaXMudmVydGV4RGF0YSwgMCwgdGhpcy52ZXJ0ZXhEYXRhLmxlbmd0aCk7XG4gIH1cbiAgY29udGFpbnNQb2ludChwb2ludCkge1xuICAgIGlmICghdGhpcy5nZXRCb3VuZHMoKS5jb250YWlucyhwb2ludC54LCBwb2ludC55KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgdGVtcFBvaW50KTtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkuZ2V0QnVmZmVyKFwiYVZlcnRleFBvc2l0aW9uXCIpLmRhdGE7XG4gICAgY29uc3QgcG9pbnRzID0gdGVtcFBvbHlnb24ucG9pbnRzO1xuICAgIGNvbnN0IGluZGljZXMgPSB0aGlzLmdlb21ldHJ5LmdldEluZGV4KCkuZGF0YTtcbiAgICBjb25zdCBsZW4gPSBpbmRpY2VzLmxlbmd0aDtcbiAgICBjb25zdCBzdGVwID0gdGhpcy5kcmF3TW9kZSA9PT0gNCA/IDMgOiAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpICsgMiA8IGxlbjsgaSArPSBzdGVwKSB7XG4gICAgICBjb25zdCBpbmQwID0gaW5kaWNlc1tpXSAqIDI7XG4gICAgICBjb25zdCBpbmQxID0gaW5kaWNlc1tpICsgMV0gKiAyO1xuICAgICAgY29uc3QgaW5kMiA9IGluZGljZXNbaSArIDJdICogMjtcbiAgICAgIHBvaW50c1swXSA9IHZlcnRpY2VzW2luZDBdO1xuICAgICAgcG9pbnRzWzFdID0gdmVydGljZXNbaW5kMCArIDFdO1xuICAgICAgcG9pbnRzWzJdID0gdmVydGljZXNbaW5kMV07XG4gICAgICBwb2ludHNbM10gPSB2ZXJ0aWNlc1tpbmQxICsgMV07XG4gICAgICBwb2ludHNbNF0gPSB2ZXJ0aWNlc1tpbmQyXTtcbiAgICAgIHBvaW50c1s1XSA9IHZlcnRpY2VzW2luZDIgKyAxXTtcbiAgICAgIGlmICh0ZW1wUG9seWdvbi5jb250YWlucyh0ZW1wUG9pbnQueCwgdGVtcFBvaW50LnkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgICBpZiAodGhpcy5fY2FjaGVkVGV4dHVyZSkge1xuICAgICAgdGhpcy5fY2FjaGVkVGV4dHVyZS5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9jYWNoZWRUZXh0dXJlID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5nZW9tZXRyeSA9IG51bGw7XG4gICAgdGhpcy5zaGFkZXIgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgIHRoaXMudXZzID0gbnVsbDtcbiAgICB0aGlzLmluZGljZXMgPSBudWxsO1xuICAgIHRoaXMudmVydGV4RGF0YSA9IG51bGw7XG4gIH1cbn07XG5sZXQgTWVzaCA9IF9NZXNoO1xuTWVzaC5CQVRDSEFCTEVfU0laRSA9IDEwMDtcblxuZXhwb3J0cy5NZXNoID0gTWVzaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lc2guanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNsYXNzIE1lc2hCYXRjaFV2cyB7XG4gIGNvbnN0cnVjdG9yKHV2QnVmZmVyLCB1dk1hdHJpeCkge1xuICAgIHRoaXMudXZCdWZmZXIgPSB1dkJ1ZmZlcjtcbiAgICB0aGlzLnV2TWF0cml4ID0gdXZNYXRyaXg7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICB0aGlzLl9idWZmZXJVcGRhdGVJZCA9IC0xO1xuICAgIHRoaXMuX3RleHR1cmVVcGRhdGVJZCA9IC0xO1xuICAgIHRoaXMuX3VwZGF0ZUlEID0gMDtcbiAgfVxuICB1cGRhdGUoZm9yY2VVcGRhdGUpIHtcbiAgICBpZiAoIWZvcmNlVXBkYXRlICYmIHRoaXMuX2J1ZmZlclVwZGF0ZUlkID09PSB0aGlzLnV2QnVmZmVyLl91cGRhdGVJRCAmJiB0aGlzLl90ZXh0dXJlVXBkYXRlSWQgPT09IHRoaXMudXZNYXRyaXguX3VwZGF0ZUlEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2J1ZmZlclVwZGF0ZUlkID0gdGhpcy51dkJ1ZmZlci5fdXBkYXRlSUQ7XG4gICAgdGhpcy5fdGV4dHVyZVVwZGF0ZUlkID0gdGhpcy51dk1hdHJpeC5fdXBkYXRlSUQ7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMudXZCdWZmZXIuZGF0YTtcbiAgICBpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRhdGEubGVuZ3RoICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgfVxuICAgIHRoaXMudXZNYXRyaXgubXVsdGlwbHlVdnMoZGF0YSwgdGhpcy5kYXRhKTtcbiAgICB0aGlzLl91cGRhdGVJRCsrO1xuICB9XG59XG5cbmV4cG9ydHMuTWVzaEJhdGNoVXZzID0gTWVzaEJhdGNoVXZzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzaEJhdGNoVXZzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcblxuY2xhc3MgTWVzaEdlb21ldHJ5IGV4dGVuZHMgY29yZS5HZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKHZlcnRpY2VzLCB1dnMsIGluZGV4KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB2ZXJ0aWNlc0J1ZmZlciA9IG5ldyBjb3JlLkJ1ZmZlcih2ZXJ0aWNlcyk7XG4gICAgY29uc3QgdXZzQnVmZmVyID0gbmV3IGNvcmUuQnVmZmVyKHV2cywgdHJ1ZSk7XG4gICAgY29uc3QgaW5kZXhCdWZmZXIgPSBuZXcgY29yZS5CdWZmZXIoaW5kZXgsIHRydWUsIHRydWUpO1xuICAgIHRoaXMuYWRkQXR0cmlidXRlKFwiYVZlcnRleFBvc2l0aW9uXCIsIHZlcnRpY2VzQnVmZmVyLCAyLCBmYWxzZSwgY29yZS5UWVBFUy5GTE9BVCkuYWRkQXR0cmlidXRlKFwiYVRleHR1cmVDb29yZFwiLCB1dnNCdWZmZXIsIDIsIGZhbHNlLCBjb3JlLlRZUEVTLkZMT0FUKS5hZGRJbmRleChpbmRleEJ1ZmZlcik7XG4gICAgdGhpcy5fdXBkYXRlSWQgPSAtMTtcbiAgfVxuICBnZXQgdmVydGV4RGlydHlJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXJzWzBdLl91cGRhdGVJRDtcbiAgfVxufVxuXG5leHBvcnRzLk1lc2hHZW9tZXRyeSA9IE1lc2hHZW9tZXRyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lc2hHZW9tZXRyeS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgbWVzaCQxID0gcmVxdWlyZSgnLi9zaGFkZXIvbWVzaC5qcycpO1xudmFyIG1lc2ggPSByZXF1aXJlKCcuL3NoYWRlci9tZXNoMi5qcycpO1xuXG5jbGFzcyBNZXNoTWF0ZXJpYWwgZXh0ZW5kcyBjb3JlLlNoYWRlciB7XG4gIGNvbnN0cnVjdG9yKHVTYW1wbGVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB7XG4gICAgICB1U2FtcGxlcixcbiAgICAgIGFscGhhOiAxLFxuICAgICAgdVRleHR1cmVNYXRyaXg6IGNvcmUuTWF0cml4LklERU5USVRZLFxuICAgICAgdUNvbG9yOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxLCAxXSlcbiAgICB9O1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHRpbnQ6IDE2Nzc3MjE1LFxuICAgICAgYWxwaGE6IDEsXG4gICAgICBwbHVnaW5OYW1lOiBcImJhdGNoXCJcbiAgICB9LCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy51bmlmb3Jtcykge1xuICAgICAgT2JqZWN0LmFzc2lnbih1bmlmb3Jtcywgb3B0aW9ucy51bmlmb3Jtcyk7XG4gICAgfVxuICAgIHN1cGVyKG9wdGlvbnMucHJvZ3JhbSB8fCBjb3JlLlByb2dyYW0uZnJvbShtZXNoW1wiZGVmYXVsdFwiXSwgbWVzaCQxW1wiZGVmYXVsdFwiXSksIHVuaWZvcm1zKTtcbiAgICB0aGlzLl9jb2xvckRpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy51dk1hdHJpeCA9IG5ldyBjb3JlLlRleHR1cmVNYXRyaXgodVNhbXBsZXIpO1xuICAgIHRoaXMuYmF0Y2hhYmxlID0gb3B0aW9ucy5wcm9ncmFtID09PSB2b2lkIDA7XG4gICAgdGhpcy5wbHVnaW5OYW1lID0gb3B0aW9ucy5wbHVnaW5OYW1lO1xuICAgIHRoaXMuX3RpbnRDb2xvciA9IG5ldyBjb3JlLkNvbG9yKG9wdGlvbnMudGludCk7XG4gICAgdGhpcy5fdGludFJHQiA9IHRoaXMuX3RpbnRDb2xvci50b0xpdHRsZUVuZGlhbk51bWJlcigpO1xuICAgIHRoaXMuX2NvbG9yRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuYWxwaGEgPSBvcHRpb25zLmFscGhhO1xuICB9XG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVTYW1wbGVyO1xuICB9XG4gIHNldCB0ZXh0dXJlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudW5pZm9ybXMudVNhbXBsZXIgIT09IHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMudW5pZm9ybXMudVNhbXBsZXIuYmFzZVRleHR1cmUuYWxwaGFNb2RlICE9PSAhdmFsdWUuYmFzZVRleHR1cmUuYWxwaGFNb2RlKSB7XG4gICAgICAgIHRoaXMuX2NvbG9yRGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy51bmlmb3Jtcy51U2FtcGxlciA9IHZhbHVlO1xuICAgICAgdGhpcy51dk1hdHJpeC50ZXh0dXJlID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHNldCBhbHBoYSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5fYWxwaGEpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fYWxwaGEgPSB2YWx1ZTtcbiAgICB0aGlzLl9jb2xvckRpcnR5ID0gdHJ1ZTtcbiAgfVxuICBnZXQgYWxwaGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FscGhhO1xuICB9XG4gIHNldCB0aW50KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB0aGlzLnRpbnQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fdGludENvbG9yLnNldFZhbHVlKHZhbHVlKTtcbiAgICB0aGlzLl90aW50UkdCID0gdGhpcy5fdGludENvbG9yLnRvTGl0dGxlRW5kaWFuTnVtYmVyKCk7XG4gICAgdGhpcy5fY29sb3JEaXJ0eSA9IHRydWU7XG4gIH1cbiAgZ2V0IHRpbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbnRDb2xvci52YWx1ZTtcbiAgfVxuICBnZXQgdGludFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl90aW50Q29sb3IudG9OdW1iZXIoKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuX2NvbG9yRGlydHkpIHtcbiAgICAgIHRoaXMuX2NvbG9yRGlydHkgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGJhc2VUZXh0dXJlID0gdGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgY29uc3QgYXBwbHlUb0NoYW5uZWxzID0gYmFzZVRleHR1cmUuYWxwaGFNb2RlO1xuICAgICAgY29yZS5Db2xvci5zaGFyZWQuc2V0VmFsdWUodGhpcy5fdGludENvbG9yKS5wcmVtdWx0aXBseSh0aGlzLl9hbHBoYSwgYXBwbHlUb0NoYW5uZWxzKS50b0FycmF5KHRoaXMudW5pZm9ybXMudUNvbG9yKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudXZNYXRyaXgudXBkYXRlKCkpIHtcbiAgICAgIHRoaXMudW5pZm9ybXMudVRleHR1cmVNYXRyaXggPSB0aGlzLnV2TWF0cml4Lm1hcENvb3JkO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLk1lc2hNYXRlcmlhbCA9IE1lc2hNYXRlcmlhbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lc2hNYXRlcmlhbC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIE1lc2ggPSByZXF1aXJlKCcuL01lc2guanMnKTtcbnZhciBNZXNoQmF0Y2hVdnMgPSByZXF1aXJlKCcuL01lc2hCYXRjaFV2cy5qcycpO1xudmFyIE1lc2hHZW9tZXRyeSA9IHJlcXVpcmUoJy4vTWVzaEdlb21ldHJ5LmpzJyk7XG52YXIgTWVzaE1hdGVyaWFsID0gcmVxdWlyZSgnLi9NZXNoTWF0ZXJpYWwuanMnKTtcblxuXG5cbmV4cG9ydHMuTWVzaCA9IE1lc2guTWVzaDtcbmV4cG9ydHMuTWVzaEJhdGNoVXZzID0gTWVzaEJhdGNoVXZzLk1lc2hCYXRjaFV2cztcbmV4cG9ydHMuTWVzaEdlb21ldHJ5ID0gTWVzaEdlb21ldHJ5Lk1lc2hHZW9tZXRyeTtcbmV4cG9ydHMuTWVzaE1hdGVyaWFsID0gTWVzaE1hdGVyaWFsLk1lc2hNYXRlcmlhbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZnJhZ21lbnQgPSBcInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnVuaWZvcm0gdmVjNCB1Q29sb3I7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdUNvbG9yO1xcbn1cXG5cIjtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmcmFnbWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc2guanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB2ZXJ0ZXggPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDMgdVRleHR1cmVNYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcblxcbiAgICB2VGV4dHVyZUNvb3JkID0gKHVUZXh0dXJlTWF0cml4ICogdmVjMyhhVGV4dHVyZUNvb3JkLCAxLjApKS54eTtcXG59XFxuXCI7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdmVydGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzaDIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xudmFyIGRpc3BsYXkgPSByZXF1aXJlKCdAcGl4aS9kaXNwbGF5Jyk7XG52YXIgc3ByaXRlID0gcmVxdWlyZSgnQHBpeGkvc3ByaXRlJyk7XG5cbmNvbnN0IF90ZW1wTWF0cml4ID0gbmV3IGNvcmUuTWF0cml4KCk7XG5kaXNwbGF5LkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9jYWNoZUFzQml0bWFwID0gZmFsc2U7XG5kaXNwbGF5LkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9jYWNoZURhdGEgPSBudWxsO1xuZGlzcGxheS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fY2FjaGVBc0JpdG1hcFJlc29sdXRpb24gPSBudWxsO1xuZGlzcGxheS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fY2FjaGVBc0JpdG1hcE11bHRpc2FtcGxlID0gbnVsbDtcbmNsYXNzIENhY2hlRGF0YSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudGV4dHVyZUNhY2hlSWQgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luYWxSZW5kZXIgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luYWxSZW5kZXJDYW52YXMgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luYWxDYWxjdWxhdGVCb3VuZHMgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luYWxHZXRMb2NhbEJvdW5kcyA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbFVwZGF0ZVRyYW5zZm9ybSA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbERlc3Ryb3kgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luYWxNYXNrID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpbmFsRmlsdGVyQXJlYSA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbENvbnRhaW5zUG9pbnQgPSBudWxsO1xuICAgIHRoaXMuc3ByaXRlID0gbnVsbDtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZGlzcGxheS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZSwge1xuICBjYWNoZUFzQml0bWFwUmVzb2x1dGlvbjoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZUFzQml0bWFwUmVzb2x1dGlvbjtcbiAgICB9LFxuICAgIHNldChyZXNvbHV0aW9uKSB7XG4gICAgICBpZiAocmVzb2x1dGlvbiA9PT0gdGhpcy5fY2FjaGVBc0JpdG1hcFJlc29sdXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2FjaGVBc0JpdG1hcFJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgICAgaWYgKHRoaXMuY2FjaGVBc0JpdG1hcCkge1xuICAgICAgICB0aGlzLmNhY2hlQXNCaXRtYXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWNoZUFzQml0bWFwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNhY2hlQXNCaXRtYXBNdWx0aXNhbXBsZToge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZUFzQml0bWFwTXVsdGlzYW1wbGU7XG4gICAgfSxcbiAgICBzZXQobXVsdGlzYW1wbGUpIHtcbiAgICAgIGlmIChtdWx0aXNhbXBsZSA9PT0gdGhpcy5fY2FjaGVBc0JpdG1hcE11bHRpc2FtcGxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhY2hlQXNCaXRtYXBNdWx0aXNhbXBsZSA9IG11bHRpc2FtcGxlO1xuICAgICAgaWYgKHRoaXMuY2FjaGVBc0JpdG1hcCkge1xuICAgICAgICB0aGlzLmNhY2hlQXNCaXRtYXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWNoZUFzQml0bWFwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNhY2hlQXNCaXRtYXA6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVBc0JpdG1hcDtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuX2NhY2hlQXNCaXRtYXAgPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhY2hlQXNCaXRtYXAgPSB2YWx1ZTtcbiAgICAgIGxldCBkYXRhO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGVEYXRhKSB7XG4gICAgICAgICAgdGhpcy5fY2FjaGVEYXRhID0gbmV3IENhY2hlRGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSB0aGlzLl9jYWNoZURhdGE7XG4gICAgICAgIGRhdGEub3JpZ2luYWxSZW5kZXIgPSB0aGlzLnJlbmRlcjtcbiAgICAgICAgZGF0YS5vcmlnaW5hbFJlbmRlckNhbnZhcyA9IHRoaXMucmVuZGVyQ2FudmFzO1xuICAgICAgICBkYXRhLm9yaWdpbmFsVXBkYXRlVHJhbnNmb3JtID0gdGhpcy51cGRhdGVUcmFuc2Zvcm07XG4gICAgICAgIGRhdGEub3JpZ2luYWxDYWxjdWxhdGVCb3VuZHMgPSB0aGlzLmNhbGN1bGF0ZUJvdW5kcztcbiAgICAgICAgZGF0YS5vcmlnaW5hbEdldExvY2FsQm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcztcbiAgICAgICAgZGF0YS5vcmlnaW5hbERlc3Ryb3kgPSB0aGlzLmRlc3Ryb3k7XG4gICAgICAgIGRhdGEub3JpZ2luYWxDb250YWluc1BvaW50ID0gdGhpcy5jb250YWluc1BvaW50O1xuICAgICAgICBkYXRhLm9yaWdpbmFsTWFzayA9IHRoaXMuX21hc2s7XG4gICAgICAgIGRhdGEub3JpZ2luYWxGaWx0ZXJBcmVhID0gdGhpcy5maWx0ZXJBcmVhO1xuICAgICAgICB0aGlzLnJlbmRlciA9IHRoaXMuX3JlbmRlckNhY2hlZDtcbiAgICAgICAgdGhpcy5yZW5kZXJDYW52YXMgPSB0aGlzLl9yZW5kZXJDYWNoZWRDYW52YXM7XG4gICAgICAgIHRoaXMuZGVzdHJveSA9IHRoaXMuX2NhY2hlQXNCaXRtYXBEZXN0cm95O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IHRoaXMuX2NhY2hlRGF0YTtcbiAgICAgICAgaWYgKGRhdGEuc3ByaXRlKSB7XG4gICAgICAgICAgdGhpcy5fZGVzdHJveUNhY2hlZERpc3BsYXlPYmplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlciA9IGRhdGEub3JpZ2luYWxSZW5kZXI7XG4gICAgICAgIHRoaXMucmVuZGVyQ2FudmFzID0gZGF0YS5vcmlnaW5hbFJlbmRlckNhbnZhcztcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZHMgPSBkYXRhLm9yaWdpbmFsQ2FsY3VsYXRlQm91bmRzO1xuICAgICAgICB0aGlzLmdldExvY2FsQm91bmRzID0gZGF0YS5vcmlnaW5hbEdldExvY2FsQm91bmRzO1xuICAgICAgICB0aGlzLmRlc3Ryb3kgPSBkYXRhLm9yaWdpbmFsRGVzdHJveTtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0gPSBkYXRhLm9yaWdpbmFsVXBkYXRlVHJhbnNmb3JtO1xuICAgICAgICB0aGlzLmNvbnRhaW5zUG9pbnQgPSBkYXRhLm9yaWdpbmFsQ29udGFpbnNQb2ludDtcbiAgICAgICAgdGhpcy5fbWFzayA9IGRhdGEub3JpZ2luYWxNYXNrO1xuICAgICAgICB0aGlzLmZpbHRlckFyZWEgPSBkYXRhLm9yaWdpbmFsRmlsdGVyQXJlYTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuZGlzcGxheS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fcmVuZGVyQ2FjaGVkID0gZnVuY3Rpb24gX3JlbmRlckNhY2hlZChyZW5kZXJlcikge1xuICBpZiAoIXRoaXMudmlzaWJsZSB8fCB0aGlzLndvcmxkQWxwaGEgPD0gMCB8fCAhdGhpcy5yZW5kZXJhYmxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0KHJlbmRlcmVyKTtcbiAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS50cmFuc2Zvcm0uX3dvcmxkSUQgPSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRDtcbiAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS53b3JsZEFscGhhID0gdGhpcy53b3JsZEFscGhhO1xuICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLl9yZW5kZXIocmVuZGVyZXIpO1xufTtcbmRpc3BsYXkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0ID0gZnVuY3Rpb24gX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0KHJlbmRlcmVyKSB7XG4gIGlmICh0aGlzLl9jYWNoZURhdGE/LnNwcml0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjYWNoZUFscGhhID0gdGhpcy5hbHBoYTtcbiAgdGhpcy5hbHBoYSA9IDE7XG4gIHJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XG4gIGNvbnN0IGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMobnVsbCwgdHJ1ZSkuY2xvbmUoKTtcbiAgaWYgKHRoaXMuZmlsdGVycz8ubGVuZ3RoKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMuZmlsdGVyc1swXS5wYWRkaW5nO1xuICAgIGJvdW5kcy5wYWQocGFkZGluZyk7XG4gIH1cbiAgYm91bmRzLmNlaWwoY29yZS5zZXR0aW5ncy5SRVNPTFVUSU9OKTtcbiAgY29uc3QgY2FjaGVkUmVuZGVyVGV4dHVyZSA9IHJlbmRlcmVyLnJlbmRlclRleHR1cmUuY3VycmVudDtcbiAgY29uc3QgY2FjaGVkU291cmNlRnJhbWUgPSByZW5kZXJlci5yZW5kZXJUZXh0dXJlLnNvdXJjZUZyYW1lLmNsb25lKCk7XG4gIGNvbnN0IGNhY2hlZERlc3RpbmF0aW9uRnJhbWUgPSByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmRlc3RpbmF0aW9uRnJhbWUuY2xvbmUoKTtcbiAgY29uc3QgY2FjaGVkUHJvamVjdGlvblRyYW5zZm9ybSA9IHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtO1xuICBjb25zdCByZW5kZXJUZXh0dXJlID0gY29yZS5SZW5kZXJUZXh0dXJlLmNyZWF0ZSh7XG4gICAgd2lkdGg6IGJvdW5kcy53aWR0aCxcbiAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHQsXG4gICAgcmVzb2x1dGlvbjogdGhpcy5jYWNoZUFzQml0bWFwUmVzb2x1dGlvbiB8fCByZW5kZXJlci5yZXNvbHV0aW9uLFxuICAgIG11bHRpc2FtcGxlOiB0aGlzLmNhY2hlQXNCaXRtYXBNdWx0aXNhbXBsZSA/PyByZW5kZXJlci5tdWx0aXNhbXBsZVxuICB9KTtcbiAgY29uc3QgdGV4dHVyZUNhY2hlSWQgPSBgY2FjaGVBc0JpdG1hcF8ke2NvcmUudXRpbHMudWlkKCl9YDtcbiAgdGhpcy5fY2FjaGVEYXRhLnRleHR1cmVDYWNoZUlkID0gdGV4dHVyZUNhY2hlSWQ7XG4gIGNvcmUuQmFzZVRleHR1cmUuYWRkVG9DYWNoZShyZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlLCB0ZXh0dXJlQ2FjaGVJZCk7XG4gIGNvcmUuVGV4dHVyZS5hZGRUb0NhY2hlKHJlbmRlclRleHR1cmUsIHRleHR1cmVDYWNoZUlkKTtcbiAgY29uc3QgbSA9IHRoaXMudHJhbnNmb3JtLmxvY2FsVHJhbnNmb3JtLmNvcHlUbyhfdGVtcE1hdHJpeCkuaW52ZXJ0KCkudHJhbnNsYXRlKC1ib3VuZHMueCwgLWJvdW5kcy55KTtcbiAgdGhpcy5yZW5kZXIgPSB0aGlzLl9jYWNoZURhdGEub3JpZ2luYWxSZW5kZXI7XG4gIHJlbmRlcmVyLnJlbmRlcih0aGlzLCB7IHJlbmRlclRleHR1cmUsIGNsZWFyOiB0cnVlLCB0cmFuc2Zvcm06IG0sIHNraXBVcGRhdGVUcmFuc2Zvcm06IGZhbHNlIH0pO1xuICByZW5kZXJlci5mcmFtZWJ1ZmZlci5ibGl0KCk7XG4gIHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtID0gY2FjaGVkUHJvamVjdGlvblRyYW5zZm9ybTtcbiAgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKGNhY2hlZFJlbmRlclRleHR1cmUsIGNhY2hlZFNvdXJjZUZyYW1lLCBjYWNoZWREZXN0aW5hdGlvbkZyYW1lKTtcbiAgdGhpcy5yZW5kZXIgPSB0aGlzLl9yZW5kZXJDYWNoZWQ7XG4gIHRoaXMudXBkYXRlVHJhbnNmb3JtID0gdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtO1xuICB0aGlzLmNhbGN1bGF0ZUJvdW5kcyA9IHRoaXMuX2NhbGN1bGF0ZUNhY2hlZEJvdW5kcztcbiAgdGhpcy5nZXRMb2NhbEJvdW5kcyA9IHRoaXMuX2dldENhY2hlZExvY2FsQm91bmRzO1xuICB0aGlzLl9tYXNrID0gbnVsbDtcbiAgdGhpcy5maWx0ZXJBcmVhID0gbnVsbDtcbiAgdGhpcy5hbHBoYSA9IGNhY2hlQWxwaGE7XG4gIGNvbnN0IGNhY2hlZFNwcml0ZSA9IG5ldyBzcHJpdGUuU3ByaXRlKHJlbmRlclRleHR1cmUpO1xuICBjYWNoZWRTcHJpdGUudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gIGNhY2hlZFNwcml0ZS5hbmNob3IueCA9IC0oYm91bmRzLnggLyBib3VuZHMud2lkdGgpO1xuICBjYWNoZWRTcHJpdGUuYW5jaG9yLnkgPSAtKGJvdW5kcy55IC8gYm91bmRzLmhlaWdodCk7XG4gIGNhY2hlZFNwcml0ZS5hbHBoYSA9IGNhY2hlQWxwaGE7XG4gIGNhY2hlZFNwcml0ZS5fYm91bmRzID0gdGhpcy5fYm91bmRzO1xuICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlID0gY2FjaGVkU3ByaXRlO1xuICB0aGlzLnRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMTtcbiAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgIHRoaXMuZW5hYmxlVGVtcFBhcmVudCgpO1xuICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgdGhpcy5kaXNhYmxlVGVtcFBhcmVudChudWxsKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICB9XG4gIHRoaXMuY29udGFpbnNQb2ludCA9IGNhY2hlZFNwcml0ZS5jb250YWluc1BvaW50LmJpbmQoY2FjaGVkU3ByaXRlKTtcbn07XG5kaXNwbGF5LkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9yZW5kZXJDYWNoZWRDYW52YXMgPSBmdW5jdGlvbiBfcmVuZGVyQ2FjaGVkQ2FudmFzKHJlbmRlcmVyKSB7XG4gIGlmICghdGhpcy52aXNpYmxlIHx8IHRoaXMud29ybGRBbHBoYSA8PSAwIHx8ICF0aGlzLnJlbmRlcmFibGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5faW5pdENhY2hlZERpc3BsYXlPYmplY3RDYW52YXMocmVuZGVyZXIpO1xuICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLndvcmxkQWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG4gIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUuX3JlbmRlckNhbnZhcyhyZW5kZXJlcik7XG59O1xuZGlzcGxheS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5faW5pdENhY2hlZERpc3BsYXlPYmplY3RDYW52YXMgPSBmdW5jdGlvbiBfaW5pdENhY2hlZERpc3BsYXlPYmplY3RDYW52YXMocmVuZGVyZXIpIHtcbiAgaWYgKHRoaXMuX2NhY2hlRGF0YT8uc3ByaXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMobnVsbCwgdHJ1ZSk7XG4gIGNvbnN0IGNhY2hlQWxwaGEgPSB0aGlzLmFscGhhO1xuICB0aGlzLmFscGhhID0gMTtcbiAgY29uc3QgY2FjaGVkUmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuY2FudmFzQ29udGV4dC5hY3RpdmVDb250ZXh0O1xuICBjb25zdCBjYWNoZWRQcm9qZWN0aW9uVHJhbnNmb3JtID0gcmVuZGVyZXIuX3Byb2pUcmFuc2Zvcm07XG4gIGJvdW5kcy5jZWlsKGNvcmUuc2V0dGluZ3MuUkVTT0xVVElPTik7XG4gIGNvbnN0IHJlbmRlclRleHR1cmUgPSBjb3JlLlJlbmRlclRleHR1cmUuY3JlYXRlKHsgd2lkdGg6IGJvdW5kcy53aWR0aCwgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0IH0pO1xuICBjb25zdCB0ZXh0dXJlQ2FjaGVJZCA9IGBjYWNoZUFzQml0bWFwXyR7Y29yZS51dGlscy51aWQoKX1gO1xuICB0aGlzLl9jYWNoZURhdGEudGV4dHVyZUNhY2hlSWQgPSB0ZXh0dXJlQ2FjaGVJZDtcbiAgY29yZS5CYXNlVGV4dHVyZS5hZGRUb0NhY2hlKHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUsIHRleHR1cmVDYWNoZUlkKTtcbiAgY29yZS5UZXh0dXJlLmFkZFRvQ2FjaGUocmVuZGVyVGV4dHVyZSwgdGV4dHVyZUNhY2hlSWQpO1xuICBjb25zdCBtID0gX3RlbXBNYXRyaXg7XG4gIHRoaXMudHJhbnNmb3JtLmxvY2FsVHJhbnNmb3JtLmNvcHlUbyhtKTtcbiAgbS5pbnZlcnQoKTtcbiAgbS50eCAtPSBib3VuZHMueDtcbiAgbS50eSAtPSBib3VuZHMueTtcbiAgdGhpcy5yZW5kZXJDYW52YXMgPSB0aGlzLl9jYWNoZURhdGEub3JpZ2luYWxSZW5kZXJDYW52YXM7XG4gIHJlbmRlcmVyLnJlbmRlcih0aGlzLCB7IHJlbmRlclRleHR1cmUsIGNsZWFyOiB0cnVlLCB0cmFuc2Zvcm06IG0sIHNraXBVcGRhdGVUcmFuc2Zvcm06IGZhbHNlIH0pO1xuICByZW5kZXJlci5jYW52YXNDb250ZXh0LmFjdGl2ZUNvbnRleHQgPSBjYWNoZWRSZW5kZXJUYXJnZXQ7XG4gIHJlbmRlcmVyLl9wcm9qVHJhbnNmb3JtID0gY2FjaGVkUHJvamVjdGlvblRyYW5zZm9ybTtcbiAgdGhpcy5yZW5kZXJDYW52YXMgPSB0aGlzLl9yZW5kZXJDYWNoZWRDYW52YXM7XG4gIHRoaXMudXBkYXRlVHJhbnNmb3JtID0gdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtO1xuICB0aGlzLmNhbGN1bGF0ZUJvdW5kcyA9IHRoaXMuX2NhbGN1bGF0ZUNhY2hlZEJvdW5kcztcbiAgdGhpcy5nZXRMb2NhbEJvdW5kcyA9IHRoaXMuX2dldENhY2hlZExvY2FsQm91bmRzO1xuICB0aGlzLl9tYXNrID0gbnVsbDtcbiAgdGhpcy5maWx0ZXJBcmVhID0gbnVsbDtcbiAgdGhpcy5hbHBoYSA9IGNhY2hlQWxwaGE7XG4gIGNvbnN0IGNhY2hlZFNwcml0ZSA9IG5ldyBzcHJpdGUuU3ByaXRlKHJlbmRlclRleHR1cmUpO1xuICBjYWNoZWRTcHJpdGUudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gIGNhY2hlZFNwcml0ZS5hbmNob3IueCA9IC0oYm91bmRzLnggLyBib3VuZHMud2lkdGgpO1xuICBjYWNoZWRTcHJpdGUuYW5jaG9yLnkgPSAtKGJvdW5kcy55IC8gYm91bmRzLmhlaWdodCk7XG4gIGNhY2hlZFNwcml0ZS5hbHBoYSA9IGNhY2hlQWxwaGE7XG4gIGNhY2hlZFNwcml0ZS5fYm91bmRzID0gdGhpcy5fYm91bmRzO1xuICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlID0gY2FjaGVkU3ByaXRlO1xuICB0aGlzLnRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMTtcbiAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgIHRoaXMucGFyZW50ID0gcmVuZGVyZXIuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xuICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gIH1cbiAgdGhpcy5jb250YWluc1BvaW50ID0gY2FjaGVkU3ByaXRlLmNvbnRhaW5zUG9pbnQuYmluZChjYWNoZWRTcHJpdGUpO1xufTtcbmRpc3BsYXkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2NhbGN1bGF0ZUNhY2hlZEJvdW5kcyA9IGZ1bmN0aW9uIF9jYWxjdWxhdGVDYWNoZWRCb3VuZHMoKSB7XG4gIHRoaXMuX2JvdW5kcy5jbGVhcigpO1xuICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLnRyYW5zZm9ybS5fd29ybGRJRCA9IHRoaXMudHJhbnNmb3JtLl93b3JsZElEO1xuICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLl9jYWxjdWxhdGVCb3VuZHMoKTtcbiAgdGhpcy5fYm91bmRzLnVwZGF0ZUlEID0gdGhpcy5fYm91bmRzSUQ7XG59O1xuZGlzcGxheS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fZ2V0Q2FjaGVkTG9jYWxCb3VuZHMgPSBmdW5jdGlvbiBfZ2V0Q2FjaGVkTG9jYWxCb3VuZHMoKSB7XG4gIHJldHVybiB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLmdldExvY2FsQm91bmRzKG51bGwpO1xufTtcbmRpc3BsYXkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2Rlc3Ryb3lDYWNoZWREaXNwbGF5T2JqZWN0ID0gZnVuY3Rpb24gX2Rlc3Ryb3lDYWNoZWREaXNwbGF5T2JqZWN0KCkge1xuICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLl90ZXh0dXJlLmRlc3Ryb3kodHJ1ZSk7XG4gIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUgPSBudWxsO1xuICBjb3JlLkJhc2VUZXh0dXJlLnJlbW92ZUZyb21DYWNoZSh0aGlzLl9jYWNoZURhdGEudGV4dHVyZUNhY2hlSWQpO1xuICBjb3JlLlRleHR1cmUucmVtb3ZlRnJvbUNhY2hlKHRoaXMuX2NhY2hlRGF0YS50ZXh0dXJlQ2FjaGVJZCk7XG4gIHRoaXMuX2NhY2hlRGF0YS50ZXh0dXJlQ2FjaGVJZCA9IG51bGw7XG59O1xuZGlzcGxheS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fY2FjaGVBc0JpdG1hcERlc3Ryb3kgPSBmdW5jdGlvbiBfY2FjaGVBc0JpdG1hcERlc3Ryb3kob3B0aW9ucykge1xuICB0aGlzLmNhY2hlQXNCaXRtYXAgPSBmYWxzZTtcbiAgdGhpcy5kZXN0cm95KG9wdGlvbnMpO1xufTtcblxuZXhwb3J0cy5DYWNoZURhdGEgPSBDYWNoZURhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRpc3BsYXkgPSByZXF1aXJlKCdAcGl4aS9kaXNwbGF5Jyk7XG5cbmRpc3BsYXkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUubmFtZSA9IG51bGw7XG5kaXNwbGF5LkNvbnRhaW5lci5wcm90b3R5cGUuZ2V0Q2hpbGRCeU5hbWUgPSBmdW5jdGlvbiBnZXRDaGlsZEJ5TmFtZShuYW1lLCBkZWVwKSB7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICBpZiAodGhpcy5jaGlsZHJlbltpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXTtcbiAgICB9XG4gIH1cbiAgaWYgKGRlZXApIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICBpZiAoIWNoaWxkLmdldENoaWxkQnlOYW1lKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0ID0gY2hpbGQuZ2V0Q2hpbGRCeU5hbWUobmFtZSwgdHJ1ZSk7XG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBkaXNwbGF5ID0gcmVxdWlyZSgnQHBpeGkvZGlzcGxheScpO1xuXG5kaXNwbGF5LkRpc3BsYXlPYmplY3QucHJvdG90eXBlLmdldEdsb2JhbFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0R2xvYmFsUG9zaXRpb24ocG9pbnQgPSBuZXcgY29yZS5Qb2ludCgpLCBza2lwVXBkYXRlID0gZmFsc2UpIHtcbiAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgdGhpcy5wYXJlbnQudG9HbG9iYWwodGhpcy5wb3NpdGlvbiwgcG9pbnQsIHNraXBVcGRhdGUpO1xuICB9IGVsc2Uge1xuICAgIHBvaW50LnggPSB0aGlzLnBvc2l0aW9uLng7XG4gICAgcG9pbnQueSA9IHRoaXMucG9zaXRpb24ueTtcbiAgfVxuICByZXR1cm4gcG9pbnQ7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xuXG5jbGFzcyBQYXJ0aWNsZUJ1ZmZlciB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMsIGR5bmFtaWNQcm9wZXJ0eUZsYWdzLCBzaXplKSB7XG4gICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBjb3JlLkdlb21ldHJ5KCk7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gW107XG4gICAgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsZXQgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgcHJvcGVydHkgPSB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IHByb3BlcnR5LmF0dHJpYnV0ZU5hbWUsXG4gICAgICAgIHNpemU6IHByb3BlcnR5LnNpemUsXG4gICAgICAgIHVwbG9hZEZ1bmN0aW9uOiBwcm9wZXJ0eS51cGxvYWRGdW5jdGlvbixcbiAgICAgICAgdHlwZTogcHJvcGVydHkudHlwZSB8fCBjb3JlLlRZUEVTLkZMT0FULFxuICAgICAgICBvZmZzZXQ6IHByb3BlcnR5Lm9mZnNldFxuICAgICAgfTtcbiAgICAgIGlmIChkeW5hbWljUHJvcGVydHlGbGFnc1tpXSkge1xuICAgICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnN0YXRpY1N0cmlkZSA9IDA7XG4gICAgdGhpcy5zdGF0aWNCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuc3RhdGljRGF0YSA9IG51bGw7XG4gICAgdGhpcy5zdGF0aWNEYXRhVWludDMyID0gbnVsbDtcbiAgICB0aGlzLmR5bmFtaWNTdHJpZGUgPSAwO1xuICAgIHRoaXMuZHluYW1pY0J1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5keW5hbWljRGF0YSA9IG51bGw7XG4gICAgdGhpcy5keW5hbWljRGF0YVVpbnQzMiA9IG51bGw7XG4gICAgdGhpcy5fdXBkYXRlSUQgPSAwO1xuICAgIHRoaXMuaW5pdEJ1ZmZlcnMoKTtcbiAgfVxuICBpbml0QnVmZmVycygpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG4gICAgbGV0IGR5bmFtaWNPZmZzZXQgPSAwO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBuZXcgY29yZS5CdWZmZXIoY29yZS51dGlscy5jcmVhdGVJbmRpY2VzRm9yUXVhZHModGhpcy5zaXplKSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZ2VvbWV0cnkuYWRkSW5kZXgodGhpcy5pbmRleEJ1ZmZlcik7XG4gICAgdGhpcy5keW5hbWljU3RyaWRlID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpcy5keW5hbWljUHJvcGVydGllc1tpXTtcbiAgICAgIHByb3BlcnR5Lm9mZnNldCA9IGR5bmFtaWNPZmZzZXQ7XG4gICAgICBkeW5hbWljT2Zmc2V0ICs9IHByb3BlcnR5LnNpemU7XG4gICAgICB0aGlzLmR5bmFtaWNTdHJpZGUgKz0gcHJvcGVydHkuc2l6ZTtcbiAgICB9XG4gICAgY29uc3QgZHluQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuc2l6ZSAqIHRoaXMuZHluYW1pY1N0cmlkZSAqIDQgKiA0KTtcbiAgICB0aGlzLmR5bmFtaWNEYXRhID0gbmV3IEZsb2F0MzJBcnJheShkeW5CdWZmZXIpO1xuICAgIHRoaXMuZHluYW1pY0RhdGFVaW50MzIgPSBuZXcgVWludDMyQXJyYXkoZHluQnVmZmVyKTtcbiAgICB0aGlzLmR5bmFtaWNCdWZmZXIgPSBuZXcgY29yZS5CdWZmZXIodGhpcy5keW5hbWljRGF0YSwgZmFsc2UsIGZhbHNlKTtcbiAgICBsZXQgc3RhdGljT2Zmc2V0ID0gMDtcbiAgICB0aGlzLnN0YXRpY1N0cmlkZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXRpY1Byb3BlcnRpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpcy5zdGF0aWNQcm9wZXJ0aWVzW2ldO1xuICAgICAgcHJvcGVydHkub2Zmc2V0ID0gc3RhdGljT2Zmc2V0O1xuICAgICAgc3RhdGljT2Zmc2V0ICs9IHByb3BlcnR5LnNpemU7XG4gICAgICB0aGlzLnN0YXRpY1N0cmlkZSArPSBwcm9wZXJ0eS5zaXplO1xuICAgIH1cbiAgICBjb25zdCBzdGF0QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuc2l6ZSAqIHRoaXMuc3RhdGljU3RyaWRlICogNCAqIDQpO1xuICAgIHRoaXMuc3RhdGljRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoc3RhdEJ1ZmZlcik7XG4gICAgdGhpcy5zdGF0aWNEYXRhVWludDMyID0gbmV3IFVpbnQzMkFycmF5KHN0YXRCdWZmZXIpO1xuICAgIHRoaXMuc3RhdGljQnVmZmVyID0gbmV3IGNvcmUuQnVmZmVyKHRoaXMuc3RhdGljRGF0YSwgdHJ1ZSwgZmFsc2UpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldO1xuICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKHByb3BlcnR5LmF0dHJpYnV0ZU5hbWUsIHRoaXMuZHluYW1pY0J1ZmZlciwgMCwgcHJvcGVydHkudHlwZSA9PT0gY29yZS5UWVBFUy5VTlNJR05FRF9CWVRFLCBwcm9wZXJ0eS50eXBlLCB0aGlzLmR5bmFtaWNTdHJpZGUgKiA0LCBwcm9wZXJ0eS5vZmZzZXQgKiA0KTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXRpY1Byb3BlcnRpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpcy5zdGF0aWNQcm9wZXJ0aWVzW2ldO1xuICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKHByb3BlcnR5LmF0dHJpYnV0ZU5hbWUsIHRoaXMuc3RhdGljQnVmZmVyLCAwLCBwcm9wZXJ0eS50eXBlID09PSBjb3JlLlRZUEVTLlVOU0lHTkVEX0JZVEUsIHByb3BlcnR5LnR5cGUsIHRoaXMuc3RhdGljU3RyaWRlICogNCwgcHJvcGVydHkub2Zmc2V0ICogNCk7XG4gICAgfVxuICB9XG4gIHVwbG9hZER5bmFtaWMoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldO1xuICAgICAgcHJvcGVydHkudXBsb2FkRnVuY3Rpb24oY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgcHJvcGVydHkudHlwZSA9PT0gY29yZS5UWVBFUy5VTlNJR05FRF9CWVRFID8gdGhpcy5keW5hbWljRGF0YVVpbnQzMiA6IHRoaXMuZHluYW1pY0RhdGEsIHRoaXMuZHluYW1pY1N0cmlkZSwgcHJvcGVydHkub2Zmc2V0KTtcbiAgICB9XG4gICAgdGhpcy5keW5hbWljQnVmZmVyLl91cGRhdGVJRCsrO1xuICB9XG4gIHVwbG9hZFN0YXRpYyhjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXRpY1Byb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpcy5zdGF0aWNQcm9wZXJ0aWVzW2ldO1xuICAgICAgcHJvcGVydHkudXBsb2FkRnVuY3Rpb24oY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgcHJvcGVydHkudHlwZSA9PT0gY29yZS5UWVBFUy5VTlNJR05FRF9CWVRFID8gdGhpcy5zdGF0aWNEYXRhVWludDMyIDogdGhpcy5zdGF0aWNEYXRhLCB0aGlzLnN0YXRpY1N0cmlkZSwgcHJvcGVydHkub2Zmc2V0KTtcbiAgICB9XG4gICAgdGhpcy5zdGF0aWNCdWZmZXIuX3VwZGF0ZUlEKys7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gbnVsbDtcbiAgICB0aGlzLmR5bmFtaWNCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuZHluYW1pY0RhdGEgPSBudWxsO1xuICAgIHRoaXMuZHluYW1pY0RhdGFVaW50MzIgPSBudWxsO1xuICAgIHRoaXMuc3RhdGljUHJvcGVydGllcyA9IG51bGw7XG4gICAgdGhpcy5zdGF0aWNCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuc3RhdGljRGF0YSA9IG51bGw7XG4gICAgdGhpcy5zdGF0aWNEYXRhVWludDMyID0gbnVsbDtcbiAgICB0aGlzLmdlb21ldHJ5LmRlc3Ryb3koKTtcbiAgfVxufVxuXG5leHBvcnRzLlBhcnRpY2xlQnVmZmVyID0gUGFydGljbGVCdWZmZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXJ0aWNsZUJ1ZmZlci5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgZGlzcGxheSA9IHJlcXVpcmUoJ0BwaXhpL2Rpc3BsYXknKTtcblxuY2xhc3MgUGFydGljbGVDb250YWluZXIgZXh0ZW5kcyBkaXNwbGF5LkNvbnRhaW5lciB7XG4gIGNvbnN0cnVjdG9yKG1heFNpemUgPSAxNTAwLCBwcm9wZXJ0aWVzLCBiYXRjaFNpemUgPSAxNjM4NCwgYXV0b1Jlc2l6ZSA9IGZhbHNlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBtYXhCYXRjaFNpemUgPSAxNjM4NDtcbiAgICBpZiAoYmF0Y2hTaXplID4gbWF4QmF0Y2hTaXplKSB7XG4gICAgICBiYXRjaFNpemUgPSBtYXhCYXRjaFNpemU7XG4gICAgfVxuICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBbZmFsc2UsIHRydWUsIGZhbHNlLCBmYWxzZSwgZmFsc2VdO1xuICAgIHRoaXMuX21heFNpemUgPSBtYXhTaXplO1xuICAgIHRoaXMuX2JhdGNoU2l6ZSA9IGJhdGNoU2l6ZTtcbiAgICB0aGlzLl9idWZmZXJzID0gbnVsbDtcbiAgICB0aGlzLl9idWZmZXJVcGRhdGVJRHMgPSBbXTtcbiAgICB0aGlzLl91cGRhdGVJRCA9IDA7XG4gICAgdGhpcy5pbnRlcmFjdGl2ZUNoaWxkcmVuID0gZmFsc2U7XG4gICAgdGhpcy5ibGVuZE1vZGUgPSBjb3JlLkJMRU5EX01PREVTLk5PUk1BTDtcbiAgICB0aGlzLmF1dG9SZXNpemUgPSBhdXRvUmVzaXplO1xuICAgIHRoaXMucm91bmRQaXhlbHMgPSB0cnVlO1xuICAgIHRoaXMuYmFzZVRleHR1cmUgPSBudWxsO1xuICAgIHRoaXMuc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcbiAgICB0aGlzLl90aW50Q29sb3IgPSBuZXcgY29yZS5Db2xvcigwKTtcbiAgICB0aGlzLnRpbnRSZ2IgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgIHRoaXMudGludCA9IDE2Nzc3MjE1O1xuICB9XG4gIHNldFByb3BlcnRpZXMocHJvcGVydGllcykge1xuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICB0aGlzLl9wcm9wZXJ0aWVzWzBdID0gXCJ2ZXJ0aWNlc1wiIGluIHByb3BlcnRpZXMgfHwgXCJzY2FsZVwiIGluIHByb3BlcnRpZXMgPyAhIXByb3BlcnRpZXMudmVydGljZXMgfHwgISFwcm9wZXJ0aWVzLnNjYWxlIDogdGhpcy5fcHJvcGVydGllc1swXTtcbiAgICAgIHRoaXMuX3Byb3BlcnRpZXNbMV0gPSBcInBvc2l0aW9uXCIgaW4gcHJvcGVydGllcyA/ICEhcHJvcGVydGllcy5wb3NpdGlvbiA6IHRoaXMuX3Byb3BlcnRpZXNbMV07XG4gICAgICB0aGlzLl9wcm9wZXJ0aWVzWzJdID0gXCJyb3RhdGlvblwiIGluIHByb3BlcnRpZXMgPyAhIXByb3BlcnRpZXMucm90YXRpb24gOiB0aGlzLl9wcm9wZXJ0aWVzWzJdO1xuICAgICAgdGhpcy5fcHJvcGVydGllc1szXSA9IFwidXZzXCIgaW4gcHJvcGVydGllcyA/ICEhcHJvcGVydGllcy51dnMgOiB0aGlzLl9wcm9wZXJ0aWVzWzNdO1xuICAgICAgdGhpcy5fcHJvcGVydGllc1s0XSA9IFwidGludFwiIGluIHByb3BlcnRpZXMgfHwgXCJhbHBoYVwiIGluIHByb3BlcnRpZXMgPyAhIXByb3BlcnRpZXMudGludCB8fCAhIXByb3BlcnRpZXMuYWxwaGEgOiB0aGlzLl9wcm9wZXJ0aWVzWzRdO1xuICAgIH1cbiAgfVxuICB1cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XG4gIH1cbiAgZ2V0IHRpbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbnRDb2xvci52YWx1ZTtcbiAgfVxuICBzZXQgdGludCh2YWx1ZSkge1xuICAgIHRoaXMuX3RpbnRDb2xvci5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgdGhpcy5fdGludENvbG9yLnRvUmdiQXJyYXkodGhpcy50aW50UmdiKTtcbiAgfVxuICByZW5kZXIocmVuZGVyZXIpIHtcbiAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCB0aGlzLndvcmxkQWxwaGEgPD0gMCB8fCAhdGhpcy5jaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMucmVuZGVyYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuYmFzZVRleHR1cmUpIHtcbiAgICAgIHRoaXMuYmFzZVRleHR1cmUgPSB0aGlzLmNoaWxkcmVuWzBdLl90ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgaWYgKCF0aGlzLmJhc2VUZXh0dXJlLnZhbGlkKSB7XG4gICAgICAgIHRoaXMuYmFzZVRleHR1cmUub25jZShcInVwZGF0ZVwiLCAoKSA9PiB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoMCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJlci5iYXRjaC5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zLnBhcnRpY2xlKTtcbiAgICByZW5kZXJlci5wbHVnaW5zLnBhcnRpY2xlLnJlbmRlcih0aGlzKTtcbiAgfVxuICBvbkNoaWxkcmVuQ2hhbmdlKHNtYWxsZXN0Q2hpbGRJbmRleCkge1xuICAgIGNvbnN0IGJ1ZmZlckluZGV4ID0gTWF0aC5mbG9vcihzbWFsbGVzdENoaWxkSW5kZXggLyB0aGlzLl9iYXRjaFNpemUpO1xuICAgIHdoaWxlICh0aGlzLl9idWZmZXJVcGRhdGVJRHMubGVuZ3RoIDwgYnVmZmVySW5kZXgpIHtcbiAgICAgIHRoaXMuX2J1ZmZlclVwZGF0ZUlEcy5wdXNoKDApO1xuICAgIH1cbiAgICB0aGlzLl9idWZmZXJVcGRhdGVJRHNbYnVmZmVySW5kZXhdID0gKyt0aGlzLl91cGRhdGVJRDtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2J1ZmZlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyc1tpXS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9idWZmZXJzID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9wcm9wZXJ0aWVzID0gbnVsbDtcbiAgICB0aGlzLl9idWZmZXJzID0gbnVsbDtcbiAgICB0aGlzLl9idWZmZXJVcGRhdGVJRHMgPSBudWxsO1xuICB9XG59XG5cbmV4cG9ydHMuUGFydGljbGVDb250YWluZXIgPSBQYXJ0aWNsZUNvbnRhaW5lcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhcnRpY2xlQ29udGFpbmVyLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBQYXJ0aWNsZUJ1ZmZlciA9IHJlcXVpcmUoJy4vUGFydGljbGVCdWZmZXIuanMnKTtcbnZhciBwYXJ0aWNsZXMkMSA9IHJlcXVpcmUoJy4vcGFydGljbGVzLmpzJyk7XG52YXIgcGFydGljbGVzID0gcmVxdWlyZSgnLi9wYXJ0aWNsZXMyLmpzJyk7XG5cbmNsYXNzIFBhcnRpY2xlUmVuZGVyZXIgZXh0ZW5kcyBjb3JlLk9iamVjdFJlbmRlcmVyIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICBzdXBlcihyZW5kZXJlcik7XG4gICAgdGhpcy5zaGFkZXIgPSBudWxsO1xuICAgIHRoaXMucHJvcGVydGllcyA9IG51bGw7XG4gICAgdGhpcy50ZW1wTWF0cml4ID0gbmV3IGNvcmUuTWF0cml4KCk7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gW1xuICAgICAge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lOiBcImFWZXJ0ZXhQb3NpdGlvblwiLFxuICAgICAgICBzaXplOiAyLFxuICAgICAgICB1cGxvYWRGdW5jdGlvbjogdGhpcy51cGxvYWRWZXJ0aWNlcyxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lOiBcImFQb3NpdGlvbkNvb3JkXCIsXG4gICAgICAgIHNpemU6IDIsXG4gICAgICAgIHVwbG9hZEZ1bmN0aW9uOiB0aGlzLnVwbG9hZFBvc2l0aW9uLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IFwiYVJvdGF0aW9uXCIsXG4gICAgICAgIHNpemU6IDEsXG4gICAgICAgIHVwbG9hZEZ1bmN0aW9uOiB0aGlzLnVwbG9hZFJvdGF0aW9uLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IFwiYVRleHR1cmVDb29yZFwiLFxuICAgICAgICBzaXplOiAyLFxuICAgICAgICB1cGxvYWRGdW5jdGlvbjogdGhpcy51cGxvYWRVdnMsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogXCJhQ29sb3JcIixcbiAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgdHlwZTogY29yZS5UWVBFUy5VTlNJR05FRF9CWVRFLFxuICAgICAgICB1cGxvYWRGdW5jdGlvbjogdGhpcy51cGxvYWRUaW50LFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH1cbiAgICBdO1xuICAgIHRoaXMuc2hhZGVyID0gY29yZS5TaGFkZXIuZnJvbShwYXJ0aWNsZXNbXCJkZWZhdWx0XCJdLCBwYXJ0aWNsZXMkMVtcImRlZmF1bHRcIl0sIHt9KTtcbiAgICB0aGlzLnN0YXRlID0gY29yZS5TdGF0ZS5mb3IyZCgpO1xuICB9XG4gIHJlbmRlcihjb250YWluZXIpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGNvbnRhaW5lci5jaGlsZHJlbjtcbiAgICBjb25zdCBtYXhTaXplID0gY29udGFpbmVyLl9tYXhTaXplO1xuICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGNvbnRhaW5lci5fYmF0Y2hTaXplO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBsZXQgdG90YWxDaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBpZiAodG90YWxDaGlsZHJlbiA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodG90YWxDaGlsZHJlbiA+IG1heFNpemUgJiYgIWNvbnRhaW5lci5hdXRvUmVzaXplKSB7XG4gICAgICB0b3RhbENoaWxkcmVuID0gbWF4U2l6ZTtcbiAgICB9XG4gICAgbGV0IGJ1ZmZlcnMgPSBjb250YWluZXIuX2J1ZmZlcnM7XG4gICAgaWYgKCFidWZmZXJzKSB7XG4gICAgICBidWZmZXJzID0gY29udGFpbmVyLl9idWZmZXJzID0gdGhpcy5nZW5lcmF0ZUJ1ZmZlcnMoY29udGFpbmVyKTtcbiAgICB9XG4gICAgY29uc3QgYmFzZVRleHR1cmUgPSBjaGlsZHJlblswXS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICBjb25zdCBwcmVtdWx0aXBsaWVkID0gYmFzZVRleHR1cmUuYWxwaGFNb2RlID4gMDtcbiAgICB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IGNvcmUudXRpbHMuY29ycmVjdEJsZW5kTW9kZShjb250YWluZXIuYmxlbmRNb2RlLCBwcmVtdWx0aXBsaWVkKTtcbiAgICByZW5kZXJlci5zdGF0ZS5zZXQodGhpcy5zdGF0ZSk7XG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nbDtcbiAgICBjb25zdCBtID0gY29udGFpbmVyLndvcmxkVHJhbnNmb3JtLmNvcHlUbyh0aGlzLnRlbXBNYXRyaXgpO1xuICAgIG0ucHJlcGVuZChyZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICB0aGlzLnNoYWRlci51bmlmb3Jtcy50cmFuc2xhdGlvbk1hdHJpeCA9IG0udG9BcnJheSh0cnVlKTtcbiAgICB0aGlzLnNoYWRlci51bmlmb3Jtcy51Q29sb3IgPSBjb3JlLkNvbG9yLnNoYXJlZC5zZXRWYWx1ZShjb250YWluZXIudGludFJnYikucHJlbXVsdGlwbHkoY29udGFpbmVyLndvcmxkQWxwaGEsIHByZW11bHRpcGxpZWQpLnRvQXJyYXkodGhpcy5zaGFkZXIudW5pZm9ybXMudUNvbG9yKTtcbiAgICB0aGlzLnNoYWRlci51bmlmb3Jtcy51U2FtcGxlciA9IGJhc2VUZXh0dXJlO1xuICAgIHRoaXMucmVuZGVyZXIuc2hhZGVyLmJpbmQodGhpcy5zaGFkZXIpO1xuICAgIGxldCB1cGRhdGVTdGF0aWMgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCB0b3RhbENoaWxkcmVuOyBpICs9IGJhdGNoU2l6ZSwgaiArPSAxKSB7XG4gICAgICBsZXQgYW1vdW50ID0gdG90YWxDaGlsZHJlbiAtIGk7XG4gICAgICBpZiAoYW1vdW50ID4gYmF0Y2hTaXplKSB7XG4gICAgICAgIGFtb3VudCA9IGJhdGNoU2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChqID49IGJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICAgIGJ1ZmZlcnMucHVzaCh0aGlzLl9nZW5lcmF0ZU9uZU1vcmVCdWZmZXIoY29udGFpbmVyKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJzW2pdO1xuICAgICAgYnVmZmVyLnVwbG9hZER5bmFtaWMoY2hpbGRyZW4sIGksIGFtb3VudCk7XG4gICAgICBjb25zdCBiaWQgPSBjb250YWluZXIuX2J1ZmZlclVwZGF0ZUlEc1tqXSB8fCAwO1xuICAgICAgdXBkYXRlU3RhdGljID0gdXBkYXRlU3RhdGljIHx8IGJ1ZmZlci5fdXBkYXRlSUQgPCBiaWQ7XG4gICAgICBpZiAodXBkYXRlU3RhdGljKSB7XG4gICAgICAgIGJ1ZmZlci5fdXBkYXRlSUQgPSBjb250YWluZXIuX3VwZGF0ZUlEO1xuICAgICAgICBidWZmZXIudXBsb2FkU3RhdGljKGNoaWxkcmVuLCBpLCBhbW91bnQpO1xuICAgICAgfVxuICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZChidWZmZXIuZ2VvbWV0cnkpO1xuICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgYW1vdW50ICogNiwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuICAgIH1cbiAgfVxuICBnZW5lcmF0ZUJ1ZmZlcnMoY29udGFpbmVyKSB7XG4gICAgY29uc3QgYnVmZmVycyA9IFtdO1xuICAgIGNvbnN0IHNpemUgPSBjb250YWluZXIuX21heFNpemU7XG4gICAgY29uc3QgYmF0Y2hTaXplID0gY29udGFpbmVyLl9iYXRjaFNpemU7XG4gICAgY29uc3QgZHluYW1pY1Byb3BlcnR5RmxhZ3MgPSBjb250YWluZXIuX3Byb3BlcnRpZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpICs9IGJhdGNoU2l6ZSkge1xuICAgICAgYnVmZmVycy5wdXNoKG5ldyBQYXJ0aWNsZUJ1ZmZlci5QYXJ0aWNsZUJ1ZmZlcih0aGlzLnByb3BlcnRpZXMsIGR5bmFtaWNQcm9wZXJ0eUZsYWdzLCBiYXRjaFNpemUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcnM7XG4gIH1cbiAgX2dlbmVyYXRlT25lTW9yZUJ1ZmZlcihjb250YWluZXIpIHtcbiAgICBjb25zdCBiYXRjaFNpemUgPSBjb250YWluZXIuX2JhdGNoU2l6ZTtcbiAgICBjb25zdCBkeW5hbWljUHJvcGVydHlGbGFncyA9IGNvbnRhaW5lci5fcHJvcGVydGllcztcbiAgICByZXR1cm4gbmV3IFBhcnRpY2xlQnVmZmVyLlBhcnRpY2xlQnVmZmVyKHRoaXMucHJvcGVydGllcywgZHluYW1pY1Byb3BlcnR5RmxhZ3MsIGJhdGNoU2l6ZSk7XG4gIH1cbiAgdXBsb2FkVmVydGljZXMoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KSB7XG4gICAgbGV0IHcwID0gMDtcbiAgICBsZXQgdzEgPSAwO1xuICAgIGxldCBoMCA9IDA7XG4gICAgbGV0IGgxID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFtb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBzcHJpdGUgPSBjaGlsZHJlbltzdGFydEluZGV4ICsgaV07XG4gICAgICBjb25zdCB0ZXh0dXJlID0gc3ByaXRlLl90ZXh0dXJlO1xuICAgICAgY29uc3Qgc3ggPSBzcHJpdGUuc2NhbGUueDtcbiAgICAgIGNvbnN0IHN5ID0gc3ByaXRlLnNjYWxlLnk7XG4gICAgICBjb25zdCB0cmltID0gdGV4dHVyZS50cmltO1xuICAgICAgY29uc3Qgb3JpZyA9IHRleHR1cmUub3JpZztcbiAgICAgIGlmICh0cmltKSB7XG4gICAgICAgIHcxID0gdHJpbS54IC0gc3ByaXRlLmFuY2hvci54ICogb3JpZy53aWR0aDtcbiAgICAgICAgdzAgPSB3MSArIHRyaW0ud2lkdGg7XG4gICAgICAgIGgxID0gdHJpbS55IC0gc3ByaXRlLmFuY2hvci55ICogb3JpZy5oZWlnaHQ7XG4gICAgICAgIGgwID0gaDEgKyB0cmltLmhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHcwID0gb3JpZy53aWR0aCAqICgxIC0gc3ByaXRlLmFuY2hvci54KTtcbiAgICAgICAgdzEgPSBvcmlnLndpZHRoICogLXNwcml0ZS5hbmNob3IueDtcbiAgICAgICAgaDAgPSBvcmlnLmhlaWdodCAqICgxIC0gc3ByaXRlLmFuY2hvci55KTtcbiAgICAgICAgaDEgPSBvcmlnLmhlaWdodCAqIC1zcHJpdGUuYW5jaG9yLnk7XG4gICAgICB9XG4gICAgICBhcnJheVtvZmZzZXRdID0gdzEgKiBzeDtcbiAgICAgIGFycmF5W29mZnNldCArIDFdID0gaDEgKiBzeTtcbiAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZV0gPSB3MCAqIHN4O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSBoMSAqIHN5O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMl0gPSB3MCAqIHN4O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMiArIDFdID0gaDAgKiBzeTtcbiAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDNdID0gdzEgKiBzeDtcbiAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDMgKyAxXSA9IGgwICogc3k7XG4gICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcbiAgICB9XG4gIH1cbiAgdXBsb2FkUG9zaXRpb24oY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuICAgICAgY29uc3Qgc3ByaXRlUG9zaXRpb24gPSBjaGlsZHJlbltzdGFydEluZGV4ICsgaV0ucG9zaXRpb247XG4gICAgICBhcnJheVtvZmZzZXRdID0gc3ByaXRlUG9zaXRpb24ueDtcbiAgICAgIGFycmF5W29mZnNldCArIDFdID0gc3ByaXRlUG9zaXRpb24ueTtcbiAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZV0gPSBzcHJpdGVQb3NpdGlvbi54O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSBzcHJpdGVQb3NpdGlvbi55O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMl0gPSBzcHJpdGVQb3NpdGlvbi54O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMiArIDFdID0gc3ByaXRlUG9zaXRpb24ueTtcbiAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDNdID0gc3ByaXRlUG9zaXRpb24ueDtcbiAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDMgKyAxXSA9IHNwcml0ZVBvc2l0aW9uLnk7XG4gICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcbiAgICB9XG4gIH1cbiAgdXBsb2FkUm90YXRpb24oY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuICAgICAgY29uc3Qgc3ByaXRlUm90YXRpb24gPSBjaGlsZHJlbltzdGFydEluZGV4ICsgaV0ucm90YXRpb247XG4gICAgICBhcnJheVtvZmZzZXRdID0gc3ByaXRlUm90YXRpb247XG4gICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gc3ByaXRlUm90YXRpb247XG4gICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IHNwcml0ZVJvdGF0aW9uO1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogM10gPSBzcHJpdGVSb3RhdGlvbjtcbiAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xuICAgIH1cbiAgfVxuICB1cGxvYWRVdnMoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbW91bnQ7ICsraSkge1xuICAgICAgY29uc3QgdGV4dHVyZVV2cyA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXS5fdGV4dHVyZS5fdXZzO1xuICAgICAgaWYgKHRleHR1cmVVdnMpIHtcbiAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IHRleHR1cmVVdnMueDA7XG4gICAgICAgIGFycmF5W29mZnNldCArIDFdID0gdGV4dHVyZVV2cy55MDtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHRleHR1cmVVdnMueDE7XG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSArIDFdID0gdGV4dHVyZVV2cy55MTtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMl0gPSB0ZXh0dXJlVXZzLngyO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyICsgMV0gPSB0ZXh0dXJlVXZzLnkyO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzXSA9IHRleHR1cmVVdnMueDM7XG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDMgKyAxXSA9IHRleHR1cmVVdnMueTM7XG4gICAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IDA7XG4gICAgICAgIGFycmF5W29mZnNldCArIDFdID0gMDtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IDA7XG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSArIDFdID0gMDtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMl0gPSAwO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyICsgMV0gPSAwO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzXSA9IDA7XG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDMgKyAxXSA9IDA7XG4gICAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB1cGxvYWRUaW50KGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIGFycmF5LCBzdHJpZGUsIG9mZnNldCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW1vdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHNwcml0ZSA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNvcmUuQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHNwcml0ZS5fdGludFJHQikudG9QcmVtdWx0aXBsaWVkKHNwcml0ZS5hbHBoYSwgc3ByaXRlLnRleHR1cmUuYmFzZVRleHR1cmUuYWxwaGFNb2RlID4gMCk7XG4gICAgICBhcnJheVtvZmZzZXRdID0gcmVzdWx0O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHJlc3VsdDtcbiAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDJdID0gcmVzdWx0O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogM10gPSByZXN1bHQ7XG4gICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgaWYgKHRoaXMuc2hhZGVyKSB7XG4gICAgICB0aGlzLnNoYWRlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMudGVtcE1hdHJpeCA9IG51bGw7XG4gIH1cbn1cblBhcnRpY2xlUmVuZGVyZXIuZXh0ZW5zaW9uID0ge1xuICBuYW1lOiBcInBhcnRpY2xlXCIsXG4gIHR5cGU6IGNvcmUuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclBsdWdpblxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQoUGFydGljbGVSZW5kZXJlcik7XG5cbmV4cG9ydHMuUGFydGljbGVSZW5kZXJlciA9IFBhcnRpY2xlUmVuZGVyZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXJ0aWNsZVJlbmRlcmVyLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgUGFydGljbGVDb250YWluZXIgPSByZXF1aXJlKCcuL1BhcnRpY2xlQ29udGFpbmVyLmpzJyk7XG52YXIgUGFydGljbGVSZW5kZXJlciA9IHJlcXVpcmUoJy4vUGFydGljbGVSZW5kZXJlci5qcycpO1xuXG5cblxuZXhwb3J0cy5QYXJ0aWNsZUNvbnRhaW5lciA9IFBhcnRpY2xlQ29udGFpbmVyLlBhcnRpY2xlQ29udGFpbmVyO1xuZXhwb3J0cy5QYXJ0aWNsZVJlbmRlcmVyID0gUGFydGljbGVSZW5kZXJlci5QYXJ0aWNsZVJlbmRlcmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBmcmFnbWVudCA9IFwidmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG5cXG52b2lkIG1haW4odm9pZCl7XFxuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdkNvbG9yO1xcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG59XCI7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZnJhZ21lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJ0aWNsZXMuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB2ZXJ0ZXggPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcXG5cXG5hdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb25Db29yZDtcXG5hdHRyaWJ1dGUgZmxvYXQgYVJvdGF0aW9uO1xcblxcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcXG51bmlmb3JtIHZlYzQgdUNvbG9yO1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpe1xcbiAgICBmbG9hdCB4ID0gKGFWZXJ0ZXhQb3NpdGlvbi54KSAqIGNvcyhhUm90YXRpb24pIC0gKGFWZXJ0ZXhQb3NpdGlvbi55KSAqIHNpbihhUm90YXRpb24pO1xcbiAgICBmbG9hdCB5ID0gKGFWZXJ0ZXhQb3NpdGlvbi54KSAqIHNpbihhUm90YXRpb24pICsgKGFWZXJ0ZXhQb3NpdGlvbi55KSAqIGNvcyhhUm90YXRpb24pO1xcblxcbiAgICB2ZWMyIHYgPSB2ZWMyKHgsIHkpO1xcbiAgICB2ID0gdiArIGFQb3NpdGlvbkNvb3JkO1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyh2LCAxLjApKS54eSwgMC4wLCAxLjApO1xcblxcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG4gICAgdkNvbG9yID0gYUNvbG9yICogdUNvbG9yO1xcbn1cXG5cIjtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2ZXJ0ZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJ0aWNsZXMyLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBkaXNwbGF5ID0gcmVxdWlyZSgnQHBpeGkvZGlzcGxheScpO1xudmFyIHRleHQgPSByZXF1aXJlKCdAcGl4aS90ZXh0Jyk7XG52YXIgQ291bnRMaW1pdGVyID0gcmVxdWlyZSgnLi9Db3VudExpbWl0ZXIuanMnKTtcblxuZnVuY3Rpb24gZmluZE11bHRpcGxlQmFzZVRleHR1cmVzKGl0ZW0sIHF1ZXVlKSB7XG4gIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKGl0ZW0/Ll90ZXh0dXJlcz8ubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtLl90ZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGl0ZW0uX3RleHR1cmVzW2ldIGluc3RhbmNlb2YgY29yZS5UZXh0dXJlKSB7XG4gICAgICAgIGNvbnN0IGJhc2VUZXh0dXJlID0gaXRlbS5fdGV4dHVyZXNbaV0uYmFzZVRleHR1cmU7XG4gICAgICAgIGlmICghcXVldWUuaW5jbHVkZXMoYmFzZVRleHR1cmUpKSB7XG4gICAgICAgICAgcXVldWUucHVzaChiYXNlVGV4dHVyZSk7XG4gICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZmluZEJhc2VUZXh0dXJlKGl0ZW0sIHF1ZXVlKSB7XG4gIGlmIChpdGVtLmJhc2VUZXh0dXJlIGluc3RhbmNlb2YgY29yZS5CYXNlVGV4dHVyZSkge1xuICAgIGNvbnN0IHRleHR1cmUgPSBpdGVtLmJhc2VUZXh0dXJlO1xuICAgIGlmICghcXVldWUuaW5jbHVkZXModGV4dHVyZSkpIHtcbiAgICAgIHF1ZXVlLnB1c2godGV4dHVyZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGZpbmRUZXh0dXJlKGl0ZW0sIHF1ZXVlKSB7XG4gIGlmIChpdGVtLl90ZXh0dXJlICYmIGl0ZW0uX3RleHR1cmUgaW5zdGFuY2VvZiBjb3JlLlRleHR1cmUpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gaXRlbS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICBpZiAoIXF1ZXVlLmluY2x1ZGVzKHRleHR1cmUpKSB7XG4gICAgICBxdWV1ZS5wdXNoKHRleHR1cmUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkcmF3VGV4dChfaGVscGVyLCBpdGVtKSB7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgdGV4dC5UZXh0KSB7XG4gICAgaXRlbS51cGRhdGVUZXh0KHRydWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRleHRTdHlsZShfaGVscGVyLCBpdGVtKSB7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgdGV4dC5UZXh0U3R5bGUpIHtcbiAgICBjb25zdCBmb250ID0gaXRlbS50b0ZvbnRTdHJpbmcoKTtcbiAgICB0ZXh0LlRleHRNZXRyaWNzLm1lYXN1cmVGb250KGZvbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGZpbmRUZXh0KGl0ZW0sIHF1ZXVlKSB7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgdGV4dC5UZXh0KSB7XG4gICAgaWYgKCFxdWV1ZS5pbmNsdWRlcyhpdGVtLnN0eWxlKSkge1xuICAgICAgcXVldWUucHVzaChpdGVtLnN0eWxlKTtcbiAgICB9XG4gICAgaWYgKCFxdWV1ZS5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgcXVldWUucHVzaChpdGVtKTtcbiAgICB9XG4gICAgY29uc3QgdGV4dHVyZSA9IGl0ZW0uX3RleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgaWYgKCFxdWV1ZS5pbmNsdWRlcyh0ZXh0dXJlKSkge1xuICAgICAgcXVldWUucHVzaCh0ZXh0dXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZmluZFRleHRTdHlsZShpdGVtLCBxdWV1ZSkge1xuICBpZiAoaXRlbSBpbnN0YW5jZW9mIHRleHQuVGV4dFN0eWxlKSB7XG4gICAgaWYgKCFxdWV1ZS5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgcXVldWUucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgX0Jhc2VQcmVwYXJlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMubGltaXRlciA9IG5ldyBDb3VudExpbWl0ZXIuQ291bnRMaW1pdGVyKF9CYXNlUHJlcGFyZS51cGxvYWRzUGVyRnJhbWUpO1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLnVwbG9hZEhvb2tIZWxwZXIgPSBudWxsO1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB0aGlzLmFkZEhvb2tzID0gW107XG4gICAgdGhpcy51cGxvYWRIb29rcyA9IFtdO1xuICAgIHRoaXMuY29tcGxldGVzID0gW107XG4gICAgdGhpcy50aWNraW5nID0gZmFsc2U7XG4gICAgdGhpcy5kZWxheWVkVGljayA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5xdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnByZXBhcmVJdGVtcygpO1xuICAgIH07XG4gICAgdGhpcy5yZWdpc3RlckZpbmRIb29rKGZpbmRUZXh0KTtcbiAgICB0aGlzLnJlZ2lzdGVyRmluZEhvb2soZmluZFRleHRTdHlsZSk7XG4gICAgdGhpcy5yZWdpc3RlckZpbmRIb29rKGZpbmRNdWx0aXBsZUJhc2VUZXh0dXJlcyk7XG4gICAgdGhpcy5yZWdpc3RlckZpbmRIb29rKGZpbmRCYXNlVGV4dHVyZSk7XG4gICAgdGhpcy5yZWdpc3RlckZpbmRIb29rKGZpbmRUZXh0dXJlKTtcbiAgICB0aGlzLnJlZ2lzdGVyVXBsb2FkSG9vayhkcmF3VGV4dCk7XG4gICAgdGhpcy5yZWdpc3RlclVwbG9hZEhvb2soY2FsY3VsYXRlVGV4dFN0eWxlKTtcbiAgfVxuICB1cGxvYWQoaXRlbSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5hZGQoaXRlbSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZXMucHVzaChyZXNvbHZlKTtcbiAgICAgICAgaWYgKCF0aGlzLnRpY2tpbmcpIHtcbiAgICAgICAgICB0aGlzLnRpY2tpbmcgPSB0cnVlO1xuICAgICAgICAgIGNvcmUuVGlja2VyLnN5c3RlbS5hZGRPbmNlKHRoaXMudGljaywgdGhpcywgY29yZS5VUERBVEVfUFJJT1JJVFkuVVRJTElUWSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0aWNrKCkge1xuICAgIHNldFRpbWVvdXQodGhpcy5kZWxheWVkVGljaywgMCk7XG4gIH1cbiAgcHJlcGFyZUl0ZW1zKCkge1xuICAgIHRoaXMubGltaXRlci5iZWdpbkZyYW1lKCk7XG4gICAgd2hpbGUgKHRoaXMucXVldWUubGVuZ3RoICYmIHRoaXMubGltaXRlci5hbGxvd2VkVG9VcGxvYWQoKSkge1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXMucXVldWVbMF07XG4gICAgICBsZXQgdXBsb2FkZWQgPSBmYWxzZTtcbiAgICAgIGlmIChpdGVtICYmICFpdGVtLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMudXBsb2FkSG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy51cGxvYWRIb29rc1tpXSh0aGlzLnVwbG9hZEhvb2tIZWxwZXIsIGl0ZW0pKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICB1cGxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdXBsb2FkZWQpIHtcbiAgICAgICAgdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMucXVldWUubGVuZ3RoKSB7XG4gICAgICB0aGlzLnRpY2tpbmcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGNvbXBsZXRlcyA9IHRoaXMuY29tcGxldGVzLnNsaWNlKDApO1xuICAgICAgdGhpcy5jb21wbGV0ZXMubGVuZ3RoID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjb21wbGV0ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29tcGxldGVzW2ldKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvcmUuVGlja2VyLnN5c3RlbS5hZGRPbmNlKHRoaXMudGljaywgdGhpcywgY29yZS5VUERBVEVfUFJJT1JJVFkuVVRJTElUWSk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyRmluZEhvb2soYWRkSG9vaykge1xuICAgIGlmIChhZGRIb29rKSB7XG4gICAgICB0aGlzLmFkZEhvb2tzLnB1c2goYWRkSG9vayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlZ2lzdGVyVXBsb2FkSG9vayh1cGxvYWRIb29rKSB7XG4gICAgaWYgKHVwbG9hZEhvb2spIHtcbiAgICAgIHRoaXMudXBsb2FkSG9va3MucHVzaCh1cGxvYWRIb29rKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWRkKGl0ZW0pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5hZGRIb29rcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKHRoaXMuYWRkSG9va3NbaV0oaXRlbSwgdGhpcy5xdWV1ZSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgZGlzcGxheS5Db250YWluZXIpIHtcbiAgICAgIGZvciAobGV0IGkgPSBpdGVtLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMuYWRkKGl0ZW0uY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnRpY2tpbmcpIHtcbiAgICAgIGNvcmUuVGlja2VyLnN5c3RlbS5yZW1vdmUodGhpcy50aWNrLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy50aWNraW5nID0gZmFsc2U7XG4gICAgdGhpcy5hZGRIb29rcyA9IG51bGw7XG4gICAgdGhpcy51cGxvYWRIb29rcyA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5jb21wbGV0ZXMgPSBudWxsO1xuICAgIHRoaXMucXVldWUgPSBudWxsO1xuICAgIHRoaXMubGltaXRlciA9IG51bGw7XG4gICAgdGhpcy51cGxvYWRIb29rSGVscGVyID0gbnVsbDtcbiAgfVxufTtcbmxldCBCYXNlUHJlcGFyZSA9IF9CYXNlUHJlcGFyZTtcbkJhc2VQcmVwYXJlLnVwbG9hZHNQZXJGcmFtZSA9IDQ7XG5cbmV4cG9ydHMuQmFzZVByZXBhcmUgPSBCYXNlUHJlcGFyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2VQcmVwYXJlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jbGFzcyBDb3VudExpbWl0ZXIge1xuICBjb25zdHJ1Y3RvcihtYXhJdGVtc1BlckZyYW1lKSB7XG4gICAgdGhpcy5tYXhJdGVtc1BlckZyYW1lID0gbWF4SXRlbXNQZXJGcmFtZTtcbiAgICB0aGlzLml0ZW1zTGVmdCA9IDA7XG4gIH1cbiAgYmVnaW5GcmFtZSgpIHtcbiAgICB0aGlzLml0ZW1zTGVmdCA9IHRoaXMubWF4SXRlbXNQZXJGcmFtZTtcbiAgfVxuICBhbGxvd2VkVG9VcGxvYWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXNMZWZ0LS0gPiAwO1xuICB9XG59XG5cbmV4cG9ydHMuQ291bnRMaW1pdGVyID0gQ291bnRMaW1pdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q291bnRMaW1pdGVyLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBncmFwaGljcyA9IHJlcXVpcmUoJ0BwaXhpL2dyYXBoaWNzJyk7XG52YXIgQmFzZVByZXBhcmUgPSByZXF1aXJlKCcuL0Jhc2VQcmVwYXJlLmpzJyk7XG5cbmZ1bmN0aW9uIHVwbG9hZEJhc2VUZXh0dXJlcyhyZW5kZXJlciwgaXRlbSkge1xuICBpZiAoaXRlbSBpbnN0YW5jZW9mIGNvcmUuQmFzZVRleHR1cmUpIHtcbiAgICBpZiAoIWl0ZW0uX2dsVGV4dHVyZXNbcmVuZGVyZXIuQ09OVEVYVF9VSURdKSB7XG4gICAgICByZW5kZXJlci50ZXh0dXJlLmJpbmQoaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwbG9hZEdyYXBoaWNzKHJlbmRlcmVyLCBpdGVtKSB7XG4gIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBncmFwaGljcy5HcmFwaGljcykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgeyBnZW9tZXRyeSB9ID0gaXRlbTtcbiAgaXRlbS5maW5pc2hQb2x5KCk7XG4gIGdlb21ldHJ5LnVwZGF0ZUJhdGNoZXMoKTtcbiAgY29uc3QgeyBiYXRjaGVzIH0gPSBnZW9tZXRyeTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgeyB0ZXh0dXJlIH0gPSBiYXRjaGVzW2ldLnN0eWxlO1xuICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICB1cGxvYWRCYXNlVGV4dHVyZXMocmVuZGVyZXIsIHRleHR1cmUuYmFzZVRleHR1cmUpO1xuICAgIH1cbiAgfVxuICBpZiAoIWdlb21ldHJ5LmJhdGNoYWJsZSkge1xuICAgIHJlbmRlcmVyLmdlb21ldHJ5LmJpbmQoZ2VvbWV0cnksIGl0ZW0uX3Jlc29sdmVEaXJlY3RTaGFkZXIocmVuZGVyZXIpKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGZpbmRHcmFwaGljcyhpdGVtLCBxdWV1ZSkge1xuICBpZiAoaXRlbSBpbnN0YW5jZW9mIGdyYXBoaWNzLkdyYXBoaWNzKSB7XG4gICAgcXVldWUucHVzaChpdGVtKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5jbGFzcyBQcmVwYXJlIGV4dGVuZHMgQmFzZVByZXBhcmUuQmFzZVByZXBhcmUge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICB0aGlzLnVwbG9hZEhvb2tIZWxwZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhmaW5kR3JhcGhpY3MpO1xuICAgIHRoaXMucmVnaXN0ZXJVcGxvYWRIb29rKHVwbG9hZEJhc2VUZXh0dXJlcyk7XG4gICAgdGhpcy5yZWdpc3RlclVwbG9hZEhvb2sodXBsb2FkR3JhcGhpY3MpO1xuICB9XG59XG5QcmVwYXJlLmV4dGVuc2lvbiA9IHtcbiAgbmFtZTogXCJwcmVwYXJlXCIsXG4gIHR5cGU6IGNvcmUuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbVxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQoUHJlcGFyZSk7XG5cbmV4cG9ydHMuUHJlcGFyZSA9IFByZXBhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QcmVwYXJlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jbGFzcyBUaW1lTGltaXRlciB7XG4gIGNvbnN0cnVjdG9yKG1heE1pbGxpc2Vjb25kcykge1xuICAgIHRoaXMubWF4TWlsbGlzZWNvbmRzID0gbWF4TWlsbGlzZWNvbmRzO1xuICAgIHRoaXMuZnJhbWVTdGFydCA9IDA7XG4gIH1cbiAgYmVnaW5GcmFtZSgpIHtcbiAgICB0aGlzLmZyYW1lU3RhcnQgPSBEYXRlLm5vdygpO1xuICB9XG4gIGFsbG93ZWRUb1VwbG9hZCgpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRoaXMuZnJhbWVTdGFydCA8IHRoaXMubWF4TWlsbGlzZWNvbmRzO1xuICB9XG59XG5cbmV4cG9ydHMuVGltZUxpbWl0ZXIgPSBUaW1lTGltaXRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbWVMaW1pdGVyLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5yZXF1aXJlKCcuL3NldHRpbmdzLmpzJyk7XG52YXIgQmFzZVByZXBhcmUgPSByZXF1aXJlKCcuL0Jhc2VQcmVwYXJlLmpzJyk7XG52YXIgQ291bnRMaW1pdGVyID0gcmVxdWlyZSgnLi9Db3VudExpbWl0ZXIuanMnKTtcbnZhciBQcmVwYXJlID0gcmVxdWlyZSgnLi9QcmVwYXJlLmpzJyk7XG52YXIgVGltZUxpbWl0ZXIgPSByZXF1aXJlKCcuL1RpbWVMaW1pdGVyLmpzJyk7XG5cblxuXG5leHBvcnRzLkJhc2VQcmVwYXJlID0gQmFzZVByZXBhcmUuQmFzZVByZXBhcmU7XG5leHBvcnRzLkNvdW50TGltaXRlciA9IENvdW50TGltaXRlci5Db3VudExpbWl0ZXI7XG5leHBvcnRzLlByZXBhcmUgPSBQcmVwYXJlLlByZXBhcmU7XG5leHBvcnRzLlRpbWVMaW1pdGVyID0gVGltZUxpbWl0ZXIuVGltZUxpbWl0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgQmFzZVByZXBhcmUgPSByZXF1aXJlKCcuL0Jhc2VQcmVwYXJlLmpzJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvcmUuc2V0dGluZ3MsIHtcbiAgVVBMT0FEU19QRVJfRlJBTUU6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gQmFzZVByZXBhcmUuQmFzZVByZXBhcmUudXBsb2Fkc1BlckZyYW1lO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBjb3JlLnV0aWxzLmRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5VUExPQURTX1BFUl9GUkFNRSBpcyBkZXByZWNhdGVkLCB1c2UgcHJlcGFyZS5CYXNlUHJlcGFyZS51cGxvYWRzUGVyRnJhbWVcIik7XG4gICAgICBCYXNlUHJlcGFyZS5CYXNlUHJlcGFyZS51cGxvYWRzUGVyRnJhbWUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3NldHRpbmdzJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3JlLnNldHRpbmdzOyB9XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNldHRpbmdzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jbGFzcyBSdW5uZXIge1xuICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgIHRoaXMuX2FsaWFzQ291bnQgPSAwO1xuICB9XG4gIGVtaXQoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiA4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXggYXJndW1lbnRzIHJlYWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgbmFtZSwgaXRlbXMgfSA9IHRoaXM7XG4gICAgdGhpcy5fYWxpYXNDb3VudCsrO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaXRlbXNbaV1bbmFtZV0oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KTtcbiAgICB9XG4gICAgaWYgKGl0ZW1zID09PSB0aGlzLml0ZW1zKSB7XG4gICAgICB0aGlzLl9hbGlhc0NvdW50LS07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGVuc3VyZU5vbkFsaWFzZWRJdGVtcygpIHtcbiAgICBpZiAodGhpcy5fYWxpYXNDb3VudCA+IDAgJiYgdGhpcy5pdGVtcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLl9hbGlhc0NvdW50ID0gMDtcbiAgICAgIHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zLnNsaWNlKDApO1xuICAgIH1cbiAgfVxuICBhZGQoaXRlbSkge1xuICAgIGlmIChpdGVtW3RoaXMuX25hbWVdKSB7XG4gICAgICB0aGlzLmVuc3VyZU5vbkFsaWFzZWRJdGVtcygpO1xuICAgICAgdGhpcy5yZW1vdmUoaXRlbSk7XG4gICAgICB0aGlzLml0ZW1zLnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlbW92ZShpdGVtKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5lbnN1cmVOb25BbGlhc2VkSXRlbXMoKTtcbiAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY29udGFpbnMoaXRlbSkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLmluY2x1ZGVzKGl0ZW0pO1xuICB9XG4gIHJlbW92ZUFsbCgpIHtcbiAgICB0aGlzLmVuc3VyZU5vbkFsaWFzZWRJdGVtcygpO1xuICAgIHRoaXMuaXRlbXMubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVtb3ZlQWxsKCk7XG4gICAgdGhpcy5pdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fbmFtZSA9IG51bGw7XG4gIH1cbiAgZ2V0IGVtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUnVubmVyLnByb3RvdHlwZSwge1xuICBkaXNwYXRjaDogeyB2YWx1ZTogUnVubmVyLnByb3RvdHlwZS5lbWl0IH0sXG4gIHJ1bjogeyB2YWx1ZTogUnVubmVyLnByb3RvdHlwZS5lbWl0IH1cbn0pO1xuXG5leHBvcnRzLlJ1bm5lciA9IFJ1bm5lcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJ1bm5lci5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIFJ1bm5lciA9IHJlcXVpcmUoJy4vUnVubmVyLmpzJyk7XG5cblxuXG5leHBvcnRzLlJ1bm5lciA9IFJ1bm5lci5SdW5uZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SUNhbnZhcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SUNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY29uc3QgQnJvd3NlckFkYXB0ZXIgPSB7XG4gIGNyZWF0ZUNhbnZhczogKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfSxcbiAgZ2V0Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEOiAoKSA9PiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGdldFdlYkdMUmVuZGVyaW5nQ29udGV4dDogKCkgPT4gV2ViR0xSZW5kZXJpbmdDb250ZXh0LFxuICBnZXROYXZpZ2F0b3I6ICgpID0+IG5hdmlnYXRvcixcbiAgZ2V0QmFzZVVybDogKCkgPT4gZG9jdW1lbnQuYmFzZVVSSSA/PyB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgZ2V0Rm9udEZhY2VTZXQ6ICgpID0+IGRvY3VtZW50LmZvbnRzLFxuICBmZXRjaDogKHVybCwgb3B0aW9ucykgPT4gZmV0Y2godXJsLCBvcHRpb25zKSxcbiAgcGFyc2VYTUw6ICh4bWwpID0+IHtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sLCBcInRleHQveG1sXCIpO1xuICB9XG59O1xuXG5leHBvcnRzLkJyb3dzZXJBZGFwdGVyID0gQnJvd3NlckFkYXB0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGFwdGVyLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlci5qcycpO1xucmVxdWlyZSgnLi9JQ2FudmFzLmpzJyk7XG5yZXF1aXJlKCcuL0lDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQuanMnKTtcbnZhciBzZXR0aW5ncyA9IHJlcXVpcmUoJy4vc2V0dGluZ3MuanMnKTtcbnZhciBpc01vYmlsZSA9IHJlcXVpcmUoJy4vdXRpbHMvaXNNb2JpbGUuanMnKTtcblxuXG5cbmV4cG9ydHMuQnJvd3NlckFkYXB0ZXIgPSBhZGFwdGVyLkJyb3dzZXJBZGFwdGVyO1xuZXhwb3J0cy5zZXR0aW5ncyA9IHNldHRpbmdzLnNldHRpbmdzO1xuZXhwb3J0cy5pc01vYmlsZSA9IGlzTW9iaWxlLmlzTW9iaWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVyLmpzJyk7XG5cbmNvbnN0IHNldHRpbmdzID0ge1xuICBBREFQVEVSOiBhZGFwdGVyLkJyb3dzZXJBZGFwdGVyLFxuICBSRVNPTFVUSU9OOiAxLFxuICBDUkVBVEVfSU1BR0VfQklUTUFQOiBmYWxzZSxcbiAgUk9VTkRfUElYRUxTOiBmYWxzZVxufTtcblxuZXhwb3J0cy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0dGluZ3MuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBpc01vYmlsZUpzID0gcmVxdWlyZSgnaXNtb2JpbGVqcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIGlzTW9iaWxlSnNfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KGlzTW9iaWxlSnMpO1xuXG5jb25zdCBpc01vYmlsZUNhbGwgPSBpc01vYmlsZUpzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5kZWZhdWx0ID8/IGlzTW9iaWxlSnNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdO1xuY29uc3QgaXNNb2JpbGUgPSBpc01vYmlsZUNhbGwoZ2xvYmFsVGhpcy5uYXZpZ2F0b3IpO1xuXG5leHBvcnRzLmlzTW9iaWxlID0gaXNNb2JpbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc01vYmlsZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgc3ByaXRlID0gcmVxdWlyZSgnQHBpeGkvc3ByaXRlJyk7XG5cbmNsYXNzIEFuaW1hdGVkU3ByaXRlIGV4dGVuZHMgc3ByaXRlLlNwcml0ZSB7XG4gIGNvbnN0cnVjdG9yKHRleHR1cmVzLCBhdXRvVXBkYXRlID0gdHJ1ZSkge1xuICAgIHN1cGVyKHRleHR1cmVzWzBdIGluc3RhbmNlb2YgY29yZS5UZXh0dXJlID8gdGV4dHVyZXNbMF0gOiB0ZXh0dXJlc1swXS50ZXh0dXJlKTtcbiAgICB0aGlzLl90ZXh0dXJlcyA9IG51bGw7XG4gICAgdGhpcy5fZHVyYXRpb25zID0gbnVsbDtcbiAgICB0aGlzLl9hdXRvVXBkYXRlID0gYXV0b1VwZGF0ZTtcbiAgICB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gZmFsc2U7XG4gICAgdGhpcy5hbmltYXRpb25TcGVlZCA9IDE7XG4gICAgdGhpcy5sb29wID0gdHJ1ZTtcbiAgICB0aGlzLnVwZGF0ZUFuY2hvciA9IGZhbHNlO1xuICAgIHRoaXMub25Db21wbGV0ZSA9IG51bGw7XG4gICAgdGhpcy5vbkZyYW1lQ2hhbmdlID0gbnVsbDtcbiAgICB0aGlzLm9uTG9vcCA9IG51bGw7XG4gICAgdGhpcy5fY3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMuX3BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9wcmV2aW91c0ZyYW1lID0gbnVsbDtcbiAgICB0aGlzLnRleHR1cmVzID0gdGV4dHVyZXM7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICBpZiAoIXRoaXMuX3BsYXlpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLl9hdXRvVXBkYXRlICYmIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIpIHtcbiAgICAgIGNvcmUuVGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGUsIHRoaXMpO1xuICAgICAgdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBwbGF5KCkge1xuICAgIGlmICh0aGlzLl9wbGF5aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3BsYXlpbmcgPSB0cnVlO1xuICAgIGlmICh0aGlzLl9hdXRvVXBkYXRlICYmICF0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyKSB7XG4gICAgICBjb3JlLlRpY2tlci5zaGFyZWQuYWRkKHRoaXMudXBkYXRlLCB0aGlzLCBjb3JlLlVQREFURV9QUklPUklUWS5ISUdIKTtcbiAgICAgIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBnb3RvQW5kU3RvcChmcmFtZU51bWJlcikge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gZnJhbWVOdW1iZXI7XG4gIH1cbiAgZ290b0FuZFBsYXkoZnJhbWVOdW1iZXIpIHtcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IGZyYW1lTnVtYmVyO1xuICAgIHRoaXMucGxheSgpO1xuICB9XG4gIHVwZGF0ZShkZWx0YVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuX3BsYXlpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWxhcHNlZCA9IHRoaXMuYW5pbWF0aW9uU3BlZWQgKiBkZWx0YVRpbWU7XG4gICAgY29uc3QgcHJldmlvdXNGcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgIGlmICh0aGlzLl9kdXJhdGlvbnMgIT09IG51bGwpIHtcbiAgICAgIGxldCBsYWcgPSB0aGlzLl9jdXJyZW50VGltZSAlIDEgKiB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdO1xuICAgICAgbGFnICs9IGVsYXBzZWQgLyA2MCAqIDFlMztcbiAgICAgIHdoaWxlIChsYWcgPCAwKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lLS07XG4gICAgICAgIGxhZyArPSB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbiA9IE1hdGguc2lnbih0aGlzLmFuaW1hdGlvblNwZWVkICogZGVsdGFUaW1lKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gTWF0aC5mbG9vcih0aGlzLl9jdXJyZW50VGltZSk7XG4gICAgICB3aGlsZSAobGFnID49IHRoaXMuX2R1cmF0aW9uc1t0aGlzLmN1cnJlbnRGcmFtZV0pIHtcbiAgICAgICAgbGFnIC09IHRoaXMuX2R1cmF0aW9uc1t0aGlzLmN1cnJlbnRGcmFtZV0gKiBzaWduO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGltZSArPSBzaWduO1xuICAgICAgfVxuICAgICAgdGhpcy5fY3VycmVudFRpbWUgKz0gbGFnIC8gdGhpcy5fZHVyYXRpb25zW3RoaXMuY3VycmVudEZyYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY3VycmVudFRpbWUgKz0gZWxhcHNlZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRUaW1lIDwgMCAmJiAhdGhpcy5sb29wKSB7XG4gICAgICB0aGlzLmdvdG9BbmRTdG9wKDApO1xuICAgICAgaWYgKHRoaXMub25Db21wbGV0ZSkge1xuICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2N1cnJlbnRUaW1lID49IHRoaXMuX3RleHR1cmVzLmxlbmd0aCAmJiAhdGhpcy5sb29wKSB7XG4gICAgICB0aGlzLmdvdG9BbmRTdG9wKHRoaXMuX3RleHR1cmVzLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKHRoaXMub25Db21wbGV0ZSkge1xuICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXZpb3VzRnJhbWUgIT09IHRoaXMuY3VycmVudEZyYW1lKSB7XG4gICAgICBpZiAodGhpcy5sb29wICYmIHRoaXMub25Mb29wKSB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvblNwZWVkID4gMCAmJiB0aGlzLmN1cnJlbnRGcmFtZSA8IHByZXZpb3VzRnJhbWUgfHwgdGhpcy5hbmltYXRpb25TcGVlZCA8IDAgJiYgdGhpcy5jdXJyZW50RnJhbWUgPiBwcmV2aW91c0ZyYW1lKSB7XG4gICAgICAgICAgdGhpcy5vbkxvb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVUZXh0dXJlKCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVRleHR1cmUoKSB7XG4gICAgY29uc3QgY3VycmVudEZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG4gICAgaWYgKHRoaXMuX3ByZXZpb3VzRnJhbWUgPT09IGN1cnJlbnRGcmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9wcmV2aW91c0ZyYW1lID0gY3VycmVudEZyYW1lO1xuICAgIHRoaXMuX3RleHR1cmUgPSB0aGlzLl90ZXh0dXJlc1tjdXJyZW50RnJhbWVdO1xuICAgIHRoaXMuX3RleHR1cmVJRCA9IC0xO1xuICAgIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSAtMTtcbiAgICB0aGlzLl9jYWNoZWRUaW50ID0gMTY3NzcyMTU7XG4gICAgdGhpcy51dnMgPSB0aGlzLl90ZXh0dXJlLl91dnMudXZzRmxvYXQzMjtcbiAgICBpZiAodGhpcy51cGRhdGVBbmNob3IpIHtcbiAgICAgIHRoaXMuX2FuY2hvci5jb3B5RnJvbSh0aGlzLl90ZXh0dXJlLmRlZmF1bHRBbmNob3IpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vbkZyYW1lQ2hhbmdlKSB7XG4gICAgICB0aGlzLm9uRnJhbWVDaGFuZ2UodGhpcy5jdXJyZW50RnJhbWUpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xuICAgIHRoaXMub25Db21wbGV0ZSA9IG51bGw7XG4gICAgdGhpcy5vbkZyYW1lQ2hhbmdlID0gbnVsbDtcbiAgICB0aGlzLm9uTG9vcCA9IG51bGw7XG4gIH1cbiAgc3RhdGljIGZyb21GcmFtZXMoZnJhbWVzKSB7XG4gICAgY29uc3QgdGV4dHVyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgdGV4dHVyZXMucHVzaChjb3JlLlRleHR1cmUuZnJvbShmcmFtZXNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBbmltYXRlZFNwcml0ZSh0ZXh0dXJlcyk7XG4gIH1cbiAgc3RhdGljIGZyb21JbWFnZXMoaW1hZ2VzKSB7XG4gICAgY29uc3QgdGV4dHVyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdGV4dHVyZXMucHVzaChjb3JlLlRleHR1cmUuZnJvbShpbWFnZXNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBbmltYXRlZFNwcml0ZSh0ZXh0dXJlcyk7XG4gIH1cbiAgZ2V0IHRvdGFsRnJhbWVzKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0dXJlcy5sZW5ndGg7XG4gIH1cbiAgZ2V0IHRleHR1cmVzKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0dXJlcztcbiAgfVxuICBzZXQgdGV4dHVyZXModmFsdWUpIHtcbiAgICBpZiAodmFsdWVbMF0gaW5zdGFuY2VvZiBjb3JlLlRleHR1cmUpIHtcbiAgICAgIHRoaXMuX3RleHR1cmVzID0gdmFsdWU7XG4gICAgICB0aGlzLl9kdXJhdGlvbnMgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90ZXh0dXJlcyA9IFtdO1xuICAgICAgdGhpcy5fZHVyYXRpb25zID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3RleHR1cmVzLnB1c2godmFsdWVbaV0udGV4dHVyZSk7XG4gICAgICAgIHRoaXMuX2R1cmF0aW9ucy5wdXNoKHZhbHVlW2ldLnRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9wcmV2aW91c0ZyYW1lID0gbnVsbDtcbiAgICB0aGlzLmdvdG9BbmRTdG9wKDApO1xuICAgIHRoaXMudXBkYXRlVGV4dHVyZSgpO1xuICB9XG4gIGdldCBjdXJyZW50RnJhbWUoKSB7XG4gICAgbGV0IGN1cnJlbnRGcmFtZSA9IE1hdGguZmxvb3IodGhpcy5fY3VycmVudFRpbWUpICUgdGhpcy5fdGV4dHVyZXMubGVuZ3RoO1xuICAgIGlmIChjdXJyZW50RnJhbWUgPCAwKSB7XG4gICAgICBjdXJyZW50RnJhbWUgKz0gdGhpcy5fdGV4dHVyZXMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudEZyYW1lO1xuICB9XG4gIHNldCBjdXJyZW50RnJhbWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gdGhpcy50b3RhbEZyYW1lcyAtIDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgW0FuaW1hdGVkU3ByaXRlXTogSW52YWxpZCBmcmFtZSBpbmRleCB2YWx1ZSAke3ZhbHVlfSwgZXhwZWN0ZWQgdG8gYmUgYmV0d2VlbiAwIGFuZCB0b3RhbEZyYW1lcyAke3RoaXMudG90YWxGcmFtZXN9LmApO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c0ZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG4gICAgdGhpcy5fY3VycmVudFRpbWUgPSB2YWx1ZTtcbiAgICBpZiAocHJldmlvdXNGcmFtZSAhPT0gdGhpcy5jdXJyZW50RnJhbWUpIHtcbiAgICAgIHRoaXMudXBkYXRlVGV4dHVyZSgpO1xuICAgIH1cbiAgfVxuICBnZXQgcGxheWluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGxheWluZztcbiAgfVxuICBnZXQgYXV0b1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b1VwZGF0ZTtcbiAgfVxuICBzZXQgYXV0b1VwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fYXV0b1VwZGF0ZSkge1xuICAgICAgdGhpcy5fYXV0b1VwZGF0ZSA9IHZhbHVlO1xuICAgICAgaWYgKCF0aGlzLl9hdXRvVXBkYXRlICYmIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIpIHtcbiAgICAgICAgY29yZS5UaWNrZXIuc2hhcmVkLnJlbW92ZSh0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYXV0b1VwZGF0ZSAmJiAhdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlciAmJiB0aGlzLl9wbGF5aW5nKSB7XG4gICAgICAgIGNvcmUuVGlja2VyLnNoYXJlZC5hZGQodGhpcy51cGRhdGUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5BbmltYXRlZFNwcml0ZSA9IEFuaW1hdGVkU3ByaXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QW5pbWF0ZWRTcHJpdGUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBBbmltYXRlZFNwcml0ZSA9IHJlcXVpcmUoJy4vQW5pbWF0ZWRTcHJpdGUuanMnKTtcblxuXG5cbmV4cG9ydHMuQW5pbWF0ZWRTcHJpdGUgPSBBbmltYXRlZFNwcml0ZS5BbmltYXRlZFNwcml0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBzcHJpdGUgPSByZXF1aXJlKCdAcGl4aS9zcHJpdGUnKTtcblxuY29uc3QgdGVtcFBvaW50ID0gbmV3IGNvcmUuUG9pbnQoKTtcbmNsYXNzIFRpbGluZ1Nwcml0ZSBleHRlbmRzIHNwcml0ZS5TcHJpdGUge1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlLCB3aWR0aCA9IDEwMCwgaGVpZ2h0ID0gMTAwKSB7XG4gICAgc3VwZXIodGV4dHVyZSk7XG4gICAgdGhpcy50aWxlVHJhbnNmb3JtID0gbmV3IGNvcmUuVHJhbnNmb3JtKCk7XG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy51dk1hdHJpeCA9IHRoaXMudGV4dHVyZS51dk1hdHJpeCB8fCBuZXcgY29yZS5UZXh0dXJlTWF0cml4KHRleHR1cmUpO1xuICAgIHRoaXMucGx1Z2luTmFtZSA9IFwidGlsaW5nU3ByaXRlXCI7XG4gICAgdGhpcy51dlJlc3BlY3RBbmNob3IgPSBmYWxzZTtcbiAgfVxuICBnZXQgY2xhbXBNYXJnaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMudXZNYXRyaXguY2xhbXBNYXJnaW47XG4gIH1cbiAgc2V0IGNsYW1wTWFyZ2luKHZhbHVlKSB7XG4gICAgdGhpcy51dk1hdHJpeC5jbGFtcE1hcmdpbiA9IHZhbHVlO1xuICAgIHRoaXMudXZNYXRyaXgudXBkYXRlKHRydWUpO1xuICB9XG4gIGdldCB0aWxlU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZVRyYW5zZm9ybS5zY2FsZTtcbiAgfVxuICBzZXQgdGlsZVNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy50aWxlVHJhbnNmb3JtLnNjYWxlLmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICBnZXQgdGlsZVBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRpbGVUcmFuc2Zvcm0ucG9zaXRpb247XG4gIH1cbiAgc2V0IHRpbGVQb3NpdGlvbih2YWx1ZSkge1xuICAgIHRoaXMudGlsZVRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5RnJvbSh2YWx1ZSk7XG4gIH1cbiAgX29uVGV4dHVyZVVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy51dk1hdHJpeCkge1xuICAgICAgdGhpcy51dk1hdHJpeC50ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcbiAgICB9XG4gICAgdGhpcy5fY2FjaGVkVGludCA9IDE2Nzc3MjE1O1xuICB9XG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcbiAgICBpZiAoIXRleHR1cmUgfHwgIXRleHR1cmUudmFsaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50aWxlVHJhbnNmb3JtLnVwZGF0ZUxvY2FsVHJhbnNmb3JtKCk7XG4gICAgdGhpcy51dk1hdHJpeC51cGRhdGUoKTtcbiAgICByZW5kZXJlci5iYXRjaC5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0pO1xuICAgIHJlbmRlcmVyLnBsdWdpbnNbdGhpcy5wbHVnaW5OYW1lXS5yZW5kZXIodGhpcyk7XG4gIH1cbiAgX2NhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICBjb25zdCBtaW5YID0gdGhpcy5fd2lkdGggKiAtdGhpcy5fYW5jaG9yLl94O1xuICAgIGNvbnN0IG1pblkgPSB0aGlzLl9oZWlnaHQgKiAtdGhpcy5fYW5jaG9yLl95O1xuICAgIGNvbnN0IG1heFggPSB0aGlzLl93aWR0aCAqICgxIC0gdGhpcy5fYW5jaG9yLl94KTtcbiAgICBjb25zdCBtYXhZID0gdGhpcy5faGVpZ2h0ICogKDEgLSB0aGlzLl9hbmNob3IuX3kpO1xuICAgIHRoaXMuX2JvdW5kcy5hZGRGcmFtZSh0aGlzLnRyYW5zZm9ybSwgbWluWCwgbWluWSwgbWF4WCwgbWF4WSk7XG4gIH1cbiAgZ2V0TG9jYWxCb3VuZHMocmVjdCkge1xuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fYm91bmRzLm1pblggPSB0aGlzLl93aWR0aCAqIC10aGlzLl9hbmNob3IuX3g7XG4gICAgICB0aGlzLl9ib3VuZHMubWluWSA9IHRoaXMuX2hlaWdodCAqIC10aGlzLl9hbmNob3IuX3k7XG4gICAgICB0aGlzLl9ib3VuZHMubWF4WCA9IHRoaXMuX3dpZHRoICogKDEgLSB0aGlzLl9hbmNob3IuX3gpO1xuICAgICAgdGhpcy5fYm91bmRzLm1heFkgPSB0aGlzLl9oZWlnaHQgKiAoMSAtIHRoaXMuX2FuY2hvci5feSk7XG4gICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2NhbEJvdW5kc1JlY3QpIHtcbiAgICAgICAgICB0aGlzLl9sb2NhbEJvdW5kc1JlY3QgPSBuZXcgY29yZS5SZWN0YW5nbGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZWN0ID0gdGhpcy5fbG9jYWxCb3VuZHNSZWN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcy5nZXRSZWN0YW5nbGUocmVjdCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5nZXRMb2NhbEJvdW5kcy5jYWxsKHRoaXMsIHJlY3QpO1xuICB9XG4gIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgdGVtcFBvaW50KTtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgICBjb25zdCB4MSA9IC13aWR0aCAqIHRoaXMuYW5jaG9yLl94O1xuICAgIGlmICh0ZW1wUG9pbnQueCA+PSB4MSAmJiB0ZW1wUG9pbnQueCA8IHgxICsgd2lkdGgpIHtcbiAgICAgIGNvbnN0IHkxID0gLWhlaWdodCAqIHRoaXMuYW5jaG9yLl95O1xuICAgICAgaWYgKHRlbXBQb2ludC55ID49IHkxICYmIHRlbXBQb2ludC55IDwgeTEgKyBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xuICAgIHRoaXMudGlsZVRyYW5zZm9ybSA9IG51bGw7XG4gICAgdGhpcy51dk1hdHJpeCA9IG51bGw7XG4gIH1cbiAgc3RhdGljIGZyb20oc291cmNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IHNvdXJjZSBpbnN0YW5jZW9mIGNvcmUuVGV4dHVyZSA/IHNvdXJjZSA6IGNvcmUuVGV4dHVyZS5mcm9tKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBUaWxpbmdTcHJpdGUodGV4dHVyZSwgb3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQpO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gIH1cbiAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydHMuVGlsaW5nU3ByaXRlID0gVGlsaW5nU3ByaXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlsaW5nU3ByaXRlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBzcHJpdGVUaWxpbmckMSA9IHJlcXVpcmUoJy4vc3ByaXRlLXRpbGluZy5qcycpO1xudmFyIHNwcml0ZVRpbGluZyA9IHJlcXVpcmUoJy4vc3ByaXRlLXRpbGluZzIuanMnKTtcbnZhciBzcHJpdGVUaWxpbmdGYWxsYmFjayQxID0gcmVxdWlyZSgnLi9zcHJpdGUtdGlsaW5nLWZhbGxiYWNrLmpzJyk7XG52YXIgc3ByaXRlVGlsaW5nRmFsbGJhY2sgPSByZXF1aXJlKCcuL3Nwcml0ZS10aWxpbmctZmFsbGJhY2syLmpzJyk7XG52YXIgc3ByaXRlVGlsaW5nU2ltcGxlID0gcmVxdWlyZSgnLi9zcHJpdGUtdGlsaW5nLXNpbXBsZS5qcycpO1xuXG5jb25zdCB0ZW1wTWF0ID0gbmV3IGNvcmUuTWF0cml4KCk7XG5jbGFzcyBUaWxpbmdTcHJpdGVSZW5kZXJlciBleHRlbmRzIGNvcmUuT2JqZWN0UmVuZGVyZXIge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICByZW5kZXJlci5ydW5uZXJzLmNvbnRleHRDaGFuZ2UuYWRkKHRoaXMpO1xuICAgIHRoaXMucXVhZCA9IG5ldyBjb3JlLlF1YWRVdigpO1xuICAgIHRoaXMuc3RhdGUgPSBjb3JlLlN0YXRlLmZvcjJkKCk7XG4gIH1cbiAgY29udGV4dENoYW5nZSgpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB7IGdsb2JhbHM6IHJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zIH07XG4gICAgdGhpcy5zaW1wbGVTaGFkZXIgPSBjb3JlLlNoYWRlci5mcm9tKHNwcml0ZVRpbGluZ0ZhbGxiYWNrW1wiZGVmYXVsdFwiXSwgc3ByaXRlVGlsaW5nU2ltcGxlW1wiZGVmYXVsdFwiXSwgdW5pZm9ybXMpO1xuICAgIHRoaXMuc2hhZGVyID0gcmVuZGVyZXIuY29udGV4dC53ZWJHTFZlcnNpb24gPiAxID8gY29yZS5TaGFkZXIuZnJvbShzcHJpdGVUaWxpbmdbXCJkZWZhdWx0XCJdLCBzcHJpdGVUaWxpbmckMVtcImRlZmF1bHRcIl0sIHVuaWZvcm1zKSA6IGNvcmUuU2hhZGVyLmZyb20oc3ByaXRlVGlsaW5nRmFsbGJhY2tbXCJkZWZhdWx0XCJdLCBzcHJpdGVUaWxpbmdGYWxsYmFjayQxW1wiZGVmYXVsdFwiXSwgdW5pZm9ybXMpO1xuICB9XG4gIHJlbmRlcih0cykge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBjb25zdCBxdWFkID0gdGhpcy5xdWFkO1xuICAgIGxldCB2ZXJ0aWNlcyA9IHF1YWQudmVydGljZXM7XG4gICAgdmVydGljZXNbMF0gPSB2ZXJ0aWNlc1s2XSA9IHRzLl93aWR0aCAqIC10cy5hbmNob3IueDtcbiAgICB2ZXJ0aWNlc1sxXSA9IHZlcnRpY2VzWzNdID0gdHMuX2hlaWdodCAqIC10cy5hbmNob3IueTtcbiAgICB2ZXJ0aWNlc1syXSA9IHZlcnRpY2VzWzRdID0gdHMuX3dpZHRoICogKDEgLSB0cy5hbmNob3IueCk7XG4gICAgdmVydGljZXNbNV0gPSB2ZXJ0aWNlc1s3XSA9IHRzLl9oZWlnaHQgKiAoMSAtIHRzLmFuY2hvci55KTtcbiAgICBjb25zdCBhbmNob3JYID0gdHMudXZSZXNwZWN0QW5jaG9yID8gdHMuYW5jaG9yLnggOiAwO1xuICAgIGNvbnN0IGFuY2hvclkgPSB0cy51dlJlc3BlY3RBbmNob3IgPyB0cy5hbmNob3IueSA6IDA7XG4gICAgdmVydGljZXMgPSBxdWFkLnV2cztcbiAgICB2ZXJ0aWNlc1swXSA9IHZlcnRpY2VzWzZdID0gLWFuY2hvclg7XG4gICAgdmVydGljZXNbMV0gPSB2ZXJ0aWNlc1szXSA9IC1hbmNob3JZO1xuICAgIHZlcnRpY2VzWzJdID0gdmVydGljZXNbNF0gPSAxIC0gYW5jaG9yWDtcbiAgICB2ZXJ0aWNlc1s1XSA9IHZlcnRpY2VzWzddID0gMSAtIGFuY2hvclk7XG4gICAgcXVhZC5pbnZhbGlkYXRlKCk7XG4gICAgY29uc3QgdGV4ID0gdHMuX3RleHR1cmU7XG4gICAgY29uc3QgYmFzZVRleCA9IHRleC5iYXNlVGV4dHVyZTtcbiAgICBjb25zdCBwcmVtdWx0aXBsaWVkID0gYmFzZVRleC5hbHBoYU1vZGUgPiAwO1xuICAgIGNvbnN0IGx0ID0gdHMudGlsZVRyYW5zZm9ybS5sb2NhbFRyYW5zZm9ybTtcbiAgICBjb25zdCB1diA9IHRzLnV2TWF0cml4O1xuICAgIGxldCBpc1NpbXBsZSA9IGJhc2VUZXguaXNQb3dlck9mVHdvICYmIHRleC5mcmFtZS53aWR0aCA9PT0gYmFzZVRleC53aWR0aCAmJiB0ZXguZnJhbWUuaGVpZ2h0ID09PSBiYXNlVGV4LmhlaWdodDtcbiAgICBpZiAoaXNTaW1wbGUpIHtcbiAgICAgIGlmICghYmFzZVRleC5fZ2xUZXh0dXJlc1tyZW5kZXJlci5DT05URVhUX1VJRF0pIHtcbiAgICAgICAgaWYgKGJhc2VUZXgud3JhcE1vZGUgPT09IGNvcmUuV1JBUF9NT0RFUy5DTEFNUCkge1xuICAgICAgICAgIGJhc2VUZXgud3JhcE1vZGUgPSBjb3JlLldSQVBfTU9ERVMuUkVQRUFUO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc1NpbXBsZSA9IGJhc2VUZXgud3JhcE1vZGUgIT09IGNvcmUuV1JBUF9NT0RFUy5DTEFNUDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2hhZGVyID0gaXNTaW1wbGUgPyB0aGlzLnNpbXBsZVNoYWRlciA6IHRoaXMuc2hhZGVyO1xuICAgIGNvbnN0IHcgPSB0ZXgud2lkdGg7XG4gICAgY29uc3QgaCA9IHRleC5oZWlnaHQ7XG4gICAgY29uc3QgVyA9IHRzLl93aWR0aDtcbiAgICBjb25zdCBIID0gdHMuX2hlaWdodDtcbiAgICB0ZW1wTWF0LnNldChsdC5hICogdyAvIFcsIGx0LmIgKiB3IC8gSCwgbHQuYyAqIGggLyBXLCBsdC5kICogaCAvIEgsIGx0LnR4IC8gVywgbHQudHkgLyBIKTtcbiAgICB0ZW1wTWF0LmludmVydCgpO1xuICAgIGlmIChpc1NpbXBsZSkge1xuICAgICAgdGVtcE1hdC5wcmVwZW5kKHV2Lm1hcENvb3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hhZGVyLnVuaWZvcm1zLnVNYXBDb29yZCA9IHV2Lm1hcENvb3JkLnRvQXJyYXkodHJ1ZSk7XG4gICAgICBzaGFkZXIudW5pZm9ybXMudUNsYW1wRnJhbWUgPSB1di51Q2xhbXBGcmFtZTtcbiAgICAgIHNoYWRlci51bmlmb3Jtcy51Q2xhbXBPZmZzZXQgPSB1di51Q2xhbXBPZmZzZXQ7XG4gICAgfVxuICAgIHNoYWRlci51bmlmb3Jtcy51VHJhbnNmb3JtID0gdGVtcE1hdC50b0FycmF5KHRydWUpO1xuICAgIHNoYWRlci51bmlmb3Jtcy51Q29sb3IgPSBjb3JlLkNvbG9yLnNoYXJlZC5zZXRWYWx1ZSh0cy50aW50KS5wcmVtdWx0aXBseSh0cy53b3JsZEFscGhhLCBwcmVtdWx0aXBsaWVkKS50b0FycmF5KHNoYWRlci51bmlmb3Jtcy51Q29sb3IpO1xuICAgIHNoYWRlci51bmlmb3Jtcy50cmFuc2xhdGlvbk1hdHJpeCA9IHRzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybS50b0FycmF5KHRydWUpO1xuICAgIHNoYWRlci51bmlmb3Jtcy51U2FtcGxlciA9IHRleDtcbiAgICByZW5kZXJlci5zaGFkZXIuYmluZChzaGFkZXIpO1xuICAgIHJlbmRlcmVyLmdlb21ldHJ5LmJpbmQocXVhZCk7XG4gICAgdGhpcy5zdGF0ZS5ibGVuZE1vZGUgPSBjb3JlLnV0aWxzLmNvcnJlY3RCbGVuZE1vZGUodHMuYmxlbmRNb2RlLCBwcmVtdWx0aXBsaWVkKTtcbiAgICByZW5kZXJlci5zdGF0ZS5zZXQodGhpcy5zdGF0ZSk7XG4gICAgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyh0aGlzLnJlbmRlcmVyLmdsLlRSSUFOR0xFUywgNiwgMCk7XG4gIH1cbn1cblRpbGluZ1Nwcml0ZVJlbmRlcmVyLmV4dGVuc2lvbiA9IHtcbiAgbmFtZTogXCJ0aWxpbmdTcHJpdGVcIixcbiAgdHlwZTogY29yZS5FeHRlbnNpb25UeXBlLlJlbmRlcmVyUGx1Z2luXG59O1xuY29yZS5leHRlbnNpb25zLmFkZChUaWxpbmdTcHJpdGVSZW5kZXJlcik7XG5cbmV4cG9ydHMuVGlsaW5nU3ByaXRlUmVuZGVyZXIgPSBUaWxpbmdTcHJpdGVSZW5kZXJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGluZ1Nwcml0ZVJlbmRlcmVyLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgVGlsaW5nU3ByaXRlID0gcmVxdWlyZSgnLi9UaWxpbmdTcHJpdGUuanMnKTtcbnZhciBUaWxpbmdTcHJpdGVSZW5kZXJlciA9IHJlcXVpcmUoJy4vVGlsaW5nU3ByaXRlUmVuZGVyZXIuanMnKTtcblxuXG5cbmV4cG9ydHMuVGlsaW5nU3ByaXRlID0gVGlsaW5nU3ByaXRlLlRpbGluZ1Nwcml0ZTtcbmV4cG9ydHMuVGlsaW5nU3ByaXRlUmVuZGVyZXIgPSBUaWxpbmdTcHJpdGVSZW5kZXJlci5UaWxpbmdTcHJpdGVSZW5kZXJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZ2wxRnJhZ21lbnRTcmMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNpZmRlZiBHTF9FWFRfc2hhZGVyX3RleHR1cmVfbG9kXFxuICAgICNleHRlbnNpb24gR0xfRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCA6IGVuYWJsZVxcbiNlbmRpZlxcbiNkZWZpbmUgU0hBREVSX05BTUUgVGlsaW5nLVNwcml0ZS0xMDBcXG5cXG5wcmVjaXNpb24gbG93cCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIHZlYzQgdUNvbG9yO1xcbnVuaWZvcm0gbWF0MyB1TWFwQ29vcmQ7XFxudW5pZm9ybSB2ZWM0IHVDbGFtcEZyYW1lO1xcbnVuaWZvcm0gdmVjMiB1Q2xhbXBPZmZzZXQ7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICB2ZWMyIGNvb3JkID0gdlRleHR1cmVDb29yZCArIGNlaWwodUNsYW1wT2Zmc2V0IC0gdlRleHR1cmVDb29yZCk7XFxuICAgIGNvb3JkID0gKHVNYXBDb29yZCAqIHZlYzMoY29vcmQsIDEuMCkpLnh5O1xcbiAgICB2ZWMyIHVuY2xhbXBlZCA9IGNvb3JkO1xcbiAgICBjb29yZCA9IGNsYW1wKGNvb3JkLCB1Q2xhbXBGcmFtZS54eSwgdUNsYW1wRnJhbWUuencpO1xcblxcbiAgICAjaWZkZWYgR0xfRVhUX3NoYWRlcl90ZXh0dXJlX2xvZFxcbiAgICAgICAgdmVjNCB0ZXhTYW1wbGUgPSB1bmNsYW1wZWQgPT0gY29vcmRcXG4gICAgICAgICAgICA/IHRleHR1cmUyRCh1U2FtcGxlciwgY29vcmQpIFxcbiAgICAgICAgICAgIDogdGV4dHVyZTJETG9kRVhUKHVTYW1wbGVyLCBjb29yZCwgMCk7XFxuICAgICNlbHNlXFxuICAgICAgICB2ZWM0IHRleFNhbXBsZSA9IHRleHR1cmUyRCh1U2FtcGxlciwgY29vcmQpO1xcbiAgICAjZW5kaWZcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4U2FtcGxlICogdUNvbG9yO1xcbn1cXG5cIjtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBnbDFGcmFnbWVudFNyYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZS10aWxpbmctZmFsbGJhY2suanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBnbDFWZXJ0ZXhTcmMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgU0hBREVSX05BTUUgVGlsaW5nLVNwcml0ZS0xMDBcXG5cXG5wcmVjaXNpb24gbG93cCBmbG9hdDtcXG5cXG5hdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7XFxudW5pZm9ybSBtYXQzIHVUcmFuc2Zvcm07XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcblxcbiAgICB2VGV4dHVyZUNvb3JkID0gKHVUcmFuc2Zvcm0gKiB2ZWMzKGFUZXh0dXJlQ29vcmQsIDEuMCkpLnh5O1xcbn1cXG5cIjtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBnbDFWZXJ0ZXhTcmM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcHJpdGUtdGlsaW5nLWZhbGxiYWNrMi5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGZyYWdtZW50U2ltcGxlU3JjID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIFNIQURFUl9OQU1FIFRpbGluZy1TcHJpdGUtU2ltcGxlLTEwMFxcblxcbnByZWNpc2lvbiBsb3dwIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gdmVjNCB1Q29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICB2ZWM0IHRleFNhbXBsZSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleFNhbXBsZSAqIHVDb2xvcjtcXG59XFxuXCI7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZnJhZ21lbnRTaW1wbGVTcmM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcHJpdGUtdGlsaW5nLXNpbXBsZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGdsMkZyYWdtZW50U3JjID0gXCIjdmVyc2lvbiAzMDAgZXNcXG4jZGVmaW5lIFNIQURFUl9OQU1FIFRpbGluZy1TcHJpdGUtMTAwXFxuXFxucHJlY2lzaW9uIGxvd3AgZmxvYXQ7XFxuXFxuaW4gdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbm91dCB2ZWM0IGZyYWdtZW50Q29sb3I7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSB2ZWM0IHVDb2xvcjtcXG51bmlmb3JtIG1hdDMgdU1hcENvb3JkO1xcbnVuaWZvcm0gdmVjNCB1Q2xhbXBGcmFtZTtcXG51bmlmb3JtIHZlYzIgdUNsYW1wT2Zmc2V0O1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgdmVjMiBjb29yZCA9IHZUZXh0dXJlQ29vcmQgKyBjZWlsKHVDbGFtcE9mZnNldCAtIHZUZXh0dXJlQ29vcmQpO1xcbiAgICBjb29yZCA9ICh1TWFwQ29vcmQgKiB2ZWMzKGNvb3JkLCAxLjApKS54eTtcXG4gICAgdmVjMiB1bmNsYW1wZWQgPSBjb29yZDtcXG4gICAgY29vcmQgPSBjbGFtcChjb29yZCwgdUNsYW1wRnJhbWUueHksIHVDbGFtcEZyYW1lLnp3KTtcXG5cXG4gICAgdmVjNCB0ZXhTYW1wbGUgPSB0ZXh0dXJlKHVTYW1wbGVyLCBjb29yZCwgdW5jbGFtcGVkID09IGNvb3JkID8gMC4wZiA6IC0zMi4wZik7Ly8gbG9kLWJpYXMgdmVyeSBuZWdhdGl2ZSB0byBmb3JjZSBsb2QgMFxcblxcbiAgICBmcmFnbWVudENvbG9yID0gdGV4U2FtcGxlICogdUNvbG9yO1xcbn1cXG5cIjtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBnbDJGcmFnbWVudFNyYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZS10aWxpbmcuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBnbDJWZXJ0ZXhTcmMgPSBcIiN2ZXJzaW9uIDMwMCBlc1xcbiNkZWZpbmUgU0hBREVSX05BTUUgVGlsaW5nLVNwcml0ZS0zMDBcXG5cXG5wcmVjaXNpb24gbG93cCBmbG9hdDtcXG5cXG5pbiB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXG5pbiB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxudW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0MyB1VHJhbnNmb3JtO1xcblxcbm91dCB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcblxcbiAgICB2VGV4dHVyZUNvb3JkID0gKHVUcmFuc2Zvcm0gKiB2ZWMzKGFUZXh0dXJlQ29vcmQsIDEuMCkpLnh5O1xcbn1cXG5cIjtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBnbDJWZXJ0ZXhTcmM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcHJpdGUtdGlsaW5nMi5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgZGlzcGxheSA9IHJlcXVpcmUoJ0BwaXhpL2Rpc3BsYXknKTtcblxuY29uc3QgdGVtcFBvaW50ID0gbmV3IGNvcmUuUG9pbnQoKTtcbmNvbnN0IGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDIsIDAsIDIsIDNdKTtcbmNsYXNzIFNwcml0ZSBleHRlbmRzIGRpc3BsYXkuQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fYW5jaG9yID0gbmV3IGNvcmUuT2JzZXJ2YWJsZVBvaW50KHRoaXMuX29uQW5jaG9yVXBkYXRlLCB0aGlzLCB0ZXh0dXJlID8gdGV4dHVyZS5kZWZhdWx0QW5jaG9yLnggOiAwLCB0ZXh0dXJlID8gdGV4dHVyZS5kZWZhdWx0QW5jaG9yLnkgOiAwKTtcbiAgICB0aGlzLl90ZXh0dXJlID0gbnVsbDtcbiAgICB0aGlzLl93aWR0aCA9IDA7XG4gICAgdGhpcy5faGVpZ2h0ID0gMDtcbiAgICB0aGlzLl90aW50Q29sb3IgPSBuZXcgY29yZS5Db2xvcigxNjc3NzIxNSk7XG4gICAgdGhpcy5fdGludFJHQiA9IG51bGw7XG4gICAgdGhpcy50aW50ID0gMTY3NzcyMTU7XG4gICAgdGhpcy5ibGVuZE1vZGUgPSBjb3JlLkJMRU5EX01PREVTLk5PUk1BTDtcbiAgICB0aGlzLl9jYWNoZWRUaW50ID0gMTY3NzcyMTU7XG4gICAgdGhpcy51dnMgPSBudWxsO1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmUgfHwgY29yZS5UZXh0dXJlLkVNUFRZO1xuICAgIHRoaXMudmVydGV4RGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XG4gICAgdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSA9IG51bGw7XG4gICAgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMTtcbiAgICB0aGlzLl90ZXh0dXJlSUQgPSAtMTtcbiAgICB0aGlzLl90cmFuc2Zvcm1UcmltbWVkSUQgPSAtMTtcbiAgICB0aGlzLl90ZXh0dXJlVHJpbW1lZElEID0gLTE7XG4gICAgdGhpcy5pbmRpY2VzID0gaW5kaWNlcztcbiAgICB0aGlzLnBsdWdpbk5hbWUgPSBcImJhdGNoXCI7XG4gICAgdGhpcy5pc1Nwcml0ZSA9IHRydWU7XG4gICAgdGhpcy5fcm91bmRQaXhlbHMgPSBjb3JlLnNldHRpbmdzLlJPVU5EX1BJWEVMUztcbiAgfVxuICBfb25UZXh0dXJlVXBkYXRlKCkge1xuICAgIHRoaXMuX3RleHR1cmVJRCA9IC0xO1xuICAgIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSAtMTtcbiAgICB0aGlzLl9jYWNoZWRUaW50ID0gMTY3NzcyMTU7XG4gICAgaWYgKHRoaXMuX3dpZHRoKSB7XG4gICAgICB0aGlzLnNjYWxlLnggPSBjb3JlLnV0aWxzLnNpZ24odGhpcy5zY2FsZS54KSAqIHRoaXMuX3dpZHRoIC8gdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoO1xuICAgIH1cbiAgICBpZiAodGhpcy5faGVpZ2h0KSB7XG4gICAgICB0aGlzLnNjYWxlLnkgPSBjb3JlLnV0aWxzLnNpZ24odGhpcy5zY2FsZS55KSAqIHRoaXMuX2hlaWdodCAvIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gICAgfVxuICB9XG4gIF9vbkFuY2hvclVwZGF0ZSgpIHtcbiAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IC0xO1xuICAgIHRoaXMuX3RyYW5zZm9ybVRyaW1tZWRJRCA9IC0xO1xuICB9XG4gIGNhbGN1bGF0ZVZlcnRpY2VzKCkge1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlO1xuICAgIGlmICh0aGlzLl90cmFuc2Zvcm1JRCA9PT0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQgJiYgdGhpcy5fdGV4dHVyZUlEID09PSB0ZXh0dXJlLl91cGRhdGVJRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdGV4dHVyZUlEICE9PSB0ZXh0dXJlLl91cGRhdGVJRCkge1xuICAgICAgdGhpcy51dnMgPSB0aGlzLl90ZXh0dXJlLl91dnMudXZzRmxvYXQzMjtcbiAgICB9XG4gICAgdGhpcy5fdHJhbnNmb3JtSUQgPSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRDtcbiAgICB0aGlzLl90ZXh0dXJlSUQgPSB0ZXh0dXJlLl91cGRhdGVJRDtcbiAgICBjb25zdCB3dCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgIGNvbnN0IGEgPSB3dC5hO1xuICAgIGNvbnN0IGIgPSB3dC5iO1xuICAgIGNvbnN0IGMgPSB3dC5jO1xuICAgIGNvbnN0IGQgPSB3dC5kO1xuICAgIGNvbnN0IHR4ID0gd3QudHg7XG4gICAgY29uc3QgdHkgPSB3dC50eTtcbiAgICBjb25zdCB2ZXJ0ZXhEYXRhID0gdGhpcy52ZXJ0ZXhEYXRhO1xuICAgIGNvbnN0IHRyaW0gPSB0ZXh0dXJlLnRyaW07XG4gICAgY29uc3Qgb3JpZyA9IHRleHR1cmUub3JpZztcbiAgICBjb25zdCBhbmNob3IgPSB0aGlzLl9hbmNob3I7XG4gICAgbGV0IHcwID0gMDtcbiAgICBsZXQgdzEgPSAwO1xuICAgIGxldCBoMCA9IDA7XG4gICAgbGV0IGgxID0gMDtcbiAgICBpZiAodHJpbSkge1xuICAgICAgdzEgPSB0cmltLnggLSBhbmNob3IuX3ggKiBvcmlnLndpZHRoO1xuICAgICAgdzAgPSB3MSArIHRyaW0ud2lkdGg7XG4gICAgICBoMSA9IHRyaW0ueSAtIGFuY2hvci5feSAqIG9yaWcuaGVpZ2h0O1xuICAgICAgaDAgPSBoMSArIHRyaW0uaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB3MSA9IC1hbmNob3IuX3ggKiBvcmlnLndpZHRoO1xuICAgICAgdzAgPSB3MSArIG9yaWcud2lkdGg7XG4gICAgICBoMSA9IC1hbmNob3IuX3kgKiBvcmlnLmhlaWdodDtcbiAgICAgIGgwID0gaDEgKyBvcmlnLmhlaWdodDtcbiAgICB9XG4gICAgdmVydGV4RGF0YVswXSA9IGEgKiB3MSArIGMgKiBoMSArIHR4O1xuICAgIHZlcnRleERhdGFbMV0gPSBkICogaDEgKyBiICogdzEgKyB0eTtcbiAgICB2ZXJ0ZXhEYXRhWzJdID0gYSAqIHcwICsgYyAqIGgxICsgdHg7XG4gICAgdmVydGV4RGF0YVszXSA9IGQgKiBoMSArIGIgKiB3MCArIHR5O1xuICAgIHZlcnRleERhdGFbNF0gPSBhICogdzAgKyBjICogaDAgKyB0eDtcbiAgICB2ZXJ0ZXhEYXRhWzVdID0gZCAqIGgwICsgYiAqIHcwICsgdHk7XG4gICAgdmVydGV4RGF0YVs2XSA9IGEgKiB3MSArIGMgKiBoMCArIHR4O1xuICAgIHZlcnRleERhdGFbN10gPSBkICogaDAgKyBiICogdzEgKyB0eTtcbiAgICBpZiAodGhpcy5fcm91bmRQaXhlbHMpIHtcbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPSBjb3JlLnNldHRpbmdzLlJFU09MVVRJT047XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleERhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmVydGV4RGF0YVtpXSA9IE1hdGgucm91bmQodmVydGV4RGF0YVtpXSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsY3VsYXRlVHJpbW1lZFZlcnRpY2VzKCkge1xuICAgIGlmICghdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSkge1xuICAgICAgdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl90cmFuc2Zvcm1UcmltbWVkSUQgPT09IHRoaXMudHJhbnNmb3JtLl93b3JsZElEICYmIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPT09IHRoaXMuX3RleHR1cmUuX3VwZGF0ZUlEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3RyYW5zZm9ybVRyaW1tZWRJRCA9IHRoaXMudHJhbnNmb3JtLl93b3JsZElEO1xuICAgIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSB0aGlzLl90ZXh0dXJlLl91cGRhdGVJRDtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcbiAgICBjb25zdCB2ZXJ0ZXhEYXRhID0gdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YTtcbiAgICBjb25zdCBvcmlnID0gdGV4dHVyZS5vcmlnO1xuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuX2FuY2hvcjtcbiAgICBjb25zdCB3dCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgIGNvbnN0IGEgPSB3dC5hO1xuICAgIGNvbnN0IGIgPSB3dC5iO1xuICAgIGNvbnN0IGMgPSB3dC5jO1xuICAgIGNvbnN0IGQgPSB3dC5kO1xuICAgIGNvbnN0IHR4ID0gd3QudHg7XG4gICAgY29uc3QgdHkgPSB3dC50eTtcbiAgICBjb25zdCB3MSA9IC1hbmNob3IuX3ggKiBvcmlnLndpZHRoO1xuICAgIGNvbnN0IHcwID0gdzEgKyBvcmlnLndpZHRoO1xuICAgIGNvbnN0IGgxID0gLWFuY2hvci5feSAqIG9yaWcuaGVpZ2h0O1xuICAgIGNvbnN0IGgwID0gaDEgKyBvcmlnLmhlaWdodDtcbiAgICB2ZXJ0ZXhEYXRhWzBdID0gYSAqIHcxICsgYyAqIGgxICsgdHg7XG4gICAgdmVydGV4RGF0YVsxXSA9IGQgKiBoMSArIGIgKiB3MSArIHR5O1xuICAgIHZlcnRleERhdGFbMl0gPSBhICogdzAgKyBjICogaDEgKyB0eDtcbiAgICB2ZXJ0ZXhEYXRhWzNdID0gZCAqIGgxICsgYiAqIHcwICsgdHk7XG4gICAgdmVydGV4RGF0YVs0XSA9IGEgKiB3MCArIGMgKiBoMCArIHR4O1xuICAgIHZlcnRleERhdGFbNV0gPSBkICogaDAgKyBiICogdzAgKyB0eTtcbiAgICB2ZXJ0ZXhEYXRhWzZdID0gYSAqIHcxICsgYyAqIGgwICsgdHg7XG4gICAgdmVydGV4RGF0YVs3XSA9IGQgKiBoMCArIGIgKiB3MSArIHR5O1xuICB9XG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICB0aGlzLmNhbGN1bGF0ZVZlcnRpY2VzKCk7XG4gICAgcmVuZGVyZXIuYmF0Y2guc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2luc1t0aGlzLnBsdWdpbk5hbWVdKTtcbiAgICByZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0ucmVuZGVyKHRoaXMpO1xuICB9XG4gIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgY29uc3QgdHJpbSA9IHRoaXMuX3RleHR1cmUudHJpbTtcbiAgICBjb25zdCBvcmlnID0gdGhpcy5fdGV4dHVyZS5vcmlnO1xuICAgIGlmICghdHJpbSB8fCB0cmltLndpZHRoID09PSBvcmlnLndpZHRoICYmIHRyaW0uaGVpZ2h0ID09PSBvcmlnLmhlaWdodCkge1xuICAgICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpO1xuICAgICAgdGhpcy5fYm91bmRzLmFkZFF1YWQodGhpcy52ZXJ0ZXhEYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYWxjdWxhdGVUcmltbWVkVmVydGljZXMoKTtcbiAgICAgIHRoaXMuX2JvdW5kcy5hZGRRdWFkKHRoaXMudmVydGV4VHJpbW1lZERhdGEpO1xuICAgIH1cbiAgfVxuICBnZXRMb2NhbEJvdW5kcyhyZWN0KSB7XG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoIXRoaXMuX2xvY2FsQm91bmRzKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsQm91bmRzID0gbmV3IGRpc3BsYXkuQm91bmRzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9sb2NhbEJvdW5kcy5taW5YID0gdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoICogLXRoaXMuX2FuY2hvci5feDtcbiAgICAgIHRoaXMuX2xvY2FsQm91bmRzLm1pblkgPSB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0ICogLXRoaXMuX2FuY2hvci5feTtcbiAgICAgIHRoaXMuX2xvY2FsQm91bmRzLm1heFggPSB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGggKiAoMSAtIHRoaXMuX2FuY2hvci5feCk7XG4gICAgICB0aGlzLl9sb2NhbEJvdW5kcy5tYXhZID0gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodCAqICgxIC0gdGhpcy5fYW5jaG9yLl95KTtcbiAgICAgIGlmICghcmVjdCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvY2FsQm91bmRzUmVjdCkge1xuICAgICAgICAgIHRoaXMuX2xvY2FsQm91bmRzUmVjdCA9IG5ldyBjb3JlLlJlY3RhbmdsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJlY3QgPSB0aGlzLl9sb2NhbEJvdW5kc1JlY3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fbG9jYWxCb3VuZHMuZ2V0UmVjdGFuZ2xlKHJlY3QpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZ2V0TG9jYWxCb3VuZHMuY2FsbCh0aGlzLCByZWN0KTtcbiAgfVxuICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UocG9pbnQsIHRlbXBQb2ludCk7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICBjb25zdCB4MSA9IC13aWR0aCAqIHRoaXMuYW5jaG9yLng7XG4gICAgbGV0IHkxID0gMDtcbiAgICBpZiAodGVtcFBvaW50LnggPj0geDEgJiYgdGVtcFBvaW50LnggPCB4MSArIHdpZHRoKSB7XG4gICAgICB5MSA9IC1oZWlnaHQgKiB0aGlzLmFuY2hvci55O1xuICAgICAgaWYgKHRlbXBQb2ludC55ID49IHkxICYmIHRlbXBQb2ludC55IDwgeTEgKyBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xuICAgIHRoaXMuX3RleHR1cmUub2ZmKFwidXBkYXRlXCIsIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSwgdGhpcyk7XG4gICAgdGhpcy5fYW5jaG9yID0gbnVsbDtcbiAgICBjb25zdCBkZXN0cm95VGV4dHVyZSA9IHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMgOiBvcHRpb25zPy50ZXh0dXJlO1xuICAgIGlmIChkZXN0cm95VGV4dHVyZSkge1xuICAgICAgY29uc3QgZGVzdHJveUJhc2VUZXh0dXJlID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucyA6IG9wdGlvbnM/LmJhc2VUZXh0dXJlO1xuICAgICAgdGhpcy5fdGV4dHVyZS5kZXN0cm95KCEhZGVzdHJveUJhc2VUZXh0dXJlKTtcbiAgICB9XG4gICAgdGhpcy5fdGV4dHVyZSA9IG51bGw7XG4gIH1cbiAgc3RhdGljIGZyb20oc291cmNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IHNvdXJjZSBpbnN0YW5jZW9mIGNvcmUuVGV4dHVyZSA/IHNvdXJjZSA6IGNvcmUuVGV4dHVyZS5mcm9tKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBTcHJpdGUodGV4dHVyZSk7XG4gIH1cbiAgc2V0IHJvdW5kUGl4ZWxzKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3JvdW5kUGl4ZWxzICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMTtcbiAgICB9XG4gICAgdGhpcy5fcm91bmRQaXhlbHMgPSB2YWx1ZTtcbiAgfVxuICBnZXQgcm91bmRQaXhlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JvdW5kUGl4ZWxzO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS54KSAqIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICBjb25zdCBzID0gY29yZS51dGlscy5zaWduKHRoaXMuc2NhbGUueCkgfHwgMTtcbiAgICB0aGlzLnNjYWxlLnggPSBzICogdmFsdWUgLyB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGg7XG4gICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLnkpICogdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgfVxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgY29uc3QgcyA9IGNvcmUudXRpbHMuc2lnbih0aGlzLnNjYWxlLnkpIHx8IDE7XG4gICAgdGhpcy5zY2FsZS55ID0gcyAqIHZhbHVlIC8gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICBnZXQgYW5jaG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9hbmNob3I7XG4gIH1cbiAgc2V0IGFuY2hvcih2YWx1ZSkge1xuICAgIHRoaXMuX2FuY2hvci5jb3B5RnJvbSh2YWx1ZSk7XG4gIH1cbiAgZ2V0IHRpbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbnRDb2xvci52YWx1ZTtcbiAgfVxuICBzZXQgdGludCh2YWx1ZSkge1xuICAgIHRoaXMuX3RpbnRDb2xvci5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgdGhpcy5fdGludFJHQiA9IHRoaXMuX3RpbnRDb2xvci50b0xpdHRsZUVuZGlhbk51bWJlcigpO1xuICB9XG4gIGdldCB0aW50VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbnRDb2xvci50b051bWJlcigpO1xuICB9XG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0dXJlO1xuICB9XG4gIHNldCB0ZXh0dXJlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3RleHR1cmUgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl90ZXh0dXJlKSB7XG4gICAgICB0aGlzLl90ZXh0dXJlLm9mZihcInVwZGF0ZVwiLCB0aGlzLl9vblRleHR1cmVVcGRhdGUsIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl90ZXh0dXJlID0gdmFsdWUgfHwgY29yZS5UZXh0dXJlLkVNUFRZO1xuICAgIHRoaXMuX2NhY2hlZFRpbnQgPSAxNjc3NzIxNTtcbiAgICB0aGlzLl90ZXh0dXJlSUQgPSAtMTtcbiAgICB0aGlzLl90ZXh0dXJlVHJpbW1lZElEID0gLTE7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUuYmFzZVRleHR1cmUudmFsaWQpIHtcbiAgICAgICAgdGhpcy5fb25UZXh0dXJlVXBkYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZS5vbmNlKFwidXBkYXRlXCIsIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuU3ByaXRlID0gU3ByaXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ByaXRlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgU3ByaXRlID0gcmVxdWlyZSgnLi9TcHJpdGUuanMnKTtcblxuXG5cbmV4cG9ydHMuU3ByaXRlID0gU3ByaXRlLlNwcml0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcblxuY29uc3QgX1Nwcml0ZXNoZWV0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlLCBkYXRhLCByZXNvbHV0aW9uRmlsZW5hbWUgPSBudWxsKSB7XG4gICAgdGhpcy5saW5rZWRTaGVldHMgPSBbXTtcbiAgICB0aGlzLl90ZXh0dXJlID0gdGV4dHVyZSBpbnN0YW5jZW9mIGNvcmUuVGV4dHVyZSA/IHRleHR1cmUgOiBudWxsO1xuICAgIHRoaXMuYmFzZVRleHR1cmUgPSB0ZXh0dXJlIGluc3RhbmNlb2YgY29yZS5CYXNlVGV4dHVyZSA/IHRleHR1cmUgOiB0aGlzLl90ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgIHRoaXMudGV4dHVyZXMgPSB7fTtcbiAgICB0aGlzLmFuaW1hdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIGNvbnN0IHJlc291cmNlID0gdGhpcy5iYXNlVGV4dHVyZS5yZXNvdXJjZTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSB0aGlzLl91cGRhdGVSZXNvbHV0aW9uKHJlc29sdXRpb25GaWxlbmFtZSB8fCAocmVzb3VyY2UgPyByZXNvdXJjZS51cmwgOiBudWxsKSk7XG4gICAgdGhpcy5fZnJhbWVzID0gdGhpcy5kYXRhLmZyYW1lcztcbiAgICB0aGlzLl9mcmFtZUtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9mcmFtZXMpO1xuICAgIHRoaXMuX2JhdGNoSW5kZXggPSAwO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbDtcbiAgfVxuICBfdXBkYXRlUmVzb2x1dGlvbihyZXNvbHV0aW9uRmlsZW5hbWUgPSBudWxsKSB7XG4gICAgY29uc3QgeyBzY2FsZSB9ID0gdGhpcy5kYXRhLm1ldGE7XG4gICAgbGV0IHJlc29sdXRpb24gPSBjb3JlLnV0aWxzLmdldFJlc29sdXRpb25PZlVybChyZXNvbHV0aW9uRmlsZW5hbWUsIG51bGwpO1xuICAgIGlmIChyZXNvbHV0aW9uID09PSBudWxsKSB7XG4gICAgICByZXNvbHV0aW9uID0gcGFyc2VGbG9hdChzY2FsZSA/PyBcIjFcIik7XG4gICAgfVxuICAgIGlmIChyZXNvbHV0aW9uICE9PSAxKSB7XG4gICAgICB0aGlzLmJhc2VUZXh0dXJlLnNldFJlc29sdXRpb24ocmVzb2x1dGlvbik7XG4gICAgfVxuICAgIHJldHVybiByZXNvbHV0aW9uO1xuICB9XG4gIHBhcnNlKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5fY2FsbGJhY2sgPSByZXNvbHZlO1xuICAgICAgdGhpcy5fYmF0Y2hJbmRleCA9IDA7XG4gICAgICBpZiAodGhpcy5fZnJhbWVLZXlzLmxlbmd0aCA8PSBfU3ByaXRlc2hlZXQuQkFUQ0hfU0laRSkge1xuICAgICAgICB0aGlzLl9wcm9jZXNzRnJhbWVzKDApO1xuICAgICAgICB0aGlzLl9wcm9jZXNzQW5pbWF0aW9ucygpO1xuICAgICAgICB0aGlzLl9wYXJzZUNvbXBsZXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9uZXh0QmF0Y2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfcHJvY2Vzc0ZyYW1lcyhpbml0aWFsRnJhbWVJbmRleCkge1xuICAgIGxldCBmcmFtZUluZGV4ID0gaW5pdGlhbEZyYW1lSW5kZXg7XG4gICAgY29uc3QgbWF4RnJhbWVzID0gX1Nwcml0ZXNoZWV0LkJBVENIX1NJWkU7XG4gICAgd2hpbGUgKGZyYW1lSW5kZXggLSBpbml0aWFsRnJhbWVJbmRleCA8IG1heEZyYW1lcyAmJiBmcmFtZUluZGV4IDwgdGhpcy5fZnJhbWVLZXlzLmxlbmd0aCkge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2ZyYW1lS2V5c1tmcmFtZUluZGV4XTtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9mcmFtZXNbaV07XG4gICAgICBjb25zdCByZWN0ID0gZGF0YS5mcmFtZTtcbiAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgIGxldCBmcmFtZSA9IG51bGw7XG4gICAgICAgIGxldCB0cmltID0gbnVsbDtcbiAgICAgICAgY29uc3Qgc291cmNlU2l6ZSA9IGRhdGEudHJpbW1lZCAhPT0gZmFsc2UgJiYgZGF0YS5zb3VyY2VTaXplID8gZGF0YS5zb3VyY2VTaXplIDogZGF0YS5mcmFtZTtcbiAgICAgICAgY29uc3Qgb3JpZyA9IG5ldyBjb3JlLlJlY3RhbmdsZSgwLCAwLCBNYXRoLmZsb29yKHNvdXJjZVNpemUudykgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3Ioc291cmNlU2l6ZS5oKSAvIHRoaXMucmVzb2x1dGlvbik7XG4gICAgICAgIGlmIChkYXRhLnJvdGF0ZWQpIHtcbiAgICAgICAgICBmcmFtZSA9IG5ldyBjb3JlLlJlY3RhbmdsZShNYXRoLmZsb29yKHJlY3QueCkgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IocmVjdC55KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LmgpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QudykgLyB0aGlzLnJlc29sdXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYW1lID0gbmV3IGNvcmUuUmVjdGFuZ2xlKE1hdGguZmxvb3IocmVjdC54KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LnkpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QudykgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IocmVjdC5oKSAvIHRoaXMucmVzb2x1dGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEudHJpbW1lZCAhPT0gZmFsc2UgJiYgZGF0YS5zcHJpdGVTb3VyY2VTaXplKSB7XG4gICAgICAgICAgdHJpbSA9IG5ldyBjb3JlLlJlY3RhbmdsZShNYXRoLmZsb29yKGRhdGEuc3ByaXRlU291cmNlU2l6ZS54KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihkYXRhLnNwcml0ZVNvdXJjZVNpemUueSkgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IocmVjdC53KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LmgpIC8gdGhpcy5yZXNvbHV0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleHR1cmVzW2ldID0gbmV3IGNvcmUuVGV4dHVyZSh0aGlzLmJhc2VUZXh0dXJlLCBmcmFtZSwgb3JpZywgdHJpbSwgZGF0YS5yb3RhdGVkID8gMiA6IDAsIGRhdGEuYW5jaG9yLCBkYXRhLmJvcmRlcnMpO1xuICAgICAgICBjb3JlLlRleHR1cmUuYWRkVG9DYWNoZSh0aGlzLnRleHR1cmVzW2ldLCBpKTtcbiAgICAgIH1cbiAgICAgIGZyYW1lSW5kZXgrKztcbiAgICB9XG4gIH1cbiAgX3Byb2Nlc3NBbmltYXRpb25zKCkge1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLmRhdGEuYW5pbWF0aW9ucyB8fCB7fTtcbiAgICBmb3IgKGNvbnN0IGFuaW1OYW1lIGluIGFuaW1hdGlvbnMpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uc1thbmltTmFtZV0gPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW5pbWF0aW9uc1thbmltTmFtZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZnJhbWVOYW1lID0gYW5pbWF0aW9uc1thbmltTmFtZV1baV07XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uc1thbmltTmFtZV0ucHVzaCh0aGlzLnRleHR1cmVzW2ZyYW1lTmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfcGFyc2VDb21wbGV0ZSgpIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLl9iYXRjaEluZGV4ID0gMDtcbiAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMudGV4dHVyZXMpO1xuICB9XG4gIF9uZXh0QmF0Y2goKSB7XG4gICAgdGhpcy5fcHJvY2Vzc0ZyYW1lcyh0aGlzLl9iYXRjaEluZGV4ICogX1Nwcml0ZXNoZWV0LkJBVENIX1NJWkUpO1xuICAgIHRoaXMuX2JhdGNoSW5kZXgrKztcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9iYXRjaEluZGV4ICogX1Nwcml0ZXNoZWV0LkJBVENIX1NJWkUgPCB0aGlzLl9mcmFtZUtleXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX25leHRCYXRjaCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc0FuaW1hdGlvbnMoKTtcbiAgICAgICAgdGhpcy5fcGFyc2VDb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0sIDApO1xuICB9XG4gIGRlc3Ryb3koZGVzdHJveUJhc2UgPSBmYWxzZSkge1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLnRleHR1cmVzKSB7XG4gICAgICB0aGlzLnRleHR1cmVzW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5fZnJhbWVzID0gbnVsbDtcbiAgICB0aGlzLl9mcmFtZUtleXMgPSBudWxsO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy50ZXh0dXJlcyA9IG51bGw7XG4gICAgaWYgKGRlc3Ryb3lCYXNlKSB7XG4gICAgICB0aGlzLl90ZXh0dXJlPy5kZXN0cm95KCk7XG4gICAgICB0aGlzLmJhc2VUZXh0dXJlLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5fdGV4dHVyZSA9IG51bGw7XG4gICAgdGhpcy5iYXNlVGV4dHVyZSA9IG51bGw7XG4gICAgdGhpcy5saW5rZWRTaGVldHMgPSBbXTtcbiAgfVxufTtcbmxldCBTcHJpdGVzaGVldCA9IF9TcHJpdGVzaGVldDtcblNwcml0ZXNoZWV0LkJBVENIX1NJWkUgPSAxZTM7XG5cbmV4cG9ydHMuU3ByaXRlc2hlZXQgPSBTcHJpdGVzaGVldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNwcml0ZXNoZWV0LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgU3ByaXRlc2hlZXQgPSByZXF1aXJlKCcuL1Nwcml0ZXNoZWV0LmpzJyk7XG52YXIgc3ByaXRlc2hlZXRBc3NldCA9IHJlcXVpcmUoJy4vc3ByaXRlc2hlZXRBc3NldC5qcycpO1xuXG5cblxuZXhwb3J0cy5TcHJpdGVzaGVldCA9IFNwcml0ZXNoZWV0LlNwcml0ZXNoZWV0O1xuZXhwb3J0cy5zcHJpdGVzaGVldEFzc2V0ID0gc3ByaXRlc2hlZXRBc3NldC5zcHJpdGVzaGVldEFzc2V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBhc3NldHMgPSByZXF1aXJlKCdAcGl4aS9hc3NldHMnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xudmFyIFNwcml0ZXNoZWV0ID0gcmVxdWlyZSgnLi9TcHJpdGVzaGVldC5qcycpO1xuXG5jb25zdCB2YWxpZEltYWdlcyA9IFtcImpwZ1wiLCBcInBuZ1wiLCBcImpwZWdcIiwgXCJhdmlmXCIsIFwid2VicFwiXTtcbmZ1bmN0aW9uIGdldENhY2hlYWJsZUFzc2V0cyhrZXlzLCBhc3NldCwgaWdub3JlTXVsdGlQYWNrKSB7XG4gIGNvbnN0IG91dCA9IHt9O1xuICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIG91dFtrZXldID0gYXNzZXQ7XG4gIH0pO1xuICBPYmplY3Qua2V5cyhhc3NldC50ZXh0dXJlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgb3V0W2tleV0gPSBhc3NldC50ZXh0dXJlc1trZXldO1xuICB9KTtcbiAgaWYgKCFpZ25vcmVNdWx0aVBhY2spIHtcbiAgICBjb25zdCBiYXNlUGF0aCA9IGNvcmUudXRpbHMucGF0aC5kaXJuYW1lKGtleXNbMF0pO1xuICAgIGFzc2V0LmxpbmtlZFNoZWV0cy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICBjb25zdCBvdXQyID0gZ2V0Q2FjaGVhYmxlQXNzZXRzKFtgJHtiYXNlUGF0aH0vJHthc3NldC5kYXRhLm1ldGEucmVsYXRlZF9tdWx0aV9wYWNrc1tpXX1gXSwgaXRlbSwgdHJ1ZSk7XG4gICAgICBPYmplY3QuYXNzaWduKG91dCwgb3V0Mik7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmNvbnN0IHNwcml0ZXNoZWV0QXNzZXQgPSB7XG4gIGV4dGVuc2lvbjogY29yZS5FeHRlbnNpb25UeXBlLkFzc2V0LFxuICBjYWNoZToge1xuICAgIHRlc3Q6IChhc3NldCkgPT4gYXNzZXQgaW5zdGFuY2VvZiBTcHJpdGVzaGVldC5TcHJpdGVzaGVldCxcbiAgICBnZXRDYWNoZWFibGVBc3NldHM6IChrZXlzLCBhc3NldCkgPT4gZ2V0Q2FjaGVhYmxlQXNzZXRzKGtleXMsIGFzc2V0LCBmYWxzZSlcbiAgfSxcbiAgcmVzb2x2ZXI6IHtcbiAgICB0ZXN0OiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IHRlbXBVUkwgPSB2YWx1ZS5zcGxpdChcIj9cIilbMF07XG4gICAgICBjb25zdCBzcGxpdCA9IHRlbXBVUkwuc3BsaXQoXCIuXCIpO1xuICAgICAgY29uc3QgZXh0ZW5zaW9uID0gc3BsaXQucG9wKCk7XG4gICAgICBjb25zdCBmb3JtYXQgPSBzcGxpdC5wb3AoKTtcbiAgICAgIHJldHVybiBleHRlbnNpb24gPT09IFwianNvblwiICYmIHZhbGlkSW1hZ2VzLmluY2x1ZGVzKGZvcm1hdCk7XG4gICAgfSxcbiAgICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBzcGxpdCA9IHZhbHVlLnNwbGl0KFwiLlwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc29sdXRpb246IHBhcnNlRmxvYXQoY29yZS5zZXR0aW5ncy5SRVRJTkFfUFJFRklYLmV4ZWModmFsdWUpPy5bMV0gPz8gXCIxXCIpLFxuICAgICAgICBmb3JtYXQ6IHNwbGl0W3NwbGl0Lmxlbmd0aCAtIDJdLFxuICAgICAgICBzcmM6IHZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgbG9hZGVyOiB7XG4gICAgbmFtZTogXCJzcHJpdGVzaGVldExvYWRlclwiLFxuICAgIGV4dGVuc2lvbjoge1xuICAgICAgdHlwZTogY29yZS5FeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgICBwcmlvcml0eTogYXNzZXRzLkxvYWRlclBhcnNlclByaW9yaXR5Lk5vcm1hbFxuICAgIH0sXG4gICAgYXN5bmMgdGVzdFBhcnNlKGFzc2V0LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gY29yZS51dGlscy5wYXRoLmV4dG5hbWUob3B0aW9ucy5zcmMpLnRvTG93ZXJDYXNlKCkgPT09IFwiLmpzb25cIiAmJiAhIWFzc2V0LmZyYW1lcztcbiAgICB9LFxuICAgIGFzeW5jIHBhcnNlKGFzc2V0LCBvcHRpb25zLCBsb2FkZXIpIHtcbiAgICAgIGxldCBiYXNlUGF0aCA9IGNvcmUudXRpbHMucGF0aC5kaXJuYW1lKG9wdGlvbnMuc3JjKTtcbiAgICAgIGlmIChiYXNlUGF0aCAmJiBiYXNlUGF0aC5sYXN0SW5kZXhPZihcIi9cIikgIT09IGJhc2VQYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgYmFzZVBhdGggKz0gXCIvXCI7XG4gICAgICB9XG4gICAgICBsZXQgaW1hZ2VQYXRoID0gYmFzZVBhdGggKyBhc3NldC5tZXRhLmltYWdlO1xuICAgICAgaW1hZ2VQYXRoID0gYXNzZXRzLmNvcHlTZWFyY2hQYXJhbXMoaW1hZ2VQYXRoLCBvcHRpb25zLnNyYyk7XG4gICAgICBjb25zdCBhc3NldHMkMSA9IGF3YWl0IGxvYWRlci5sb2FkKFtpbWFnZVBhdGhdKTtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBhc3NldHMkMVtpbWFnZVBhdGhdO1xuICAgICAgY29uc3Qgc3ByaXRlc2hlZXQgPSBuZXcgU3ByaXRlc2hlZXQuU3ByaXRlc2hlZXQodGV4dHVyZS5iYXNlVGV4dHVyZSwgYXNzZXQsIG9wdGlvbnMuc3JjKTtcbiAgICAgIGF3YWl0IHNwcml0ZXNoZWV0LnBhcnNlKCk7XG4gICAgICBjb25zdCBtdWx0aVBhY2tzID0gYXNzZXQ/Lm1ldGE/LnJlbGF0ZWRfbXVsdGlfcGFja3M7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShtdWx0aVBhY2tzKSkge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgbXVsdGlQYWNrcykge1xuICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBpdGVtVXJsID0gYmFzZVBhdGggKyBpdGVtO1xuICAgICAgICAgIGlmIChvcHRpb25zLmRhdGE/Lmlnbm9yZU11bHRpUGFjaykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW1VcmwgPSBhc3NldHMuY29weVNlYXJjaFBhcmFtcyhpdGVtVXJsLCBvcHRpb25zLnNyYyk7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChsb2FkZXIubG9hZCh7XG4gICAgICAgICAgICBzcmM6IGl0ZW1VcmwsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGlnbm9yZU11bHRpUGFjazogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIHNwcml0ZXNoZWV0LmxpbmtlZFNoZWV0cyA9IHJlcztcbiAgICAgICAgcmVzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBpdGVtLmxpbmtlZFNoZWV0cyA9IFtzcHJpdGVzaGVldF0uY29uY2F0KHNwcml0ZXNoZWV0LmxpbmtlZFNoZWV0cy5maWx0ZXIoKHNwKSA9PiBzcCAhPT0gaXRlbSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzcHJpdGVzaGVldDtcbiAgICB9LFxuICAgIHVubG9hZChzcHJpdGVzaGVldCkge1xuICAgICAgc3ByaXRlc2hlZXQuZGVzdHJveSh0cnVlKTtcbiAgICB9XG4gIH1cbn07XG5jb3JlLmV4dGVuc2lvbnMuYWRkKHNwcml0ZXNoZWV0QXNzZXQpO1xuXG5leHBvcnRzLnNwcml0ZXNoZWV0QXNzZXQgPSBzcHJpdGVzaGVldEFzc2V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ByaXRlc2hlZXRBc3NldC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgdGV4dCA9IHJlcXVpcmUoJ0BwaXhpL3RleHQnKTtcbnZhciBCaXRtYXBGb250RGF0YSA9IHJlcXVpcmUoJy4vQml0bWFwRm9udERhdGEuanMnKTtcbnZhciBpbmRleCA9IHJlcXVpcmUoJy4vZm9ybWF0cy9pbmRleC5qcycpO1xucmVxdWlyZSgnLi91dGlscy9pbmRleC5qcycpO1xudmFyIHJlc29sdmVDaGFyYWN0ZXJzID0gcmVxdWlyZSgnLi91dGlscy9yZXNvbHZlQ2hhcmFjdGVycy5qcycpO1xudmFyIGRyYXdHbHlwaCA9IHJlcXVpcmUoJy4vdXRpbHMvZHJhd0dseXBoLmpzJyk7XG52YXIgZXh0cmFjdENoYXJDb2RlID0gcmVxdWlyZSgnLi91dGlscy9leHRyYWN0Q2hhckNvZGUuanMnKTtcblxuY29uc3QgX0JpdG1hcEZvbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHRleHR1cmVzLCBvd25zVGV4dHVyZXMpIHtcbiAgICBjb25zdCBbaW5mb10gPSBkYXRhLmluZm87XG4gICAgY29uc3QgW2NvbW1vbl0gPSBkYXRhLmNvbW1vbjtcbiAgICBjb25zdCBbcGFnZV0gPSBkYXRhLnBhZ2U7XG4gICAgY29uc3QgW2Rpc3RhbmNlRmllbGRdID0gZGF0YS5kaXN0YW5jZUZpZWxkO1xuICAgIGNvbnN0IHJlcyA9IGNvcmUudXRpbHMuZ2V0UmVzb2x1dGlvbk9mVXJsKHBhZ2UuZmlsZSk7XG4gICAgY29uc3QgcGFnZVRleHR1cmVzID0ge307XG4gICAgdGhpcy5fb3duc1RleHR1cmVzID0gb3duc1RleHR1cmVzO1xuICAgIHRoaXMuZm9udCA9IGluZm8uZmFjZTtcbiAgICB0aGlzLnNpemUgPSBpbmZvLnNpemU7XG4gICAgdGhpcy5saW5lSGVpZ2h0ID0gY29tbW9uLmxpbmVIZWlnaHQgLyByZXM7XG4gICAgdGhpcy5jaGFycyA9IHt9O1xuICAgIHRoaXMucGFnZVRleHR1cmVzID0gcGFnZVRleHR1cmVzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5wYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB7IGlkLCBmaWxlIH0gPSBkYXRhLnBhZ2VbaV07XG4gICAgICBwYWdlVGV4dHVyZXNbaWRdID0gdGV4dHVyZXMgaW5zdGFuY2VvZiBBcnJheSA/IHRleHR1cmVzW2ldIDogdGV4dHVyZXNbZmlsZV07XG4gICAgICBpZiAoZGlzdGFuY2VGaWVsZD8uZmllbGRUeXBlICYmIGRpc3RhbmNlRmllbGQuZmllbGRUeXBlICE9PSBcIm5vbmVcIikge1xuICAgICAgICBwYWdlVGV4dHVyZXNbaWRdLmJhc2VUZXh0dXJlLmFscGhhTW9kZSA9IGNvcmUuQUxQSEFfTU9ERVMuTk9fUFJFTVVMVElQTElFRF9BTFBIQTtcbiAgICAgICAgcGFnZVRleHR1cmVzW2lkXS5iYXNlVGV4dHVyZS5taXBtYXAgPSBjb3JlLk1JUE1BUF9NT0RFUy5PRkY7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5jaGFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB7IGlkLCBwYWdlOiBwYWdlMiB9ID0gZGF0YS5jaGFyW2ldO1xuICAgICAgbGV0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgeG9mZnNldCwgeW9mZnNldCwgeGFkdmFuY2UgfSA9IGRhdGEuY2hhcltpXTtcbiAgICAgIHggLz0gcmVzO1xuICAgICAgeSAvPSByZXM7XG4gICAgICB3aWR0aCAvPSByZXM7XG4gICAgICBoZWlnaHQgLz0gcmVzO1xuICAgICAgeG9mZnNldCAvPSByZXM7XG4gICAgICB5b2Zmc2V0IC89IHJlcztcbiAgICAgIHhhZHZhbmNlIC89IHJlcztcbiAgICAgIGNvbnN0IHJlY3QgPSBuZXcgY29yZS5SZWN0YW5nbGUoeCArIHBhZ2VUZXh0dXJlc1twYWdlMl0uZnJhbWUueCAvIHJlcywgeSArIHBhZ2VUZXh0dXJlc1twYWdlMl0uZnJhbWUueSAvIHJlcywgd2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmNoYXJzW2lkXSA9IHtcbiAgICAgICAgeE9mZnNldDogeG9mZnNldCxcbiAgICAgICAgeU9mZnNldDogeW9mZnNldCxcbiAgICAgICAgeEFkdmFuY2U6IHhhZHZhbmNlLFxuICAgICAgICBrZXJuaW5nOiB7fSxcbiAgICAgICAgdGV4dHVyZTogbmV3IGNvcmUuVGV4dHVyZShwYWdlVGV4dHVyZXNbcGFnZTJdLmJhc2VUZXh0dXJlLCByZWN0KSxcbiAgICAgICAgcGFnZTogcGFnZTJcbiAgICAgIH07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5rZXJuaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgeyBmaXJzdCwgc2Vjb25kLCBhbW91bnQgfSA9IGRhdGEua2VybmluZ1tpXTtcbiAgICAgIGZpcnN0IC89IHJlcztcbiAgICAgIHNlY29uZCAvPSByZXM7XG4gICAgICBhbW91bnQgLz0gcmVzO1xuICAgICAgaWYgKHRoaXMuY2hhcnNbc2Vjb25kXSkge1xuICAgICAgICB0aGlzLmNoYXJzW3NlY29uZF0ua2VybmluZ1tmaXJzdF0gPSBhbW91bnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGlzdGFuY2VGaWVsZFJhbmdlID0gZGlzdGFuY2VGaWVsZD8uZGlzdGFuY2VSYW5nZTtcbiAgICB0aGlzLmRpc3RhbmNlRmllbGRUeXBlID0gZGlzdGFuY2VGaWVsZD8uZmllbGRUeXBlPy50b0xvd2VyQ2FzZSgpID8/IFwibm9uZVwiO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLmNoYXJzKSB7XG4gICAgICB0aGlzLmNoYXJzW2lkXS50ZXh0dXJlLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuY2hhcnNbaWRdLnRleHR1cmUgPSBudWxsO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMucGFnZVRleHR1cmVzKSB7XG4gICAgICBpZiAodGhpcy5fb3duc1RleHR1cmVzKSB7XG4gICAgICAgIHRoaXMucGFnZVRleHR1cmVzW2lkXS5kZXN0cm95KHRydWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5wYWdlVGV4dHVyZXNbaWRdID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5jaGFycyA9IG51bGw7XG4gICAgdGhpcy5wYWdlVGV4dHVyZXMgPSBudWxsO1xuICB9XG4gIHN0YXRpYyBpbnN0YWxsKGRhdGEsIHRleHR1cmVzLCBvd25zVGV4dHVyZXMpIHtcbiAgICBsZXQgZm9udERhdGE7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBCaXRtYXBGb250RGF0YS5CaXRtYXBGb250RGF0YSkge1xuICAgICAgZm9udERhdGEgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmb3JtYXQgPSBpbmRleC5hdXRvRGV0ZWN0Rm9ybWF0KGRhdGEpO1xuICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGRhdGEgZm9ybWF0IGZvciBmb250LlwiKTtcbiAgICAgIH1cbiAgICAgIGZvbnREYXRhID0gZm9ybWF0LnBhcnNlKGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGV4dHVyZXMgaW5zdGFuY2VvZiBjb3JlLlRleHR1cmUpIHtcbiAgICAgIHRleHR1cmVzID0gW3RleHR1cmVzXTtcbiAgICB9XG4gICAgY29uc3QgZm9udCA9IG5ldyBfQml0bWFwRm9udChmb250RGF0YSwgdGV4dHVyZXMsIG93bnNUZXh0dXJlcyk7XG4gICAgX0JpdG1hcEZvbnQuYXZhaWxhYmxlW2ZvbnQuZm9udF0gPSBmb250O1xuICAgIHJldHVybiBmb250O1xuICB9XG4gIHN0YXRpYyB1bmluc3RhbGwobmFtZSkge1xuICAgIGNvbnN0IGZvbnQgPSBfQml0bWFwRm9udC5hdmFpbGFibGVbbmFtZV07XG4gICAgaWYgKCFmb250KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGZvbnQgZm91bmQgbmFtZWQgJyR7bmFtZX0nYCk7XG4gICAgfVxuICAgIGZvbnQuZGVzdHJveSgpO1xuICAgIGRlbGV0ZSBfQml0bWFwRm9udC5hdmFpbGFibGVbbmFtZV07XG4gIH1cbiAgc3RhdGljIGZyb20obmFtZSwgdGV4dFN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQml0bWFwRm9udF0gUHJvcGVydHkgYG5hbWVgIGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2hhcnMsXG4gICAgICBwYWRkaW5nLFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIHRleHR1cmVXaWR0aCxcbiAgICAgIHRleHR1cmVIZWlnaHQsXG4gICAgICAuLi5iYXNlT3B0aW9uc1xuICAgIH0gPSBPYmplY3QuYXNzaWduKHt9LCBfQml0bWFwRm9udC5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3QgY2hhcnNMaXN0ID0gcmVzb2x2ZUNoYXJhY3RlcnMucmVzb2x2ZUNoYXJhY3RlcnMoY2hhcnMpO1xuICAgIGNvbnN0IHN0eWxlID0gdGV4dFN0eWxlIGluc3RhbmNlb2YgdGV4dC5UZXh0U3R5bGUgPyB0ZXh0U3R5bGUgOiBuZXcgdGV4dC5UZXh0U3R5bGUodGV4dFN0eWxlKTtcbiAgICBjb25zdCBsaW5lV2lkdGggPSB0ZXh0dXJlV2lkdGg7XG4gICAgY29uc3QgZm9udERhdGEgPSBuZXcgQml0bWFwRm9udERhdGEuQml0bWFwRm9udERhdGEoKTtcbiAgICBmb250RGF0YS5pbmZvWzBdID0ge1xuICAgICAgZmFjZTogc3R5bGUuZm9udEZhbWlseSxcbiAgICAgIHNpemU6IHN0eWxlLmZvbnRTaXplXG4gICAgfTtcbiAgICBmb250RGF0YS5jb21tb25bMF0gPSB7XG4gICAgICBsaW5lSGVpZ2h0OiBzdHlsZS5mb250U2l6ZVxuICAgIH07XG4gICAgbGV0IHBvc2l0aW9uWCA9IDA7XG4gICAgbGV0IHBvc2l0aW9uWSA9IDA7XG4gICAgbGV0IGNhbnZhcztcbiAgICBsZXQgY29udGV4dDtcbiAgICBsZXQgYmFzZVRleHR1cmU7XG4gICAgbGV0IG1heENoYXJIZWlnaHQgPSAwO1xuICAgIGNvbnN0IGJhc2VUZXh0dXJlcyA9IFtdO1xuICAgIGNvbnN0IHRleHR1cmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyc0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIGNhbnZhcyA9IGNvcmUuc2V0dGluZ3MuQURBUFRFUi5jcmVhdGVDYW52YXMoKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gdGV4dHVyZVdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGV4dHVyZUhlaWdodDtcbiAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIGJhc2VUZXh0dXJlID0gbmV3IGNvcmUuQmFzZVRleHR1cmUoY2FudmFzLCB7IHJlc29sdXRpb24sIC4uLmJhc2VPcHRpb25zIH0pO1xuICAgICAgICBiYXNlVGV4dHVyZXMucHVzaChiYXNlVGV4dHVyZSk7XG4gICAgICAgIHRleHR1cmVzLnB1c2gobmV3IGNvcmUuVGV4dHVyZShiYXNlVGV4dHVyZSkpO1xuICAgICAgICBmb250RGF0YS5wYWdlLnB1c2goe1xuICAgICAgICAgIGlkOiB0ZXh0dXJlcy5sZW5ndGggLSAxLFxuICAgICAgICAgIGZpbGU6IFwiXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFyYWN0ZXIgPSBjaGFyc0xpc3RbaV07XG4gICAgICBjb25zdCBtZXRyaWNzID0gdGV4dC5UZXh0TWV0cmljcy5tZWFzdXJlVGV4dChjaGFyYWN0ZXIsIHN0eWxlLCBmYWxzZSwgY2FudmFzKTtcbiAgICAgIGNvbnN0IHdpZHRoID0gbWV0cmljcy53aWR0aDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChtZXRyaWNzLmhlaWdodCk7XG4gICAgICBjb25zdCB0ZXh0dXJlR2x5cGhXaWR0aCA9IE1hdGguY2VpbCgoc3R5bGUuZm9udFN0eWxlID09PSBcIml0YWxpY1wiID8gMiA6IDEpICogd2lkdGgpO1xuICAgICAgaWYgKHBvc2l0aW9uWSA+PSB0ZXh0dXJlSGVpZ2h0IC0gaGVpZ2h0ICogcmVzb2x1dGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb25ZID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbQml0bWFwRm9udF0gdGV4dHVyZUhlaWdodCAke3RleHR1cmVIZWlnaHR9cHggaXMgdG9vIHNtYWxsIChmb250RmFtaWx5OiAnJHtzdHlsZS5mb250RmFtaWx5fScsIGZvbnRTaXplOiAke3N0eWxlLmZvbnRTaXplfXB4LCBjaGFyOiAnJHtjaGFyYWN0ZXJ9JylgKTtcbiAgICAgICAgfVxuICAgICAgICAtLWk7XG4gICAgICAgIGNhbnZhcyA9IG51bGw7XG4gICAgICAgIGNvbnRleHQgPSBudWxsO1xuICAgICAgICBiYXNlVGV4dHVyZSA9IG51bGw7XG4gICAgICAgIHBvc2l0aW9uWSA9IDA7XG4gICAgICAgIHBvc2l0aW9uWCA9IDA7XG4gICAgICAgIG1heENoYXJIZWlnaHQgPSAwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG1heENoYXJIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQgKyBtZXRyaWNzLmZvbnRQcm9wZXJ0aWVzLmRlc2NlbnQsIG1heENoYXJIZWlnaHQpO1xuICAgICAgaWYgKHRleHR1cmVHbHlwaFdpZHRoICogcmVzb2x1dGlvbiArIHBvc2l0aW9uWCA+PSBsaW5lV2lkdGgpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uWCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgW0JpdG1hcEZvbnRdIHRleHR1cmVXaWR0aCAke3RleHR1cmVXaWR0aH1weCBpcyB0b28gc21hbGwgKGZvbnRGYW1pbHk6ICcke3N0eWxlLmZvbnRGYW1pbHl9JywgZm9udFNpemU6ICR7c3R5bGUuZm9udFNpemV9cHgsIGNoYXI6ICcke2NoYXJhY3Rlcn0nKWApO1xuICAgICAgICB9XG4gICAgICAgIC0taTtcbiAgICAgICAgcG9zaXRpb25ZICs9IG1heENoYXJIZWlnaHQgKiByZXNvbHV0aW9uO1xuICAgICAgICBwb3NpdGlvblkgPSBNYXRoLmNlaWwocG9zaXRpb25ZKTtcbiAgICAgICAgcG9zaXRpb25YID0gMDtcbiAgICAgICAgbWF4Q2hhckhlaWdodCA9IDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZHJhd0dseXBoLmRyYXdHbHlwaChjYW52YXMsIGNvbnRleHQsIG1ldHJpY3MsIHBvc2l0aW9uWCwgcG9zaXRpb25ZLCByZXNvbHV0aW9uLCBzdHlsZSk7XG4gICAgICBjb25zdCBpZCA9IGV4dHJhY3RDaGFyQ29kZS5leHRyYWN0Q2hhckNvZGUobWV0cmljcy50ZXh0KTtcbiAgICAgIGZvbnREYXRhLmNoYXIucHVzaCh7XG4gICAgICAgIGlkLFxuICAgICAgICBwYWdlOiB0ZXh0dXJlcy5sZW5ndGggLSAxLFxuICAgICAgICB4OiBwb3NpdGlvblggLyByZXNvbHV0aW9uLFxuICAgICAgICB5OiBwb3NpdGlvblkgLyByZXNvbHV0aW9uLFxuICAgICAgICB3aWR0aDogdGV4dHVyZUdseXBoV2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgeG9mZnNldDogMCxcbiAgICAgICAgeW9mZnNldDogMCxcbiAgICAgICAgeGFkdmFuY2U6IHdpZHRoIC0gKHN0eWxlLmRyb3BTaGFkb3cgPyBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2UgOiAwKSAtIChzdHlsZS5zdHJva2UgPyBzdHlsZS5zdHJva2VUaGlja25lc3MgOiAwKVxuICAgICAgfSk7XG4gICAgICBwb3NpdGlvblggKz0gKHRleHR1cmVHbHlwaFdpZHRoICsgMiAqIHBhZGRpbmcpICogcmVzb2x1dGlvbjtcbiAgICAgIHBvc2l0aW9uWCA9IE1hdGguY2VpbChwb3NpdGlvblgpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2hhcnNMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBmaXJzdCA9IGNoYXJzTGlzdFtpXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgY29uc3Qgc2Vjb25kID0gY2hhcnNMaXN0W2pdO1xuICAgICAgICBjb25zdCBjMSA9IGNvbnRleHQubWVhc3VyZVRleHQoZmlyc3QpLndpZHRoO1xuICAgICAgICBjb25zdCBjMiA9IGNvbnRleHQubWVhc3VyZVRleHQoc2Vjb25kKS53aWR0aDtcbiAgICAgICAgY29uc3QgdG90YWwgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGZpcnN0ICsgc2Vjb25kKS53aWR0aDtcbiAgICAgICAgY29uc3QgYW1vdW50ID0gdG90YWwgLSAoYzEgKyBjMik7XG4gICAgICAgIGlmIChhbW91bnQpIHtcbiAgICAgICAgICBmb250RGF0YS5rZXJuaW5nLnB1c2goe1xuICAgICAgICAgICAgZmlyc3Q6IGV4dHJhY3RDaGFyQ29kZS5leHRyYWN0Q2hhckNvZGUoZmlyc3QpLFxuICAgICAgICAgICAgc2Vjb25kOiBleHRyYWN0Q2hhckNvZGUuZXh0cmFjdENoYXJDb2RlKHNlY29uZCksXG4gICAgICAgICAgICBhbW91bnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmb250ID0gbmV3IF9CaXRtYXBGb250KGZvbnREYXRhLCB0ZXh0dXJlcywgdHJ1ZSk7XG4gICAgaWYgKF9CaXRtYXBGb250LmF2YWlsYWJsZVtuYW1lXSAhPT0gdm9pZCAwKSB7XG4gICAgICBfQml0bWFwRm9udC51bmluc3RhbGwobmFtZSk7XG4gICAgfVxuICAgIF9CaXRtYXBGb250LmF2YWlsYWJsZVtuYW1lXSA9IGZvbnQ7XG4gICAgcmV0dXJuIGZvbnQ7XG4gIH1cbn07XG5sZXQgQml0bWFwRm9udCA9IF9CaXRtYXBGb250O1xuQml0bWFwRm9udC5BTFBIQSA9IFtbXCJhXCIsIFwielwiXSwgW1wiQVwiLCBcIlpcIl0sIFwiIFwiXTtcbkJpdG1hcEZvbnQuTlVNRVJJQyA9IFtbXCIwXCIsIFwiOVwiXV07XG5CaXRtYXBGb250LkFMUEhBTlVNRVJJQyA9IFtbXCJhXCIsIFwielwiXSwgW1wiQVwiLCBcIlpcIl0sIFtcIjBcIiwgXCI5XCJdLCBcIiBcIl07XG5CaXRtYXBGb250LkFTQ0lJID0gW1tcIiBcIiwgXCJ+XCJdXTtcbkJpdG1hcEZvbnQuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHJlc29sdXRpb246IDEsXG4gIHRleHR1cmVXaWR0aDogNTEyLFxuICB0ZXh0dXJlSGVpZ2h0OiA1MTIsXG4gIHBhZGRpbmc6IDQsXG4gIGNoYXJzOiBfQml0bWFwRm9udC5BTFBIQU5VTUVSSUNcbn07XG5CaXRtYXBGb250LmF2YWlsYWJsZSA9IHt9O1xuXG5leHBvcnRzLkJpdG1hcEZvbnQgPSBCaXRtYXBGb250O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qml0bWFwRm9udC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY2xhc3MgQml0bWFwRm9udERhdGEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmluZm8gPSBbXTtcbiAgICB0aGlzLmNvbW1vbiA9IFtdO1xuICAgIHRoaXMucGFnZSA9IFtdO1xuICAgIHRoaXMuY2hhciA9IFtdO1xuICAgIHRoaXMua2VybmluZyA9IFtdO1xuICAgIHRoaXMuZGlzdGFuY2VGaWVsZCA9IFtdO1xuICB9XG59XG5cbmV4cG9ydHMuQml0bWFwRm9udERhdGEgPSBCaXRtYXBGb250RGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpdG1hcEZvbnREYXRhLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBkaXNwbGF5ID0gcmVxdWlyZSgnQHBpeGkvZGlzcGxheScpO1xudmFyIG1lc2ggPSByZXF1aXJlKCdAcGl4aS9tZXNoJyk7XG52YXIgQml0bWFwRm9udCA9IHJlcXVpcmUoJy4vQml0bWFwRm9udC5qcycpO1xudmFyIG1zZGYkMSA9IHJlcXVpcmUoJy4vc2hhZGVyL21zZGYuanMnKTtcbnZhciBtc2RmID0gcmVxdWlyZSgnLi9zaGFkZXIvbXNkZjIuanMnKTtcbnJlcXVpcmUoJy4vdXRpbHMvaW5kZXguanMnKTtcbnZhciBzcGxpdFRleHRUb0NoYXJhY3RlcnMgPSByZXF1aXJlKCcuL3V0aWxzL3NwbGl0VGV4dFRvQ2hhcmFjdGVycy5qcycpO1xudmFyIGV4dHJhY3RDaGFyQ29kZSA9IHJlcXVpcmUoJy4vdXRpbHMvZXh0cmFjdENoYXJDb2RlLmpzJyk7XG5cbmNvbnN0IHBhZ2VNZXNoRGF0YURlZmF1bHRQYWdlTWVzaERhdGEgPSBbXTtcbmNvbnN0IHBhZ2VNZXNoRGF0YU1TREZQYWdlTWVzaERhdGEgPSBbXTtcbmNvbnN0IGNoYXJSZW5kZXJEYXRhUG9vbCA9IFtdO1xuY29uc3QgX0JpdG1hcFRleHQgPSBjbGFzcyBleHRlbmRzIGRpc3BsYXkuQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IodGV4dCwgc3R5bGUgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgeyBhbGlnbiwgdGludCwgbWF4V2lkdGgsIGxldHRlclNwYWNpbmcsIGZvbnROYW1lLCBmb250U2l6ZSB9ID0gT2JqZWN0LmFzc2lnbih7fSwgX0JpdG1hcFRleHQuc3R5bGVEZWZhdWx0cywgc3R5bGUpO1xuICAgIGlmICghQml0bWFwRm9udC5CaXRtYXBGb250LmF2YWlsYWJsZVtmb250TmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBCaXRtYXBGb250IFwiJHtmb250TmFtZX1cImApO1xuICAgIH1cbiAgICB0aGlzLl9hY3RpdmVQYWdlc01lc2hEYXRhID0gW107XG4gICAgdGhpcy5fdGV4dFdpZHRoID0gMDtcbiAgICB0aGlzLl90ZXh0SGVpZ2h0ID0gMDtcbiAgICB0aGlzLl9hbGlnbiA9IGFsaWduO1xuICAgIHRoaXMuX3RpbnRDb2xvciA9IG5ldyBjb3JlLkNvbG9yKHRpbnQpO1xuICAgIHRoaXMuX2ZvbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5fZm9udE5hbWUgPSBmb250TmFtZTtcbiAgICB0aGlzLl9mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5fbWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB0aGlzLl9tYXhMaW5lSGVpZ2h0ID0gMDtcbiAgICB0aGlzLl9sZXR0ZXJTcGFjaW5nID0gbGV0dGVyU3BhY2luZztcbiAgICB0aGlzLl9hbmNob3IgPSBuZXcgY29yZS5PYnNlcnZhYmxlUG9pbnQoKCkgPT4ge1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfSwgdGhpcywgMCwgMCk7XG4gICAgdGhpcy5fcm91bmRQaXhlbHMgPSBjb3JlLnNldHRpbmdzLlJPVU5EX1BJWEVMUztcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9yZXNvbHV0aW9uID0gY29yZS5zZXR0aW5ncy5SRVNPTFVUSU9OO1xuICAgIHRoaXMuX2F1dG9SZXNvbHV0aW9uID0gdHJ1ZTtcbiAgICB0aGlzLl90ZXh0dXJlQ2FjaGUgPSB7fTtcbiAgfVxuICB1cGRhdGVUZXh0KCkge1xuICAgIGNvbnN0IGRhdGEgPSBCaXRtYXBGb250LkJpdG1hcEZvbnQuYXZhaWxhYmxlW3RoaXMuX2ZvbnROYW1lXTtcbiAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuZm9udFNpemU7XG4gICAgY29uc3Qgc2NhbGUgPSBmb250U2l6ZSAvIGRhdGEuc2l6ZTtcbiAgICBjb25zdCBwb3MgPSBuZXcgY29yZS5Qb2ludCgpO1xuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgY29uc3QgbGluZVdpZHRocyA9IFtdO1xuICAgIGNvbnN0IGxpbmVTcGFjZXMgPSBbXTtcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5fdGV4dC5yZXBsYWNlKC8oPzpcXHJcXG58XFxyKS9nLCBcIlxcblwiKSB8fCBcIiBcIjtcbiAgICBjb25zdCBjaGFyc0lucHV0ID0gc3BsaXRUZXh0VG9DaGFyYWN0ZXJzLnNwbGl0VGV4dFRvQ2hhcmFjdGVycyh0ZXh0KTtcbiAgICBjb25zdCBtYXhXaWR0aCA9IHRoaXMuX21heFdpZHRoICogZGF0YS5zaXplIC8gZm9udFNpemU7XG4gICAgY29uc3QgcGFnZU1lc2hEYXRhUG9vbCA9IGRhdGEuZGlzdGFuY2VGaWVsZFR5cGUgPT09IFwibm9uZVwiID8gcGFnZU1lc2hEYXRhRGVmYXVsdFBhZ2VNZXNoRGF0YSA6IHBhZ2VNZXNoRGF0YU1TREZQYWdlTWVzaERhdGE7XG4gICAgbGV0IHByZXZDaGFyQ29kZSA9IG51bGw7XG4gICAgbGV0IGxhc3RMaW5lV2lkdGggPSAwO1xuICAgIGxldCBtYXhMaW5lV2lkdGggPSAwO1xuICAgIGxldCBsaW5lID0gMDtcbiAgICBsZXQgbGFzdEJyZWFrUG9zID0gLTE7XG4gICAgbGV0IGxhc3RCcmVha1dpZHRoID0gMDtcbiAgICBsZXQgc3BhY2VzUmVtb3ZlZCA9IDA7XG4gICAgbGV0IG1heExpbmVIZWlnaHQgPSAwO1xuICAgIGxldCBzcGFjZUNvdW50ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzSW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYXIgPSBjaGFyc0lucHV0W2ldO1xuICAgICAgY29uc3QgY2hhckNvZGUgPSBleHRyYWN0Q2hhckNvZGUuZXh0cmFjdENoYXJDb2RlKGNoYXIpO1xuICAgICAgaWYgKC8oPzpcXHMpLy50ZXN0KGNoYXIpKSB7XG4gICAgICAgIGxhc3RCcmVha1BvcyA9IGk7XG4gICAgICAgIGxhc3RCcmVha1dpZHRoID0gbGFzdExpbmVXaWR0aDtcbiAgICAgICAgc3BhY2VDb3VudCsrO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09IFwiXFxyXCIgfHwgY2hhciA9PT0gXCJcXG5cIikge1xuICAgICAgICBsaW5lV2lkdGhzLnB1c2gobGFzdExpbmVXaWR0aCk7XG4gICAgICAgIGxpbmVTcGFjZXMucHVzaCgtMSk7XG4gICAgICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgbGFzdExpbmVXaWR0aCk7XG4gICAgICAgICsrbGluZTtcbiAgICAgICAgKytzcGFjZXNSZW1vdmVkO1xuICAgICAgICBwb3MueCA9IDA7XG4gICAgICAgIHBvcy55ICs9IGRhdGEubGluZUhlaWdodDtcbiAgICAgICAgcHJldkNoYXJDb2RlID0gbnVsbDtcbiAgICAgICAgc3BhY2VDb3VudCA9IDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhckRhdGEgPSBkYXRhLmNoYXJzW2NoYXJDb2RlXTtcbiAgICAgIGlmICghY2hhckRhdGEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJldkNoYXJDb2RlICYmIGNoYXJEYXRhLmtlcm5pbmdbcHJldkNoYXJDb2RlXSkge1xuICAgICAgICBwb3MueCArPSBjaGFyRGF0YS5rZXJuaW5nW3ByZXZDaGFyQ29kZV07XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFyUmVuZGVyRGF0YSA9IGNoYXJSZW5kZXJEYXRhUG9vbC5wb3AoKSB8fCB7XG4gICAgICAgIHRleHR1cmU6IGNvcmUuVGV4dHVyZS5FTVBUWSxcbiAgICAgICAgbGluZTogMCxcbiAgICAgICAgY2hhckNvZGU6IDAsXG4gICAgICAgIHByZXZTcGFjZXM6IDAsXG4gICAgICAgIHBvc2l0aW9uOiBuZXcgY29yZS5Qb2ludCgpXG4gICAgICB9O1xuICAgICAgY2hhclJlbmRlckRhdGEudGV4dHVyZSA9IGNoYXJEYXRhLnRleHR1cmU7XG4gICAgICBjaGFyUmVuZGVyRGF0YS5saW5lID0gbGluZTtcbiAgICAgIGNoYXJSZW5kZXJEYXRhLmNoYXJDb2RlID0gY2hhckNvZGU7XG4gICAgICBjaGFyUmVuZGVyRGF0YS5wb3NpdGlvbi54ID0gTWF0aC5yb3VuZChwb3MueCArIGNoYXJEYXRhLnhPZmZzZXQgKyB0aGlzLl9sZXR0ZXJTcGFjaW5nIC8gMik7XG4gICAgICBjaGFyUmVuZGVyRGF0YS5wb3NpdGlvbi55ID0gTWF0aC5yb3VuZChwb3MueSArIGNoYXJEYXRhLnlPZmZzZXQpO1xuICAgICAgY2hhclJlbmRlckRhdGEucHJldlNwYWNlcyA9IHNwYWNlQ291bnQ7XG4gICAgICBjaGFycy5wdXNoKGNoYXJSZW5kZXJEYXRhKTtcbiAgICAgIGxhc3RMaW5lV2lkdGggPSBjaGFyUmVuZGVyRGF0YS5wb3NpdGlvbi54ICsgTWF0aC5tYXgoY2hhckRhdGEueEFkdmFuY2UgLSBjaGFyRGF0YS54T2Zmc2V0LCBjaGFyRGF0YS50ZXh0dXJlLm9yaWcud2lkdGgpO1xuICAgICAgcG9zLnggKz0gY2hhckRhdGEueEFkdmFuY2UgKyB0aGlzLl9sZXR0ZXJTcGFjaW5nO1xuICAgICAgbWF4TGluZUhlaWdodCA9IE1hdGgubWF4KG1heExpbmVIZWlnaHQsIGNoYXJEYXRhLnlPZmZzZXQgKyBjaGFyRGF0YS50ZXh0dXJlLmhlaWdodCk7XG4gICAgICBwcmV2Q2hhckNvZGUgPSBjaGFyQ29kZTtcbiAgICAgIGlmIChsYXN0QnJlYWtQb3MgIT09IC0xICYmIG1heFdpZHRoID4gMCAmJiBwb3MueCA+IG1heFdpZHRoKSB7XG4gICAgICAgICsrc3BhY2VzUmVtb3ZlZDtcbiAgICAgICAgY29yZS51dGlscy5yZW1vdmVJdGVtcyhjaGFycywgMSArIGxhc3RCcmVha1BvcyAtIHNwYWNlc1JlbW92ZWQsIDEgKyBpIC0gbGFzdEJyZWFrUG9zKTtcbiAgICAgICAgaSA9IGxhc3RCcmVha1BvcztcbiAgICAgICAgbGFzdEJyZWFrUG9zID0gLTE7XG4gICAgICAgIGxpbmVXaWR0aHMucHVzaChsYXN0QnJlYWtXaWR0aCk7XG4gICAgICAgIGxpbmVTcGFjZXMucHVzaChjaGFycy5sZW5ndGggPiAwID8gY2hhcnNbY2hhcnMubGVuZ3RoIC0gMV0ucHJldlNwYWNlcyA6IDApO1xuICAgICAgICBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxhc3RCcmVha1dpZHRoKTtcbiAgICAgICAgbGluZSsrO1xuICAgICAgICBwb3MueCA9IDA7XG4gICAgICAgIHBvcy55ICs9IGRhdGEubGluZUhlaWdodDtcbiAgICAgICAgcHJldkNoYXJDb2RlID0gbnVsbDtcbiAgICAgICAgc3BhY2VDb3VudCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxhc3RDaGFyID0gY2hhcnNJbnB1dFtjaGFyc0lucHV0Lmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0Q2hhciAhPT0gXCJcXHJcIiAmJiBsYXN0Q2hhciAhPT0gXCJcXG5cIikge1xuICAgICAgaWYgKC8oPzpcXHMpLy50ZXN0KGxhc3RDaGFyKSkge1xuICAgICAgICBsYXN0TGluZVdpZHRoID0gbGFzdEJyZWFrV2lkdGg7XG4gICAgICB9XG4gICAgICBsaW5lV2lkdGhzLnB1c2gobGFzdExpbmVXaWR0aCk7XG4gICAgICBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxhc3RMaW5lV2lkdGgpO1xuICAgICAgbGluZVNwYWNlcy5wdXNoKC0xKTtcbiAgICB9XG4gICAgY29uc3QgbGluZUFsaWduT2Zmc2V0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGxpbmU7IGkrKykge1xuICAgICAgbGV0IGFsaWduT2Zmc2V0ID0gMDtcbiAgICAgIGlmICh0aGlzLl9hbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgIGFsaWduT2Zmc2V0ID0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYWxpZ24gPT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgYWxpZ25PZmZzZXQgPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXSkgLyAyO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9hbGlnbiA9PT0gXCJqdXN0aWZ5XCIpIHtcbiAgICAgICAgYWxpZ25PZmZzZXQgPSBsaW5lU3BhY2VzW2ldIDwgMCA/IDAgOiAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXSkgLyBsaW5lU3BhY2VzW2ldO1xuICAgICAgfVxuICAgICAgbGluZUFsaWduT2Zmc2V0cy5wdXNoKGFsaWduT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgbGVuQ2hhcnMgPSBjaGFycy5sZW5ndGg7XG4gICAgY29uc3QgcGFnZXNNZXNoRGF0YSA9IHt9O1xuICAgIGNvbnN0IG5ld1BhZ2VzTWVzaERhdGEgPSBbXTtcbiAgICBjb25zdCBhY3RpdmVQYWdlc01lc2hEYXRhID0gdGhpcy5fYWN0aXZlUGFnZXNNZXNoRGF0YTtcbiAgICBwYWdlTWVzaERhdGFQb29sLnB1c2goLi4uYWN0aXZlUGFnZXNNZXNoRGF0YSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5DaGFyczsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gY2hhcnNbaV0udGV4dHVyZTtcbiAgICAgIGNvbnN0IGJhc2VUZXh0dXJlVWlkID0gdGV4dHVyZS5iYXNlVGV4dHVyZS51aWQ7XG4gICAgICBpZiAoIXBhZ2VzTWVzaERhdGFbYmFzZVRleHR1cmVVaWRdKSB7XG4gICAgICAgIGxldCBwYWdlTWVzaERhdGEgPSBwYWdlTWVzaERhdGFQb29sLnBvcCgpO1xuICAgICAgICBpZiAoIXBhZ2VNZXNoRGF0YSkge1xuICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IG1lc2guTWVzaEdlb21ldHJ5KCk7XG4gICAgICAgICAgbGV0IG1hdGVyaWFsO1xuICAgICAgICAgIGxldCBtZXNoQmxlbmRNb2RlO1xuICAgICAgICAgIGlmIChkYXRhLmRpc3RhbmNlRmllbGRUeXBlID09PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgbWF0ZXJpYWwgPSBuZXcgbWVzaC5NZXNoTWF0ZXJpYWwoY29yZS5UZXh0dXJlLkVNUFRZKTtcbiAgICAgICAgICAgIG1lc2hCbGVuZE1vZGUgPSBjb3JlLkJMRU5EX01PREVTLk5PUk1BTDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0ZXJpYWwgPSBuZXcgbWVzaC5NZXNoTWF0ZXJpYWwoY29yZS5UZXh0dXJlLkVNUFRZLCB7IHByb2dyYW06IGNvcmUuUHJvZ3JhbS5mcm9tKG1zZGZbXCJkZWZhdWx0XCJdLCBtc2RmJDFbXCJkZWZhdWx0XCJdKSwgdW5pZm9ybXM6IHsgdUZXaWR0aDogMCB9IH0pO1xuICAgICAgICAgICAgbWVzaEJsZW5kTW9kZSA9IGNvcmUuQkxFTkRfTU9ERVMuTk9STUFMX05QTTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbWVzaCQxID0gbmV3IG1lc2guTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICAgIG1lc2gkMS5ibGVuZE1vZGUgPSBtZXNoQmxlbmRNb2RlO1xuICAgICAgICAgIHBhZ2VNZXNoRGF0YSA9IHtcbiAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgaW5kZXhDb3VudDogMCxcbiAgICAgICAgICAgIHZlcnRleENvdW50OiAwLFxuICAgICAgICAgICAgdXZzQ291bnQ6IDAsXG4gICAgICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgICAgIG1lc2g6IG1lc2gkMSxcbiAgICAgICAgICAgIHZlcnRpY2VzOiBudWxsLFxuICAgICAgICAgICAgdXZzOiBudWxsLFxuICAgICAgICAgICAgaW5kaWNlczogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcGFnZU1lc2hEYXRhLmluZGV4ID0gMDtcbiAgICAgICAgcGFnZU1lc2hEYXRhLmluZGV4Q291bnQgPSAwO1xuICAgICAgICBwYWdlTWVzaERhdGEudmVydGV4Q291bnQgPSAwO1xuICAgICAgICBwYWdlTWVzaERhdGEudXZzQ291bnQgPSAwO1xuICAgICAgICBwYWdlTWVzaERhdGEudG90YWwgPSAwO1xuICAgICAgICBjb25zdCB7IF90ZXh0dXJlQ2FjaGUgfSA9IHRoaXM7XG4gICAgICAgIF90ZXh0dXJlQ2FjaGVbYmFzZVRleHR1cmVVaWRdID0gX3RleHR1cmVDYWNoZVtiYXNlVGV4dHVyZVVpZF0gfHwgbmV3IGNvcmUuVGV4dHVyZSh0ZXh0dXJlLmJhc2VUZXh0dXJlKTtcbiAgICAgICAgcGFnZU1lc2hEYXRhLm1lc2gudGV4dHVyZSA9IF90ZXh0dXJlQ2FjaGVbYmFzZVRleHR1cmVVaWRdO1xuICAgICAgICBwYWdlTWVzaERhdGEubWVzaC50aW50ID0gdGhpcy5fdGludENvbG9yLnZhbHVlO1xuICAgICAgICBuZXdQYWdlc01lc2hEYXRhLnB1c2gocGFnZU1lc2hEYXRhKTtcbiAgICAgICAgcGFnZXNNZXNoRGF0YVtiYXNlVGV4dHVyZVVpZF0gPSBwYWdlTWVzaERhdGE7XG4gICAgICB9XG4gICAgICBwYWdlc01lc2hEYXRhW2Jhc2VUZXh0dXJlVWlkXS50b3RhbCsrO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGl2ZVBhZ2VzTWVzaERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghbmV3UGFnZXNNZXNoRGF0YS5pbmNsdWRlcyhhY3RpdmVQYWdlc01lc2hEYXRhW2ldKSkge1xuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKGFjdGl2ZVBhZ2VzTWVzaERhdGFbaV0ubWVzaCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3UGFnZXNNZXNoRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG5ld1BhZ2VzTWVzaERhdGFbaV0ubWVzaC5wYXJlbnQgIT09IHRoaXMpIHtcbiAgICAgICAgdGhpcy5hZGRDaGlsZChuZXdQYWdlc01lc2hEYXRhW2ldLm1lc2gpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9hY3RpdmVQYWdlc01lc2hEYXRhID0gbmV3UGFnZXNNZXNoRGF0YTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gcGFnZXNNZXNoRGF0YSkge1xuICAgICAgY29uc3QgcGFnZU1lc2hEYXRhID0gcGFnZXNNZXNoRGF0YVtpXTtcbiAgICAgIGNvbnN0IHRvdGFsID0gcGFnZU1lc2hEYXRhLnRvdGFsO1xuICAgICAgaWYgKCEocGFnZU1lc2hEYXRhLmluZGljZXM/Lmxlbmd0aCA+IDYgKiB0b3RhbCkgfHwgcGFnZU1lc2hEYXRhLnZlcnRpY2VzLmxlbmd0aCA8IG1lc2guTWVzaC5CQVRDSEFCTEVfU0laRSAqIDIpIHtcbiAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSg0ICogMiAqIHRvdGFsKTtcbiAgICAgICAgcGFnZU1lc2hEYXRhLnV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoNCAqIDIgKiB0b3RhbCk7XG4gICAgICAgIHBhZ2VNZXNoRGF0YS5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KDYgKiB0b3RhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0b3RhbDIgPSBwYWdlTWVzaERhdGEudG90YWw7XG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gcGFnZU1lc2hEYXRhLnZlcnRpY2VzO1xuICAgICAgICBmb3IgKGxldCBpMiA9IHRvdGFsMiAqIDQgKiAyOyBpMiA8IHZlcnRpY2VzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgIHZlcnRpY2VzW2kyXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhZ2VNZXNoRGF0YS5tZXNoLnNpemUgPSA2ICogdG90YWw7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuQ2hhcnM7IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IGNoYXJzW2ldO1xuICAgICAgbGV0IG9mZnNldCA9IGNoYXIucG9zaXRpb24ueCArIGxpbmVBbGlnbk9mZnNldHNbY2hhci5saW5lXSAqICh0aGlzLl9hbGlnbiA9PT0gXCJqdXN0aWZ5XCIgPyBjaGFyLnByZXZTcGFjZXMgOiAxKTtcbiAgICAgIGlmICh0aGlzLl9yb3VuZFBpeGVscykge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLnJvdW5kKG9mZnNldCk7XG4gICAgICB9XG4gICAgICBjb25zdCB4UG9zID0gb2Zmc2V0ICogc2NhbGU7XG4gICAgICBjb25zdCB5UG9zID0gY2hhci5wb3NpdGlvbi55ICogc2NhbGU7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gY2hhci50ZXh0dXJlO1xuICAgICAgY29uc3QgcGFnZU1lc2ggPSBwYWdlc01lc2hEYXRhW3RleHR1cmUuYmFzZVRleHR1cmUudWlkXTtcbiAgICAgIGNvbnN0IHRleHR1cmVGcmFtZSA9IHRleHR1cmUuZnJhbWU7XG4gICAgICBjb25zdCB0ZXh0dXJlVXZzID0gdGV4dHVyZS5fdXZzO1xuICAgICAgY29uc3QgaW5kZXggPSBwYWdlTWVzaC5pbmRleCsrO1xuICAgICAgcGFnZU1lc2guaW5kaWNlc1tpbmRleCAqIDYgKyAwXSA9IDAgKyBpbmRleCAqIDQ7XG4gICAgICBwYWdlTWVzaC5pbmRpY2VzW2luZGV4ICogNiArIDFdID0gMSArIGluZGV4ICogNDtcbiAgICAgIHBhZ2VNZXNoLmluZGljZXNbaW5kZXggKiA2ICsgMl0gPSAyICsgaW5kZXggKiA0O1xuICAgICAgcGFnZU1lc2guaW5kaWNlc1tpbmRleCAqIDYgKyAzXSA9IDAgKyBpbmRleCAqIDQ7XG4gICAgICBwYWdlTWVzaC5pbmRpY2VzW2luZGV4ICogNiArIDRdID0gMiArIGluZGV4ICogNDtcbiAgICAgIHBhZ2VNZXNoLmluZGljZXNbaW5kZXggKiA2ICsgNV0gPSAzICsgaW5kZXggKiA0O1xuICAgICAgcGFnZU1lc2gudmVydGljZXNbaW5kZXggKiA4ICsgMF0gPSB4UG9zO1xuICAgICAgcGFnZU1lc2gudmVydGljZXNbaW5kZXggKiA4ICsgMV0gPSB5UG9zO1xuICAgICAgcGFnZU1lc2gudmVydGljZXNbaW5kZXggKiA4ICsgMl0gPSB4UG9zICsgdGV4dHVyZUZyYW1lLndpZHRoICogc2NhbGU7XG4gICAgICBwYWdlTWVzaC52ZXJ0aWNlc1tpbmRleCAqIDggKyAzXSA9IHlQb3M7XG4gICAgICBwYWdlTWVzaC52ZXJ0aWNlc1tpbmRleCAqIDggKyA0XSA9IHhQb3MgKyB0ZXh0dXJlRnJhbWUud2lkdGggKiBzY2FsZTtcbiAgICAgIHBhZ2VNZXNoLnZlcnRpY2VzW2luZGV4ICogOCArIDVdID0geVBvcyArIHRleHR1cmVGcmFtZS5oZWlnaHQgKiBzY2FsZTtcbiAgICAgIHBhZ2VNZXNoLnZlcnRpY2VzW2luZGV4ICogOCArIDZdID0geFBvcztcbiAgICAgIHBhZ2VNZXNoLnZlcnRpY2VzW2luZGV4ICogOCArIDddID0geVBvcyArIHRleHR1cmVGcmFtZS5oZWlnaHQgKiBzY2FsZTtcbiAgICAgIHBhZ2VNZXNoLnV2c1tpbmRleCAqIDggKyAwXSA9IHRleHR1cmVVdnMueDA7XG4gICAgICBwYWdlTWVzaC51dnNbaW5kZXggKiA4ICsgMV0gPSB0ZXh0dXJlVXZzLnkwO1xuICAgICAgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDJdID0gdGV4dHVyZVV2cy54MTtcbiAgICAgIHBhZ2VNZXNoLnV2c1tpbmRleCAqIDggKyAzXSA9IHRleHR1cmVVdnMueTE7XG4gICAgICBwYWdlTWVzaC51dnNbaW5kZXggKiA4ICsgNF0gPSB0ZXh0dXJlVXZzLngyO1xuICAgICAgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDVdID0gdGV4dHVyZVV2cy55MjtcbiAgICAgIHBhZ2VNZXNoLnV2c1tpbmRleCAqIDggKyA2XSA9IHRleHR1cmVVdnMueDM7XG4gICAgICBwYWdlTWVzaC51dnNbaW5kZXggKiA4ICsgN10gPSB0ZXh0dXJlVXZzLnkzO1xuICAgIH1cbiAgICB0aGlzLl90ZXh0V2lkdGggPSBtYXhMaW5lV2lkdGggKiBzY2FsZTtcbiAgICB0aGlzLl90ZXh0SGVpZ2h0ID0gKHBvcy55ICsgZGF0YS5saW5lSGVpZ2h0KSAqIHNjYWxlO1xuICAgIGZvciAoY29uc3QgaSBpbiBwYWdlc01lc2hEYXRhKSB7XG4gICAgICBjb25zdCBwYWdlTWVzaERhdGEgPSBwYWdlc01lc2hEYXRhW2ldO1xuICAgICAgaWYgKHRoaXMuYW5jaG9yLnggIT09IDAgfHwgdGhpcy5hbmNob3IueSAhPT0gMCkge1xuICAgICAgICBsZXQgdmVydGV4Q291bnQgPSAwO1xuICAgICAgICBjb25zdCBhbmNob3JPZmZzZXRYID0gdGhpcy5fdGV4dFdpZHRoICogdGhpcy5hbmNob3IueDtcbiAgICAgICAgY29uc3QgYW5jaG9yT2Zmc2V0WSA9IHRoaXMuX3RleHRIZWlnaHQgKiB0aGlzLmFuY2hvci55O1xuICAgICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgcGFnZU1lc2hEYXRhLnRvdGFsOyBpMisrKSB7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFg7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFk7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFg7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFk7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFg7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFk7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFg7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX21heExpbmVIZWlnaHQgPSBtYXhMaW5lSGVpZ2h0ICogc2NhbGU7XG4gICAgICBjb25zdCB2ZXJ0ZXhCdWZmZXIgPSBwYWdlTWVzaERhdGEubWVzaC5nZW9tZXRyeS5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIik7XG4gICAgICBjb25zdCB0ZXh0dXJlQnVmZmVyID0gcGFnZU1lc2hEYXRhLm1lc2guZ2VvbWV0cnkuZ2V0QnVmZmVyKFwiYVRleHR1cmVDb29yZFwiKTtcbiAgICAgIGNvbnN0IGluZGV4QnVmZmVyID0gcGFnZU1lc2hEYXRhLm1lc2guZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgICAgIHZlcnRleEJ1ZmZlci5kYXRhID0gcGFnZU1lc2hEYXRhLnZlcnRpY2VzO1xuICAgICAgdGV4dHVyZUJ1ZmZlci5kYXRhID0gcGFnZU1lc2hEYXRhLnV2cztcbiAgICAgIGluZGV4QnVmZmVyLmRhdGEgPSBwYWdlTWVzaERhdGEuaW5kaWNlcztcbiAgICAgIHZlcnRleEJ1ZmZlci51cGRhdGUoKTtcbiAgICAgIHRleHR1cmVCdWZmZXIudXBkYXRlKCk7XG4gICAgICBpbmRleEJ1ZmZlci51cGRhdGUoKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhclJlbmRlckRhdGFQb29sLnB1c2goY2hhcnNbaV0pO1xuICAgIH1cbiAgICB0aGlzLl9mb250ID0gZGF0YTtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIH1cbiAgdXBkYXRlVHJhbnNmb3JtKCkge1xuICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICB0aGlzLmNvbnRhaW5lclVwZGF0ZVRyYW5zZm9ybSgpO1xuICB9XG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICBpZiAodGhpcy5fYXV0b1Jlc29sdXRpb24gJiYgdGhpcy5fcmVzb2x1dGlvbiAhPT0gcmVuZGVyZXIucmVzb2x1dGlvbikge1xuICAgICAgdGhpcy5fcmVzb2x1dGlvbiA9IHJlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgeyBkaXN0YW5jZUZpZWxkUmFuZ2UsIGRpc3RhbmNlRmllbGRUeXBlLCBzaXplIH0gPSBCaXRtYXBGb250LkJpdG1hcEZvbnQuYXZhaWxhYmxlW3RoaXMuX2ZvbnROYW1lXTtcbiAgICBpZiAoZGlzdGFuY2VGaWVsZFR5cGUgIT09IFwibm9uZVwiKSB7XG4gICAgICBjb25zdCB7IGEsIGIsIGMsIGQgfSA9IHRoaXMud29ybGRUcmFuc2Zvcm07XG4gICAgICBjb25zdCBkeCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgICAgIGNvbnN0IGR5ID0gTWF0aC5zcXJ0KGMgKiBjICsgZCAqIGQpO1xuICAgICAgY29uc3Qgd29ybGRTY2FsZSA9IChNYXRoLmFicyhkeCkgKyBNYXRoLmFicyhkeSkpIC8gMjtcbiAgICAgIGNvbnN0IGZvbnRTY2FsZSA9IHRoaXMuZm9udFNpemUgLyBzaXplO1xuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHJlbmRlcmVyLl92aWV3LnJlc29sdXRpb247XG4gICAgICBmb3IgKGNvbnN0IG1lc2ggb2YgdGhpcy5fYWN0aXZlUGFnZXNNZXNoRGF0YSkge1xuICAgICAgICBtZXNoLm1lc2guc2hhZGVyLnVuaWZvcm1zLnVGV2lkdGggPSB3b3JsZFNjYWxlICogZGlzdGFuY2VGaWVsZFJhbmdlICogZm9udFNjYWxlICogcmVzb2x1dGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIuX3JlbmRlcihyZW5kZXJlcik7XG4gIH1cbiAgZ2V0TG9jYWxCb3VuZHMoKSB7XG4gICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgIHJldHVybiBzdXBlci5nZXRMb2NhbEJvdW5kcygpO1xuICB9XG4gIHZhbGlkYXRlKCkge1xuICAgIGNvbnN0IGZvbnQgPSBCaXRtYXBGb250LkJpdG1hcEZvbnQuYXZhaWxhYmxlW3RoaXMuX2ZvbnROYW1lXTtcbiAgICBpZiAoIWZvbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBCaXRtYXBGb250IFwiJHt0aGlzLl9mb250TmFtZX1cImApO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZm9udCAhPT0gZm9udCkge1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICB0aGlzLnVwZGF0ZVRleHQoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHRpbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbnRDb2xvci52YWx1ZTtcbiAgfVxuICBzZXQgdGludCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnRpbnQgPT09IHZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX3RpbnRDb2xvci5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hY3RpdmVQYWdlc01lc2hEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9hY3RpdmVQYWdlc01lc2hEYXRhW2ldLm1lc2gudGludCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBnZXQgYWxpZ24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FsaWduO1xuICB9XG4gIHNldCBhbGlnbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9hbGlnbiAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2FsaWduID0gdmFsdWU7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0IGZvbnROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9mb250TmFtZTtcbiAgfVxuICBzZXQgZm9udE5hbWUodmFsdWUpIHtcbiAgICBpZiAoIUJpdG1hcEZvbnQuQml0bWFwRm9udC5hdmFpbGFibGVbdmFsdWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgQml0bWFwRm9udCBcIiR7dmFsdWV9XCJgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2ZvbnROYW1lICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fZm9udE5hbWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBnZXQgZm9udFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRTaXplID8/IEJpdG1hcEZvbnQuQml0bWFwRm9udC5hdmFpbGFibGVbdGhpcy5fZm9udE5hbWVdLnNpemU7XG4gIH1cbiAgc2V0IGZvbnRTaXplKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2ZvbnRTaXplICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fZm9udFNpemUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBnZXQgYW5jaG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9hbmNob3I7XG4gIH1cbiAgc2V0IGFuY2hvcih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRoaXMuX2FuY2hvci5zZXQodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hbmNob3IuY29weUZyb20odmFsdWUpO1xuICAgIH1cbiAgfVxuICBnZXQgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgfVxuICBzZXQgdGV4dCh0ZXh0KSB7XG4gICAgdGV4dCA9IFN0cmluZyh0ZXh0ID09PSBudWxsIHx8IHRleHQgPT09IHZvaWQgMCA/IFwiXCIgOiB0ZXh0KTtcbiAgICBpZiAodGhpcy5fdGV4dCA9PT0gdGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl90ZXh0ID0gdGV4dDtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuICBnZXQgbWF4V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21heFdpZHRoO1xuICB9XG4gIHNldCBtYXhXaWR0aCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9tYXhXaWR0aCA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbWF4V2lkdGggPSB2YWx1ZTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuICBnZXQgbWF4TGluZUhlaWdodCgpIHtcbiAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXMuX21heExpbmVIZWlnaHQ7XG4gIH1cbiAgZ2V0IHRleHRXaWR0aCgpIHtcbiAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RleHRXaWR0aDtcbiAgfVxuICBnZXQgbGV0dGVyU3BhY2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5fbGV0dGVyU3BhY2luZztcbiAgfVxuICBzZXQgbGV0dGVyU3BhY2luZyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9sZXR0ZXJTcGFjaW5nICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fbGV0dGVyU3BhY2luZyA9IHZhbHVlO1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGdldCByb3VuZFBpeGVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fcm91bmRQaXhlbHM7XG4gIH1cbiAgc2V0IHJvdW5kUGl4ZWxzKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9yb3VuZFBpeGVscykge1xuICAgICAgdGhpcy5fcm91bmRQaXhlbHMgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBnZXQgdGV4dEhlaWdodCgpIHtcbiAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RleHRIZWlnaHQ7XG4gIH1cbiAgZ2V0IHJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdXRpb247XG4gIH1cbiAgc2V0IHJlc29sdXRpb24odmFsdWUpIHtcbiAgICB0aGlzLl9hdXRvUmVzb2x1dGlvbiA9IGZhbHNlO1xuICAgIGlmICh0aGlzLl9yZXNvbHV0aW9uID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9yZXNvbHV0aW9uID0gdmFsdWU7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cbiAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBfdGV4dHVyZUNhY2hlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGRhdGEgPSBCaXRtYXBGb250LkJpdG1hcEZvbnQuYXZhaWxhYmxlW3RoaXMuX2ZvbnROYW1lXTtcbiAgICBjb25zdCBwYWdlTWVzaERhdGFQb29sID0gZGF0YS5kaXN0YW5jZUZpZWxkVHlwZSA9PT0gXCJub25lXCIgPyBwYWdlTWVzaERhdGFEZWZhdWx0UGFnZU1lc2hEYXRhIDogcGFnZU1lc2hEYXRhTVNERlBhZ2VNZXNoRGF0YTtcbiAgICBwYWdlTWVzaERhdGFQb29sLnB1c2goLi4udGhpcy5fYWN0aXZlUGFnZXNNZXNoRGF0YSk7XG4gICAgZm9yIChjb25zdCBwYWdlTWVzaERhdGEgb2YgdGhpcy5fYWN0aXZlUGFnZXNNZXNoRGF0YSkge1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZChwYWdlTWVzaERhdGEubWVzaCk7XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZVBhZ2VzTWVzaERhdGEgPSBbXTtcbiAgICBwYWdlTWVzaERhdGFQb29sLmZpbHRlcigocGFnZSkgPT4gX3RleHR1cmVDYWNoZVtwYWdlLm1lc2gudGV4dHVyZS5iYXNlVGV4dHVyZS51aWRdKS5mb3JFYWNoKChwYWdlKSA9PiB7XG4gICAgICBwYWdlLm1lc2gudGV4dHVyZSA9IGNvcmUuVGV4dHVyZS5FTVBUWTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IGlkIGluIF90ZXh0dXJlQ2FjaGUpIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBfdGV4dHVyZUNhY2hlW2lkXTtcbiAgICAgIHRleHR1cmUuZGVzdHJveSgpO1xuICAgICAgZGVsZXRlIF90ZXh0dXJlQ2FjaGVbaWRdO1xuICAgIH1cbiAgICB0aGlzLl9mb250ID0gbnVsbDtcbiAgICB0aGlzLl90aW50Q29sb3IgPSBudWxsO1xuICAgIHRoaXMuX3RleHR1cmVDYWNoZSA9IG51bGw7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgfVxufTtcbmxldCBCaXRtYXBUZXh0ID0gX0JpdG1hcFRleHQ7XG5CaXRtYXBUZXh0LnN0eWxlRGVmYXVsdHMgPSB7XG4gIGFsaWduOiBcImxlZnRcIixcbiAgdGludDogMTY3NzcyMTUsXG4gIG1heFdpZHRoOiAwLFxuICBsZXR0ZXJTcGFjaW5nOiAwXG59O1xuXG5leHBvcnRzLkJpdG1hcFRleHQgPSBCaXRtYXBUZXh0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qml0bWFwVGV4dC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qml0bWFwVGV4dFN0eWxlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgQml0bWFwRm9udERhdGEgPSByZXF1aXJlKCcuLi9CaXRtYXBGb250RGF0YS5qcycpO1xuXG5jbGFzcyBUZXh0Rm9ybWF0IHtcbiAgc3RhdGljIHRlc3QoZGF0YSkge1xuICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBkYXRhLnN0YXJ0c1dpdGgoXCJpbmZvIGZhY2U9XCIpO1xuICB9XG4gIHN0YXRpYyBwYXJzZSh0eHQpIHtcbiAgICBjb25zdCBpdGVtcyA9IHR4dC5tYXRjaCgvXlthLXpdK1xccysuKyQvZ20pO1xuICAgIGNvbnN0IHJhd0RhdGEgPSB7XG4gICAgICBpbmZvOiBbXSxcbiAgICAgIGNvbW1vbjogW10sXG4gICAgICBwYWdlOiBbXSxcbiAgICAgIGNoYXI6IFtdLFxuICAgICAgY2hhcnM6IFtdLFxuICAgICAga2VybmluZzogW10sXG4gICAgICBrZXJuaW5nczogW10sXG4gICAgICBkaXN0YW5jZUZpZWxkOiBbXVxuICAgIH07XG4gICAgZm9yIChjb25zdCBpIGluIGl0ZW1zKSB7XG4gICAgICBjb25zdCBuYW1lID0gaXRlbXNbaV0ubWF0Y2goL15bYS16XSsvZ20pWzBdO1xuICAgICAgY29uc3QgYXR0cmlidXRlTGlzdCA9IGl0ZW1zW2ldLm1hdGNoKC9bYS16QS1aXSs9KFteXFxzXCInXSt8XCIoW15cIl0qKVwiKS9nbSk7XG4gICAgICBjb25zdCBpdGVtRGF0YSA9IHt9O1xuICAgICAgZm9yIChjb25zdCBpMiBpbiBhdHRyaWJ1dGVMaXN0KSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gYXR0cmlidXRlTGlzdFtpMl0uc3BsaXQoXCI9XCIpO1xuICAgICAgICBjb25zdCBrZXkgPSBzcGxpdFswXTtcbiAgICAgICAgY29uc3Qgc3RyVmFsdWUgPSBzcGxpdFsxXS5yZXBsYWNlKC9cIi9nbSwgXCJcIik7XG4gICAgICAgIGNvbnN0IGZsb2F0VmFsdWUgPSBwYXJzZUZsb2F0KHN0clZhbHVlKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpc05hTihmbG9hdFZhbHVlKSA/IHN0clZhbHVlIDogZmxvYXRWYWx1ZTtcbiAgICAgICAgaXRlbURhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmF3RGF0YVtuYW1lXS5wdXNoKGl0ZW1EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZm9udCA9IG5ldyBCaXRtYXBGb250RGF0YS5CaXRtYXBGb250RGF0YSgpO1xuICAgIHJhd0RhdGEuaW5mby5mb3JFYWNoKChpbmZvKSA9PiBmb250LmluZm8ucHVzaCh7XG4gICAgICBmYWNlOiBpbmZvLmZhY2UsXG4gICAgICBzaXplOiBwYXJzZUludChpbmZvLnNpemUsIDEwKVxuICAgIH0pKTtcbiAgICByYXdEYXRhLmNvbW1vbi5mb3JFYWNoKChjb21tb24pID0+IGZvbnQuY29tbW9uLnB1c2goe1xuICAgICAgbGluZUhlaWdodDogcGFyc2VJbnQoY29tbW9uLmxpbmVIZWlnaHQsIDEwKVxuICAgIH0pKTtcbiAgICByYXdEYXRhLnBhZ2UuZm9yRWFjaCgocGFnZSkgPT4gZm9udC5wYWdlLnB1c2goe1xuICAgICAgaWQ6IHBhcnNlSW50KHBhZ2UuaWQsIDEwKSxcbiAgICAgIGZpbGU6IHBhZ2UuZmlsZVxuICAgIH0pKTtcbiAgICByYXdEYXRhLmNoYXIuZm9yRWFjaCgoY2hhcikgPT4gZm9udC5jaGFyLnB1c2goe1xuICAgICAgaWQ6IHBhcnNlSW50KGNoYXIuaWQsIDEwKSxcbiAgICAgIHBhZ2U6IHBhcnNlSW50KGNoYXIucGFnZSwgMTApLFxuICAgICAgeDogcGFyc2VJbnQoY2hhci54LCAxMCksXG4gICAgICB5OiBwYXJzZUludChjaGFyLnksIDEwKSxcbiAgICAgIHdpZHRoOiBwYXJzZUludChjaGFyLndpZHRoLCAxMCksXG4gICAgICBoZWlnaHQ6IHBhcnNlSW50KGNoYXIuaGVpZ2h0LCAxMCksXG4gICAgICB4b2Zmc2V0OiBwYXJzZUludChjaGFyLnhvZmZzZXQsIDEwKSxcbiAgICAgIHlvZmZzZXQ6IHBhcnNlSW50KGNoYXIueW9mZnNldCwgMTApLFxuICAgICAgeGFkdmFuY2U6IHBhcnNlSW50KGNoYXIueGFkdmFuY2UsIDEwKVxuICAgIH0pKTtcbiAgICByYXdEYXRhLmtlcm5pbmcuZm9yRWFjaCgoa2VybmluZykgPT4gZm9udC5rZXJuaW5nLnB1c2goe1xuICAgICAgZmlyc3Q6IHBhcnNlSW50KGtlcm5pbmcuZmlyc3QsIDEwKSxcbiAgICAgIHNlY29uZDogcGFyc2VJbnQoa2VybmluZy5zZWNvbmQsIDEwKSxcbiAgICAgIGFtb3VudDogcGFyc2VJbnQoa2VybmluZy5hbW91bnQsIDEwKVxuICAgIH0pKTtcbiAgICByYXdEYXRhLmRpc3RhbmNlRmllbGQuZm9yRWFjaCgoZGYpID0+IGZvbnQuZGlzdGFuY2VGaWVsZC5wdXNoKHtcbiAgICAgIGRpc3RhbmNlUmFuZ2U6IHBhcnNlSW50KGRmLmRpc3RhbmNlUmFuZ2UsIDEwKSxcbiAgICAgIGZpZWxkVHlwZTogZGYuZmllbGRUeXBlXG4gICAgfSkpO1xuICAgIHJldHVybiBmb250O1xuICB9XG59XG5cbmV4cG9ydHMuVGV4dEZvcm1hdCA9IFRleHRGb3JtYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0Rm9ybWF0LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgQml0bWFwRm9udERhdGEgPSByZXF1aXJlKCcuLi9CaXRtYXBGb250RGF0YS5qcycpO1xuXG5jbGFzcyBYTUxGb3JtYXQge1xuICBzdGF0aWMgdGVzdChkYXRhKSB7XG4gICAgY29uc3QgeG1sID0gZGF0YTtcbiAgICByZXR1cm4gXCJnZXRFbGVtZW50c0J5VGFnTmFtZVwiIGluIHhtbCAmJiB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYWdlXCIpLmxlbmd0aCAmJiB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbmZvXCIpWzBdLmdldEF0dHJpYnV0ZShcImZhY2VcIikgIT09IG51bGw7XG4gIH1cbiAgc3RhdGljIHBhcnNlKHhtbCkge1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgQml0bWFwRm9udERhdGEuQml0bWFwRm9udERhdGEoKTtcbiAgICBjb25zdCBpbmZvID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5mb1wiKTtcbiAgICBjb25zdCBjb21tb24gPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjb21tb25cIik7XG4gICAgY29uc3QgcGFnZSA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInBhZ2VcIik7XG4gICAgY29uc3QgY2hhciA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNoYXJcIik7XG4gICAgY29uc3Qga2VybmluZyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImtlcm5pbmdcIik7XG4gICAgY29uc3QgZGlzdGFuY2VGaWVsZCA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRpc3RhbmNlRmllbGRcIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhLmluZm8ucHVzaCh7XG4gICAgICAgIGZhY2U6IGluZm9baV0uZ2V0QXR0cmlidXRlKFwiZmFjZVwiKSxcbiAgICAgICAgc2l6ZTogcGFyc2VJbnQoaW5mb1tpXS5nZXRBdHRyaWJ1dGUoXCJzaXplXCIpLCAxMClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1vbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YS5jb21tb24ucHVzaCh7XG4gICAgICAgIGxpbmVIZWlnaHQ6IHBhcnNlSW50KGNvbW1vbltpXS5nZXRBdHRyaWJ1dGUoXCJsaW5lSGVpZ2h0XCIpLCAxMClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEucGFnZS5wdXNoKHtcbiAgICAgICAgaWQ6IHBhcnNlSW50KHBhZ2VbaV0uZ2V0QXR0cmlidXRlKFwiaWRcIiksIDEwKSB8fCAwLFxuICAgICAgICBmaWxlOiBwYWdlW2ldLmdldEF0dHJpYnV0ZShcImZpbGVcIilcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxldHRlciA9IGNoYXJbaV07XG4gICAgICBkYXRhLmNoYXIucHVzaCh7XG4gICAgICAgIGlkOiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwiaWRcIiksIDEwKSxcbiAgICAgICAgcGFnZTogcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZShcInBhZ2VcIiksIDEwKSB8fCAwLFxuICAgICAgICB4OiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwieFwiKSwgMTApLFxuICAgICAgICB5OiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwieVwiKSwgMTApLFxuICAgICAgICB3aWR0aDogcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZShcIndpZHRoXCIpLCAxMCksXG4gICAgICAgIGhlaWdodDogcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKSwgMTApLFxuICAgICAgICB4b2Zmc2V0OiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwieG9mZnNldFwiKSwgMTApLFxuICAgICAgICB5b2Zmc2V0OiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwieW9mZnNldFwiKSwgMTApLFxuICAgICAgICB4YWR2YW5jZTogcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZShcInhhZHZhbmNlXCIpLCAxMClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEua2VybmluZy5wdXNoKHtcbiAgICAgICAgZmlyc3Q6IHBhcnNlSW50KGtlcm5pbmdbaV0uZ2V0QXR0cmlidXRlKFwiZmlyc3RcIiksIDEwKSxcbiAgICAgICAgc2Vjb25kOiBwYXJzZUludChrZXJuaW5nW2ldLmdldEF0dHJpYnV0ZShcInNlY29uZFwiKSwgMTApLFxuICAgICAgICBhbW91bnQ6IHBhcnNlSW50KGtlcm5pbmdbaV0uZ2V0QXR0cmlidXRlKFwiYW1vdW50XCIpLCAxMClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpc3RhbmNlRmllbGQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEuZGlzdGFuY2VGaWVsZC5wdXNoKHtcbiAgICAgICAgZmllbGRUeXBlOiBkaXN0YW5jZUZpZWxkW2ldLmdldEF0dHJpYnV0ZShcImZpZWxkVHlwZVwiKSxcbiAgICAgICAgZGlzdGFuY2VSYW5nZTogcGFyc2VJbnQoZGlzdGFuY2VGaWVsZFtpXS5nZXRBdHRyaWJ1dGUoXCJkaXN0YW5jZVJhbmdlXCIpLCAxMClcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxufVxuXG5leHBvcnRzLlhNTEZvcm1hdCA9IFhNTEZvcm1hdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVhNTEZvcm1hdC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgWE1MRm9ybWF0ID0gcmVxdWlyZSgnLi9YTUxGb3JtYXQuanMnKTtcblxuY2xhc3MgWE1MU3RyaW5nRm9ybWF0IHtcbiAgc3RhdGljIHRlc3QoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBkYXRhLmluY2x1ZGVzKFwiPGZvbnQ+XCIpKSB7XG4gICAgICByZXR1cm4gWE1MRm9ybWF0LlhNTEZvcm1hdC50ZXN0KGNvcmUuc2V0dGluZ3MuQURBUFRFUi5wYXJzZVhNTChkYXRhKSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgcGFyc2UoeG1sVHh0KSB7XG4gICAgcmV0dXJuIFhNTEZvcm1hdC5YTUxGb3JtYXQucGFyc2UoY29yZS5zZXR0aW5ncy5BREFQVEVSLnBhcnNlWE1MKHhtbFR4dCkpO1xuICB9XG59XG5cbmV4cG9ydHMuWE1MU3RyaW5nRm9ybWF0ID0gWE1MU3RyaW5nRm9ybWF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9WE1MU3RyaW5nRm9ybWF0LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgVGV4dEZvcm1hdCA9IHJlcXVpcmUoJy4vVGV4dEZvcm1hdC5qcycpO1xudmFyIFhNTEZvcm1hdCA9IHJlcXVpcmUoJy4vWE1MRm9ybWF0LmpzJyk7XG52YXIgWE1MU3RyaW5nRm9ybWF0ID0gcmVxdWlyZSgnLi9YTUxTdHJpbmdGb3JtYXQuanMnKTtcblxuY29uc3QgZm9ybWF0cyA9IFtcbiAgVGV4dEZvcm1hdC5UZXh0Rm9ybWF0LFxuICBYTUxGb3JtYXQuWE1MRm9ybWF0LFxuICBYTUxTdHJpbmdGb3JtYXQuWE1MU3RyaW5nRm9ybWF0XG5dO1xuZnVuY3Rpb24gYXV0b0RldGVjdEZvcm1hdChkYXRhKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybWF0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChmb3JtYXRzW2ldLnRlc3QoZGF0YSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRzW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0cy5UZXh0Rm9ybWF0ID0gVGV4dEZvcm1hdC5UZXh0Rm9ybWF0O1xuZXhwb3J0cy5YTUxGb3JtYXQgPSBYTUxGb3JtYXQuWE1MRm9ybWF0O1xuZXhwb3J0cy5YTUxTdHJpbmdGb3JtYXQgPSBYTUxTdHJpbmdGb3JtYXQuWE1MU3RyaW5nRm9ybWF0O1xuZXhwb3J0cy5hdXRvRGV0ZWN0Rm9ybWF0ID0gYXV0b0RldGVjdEZvcm1hdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgQml0bWFwRm9udCA9IHJlcXVpcmUoJy4vQml0bWFwRm9udC5qcycpO1xudmFyIEJpdG1hcEZvbnREYXRhID0gcmVxdWlyZSgnLi9CaXRtYXBGb250RGF0YS5qcycpO1xudmFyIEJpdG1hcFRleHQgPSByZXF1aXJlKCcuL0JpdG1hcFRleHQuanMnKTtcbnJlcXVpcmUoJy4vQml0bWFwVGV4dFN0eWxlLmpzJyk7XG52YXIgaW5kZXggPSByZXF1aXJlKCcuL2Zvcm1hdHMvaW5kZXguanMnKTtcbnZhciBsb2FkQml0bWFwRm9udCA9IHJlcXVpcmUoJy4vbG9hZEJpdG1hcEZvbnQuanMnKTtcbnZhciBUZXh0Rm9ybWF0ID0gcmVxdWlyZSgnLi9mb3JtYXRzL1RleHRGb3JtYXQuanMnKTtcbnZhciBYTUxGb3JtYXQgPSByZXF1aXJlKCcuL2Zvcm1hdHMvWE1MRm9ybWF0LmpzJyk7XG52YXIgWE1MU3RyaW5nRm9ybWF0ID0gcmVxdWlyZSgnLi9mb3JtYXRzL1hNTFN0cmluZ0Zvcm1hdC5qcycpO1xuXG5cblxuZXhwb3J0cy5CaXRtYXBGb250ID0gQml0bWFwRm9udC5CaXRtYXBGb250O1xuZXhwb3J0cy5CaXRtYXBGb250RGF0YSA9IEJpdG1hcEZvbnREYXRhLkJpdG1hcEZvbnREYXRhO1xuZXhwb3J0cy5CaXRtYXBUZXh0ID0gQml0bWFwVGV4dC5CaXRtYXBUZXh0O1xuZXhwb3J0cy5hdXRvRGV0ZWN0Rm9ybWF0ID0gaW5kZXguYXV0b0RldGVjdEZvcm1hdDtcbmV4cG9ydHMubG9hZEJpdG1hcEZvbnQgPSBsb2FkQml0bWFwRm9udC5sb2FkQml0bWFwRm9udDtcbmV4cG9ydHMuVGV4dEZvcm1hdCA9IFRleHRGb3JtYXQuVGV4dEZvcm1hdDtcbmV4cG9ydHMuWE1MRm9ybWF0ID0gWE1MRm9ybWF0LlhNTEZvcm1hdDtcbmV4cG9ydHMuWE1MU3RyaW5nRm9ybWF0ID0gWE1MU3RyaW5nRm9ybWF0LlhNTFN0cmluZ0Zvcm1hdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgYXNzZXRzID0gcmVxdWlyZSgnQHBpeGkvYXNzZXRzJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBCaXRtYXBGb250ID0gcmVxdWlyZSgnLi9CaXRtYXBGb250LmpzJyk7XG5yZXF1aXJlKCcuL2Zvcm1hdHMvaW5kZXguanMnKTtcbnZhciBUZXh0Rm9ybWF0ID0gcmVxdWlyZSgnLi9mb3JtYXRzL1RleHRGb3JtYXQuanMnKTtcbnZhciBYTUxTdHJpbmdGb3JtYXQgPSByZXF1aXJlKCcuL2Zvcm1hdHMvWE1MU3RyaW5nRm9ybWF0LmpzJyk7XG5cbmNvbnN0IHZhbGlkRXh0ZW5zaW9ucyA9IFtcIi54bWxcIiwgXCIuZm50XCJdO1xuY29uc3QgbG9hZEJpdG1hcEZvbnQgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IGNvcmUuRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgIHByaW9yaXR5OiBhc3NldHMuTG9hZGVyUGFyc2VyUHJpb3JpdHkuTm9ybWFsXG4gIH0sXG4gIG5hbWU6IFwibG9hZEJpdG1hcEZvbnRcIixcbiAgdGVzdCh1cmwpIHtcbiAgICByZXR1cm4gdmFsaWRFeHRlbnNpb25zLmluY2x1ZGVzKGNvcmUudXRpbHMucGF0aC5leHRuYW1lKHVybCkudG9Mb3dlckNhc2UoKSk7XG4gIH0sXG4gIGFzeW5jIHRlc3RQYXJzZShkYXRhKSB7XG4gICAgcmV0dXJuIFRleHRGb3JtYXQuVGV4dEZvcm1hdC50ZXN0KGRhdGEpIHx8IFhNTFN0cmluZ0Zvcm1hdC5YTUxTdHJpbmdGb3JtYXQudGVzdChkYXRhKTtcbiAgfSxcbiAgYXN5bmMgcGFyc2UoYXNzZXQsIGRhdGEsIGxvYWRlcikge1xuICAgIGNvbnN0IGZvbnREYXRhID0gVGV4dEZvcm1hdC5UZXh0Rm9ybWF0LnRlc3QoYXNzZXQpID8gVGV4dEZvcm1hdC5UZXh0Rm9ybWF0LnBhcnNlKGFzc2V0KSA6IFhNTFN0cmluZ0Zvcm1hdC5YTUxTdHJpbmdGb3JtYXQucGFyc2UoYXNzZXQpO1xuICAgIGNvbnN0IHsgc3JjIH0gPSBkYXRhO1xuICAgIGNvbnN0IHsgcGFnZTogcGFnZXMgfSA9IGZvbnREYXRhO1xuICAgIGNvbnN0IHRleHR1cmVVcmxzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWdlcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgcGFnZUZpbGUgPSBwYWdlc1tpXS5maWxlO1xuICAgICAgbGV0IGltYWdlUGF0aCA9IGNvcmUudXRpbHMucGF0aC5qb2luKGNvcmUudXRpbHMucGF0aC5kaXJuYW1lKHNyYyksIHBhZ2VGaWxlKTtcbiAgICAgIGltYWdlUGF0aCA9IGFzc2V0cy5jb3B5U2VhcmNoUGFyYW1zKGltYWdlUGF0aCwgc3JjKTtcbiAgICAgIHRleHR1cmVVcmxzLnB1c2goaW1hZ2VQYXRoKTtcbiAgICB9XG4gICAgY29uc3QgbG9hZGVkVGV4dHVyZXMgPSBhd2FpdCBsb2FkZXIubG9hZCh0ZXh0dXJlVXJscyk7XG4gICAgY29uc3QgdGV4dHVyZXMgPSB0ZXh0dXJlVXJscy5tYXAoKHVybCkgPT4gbG9hZGVkVGV4dHVyZXNbdXJsXSk7XG4gICAgcmV0dXJuIEJpdG1hcEZvbnQuQml0bWFwRm9udC5pbnN0YWxsKGZvbnREYXRhLCB0ZXh0dXJlcywgdHJ1ZSk7XG4gIH0sXG4gIGFzeW5jIGxvYWQodXJsLCBfb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29yZS5zZXR0aW5ncy5BREFQVEVSLmZldGNoKHVybCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfSxcbiAgdW5sb2FkKGJpdG1hcEZvbnQpIHtcbiAgICBiaXRtYXBGb250LmRlc3Ryb3koKTtcbiAgfVxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQobG9hZEJpdG1hcEZvbnQpO1xuXG5leHBvcnRzLmxvYWRCaXRtYXBGb250ID0gbG9hZEJpdG1hcEZvbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkQml0bWFwRm9udC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIG1zZGZGcmFnID0gXCIvLyBQaXhpIHRleHR1cmUgaW5mb1xcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcblxcclxcbi8vIFRpbnRcXHJcXG51bmlmb3JtIHZlYzQgdUNvbG9yO1xcclxcblxcclxcbi8vIG9uIDJEIGFwcGxpY2F0aW9ucyBmd2lkdGggaXMgc2NyZWVuU2NhbGUgLyBnbHlwaEF0bGFzU2NhbGUgKiBkaXN0YW5jZUZpZWxkUmFuZ2VcXHJcXG51bmlmb3JtIGZsb2F0IHVGV2lkdGg7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpIHtcXHJcXG5cXHJcXG4gIC8vIFRvIHN0YWNrIE1TREYgYW5kIFNERiB3ZSBuZWVkIGEgbm9uLXByZS1tdWx0aXBsaWVkLWFscGhhIHRleHR1cmUuXFxyXFxuICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXHJcXG5cXHJcXG4gIC8vIE1TREZcXHJcXG4gIGZsb2F0IG1lZGlhbiA9IHRleENvbG9yLnIgKyB0ZXhDb2xvci5nICsgdGV4Q29sb3IuYiAtXFxyXFxuICAgICAgICAgICAgICAgICAgbWluKHRleENvbG9yLnIsIG1pbih0ZXhDb2xvci5nLCB0ZXhDb2xvci5iKSkgLVxcclxcbiAgICAgICAgICAgICAgICAgIG1heCh0ZXhDb2xvci5yLCBtYXgodGV4Q29sb3IuZywgdGV4Q29sb3IuYikpO1xcclxcbiAgLy8gU0RGXFxyXFxuICBtZWRpYW4gPSBtaW4obWVkaWFuLCB0ZXhDb2xvci5hKTtcXHJcXG5cXHJcXG4gIGZsb2F0IHNjcmVlblB4RGlzdGFuY2UgPSB1RldpZHRoICogKG1lZGlhbiAtIDAuNSk7XFxyXFxuICBmbG9hdCBhbHBoYSA9IGNsYW1wKHNjcmVlblB4RGlzdGFuY2UgKyAwLjUsIDAuMCwgMS4wKTtcXHJcXG4gIGlmIChtZWRpYW4gPCAwLjAxKSB7XFxyXFxuICAgIGFscGhhID0gMC4wO1xcclxcbiAgfSBlbHNlIGlmIChtZWRpYW4gPiAwLjk5KSB7XFxyXFxuICAgIGFscGhhID0gMS4wO1xcclxcbiAgfVxcclxcblxcclxcbiAgLy8gR2FtbWEgY29ycmVjdGlvbiBmb3IgY292ZXJhZ2UtbGlrZSBhbHBoYVxcclxcbiAgZmxvYXQgbHVtYSA9IGRvdCh1Q29sb3IucmdiLCB2ZWMzKDAuMjk5LCAwLjU4NywgMC4xMTQpKTtcXHJcXG4gIGZsb2F0IGdhbW1hID0gbWl4KDEuMCwgMS4wIC8gMi4yLCBsdW1hKTtcXHJcXG4gIGZsb2F0IGNvdmVyYWdlID0gcG93KHVDb2xvci5hICogYWxwaGEsIGdhbW1hKTsgIFxcclxcblxcclxcbiAgLy8gTlBNIFRleHR1cmVzLCBOUE0gb3V0cHV0c1xcclxcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh1Q29sb3IucmdiLCBjb3ZlcmFnZSk7XFxyXFxufVxcclxcblwiO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1zZGZGcmFnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXNkZi5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIG1zZGZWZXJ0ID0gXCIvLyBNZXNoIG1hdGVyaWFsIGRlZmF1bHQgZnJhZ21lbnRcXHJcXG5hdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxyXFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG51bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7XFxyXFxudW5pZm9ybSBtYXQzIHVUZXh0dXJlTWF0cml4O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXHJcXG5cXHJcXG4gICAgdlRleHR1cmVDb29yZCA9ICh1VGV4dHVyZU1hdHJpeCAqIHZlYzMoYVRleHR1cmVDb29yZCwgMS4wKSkueHk7XFxyXFxufVxcclxcblwiO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1zZGZWZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXNkZjIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xudmFyIGdlbmVyYXRlRmlsbFN0eWxlID0gcmVxdWlyZSgnLi9nZW5lcmF0ZUZpbGxTdHlsZS5qcycpO1xuXG5mdW5jdGlvbiBkcmF3R2x5cGgoY2FudmFzLCBjb250ZXh0LCBtZXRyaWNzLCB4LCB5LCByZXNvbHV0aW9uLCBzdHlsZSkge1xuICBjb25zdCBjaGFyID0gbWV0cmljcy50ZXh0O1xuICBjb25zdCBmb250UHJvcGVydGllcyA9IG1ldHJpY3MuZm9udFByb3BlcnRpZXM7XG4gIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICBjb250ZXh0LnNjYWxlKHJlc29sdXRpb24sIHJlc29sdXRpb24pO1xuICBjb25zdCB0eCA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcyAvIDI7XG4gIGNvbnN0IHR5ID0gLShzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyKTtcbiAgY29udGV4dC5mb250ID0gc3R5bGUudG9Gb250U3RyaW5nKCk7XG4gIGNvbnRleHQubGluZVdpZHRoID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xuICBjb250ZXh0LnRleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZTtcbiAgY29udGV4dC5saW5lSm9pbiA9IHN0eWxlLmxpbmVKb2luO1xuICBjb250ZXh0Lm1pdGVyTGltaXQgPSBzdHlsZS5taXRlckxpbWl0O1xuICBjb250ZXh0LmZpbGxTdHlsZSA9IGdlbmVyYXRlRmlsbFN0eWxlLmdlbmVyYXRlRmlsbFN0eWxlKGNhbnZhcywgY29udGV4dCwgc3R5bGUsIHJlc29sdXRpb24sIFtjaGFyXSwgbWV0cmljcyk7XG4gIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzdHlsZS5zdHJva2U7XG4gIGlmIChzdHlsZS5kcm9wU2hhZG93KSB7XG4gICAgY29uc3QgZHJvcFNoYWRvd0NvbG9yID0gc3R5bGUuZHJvcFNoYWRvd0NvbG9yO1xuICAgIGNvbnN0IGRyb3BTaGFkb3dCbHVyID0gc3R5bGUuZHJvcFNoYWRvd0JsdXIgKiByZXNvbHV0aW9uO1xuICAgIGNvbnN0IGRyb3BTaGFkb3dEaXN0YW5jZSA9IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZSAqIHJlc29sdXRpb247XG4gICAgY29udGV4dC5zaGFkb3dDb2xvciA9IGNvcmUuQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGRyb3BTaGFkb3dDb2xvcikuc2V0QWxwaGEoc3R5bGUuZHJvcFNoYWRvd0FscGhhKS50b1JnYmFTdHJpbmcoKTtcbiAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSBkcm9wU2hhZG93Qmx1cjtcbiAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSBNYXRoLmNvcyhzdHlsZS5kcm9wU2hhZG93QW5nbGUpICogZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IE1hdGguc2luKHN0eWxlLmRyb3BTaGFkb3dBbmdsZSkgKiBkcm9wU2hhZG93RGlzdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcbiAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSAwO1xuICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgfVxuICBpZiAoc3R5bGUuc3Ryb2tlICYmIHN0eWxlLnN0cm9rZVRoaWNrbmVzcykge1xuICAgIGNvbnRleHQuc3Ryb2tlVGV4dChjaGFyLCB0eCwgdHkgKyBtZXRyaWNzLmxpbmVIZWlnaHQgLSBmb250UHJvcGVydGllcy5kZXNjZW50KTtcbiAgfVxuICBpZiAoc3R5bGUuZmlsbCkge1xuICAgIGNvbnRleHQuZmlsbFRleHQoY2hhciwgdHgsIHR5ICsgbWV0cmljcy5saW5lSGVpZ2h0IC0gZm9udFByb3BlcnRpZXMuZGVzY2VudCk7XG4gIH1cbiAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gIGNvbnRleHQuZmlsbFN0eWxlID0gXCJyZ2JhKDAsIDAsIDAsIDApXCI7XG59XG5cbmV4cG9ydHMuZHJhd0dseXBoID0gZHJhd0dseXBoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHJhd0dseXBoLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBleHRyYWN0Q2hhckNvZGUoc3RyKSB7XG4gIHJldHVybiBzdHIuY29kZVBvaW50QXQgPyBzdHIuY29kZVBvaW50QXQoMCkgOiBzdHIuY2hhckNvZGVBdCgwKTtcbn1cblxuZXhwb3J0cy5leHRyYWN0Q2hhckNvZGUgPSBleHRyYWN0Q2hhckNvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0Q2hhckNvZGUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB0ZXh0ID0gcmVxdWlyZSgnQHBpeGkvdGV4dCcpO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUZpbGxTdHlsZShjYW52YXMsIGNvbnRleHQsIHN0eWxlLCByZXNvbHV0aW9uLCBsaW5lcywgbWV0cmljcykge1xuICBjb25zdCBmaWxsU3R5bGUgPSBzdHlsZS5maWxsO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsbFN0eWxlKSkge1xuICAgIHJldHVybiBmaWxsU3R5bGU7XG4gIH0gZWxzZSBpZiAoZmlsbFN0eWxlLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmaWxsU3R5bGVbMF07XG4gIH1cbiAgbGV0IGdyYWRpZW50O1xuICBjb25zdCBkcm9wU2hhZG93Q29ycmVjdGlvbiA9IHN0eWxlLmRyb3BTaGFkb3cgPyBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2UgOiAwO1xuICBjb25zdCBwYWRkaW5nID0gc3R5bGUucGFkZGluZyB8fCAwO1xuICBjb25zdCB3aWR0aCA9IGNhbnZhcy53aWR0aCAvIHJlc29sdXRpb24gLSBkcm9wU2hhZG93Q29ycmVjdGlvbiAtIHBhZGRpbmcgKiAyO1xuICBjb25zdCBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0IC8gcmVzb2x1dGlvbiAtIGRyb3BTaGFkb3dDb3JyZWN0aW9uIC0gcGFkZGluZyAqIDI7XG4gIGNvbnN0IGZpbGwgPSBmaWxsU3R5bGUuc2xpY2UoKTtcbiAgY29uc3QgZmlsbEdyYWRpZW50U3RvcHMgPSBzdHlsZS5maWxsR3JhZGllbnRTdG9wcy5zbGljZSgpO1xuICBpZiAoIWZpbGxHcmFkaWVudFN0b3BzLmxlbmd0aCkge1xuICAgIGNvbnN0IGxlbmd0aFBsdXMxID0gZmlsbC5sZW5ndGggKyAxO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoUGx1czE7ICsraSkge1xuICAgICAgZmlsbEdyYWRpZW50U3RvcHMucHVzaChpIC8gbGVuZ3RoUGx1czEpO1xuICAgIH1cbiAgfVxuICBmaWxsLnVuc2hpZnQoZmlsbFN0eWxlWzBdKTtcbiAgZmlsbEdyYWRpZW50U3RvcHMudW5zaGlmdCgwKTtcbiAgZmlsbC5wdXNoKGZpbGxTdHlsZVtmaWxsU3R5bGUubGVuZ3RoIC0gMV0pO1xuICBmaWxsR3JhZGllbnRTdG9wcy5wdXNoKDEpO1xuICBpZiAoc3R5bGUuZmlsbEdyYWRpZW50VHlwZSA9PT0gdGV4dC5URVhUX0dSQURJRU5ULkxJTkVBUl9WRVJUSUNBTCkge1xuICAgIGdyYWRpZW50ID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCh3aWR0aCAvIDIsIHBhZGRpbmcsIHdpZHRoIC8gMiwgaGVpZ2h0ICsgcGFkZGluZyk7XG4gICAgbGV0IGxhc3RJdGVyYXRpb25TdG9wID0gMDtcbiAgICBjb25zdCB0ZXh0SGVpZ2h0ID0gbWV0cmljcy5mb250UHJvcGVydGllcy5mb250U2l6ZSArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcztcbiAgICBjb25zdCBncmFkU3RvcExpbmVIZWlnaHQgPSB0ZXh0SGVpZ2h0IC8gaGVpZ2h0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRoaXNMaW5lVG9wID0gbWV0cmljcy5saW5lSGVpZ2h0ICogaTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZmlsbC5sZW5ndGg7IGorKykge1xuICAgICAgICBsZXQgbGluZVN0b3AgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIGZpbGxHcmFkaWVudFN0b3BzW2pdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgbGluZVN0b3AgPSBmaWxsR3JhZGllbnRTdG9wc1tqXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lU3RvcCA9IGogLyBmaWxsLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnbG9iYWxTdG9wID0gdGhpc0xpbmVUb3AgLyBoZWlnaHQgKyBsaW5lU3RvcCAqIGdyYWRTdG9wTGluZUhlaWdodDtcbiAgICAgICAgbGV0IGNsYW1wZWRTdG9wID0gTWF0aC5tYXgobGFzdEl0ZXJhdGlvblN0b3AsIGdsb2JhbFN0b3ApO1xuICAgICAgICBjbGFtcGVkU3RvcCA9IE1hdGgubWluKGNsYW1wZWRTdG9wLCAxKTtcbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKGNsYW1wZWRTdG9wLCBmaWxsW2pdKTtcbiAgICAgICAgbGFzdEl0ZXJhdGlvblN0b3AgPSBjbGFtcGVkU3RvcDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZ3JhZGllbnQgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KHBhZGRpbmcsIGhlaWdodCAvIDIsIHdpZHRoICsgcGFkZGluZywgaGVpZ2h0IC8gMik7XG4gICAgY29uc3QgdG90YWxJdGVyYXRpb25zID0gZmlsbC5sZW5ndGggKyAxO1xuICAgIGxldCBjdXJyZW50SXRlcmF0aW9uID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBzdG9wO1xuICAgICAgaWYgKHR5cGVvZiBmaWxsR3JhZGllbnRTdG9wc1tpXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBzdG9wID0gZmlsbEdyYWRpZW50U3RvcHNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9wID0gY3VycmVudEl0ZXJhdGlvbiAvIHRvdGFsSXRlcmF0aW9ucztcbiAgICAgIH1cbiAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLCBmaWxsW2ldKTtcbiAgICAgIGN1cnJlbnRJdGVyYXRpb24rKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdyYWRpZW50O1xufVxuXG5leHBvcnRzLmdlbmVyYXRlRmlsbFN0eWxlID0gZ2VuZXJhdGVGaWxsU3R5bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZUZpbGxTdHlsZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGRyYXdHbHlwaCA9IHJlcXVpcmUoJy4vZHJhd0dseXBoLmpzJyk7XG52YXIgZXh0cmFjdENoYXJDb2RlID0gcmVxdWlyZSgnLi9leHRyYWN0Q2hhckNvZGUuanMnKTtcbnZhciBnZW5lcmF0ZUZpbGxTdHlsZSA9IHJlcXVpcmUoJy4vZ2VuZXJhdGVGaWxsU3R5bGUuanMnKTtcbnZhciByZXNvbHZlQ2hhcmFjdGVycyA9IHJlcXVpcmUoJy4vcmVzb2x2ZUNoYXJhY3RlcnMuanMnKTtcbnZhciBzcGxpdFRleHRUb0NoYXJhY3RlcnMgPSByZXF1aXJlKCcuL3NwbGl0VGV4dFRvQ2hhcmFjdGVycy5qcycpO1xuXG5cblxuZXhwb3J0cy5kcmF3R2x5cGggPSBkcmF3R2x5cGguZHJhd0dseXBoO1xuZXhwb3J0cy5leHRyYWN0Q2hhckNvZGUgPSBleHRyYWN0Q2hhckNvZGUuZXh0cmFjdENoYXJDb2RlO1xuZXhwb3J0cy5nZW5lcmF0ZUZpbGxTdHlsZSA9IGdlbmVyYXRlRmlsbFN0eWxlLmdlbmVyYXRlRmlsbFN0eWxlO1xuZXhwb3J0cy5yZXNvbHZlQ2hhcmFjdGVycyA9IHJlc29sdmVDaGFyYWN0ZXJzLnJlc29sdmVDaGFyYWN0ZXJzO1xuZXhwb3J0cy5zcGxpdFRleHRUb0NoYXJhY3RlcnMgPSBzcGxpdFRleHRUb0NoYXJhY3RlcnMuc3BsaXRUZXh0VG9DaGFyYWN0ZXJzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBzcGxpdFRleHRUb0NoYXJhY3RlcnMgPSByZXF1aXJlKCcuL3NwbGl0VGV4dFRvQ2hhcmFjdGVycy5qcycpO1xuXG5mdW5jdGlvbiByZXNvbHZlQ2hhcmFjdGVycyhjaGFycykge1xuICBpZiAodHlwZW9mIGNoYXJzID09PSBcInN0cmluZ1wiKSB7XG4gICAgY2hhcnMgPSBbY2hhcnNdO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IGNoYXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgIGNvbnN0IGl0ZW0gPSBjaGFyc1tpXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgaWYgKGl0ZW0ubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW0JpdG1hcEZvbnRdOiBJbnZhbGlkIGNoYXJhY3RlciByYW5nZSBsZW5ndGgsIGV4cGVjdGluZyAyIGdvdCAke2l0ZW0ubGVuZ3RofS5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0Q29kZSA9IGl0ZW1bMF0uY2hhckNvZGVBdCgwKTtcbiAgICAgIGNvbnN0IGVuZENvZGUgPSBpdGVtWzFdLmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoZW5kQ29kZSA8IHN0YXJ0Q29kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQml0bWFwRm9udF06IEludmFsaWQgY2hhcmFjdGVyIHJhbmdlLlwiKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkyID0gc3RhcnRDb2RlLCBqMiA9IGVuZENvZGU7IGkyIDw9IGoyOyBpMisrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaTIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2goLi4uc3BsaXRUZXh0VG9DaGFyYWN0ZXJzLnNwbGl0VGV4dFRvQ2hhcmFjdGVycyhpdGVtKSk7XG4gICAgfVxuICB9XG4gIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW0JpdG1hcEZvbnRdOiBFbXB0eSBzZXQgd2hlbiByZXNvbHZpbmcgY2hhcmFjdGVycy5cIik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0cy5yZXNvbHZlQ2hhcmFjdGVycyA9IHJlc29sdmVDaGFyYWN0ZXJzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZUNoYXJhY3RlcnMuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIHNwbGl0VGV4dFRvQ2hhcmFjdGVycyh0ZXh0KSB7XG4gIHJldHVybiBBcnJheS5mcm9tID8gQXJyYXkuZnJvbSh0ZXh0KSA6IHRleHQuc3BsaXQoXCJcIik7XG59XG5cbmV4cG9ydHMuc3BsaXRUZXh0VG9DaGFyYWN0ZXJzID0gc3BsaXRUZXh0VG9DaGFyYWN0ZXJzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3BsaXRUZXh0VG9DaGFyYWN0ZXJzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBzcHJpdGUgPSByZXF1aXJlKCdAcGl4aS9zcHJpdGUnKTtcbnZhciB0ZXh0ID0gcmVxdWlyZSgnQHBpeGkvdGV4dCcpO1xudmFyIEhUTUxUZXh0U3R5bGUgPSByZXF1aXJlKCcuL0hUTUxUZXh0U3R5bGUuanMnKTtcblxuY29uc3QgX0hUTUxUZXh0ID0gY2xhc3MgZXh0ZW5kcyBzcHJpdGUuU3ByaXRlIHtcbiAgY29uc3RydWN0b3IodGV4dCA9IFwiXCIsIHN0eWxlID0ge30pIHtcbiAgICBzdXBlcihjb3JlLlRleHR1cmUuRU1QVFkpO1xuICAgIHRoaXMuX3RleHQgPSBudWxsO1xuICAgIHRoaXMuX3N0eWxlID0gbnVsbDtcbiAgICB0aGlzLl9hdXRvUmVzb2x1dGlvbiA9IHRydWU7XG4gICAgdGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuICAgIHRoaXMubG9jYWxTdHlsZUlEID0gLTE7XG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIHRoaXMub3duc1N0eWxlID0gZmFsc2U7XG4gICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gY29yZS5UZXh0dXJlLmZyb20oaW1hZ2UsIHtcbiAgICAgIHNjYWxlTW9kZTogY29yZS5zZXR0aW5ncy5TQ0FMRV9NT0RFLFxuICAgICAgcmVzb3VyY2VPcHRpb25zOiB7XG4gICAgICAgIGF1dG9Mb2FkOiBmYWxzZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRleHR1cmUub3JpZyA9IG5ldyBjb3JlLlJlY3RhbmdsZSgpO1xuICAgIHRleHR1cmUudHJpbSA9IG5ldyBjb3JlLlJlY3RhbmdsZSgpO1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgY29uc3QgbnNzdmcgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG4gICAgY29uc3QgbnN4aHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuICAgIGNvbnN0IHN2Z1Jvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnNzdmcsIFwic3ZnXCIpO1xuICAgIGNvbnN0IGZvcmVpZ25PYmplY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnNzdmcsIFwiZm9yZWlnbk9iamVjdFwiKTtcbiAgICBjb25zdCBkb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zeGh0bWwsIFwiZGl2XCIpO1xuICAgIGNvbnN0IHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuc3hodG1sLCBcInN0eWxlXCIpO1xuICAgIGZvcmVpZ25PYmplY3Quc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIxMDAwMFwiKTtcbiAgICBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjEwMDAwXCIpO1xuICAgIGZvcmVpZ25PYmplY3Quc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgIHN2Z1Jvb3QuYXBwZW5kQ2hpbGQoZm9yZWlnbk9iamVjdCk7XG4gICAgdGhpcy5tYXhXaWR0aCA9IF9IVE1MVGV4dC5kZWZhdWx0TWF4V2lkdGg7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSBfSFRNTFRleHQuZGVmYXVsdE1heEhlaWdodDtcbiAgICB0aGlzLl9kb21FbGVtZW50ID0gZG9tRWxlbWVudDtcbiAgICB0aGlzLl9zdHlsZUVsZW1lbnQgPSBzdHlsZUVsZW1lbnQ7XG4gICAgdGhpcy5fc3ZnUm9vdCA9IHN2Z1Jvb3Q7XG4gICAgdGhpcy5fZm9yZWlnbk9iamVjdCA9IGZvcmVpZ25PYmplY3Q7XG4gICAgdGhpcy5fZm9yZWlnbk9iamVjdC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgIHRoaXMuX2ZvcmVpZ25PYmplY3QuYXBwZW5kQ2hpbGQoZG9tRWxlbWVudCk7XG4gICAgdGhpcy5faW1hZ2UgPSBpbWFnZTtcbiAgICB0aGlzLl9sb2FkSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICB0aGlzLl9hdXRvUmVzb2x1dGlvbiA9IF9IVE1MVGV4dC5kZWZhdWx0QXV0b1Jlc29sdXRpb247XG4gICAgdGhpcy5fcmVzb2x1dGlvbiA9IF9IVE1MVGV4dC5kZWZhdWx0UmVzb2x1dGlvbiA/PyBjb3JlLnNldHRpbmdzLlJFU09MVVRJT047XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gIH1cbiAgbWVhc3VyZVRleHQob3ZlcnJpZGVzKSB7XG4gICAgY29uc3QgeyB0ZXh0LCBzdHlsZSwgcmVzb2x1dGlvbiB9ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICB0ZXh0OiB0aGlzLl90ZXh0LFxuICAgICAgc3R5bGU6IHRoaXMuX3N0eWxlLFxuICAgICAgcmVzb2x1dGlvbjogdGhpcy5fcmVzb2x1dGlvblxuICAgIH0sIG92ZXJyaWRlcyk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9kb21FbGVtZW50LCB7XG4gICAgICBpbm5lckhUTUw6IHRleHQsXG4gICAgICBzdHlsZTogc3R5bGUudG9DU1MocmVzb2x1dGlvbilcbiAgICB9KTtcbiAgICB0aGlzLl9zdHlsZUVsZW1lbnQudGV4dENvbnRlbnQgPSBzdHlsZS50b0dsb2JhbENTUygpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fc3ZnUm9vdCk7XG4gICAgY29uc3QgY29udGVudEJvdW5kcyA9IHRoaXMuX2RvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdGhpcy5fc3ZnUm9vdC5yZW1vdmUoKTtcbiAgICBjb25zdCBjb250ZW50V2lkdGggPSBNYXRoLm1pbih0aGlzLm1heFdpZHRoLCBNYXRoLmNlaWwoY29udGVudEJvdW5kcy53aWR0aCkpO1xuICAgIGNvbnN0IGNvbnRlbnRIZWlnaHQgPSBNYXRoLm1pbih0aGlzLm1heEhlaWdodCwgTWF0aC5jZWlsKGNvbnRlbnRCb3VuZHMuaGVpZ2h0KSk7XG4gICAgdGhpcy5fc3ZnUm9vdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBjb250ZW50V2lkdGgudG9TdHJpbmcoKSk7XG4gICAgdGhpcy5fc3ZnUm9vdC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgY29udGVudEhlaWdodC50b1N0cmluZygpKTtcbiAgICBpZiAodGV4dCAhPT0gdGhpcy5fdGV4dCkge1xuICAgICAgdGhpcy5fZG9tRWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl90ZXh0O1xuICAgIH1cbiAgICBpZiAoc3R5bGUgIT09IHRoaXMuX3N0eWxlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMuX2RvbUVsZW1lbnQsIHsgc3R5bGU6IHRoaXMuX3N0eWxlPy50b0NTUyhyZXNvbHV0aW9uKSB9KTtcbiAgICAgIHRoaXMuX3N0eWxlRWxlbWVudC50ZXh0Q29udGVudCA9IHRoaXMuX3N0eWxlPy50b0dsb2JhbENTUygpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IGNvbnRlbnRXaWR0aCArIHN0eWxlLnBhZGRpbmcgKiAyLFxuICAgICAgaGVpZ2h0OiBjb250ZW50SGVpZ2h0ICsgc3R5bGUucGFkZGluZyAqIDJcbiAgICB9O1xuICB9XG4gIGFzeW5jIHVwZGF0ZVRleHQocmVzcGVjdERpcnR5ID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgc3R5bGUsIF9pbWFnZTogaW1hZ2UsIF9sb2FkSW1hZ2U6IGxvYWRJbWFnZSB9ID0gdGhpcztcbiAgICBpZiAodGhpcy5sb2NhbFN0eWxlSUQgIT09IHN0eWxlLnN0eWxlSUQpIHtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgdGhpcy5sb2NhbFN0eWxlSUQgPSBzdHlsZS5zdHlsZUlEO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZGlydHkgJiYgcmVzcGVjdERpcnR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5tZWFzdXJlVGV4dCgpO1xuICAgIGltYWdlLndpZHRoID0gbG9hZEltYWdlLndpZHRoID0gTWF0aC5jZWlsKE1hdGgubWF4KDEsIHdpZHRoKSk7XG4gICAgaW1hZ2UuaGVpZ2h0ID0gbG9hZEltYWdlLmhlaWdodCA9IE1hdGguY2VpbChNYXRoLm1heCgxLCBoZWlnaHQpKTtcbiAgICBpZiAoIXRoaXMuX2xvYWRpbmcpIHtcbiAgICAgIHRoaXMuX2xvYWRpbmcgPSB0cnVlO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgbG9hZEltYWdlLm9ubG9hZCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBzdHlsZS5vbkJlZm9yZURyYXcoKTtcbiAgICAgICAgICB0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgaW1hZ2Uuc3JjID0gbG9hZEltYWdlLnNyYztcbiAgICAgICAgICBsb2FkSW1hZ2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgICBsb2FkSW1hZ2Uuc3JjID0gXCJcIjtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmUoKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN2Z1VSTCA9IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcodGhpcy5fc3ZnUm9vdCk7XG4gICAgICAgIGxvYWRJbWFnZS5zcmMgPSBgZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmOCwke2VuY29kZVVSSUNvbXBvbmVudChzdmdVUkwpfWA7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0IHNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW1hZ2U7XG4gIH1cbiAgdXBkYXRlVGV4dHVyZSgpIHtcbiAgICBjb25zdCB7IHN0eWxlLCB0ZXh0dXJlLCBfaW1hZ2U6IGltYWdlLCByZXNvbHV0aW9uIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcGFkZGluZyB9ID0gc3R5bGU7XG4gICAgY29uc3QgeyBiYXNlVGV4dHVyZSB9ID0gdGV4dHVyZTtcbiAgICB0ZXh0dXJlLnRyaW0ud2lkdGggPSB0ZXh0dXJlLl9mcmFtZS53aWR0aCA9IGltYWdlLndpZHRoIC8gcmVzb2x1dGlvbjtcbiAgICB0ZXh0dXJlLnRyaW0uaGVpZ2h0ID0gdGV4dHVyZS5fZnJhbWUuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0IC8gcmVzb2x1dGlvbjtcbiAgICB0ZXh0dXJlLnRyaW0ueCA9IC1wYWRkaW5nO1xuICAgIHRleHR1cmUudHJpbS55ID0gLXBhZGRpbmc7XG4gICAgdGV4dHVyZS5vcmlnLndpZHRoID0gdGV4dHVyZS5fZnJhbWUud2lkdGggLSBwYWRkaW5nICogMjtcbiAgICB0ZXh0dXJlLm9yaWcuaGVpZ2h0ID0gdGV4dHVyZS5fZnJhbWUuaGVpZ2h0IC0gcGFkZGluZyAqIDI7XG4gICAgdGhpcy5fb25UZXh0dXJlVXBkYXRlKCk7XG4gICAgYmFzZVRleHR1cmUuc2V0UmVhbFNpemUoaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgcmVzb2x1dGlvbik7XG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICB9XG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICBpZiAodGhpcy5fYXV0b1Jlc29sdXRpb24gJiYgdGhpcy5fcmVzb2x1dGlvbiAhPT0gcmVuZGVyZXIucmVzb2x1dGlvbikge1xuICAgICAgdGhpcy5fcmVzb2x1dGlvbiA9IHJlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIHN1cGVyLl9yZW5kZXIocmVuZGVyZXIpO1xuICB9XG4gIF9yZW5kZXJDYW52YXMocmVuZGVyZXIpIHtcbiAgICBpZiAodGhpcy5fYXV0b1Jlc29sdXRpb24gJiYgdGhpcy5fcmVzb2x1dGlvbiAhPT0gcmVuZGVyZXIucmVzb2x1dGlvbikge1xuICAgICAgdGhpcy5fcmVzb2x1dGlvbiA9IHJlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIHN1cGVyLl9yZW5kZXJDYW52YXMocmVuZGVyZXIpO1xuICB9XG4gIGdldExvY2FsQm91bmRzKHJlY3QpIHtcbiAgICB0aGlzLnVwZGF0ZVRleHQodHJ1ZSk7XG4gICAgcmV0dXJuIHN1cGVyLmdldExvY2FsQm91bmRzKHJlY3QpO1xuICB9XG4gIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKTtcbiAgICB0aGlzLl9ib3VuZHMuYWRkUXVhZCh0aGlzLnZlcnRleERhdGEpO1xuICB9XG4gIF9vblN0eWxlQ2hhbmdlKCkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIG9wdGlvbnMgPSB7IGNoaWxkcmVuOiBvcHRpb25zIH07XG4gICAgfVxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBfSFRNTFRleHQuZGVmYXVsdERlc3Ryb3lPcHRpb25zLCBvcHRpb25zKTtcbiAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xuICAgIGNvbnN0IGZvcmNlQ2xlYXIgPSBudWxsO1xuICAgIGlmICh0aGlzLm93bnNTdHlsZSkge1xuICAgICAgdGhpcy5fc3R5bGU/LmNsZWFuRm9udHMoKTtcbiAgICB9XG4gICAgdGhpcy5fc3R5bGUgPSBmb3JjZUNsZWFyO1xuICAgIHRoaXMuX3N2Z1Jvb3Q/LnJlbW92ZSgpO1xuICAgIHRoaXMuX3N2Z1Jvb3QgPSBmb3JjZUNsZWFyO1xuICAgIHRoaXMuX2RvbUVsZW1lbnQ/LnJlbW92ZSgpO1xuICAgIHRoaXMuX2RvbUVsZW1lbnQgPSBmb3JjZUNsZWFyO1xuICAgIHRoaXMuX2ZvcmVpZ25PYmplY3Q/LnJlbW92ZSgpO1xuICAgIHRoaXMuX2ZvcmVpZ25PYmplY3QgPSBmb3JjZUNsZWFyO1xuICAgIHRoaXMuX3N0eWxlRWxlbWVudD8ucmVtb3ZlKCk7XG4gICAgdGhpcy5fc3R5bGVFbGVtZW50ID0gZm9yY2VDbGVhcjtcbiAgICB0aGlzLl9sb2FkSW1hZ2Uuc3JjID0gXCJcIjtcbiAgICB0aGlzLl9sb2FkSW1hZ2Uub25sb2FkID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkSW1hZ2UgPSBmb3JjZUNsZWFyO1xuICAgIHRoaXMuX2ltYWdlLnNyYyA9IFwiXCI7XG4gICAgdGhpcy5faW1hZ2UgPSBmb3JjZUNsZWFyO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICB0aGlzLnVwZGF0ZVRleHQodHJ1ZSk7XG4gICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuc2NhbGUueCkgKiB0aGlzLl9pbWFnZS53aWR0aCAvIHRoaXMucmVzb2x1dGlvbjtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLnVwZGF0ZVRleHQodHJ1ZSk7XG4gICAgY29uc3QgcyA9IGNvcmUudXRpbHMuc2lnbih0aGlzLnNjYWxlLngpIHx8IDE7XG4gICAgdGhpcy5zY2FsZS54ID0gcyAqIHZhbHVlIC8gdGhpcy5faW1hZ2Uud2lkdGggLyB0aGlzLnJlc29sdXRpb247XG4gICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS55KSAqIHRoaXMuX2ltYWdlLmhlaWdodCAvIHRoaXMucmVzb2x1dGlvbjtcbiAgfVxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIGNvbnN0IHMgPSBjb3JlLnV0aWxzLnNpZ24odGhpcy5zY2FsZS55KSB8fCAxO1xuICAgIHRoaXMuc2NhbGUueSA9IHMgKiB2YWx1ZSAvIHRoaXMuX2ltYWdlLmhlaWdodCAvIHRoaXMucmVzb2x1dGlvbjtcbiAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICBnZXQgc3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICB9XG4gIHNldCBzdHlsZShzdHlsZSkge1xuICAgIGlmICh0aGlzLl9zdHlsZSA9PT0gc3R5bGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3R5bGUgPSBzdHlsZSB8fCB7fTtcbiAgICBpZiAoc3R5bGUgaW5zdGFuY2VvZiBIVE1MVGV4dFN0eWxlLkhUTUxUZXh0U3R5bGUpIHtcbiAgICAgIHRoaXMub3duc1N0eWxlID0gZmFsc2U7XG4gICAgICB0aGlzLl9zdHlsZSA9IHN0eWxlO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUgaW5zdGFuY2VvZiB0ZXh0LlRleHRTdHlsZSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW0hUTUxUZXh0XSBDbG9uaW5nIFRleHRTdHlsZSwgaWYgdGhpcyBpcyBub3Qgd2hhdCB5b3Ugd2FudCwgdXNlIEhUTUxUZXh0U3R5bGVcIik7XG4gICAgICB0aGlzLm93bnNTdHlsZSA9IHRydWU7XG4gICAgICB0aGlzLl9zdHlsZSA9IEhUTUxUZXh0U3R5bGUuSFRNTFRleHRTdHlsZS5mcm9tKHN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vd25zU3R5bGUgPSB0cnVlO1xuICAgICAgdGhpcy5fc3R5bGUgPSBuZXcgSFRNTFRleHRTdHlsZS5IVE1MVGV4dFN0eWxlKHN0eWxlKTtcbiAgICB9XG4gICAgdGhpcy5sb2NhbFN0eWxlSUQgPSAtMTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuICBnZXQgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgfVxuICBzZXQgdGV4dCh0ZXh0KSB7XG4gICAgdGV4dCA9IFN0cmluZyh0ZXh0ID09PSBcIlwiIHx8IHRleHQgPT09IG51bGwgfHwgdGV4dCA9PT0gdm9pZCAwID8gXCIgXCIgOiB0ZXh0KTtcbiAgICB0ZXh0ID0gdGhpcy5zYW5pdGlzZVRleHQodGV4dCk7XG4gICAgaWYgKHRoaXMuX3RleHQgPT09IHRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdGV4dCA9IHRleHQ7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cbiAgZ2V0IHJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdXRpb247XG4gIH1cbiAgc2V0IHJlc29sdXRpb24odmFsdWUpIHtcbiAgICB0aGlzLl9hdXRvUmVzb2x1dGlvbiA9IGZhbHNlO1xuICAgIGlmICh0aGlzLl9yZXNvbHV0aW9uID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9yZXNvbHV0aW9uID0gdmFsdWU7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cbiAgc2FuaXRpc2VUZXh0KHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC88YnI+L2dpLCBcIjxici8+XCIpLnJlcGxhY2UoLzxocj4vZ2ksIFwiPGhyLz5cIikucmVwbGFjZSgvJm5ic3A7L2dpLCBcIiYjMTYwO1wiKTtcbiAgfVxufTtcbmxldCBIVE1MVGV4dCA9IF9IVE1MVGV4dDtcbkhUTUxUZXh0LmRlZmF1bHREZXN0cm95T3B0aW9ucyA9IHtcbiAgdGV4dHVyZTogdHJ1ZSxcbiAgY2hpbGRyZW46IGZhbHNlLFxuICBiYXNlVGV4dHVyZTogdHJ1ZVxufTtcbkhUTUxUZXh0LmRlZmF1bHRNYXhXaWR0aCA9IDIwMjQ7XG5IVE1MVGV4dC5kZWZhdWx0TWF4SGVpZ2h0ID0gMjAyNDtcbkhUTUxUZXh0LmRlZmF1bHRBdXRvUmVzb2x1dGlvbiA9IHRydWU7XG5cbmV4cG9ydHMuSFRNTFRleHQgPSBIVE1MVGV4dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhUTUxUZXh0LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciB0ZXh0ID0gcmVxdWlyZSgnQHBpeGkvdGV4dCcpO1xuXG5jb25zdCBfSFRNTFRleHRTdHlsZSA9IGNsYXNzIGV4dGVuZHMgdGV4dC5UZXh0U3R5bGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuX2ZvbnRzID0gW107XG4gICAgdGhpcy5fb3ZlcnJpZGVzID0gW107XG4gICAgdGhpcy5fc3R5bGVzaGVldCA9IFwiXCI7XG4gICAgdGhpcy5mb250c0RpcnR5ID0gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGZyb20ob3JpZ2luYWxTdHlsZSkge1xuICAgIHJldHVybiBuZXcgX0hUTUxUZXh0U3R5bGUoT2JqZWN0LmtleXMoX0hUTUxUZXh0U3R5bGUuZGVmYXVsdE9wdGlvbnMpLnJlZHVjZSgob2JqLCBwcm9wKSA9PiAoeyAuLi5vYmosIFtwcm9wXTogb3JpZ2luYWxTdHlsZVtwcm9wXSB9KSwge30pKTtcbiAgfVxuICBjbGVhbkZvbnRzKCkge1xuICAgIGlmICh0aGlzLl9mb250cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9mb250cy5mb3JFYWNoKChmb250KSA9PiB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoZm9udC5zcmMpO1xuICAgICAgICBmb250LnJlZnMtLTtcbiAgICAgICAgaWYgKGZvbnQucmVmcyA9PT0gMCkge1xuICAgICAgICAgIGlmIChmb250LmZvbnRGYWNlKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5mb250cy5kZWxldGUoZm9udC5mb250RmFjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBfSFRNTFRleHRTdHlsZS5hdmFpbGFibGVGb250c1tmb250Lm9yaWdpbmFsVXJsXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmZvbnRGYW1pbHkgPSBcIkFyaWFsXCI7XG4gICAgICB0aGlzLl9mb250cy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICB0aGlzLmZvbnRzRGlydHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBsb2FkRm9udCh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXZhaWxhYmxlRm9udHMgfSA9IF9IVE1MVGV4dFN0eWxlO1xuICAgIGlmIChhdmFpbGFibGVGb250c1t1cmxdKSB7XG4gICAgICBjb25zdCBmb250ID0gYXZhaWxhYmxlRm9udHNbdXJsXTtcbiAgICAgIHRoaXMuX2ZvbnRzLnB1c2goZm9udCk7XG4gICAgICBmb250LnJlZnMrKztcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgdGhpcy5mb250c0RpcnR5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcmUuc2V0dGluZ3MuQURBUFRFUi5mZXRjaCh1cmwpLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5ibG9iKCkpLnRoZW4oYXN5bmMgKGJsb2IpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoW3NyYywgcmVhZGVyLnJlc3VsdF0pO1xuICAgICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcbiAgICB9KSkudGhlbihhc3luYyAoW3NyYywgZGF0YVNyY10pID0+IHtcbiAgICAgIGNvbnN0IGZvbnQgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgZmFtaWx5OiBjb3JlLnV0aWxzLnBhdGguYmFzZW5hbWUodXJsLCBjb3JlLnV0aWxzLnBhdGguZXh0bmFtZSh1cmwpKSxcbiAgICAgICAgd2VpZ2h0OiBcIm5vcm1hbFwiLFxuICAgICAgICBzdHlsZTogXCJub3JtYWxcIixcbiAgICAgICAgc3JjLFxuICAgICAgICBkYXRhU3JjLFxuICAgICAgICByZWZzOiAxLFxuICAgICAgICBvcmlnaW5hbFVybDogdXJsLFxuICAgICAgICBmb250RmFjZTogbnVsbFxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICBhdmFpbGFibGVGb250c1t1cmxdID0gZm9udDtcbiAgICAgIHRoaXMuX2ZvbnRzLnB1c2goZm9udCk7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgIGNvbnN0IGZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKGZvbnQuZmFtaWx5LCBgdXJsKCR7Zm9udC5zcmN9KWAsIHtcbiAgICAgICAgd2VpZ2h0OiBmb250LndlaWdodCxcbiAgICAgICAgc3R5bGU6IGZvbnQuc3R5bGVcbiAgICAgIH0pO1xuICAgICAgZm9udC5mb250RmFjZSA9IGZvbnRGYWNlO1xuICAgICAgYXdhaXQgZm9udEZhY2UubG9hZCgpO1xuICAgICAgZG9jdW1lbnQuZm9udHMuYWRkKGZvbnRGYWNlKTtcbiAgICAgIGF3YWl0IGRvY3VtZW50LmZvbnRzLnJlYWR5O1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICB0aGlzLmZvbnRzRGlydHkgPSB0cnVlO1xuICAgIH0pO1xuICB9XG4gIGFkZE92ZXJyaWRlKC4uLnZhbHVlKSB7XG4gICAgY29uc3QgdG9BZGQgPSB2YWx1ZS5maWx0ZXIoKHYpID0+ICF0aGlzLl9vdmVycmlkZXMuaW5jbHVkZXModikpO1xuICAgIGlmICh0b0FkZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9vdmVycmlkZXMucHVzaCguLi50b0FkZCk7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgcmVtb3ZlT3ZlcnJpZGUoLi4udmFsdWUpIHtcbiAgICBjb25zdCB0b1JlbW92ZSA9IHZhbHVlLmZpbHRlcigodikgPT4gdGhpcy5fb3ZlcnJpZGVzLmluY2x1ZGVzKHYpKTtcbiAgICBpZiAodG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fb3ZlcnJpZGVzID0gdGhpcy5fb3ZlcnJpZGVzLmZpbHRlcigodikgPT4gIXRvUmVtb3ZlLmluY2x1ZGVzKHYpKTtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICB0b0NTUyhzY2FsZSkge1xuICAgIHJldHVybiBbXG4gICAgICBgdHJhbnNmb3JtOiBzY2FsZSgke3NjYWxlfSlgLFxuICAgICAgYHRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0YCxcbiAgICAgIFwiZGlzcGxheTogaW5saW5lLWJsb2NrXCIsXG4gICAgICBgY29sb3I6ICR7dGhpcy5ub3JtYWxpemVDb2xvcih0aGlzLmZpbGwpfWAsXG4gICAgICBgZm9udC1zaXplOiAke3RoaXMuZm9udFNpemV9cHhgLFxuICAgICAgYGZvbnQtZmFtaWx5OiAke3RoaXMuZm9udEZhbWlseX1gLFxuICAgICAgYGZvbnQtd2VpZ2h0OiAke3RoaXMuZm9udFdlaWdodH1gLFxuICAgICAgYGZvbnQtc3R5bGU6ICR7dGhpcy5mb250U3R5bGV9YCxcbiAgICAgIGBmb250LXZhcmlhbnQ6ICR7dGhpcy5mb250VmFyaWFudH1gLFxuICAgICAgYGxldHRlci1zcGFjaW5nOiAke3RoaXMubGV0dGVyU3BhY2luZ31weGAsXG4gICAgICBgdGV4dC1hbGlnbjogJHt0aGlzLmFsaWdufWAsXG4gICAgICBgcGFkZGluZzogJHt0aGlzLnBhZGRpbmd9cHhgLFxuICAgICAgYHdoaXRlLXNwYWNlOiAke3RoaXMud2hpdGVTcGFjZX1gLFxuICAgICAgLi4udGhpcy5saW5lSGVpZ2h0ID8gW2BsaW5lLWhlaWdodDogJHt0aGlzLmxpbmVIZWlnaHR9cHhgXSA6IFtdLFxuICAgICAgLi4udGhpcy53b3JkV3JhcCA/IFtcbiAgICAgICAgYHdvcmQtd3JhcDogJHt0aGlzLmJyZWFrV29yZHMgPyBcImJyZWFrLWFsbFwiIDogXCJicmVhay13b3JkXCJ9YCxcbiAgICAgICAgYG1heC13aWR0aDogJHt0aGlzLndvcmRXcmFwV2lkdGh9cHhgXG4gICAgICBdIDogW10sXG4gICAgICAuLi50aGlzLnN0cm9rZVRoaWNrbmVzcyA/IFtcbiAgICAgICAgYC13ZWJraXQtdGV4dC1zdHJva2Utd2lkdGg6ICR7dGhpcy5zdHJva2VUaGlja25lc3N9cHhgLFxuICAgICAgICBgLXdlYmtpdC10ZXh0LXN0cm9rZS1jb2xvcjogJHt0aGlzLm5vcm1hbGl6ZUNvbG9yKHRoaXMuc3Ryb2tlKX1gLFxuICAgICAgICBgdGV4dC1zdHJva2Utd2lkdGg6ICR7dGhpcy5zdHJva2VUaGlja25lc3N9cHhgLFxuICAgICAgICBgdGV4dC1zdHJva2UtY29sb3I6ICR7dGhpcy5ub3JtYWxpemVDb2xvcih0aGlzLnN0cm9rZSl9YCxcbiAgICAgICAgXCJwYWludC1vcmRlcjogc3Ryb2tlXCJcbiAgICAgIF0gOiBbXSxcbiAgICAgIC4uLnRoaXMuZHJvcFNoYWRvdyA/IFt0aGlzLmRyb3BTaGFkb3dUb0NTUygpXSA6IFtdLFxuICAgICAgLi4udGhpcy5fb3ZlcnJpZGVzXG4gICAgXS5qb2luKFwiO1wiKTtcbiAgfVxuICB0b0dsb2JhbENTUygpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udHMucmVkdWNlKChyZXN1bHQsIGZvbnQpID0+IGAke3Jlc3VsdH1cbiAgICAgICAgICAgIEBmb250LWZhY2Uge1xuICAgICAgICAgICAgICAgIGZvbnQtZmFtaWx5OiBcIiR7Zm9udC5mYW1pbHl9XCI7XG4gICAgICAgICAgICAgICAgc3JjOiB1cmwoJyR7Zm9udC5kYXRhU3JjfScpO1xuICAgICAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiAke2ZvbnQud2VpZ2h0fTtcbiAgICAgICAgICAgICAgICBmb250LXN0eWxlOiAke2ZvbnQuc3R5bGV9OyBcbiAgICAgICAgICAgIH1gLCB0aGlzLl9zdHlsZXNoZWV0KTtcbiAgfVxuICBnZXQgc3R5bGVzaGVldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGVzaGVldDtcbiAgfVxuICBzZXQgc3R5bGVzaGVldCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9zdHlsZXNoZWV0ICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fc3R5bGVzaGVldCA9IHZhbHVlO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIG5vcm1hbGl6ZUNvbG9yKGNvbG9yKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgICBjb2xvciA9IGNvcmUudXRpbHMucmdiMmhleChjb2xvcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29sb3IgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBjb3JlLnV0aWxzLmhleDJzdHJpbmcoY29sb3IpO1xuICAgIH1cbiAgICByZXR1cm4gY29sb3I7XG4gIH1cbiAgZHJvcFNoYWRvd1RvQ1NTKCkge1xuICAgIGxldCBjb2xvciA9IHRoaXMubm9ybWFsaXplQ29sb3IodGhpcy5kcm9wU2hhZG93Q29sb3IpO1xuICAgIGNvbnN0IGFscGhhID0gdGhpcy5kcm9wU2hhZG93QWxwaGE7XG4gICAgY29uc3QgeCA9IE1hdGgucm91bmQoTWF0aC5jb3ModGhpcy5kcm9wU2hhZG93QW5nbGUpICogdGhpcy5kcm9wU2hhZG93RGlzdGFuY2UpO1xuICAgIGNvbnN0IHkgPSBNYXRoLnJvdW5kKE1hdGguc2luKHRoaXMuZHJvcFNoYWRvd0FuZ2xlKSAqIHRoaXMuZHJvcFNoYWRvd0Rpc3RhbmNlKTtcbiAgICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcIiNcIikgJiYgYWxwaGEgPCAxKSB7XG4gICAgICBjb2xvciArPSAoYWxwaGEgKiAyNTUgfCAwKS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xuICAgIH1cbiAgICBjb25zdCBwb3NpdGlvbiA9IGAke3h9cHggJHt5fXB4YDtcbiAgICBpZiAodGhpcy5kcm9wU2hhZG93Qmx1ciA+IDApIHtcbiAgICAgIHJldHVybiBgdGV4dC1zaGFkb3c6ICR7cG9zaXRpb259ICR7dGhpcy5kcm9wU2hhZG93Qmx1cn1weCAke2NvbG9yfWA7XG4gICAgfVxuICAgIHJldHVybiBgdGV4dC1zaGFkb3c6ICR7cG9zaXRpb259ICR7Y29sb3J9YDtcbiAgfVxuICByZXNldCgpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIF9IVE1MVGV4dFN0eWxlLmRlZmF1bHRPcHRpb25zKTtcbiAgfVxuICBvbkJlZm9yZURyYXcoKSB7XG4gICAgY29uc3QgeyBmb250c0RpcnR5OiBwcmV2Rm9udHNEaXJ0eSB9ID0gdGhpcztcbiAgICB0aGlzLmZvbnRzRGlydHkgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5pc1NhZmFyaSAmJiB0aGlzLl9mb250cy5sZW5ndGggPiAwICYmIHByZXZGb250c0RpcnR5KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBnZXQgaXNTYWZhcmkoKSB7XG4gICAgY29uc3QgeyB1c2VyQWdlbnQgfSA9IGNvcmUuc2V0dGluZ3MuQURBUFRFUi5nZXROYXZpZ2F0b3IoKTtcbiAgICByZXR1cm4gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdCh1c2VyQWdlbnQpO1xuICB9XG4gIHNldCBmaWxsR3JhZGllbnRTdG9wcyhfdmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbSFRNTFRleHRTdHlsZV0gZmlsbEdyYWRpZW50U3RvcHMgaXMgbm90IHN1cHBvcnRlZCBieSBIVE1MVGV4dFwiKTtcbiAgfVxuICBnZXQgZmlsbEdyYWRpZW50U3RvcHMoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmZpbGxHcmFkaWVudFN0b3BzO1xuICB9XG4gIHNldCBmaWxsR3JhZGllbnRUeXBlKF92YWx1ZSkge1xuICAgIGNvbnNvbGUud2FybihcIltIVE1MVGV4dFN0eWxlXSBmaWxsR3JhZGllbnRUeXBlIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSFRNTFRleHRcIik7XG4gIH1cbiAgZ2V0IGZpbGxHcmFkaWVudFR5cGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmZpbGxHcmFkaWVudFR5cGU7XG4gIH1cbiAgc2V0IG1pdGVyTGltaXQoX3ZhbHVlKSB7XG4gICAgY29uc29sZS53YXJuKFwiW0hUTUxUZXh0U3R5bGVdIG1pdGVyTGltaXQgaXMgbm90IHN1cHBvcnRlZCBieSBIVE1MVGV4dFwiKTtcbiAgfVxuICBnZXQgbWl0ZXJMaW1pdCgpIHtcbiAgICByZXR1cm4gc3VwZXIubWl0ZXJMaW1pdDtcbiAgfVxuICBzZXQgdHJpbShfdmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbSFRNTFRleHRTdHlsZV0gdHJpbSBpcyBub3Qgc3VwcG9ydGVkIGJ5IEhUTUxUZXh0XCIpO1xuICB9XG4gIGdldCB0cmltKCkge1xuICAgIHJldHVybiBzdXBlci50cmltO1xuICB9XG4gIHNldCB0ZXh0QmFzZWxpbmUoX3ZhbHVlKSB7XG4gICAgY29uc29sZS53YXJuKFwiW0hUTUxUZXh0U3R5bGVdIHRleHRCYXNlbGluZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IEhUTUxUZXh0XCIpO1xuICB9XG4gIGdldCB0ZXh0QmFzZWxpbmUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRleHRCYXNlbGluZTtcbiAgfVxuICBzZXQgbGVhZGluZyhfdmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbSFRNTFRleHRTdHlsZV0gbGVhZGluZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IEhUTUxUZXh0XCIpO1xuICB9XG4gIGdldCBsZWFkaW5nKCkge1xuICAgIHJldHVybiBzdXBlci5sZWFkaW5nO1xuICB9XG4gIHNldCBsaW5lSm9pbihfdmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbSFRNTFRleHRTdHlsZV0gbGluZUpvaW4gaXMgbm90IHN1cHBvcnRlZCBieSBIVE1MVGV4dFwiKTtcbiAgfVxuICBnZXQgbGluZUpvaW4oKSB7XG4gICAgcmV0dXJuIHN1cGVyLmxpbmVKb2luO1xuICB9XG59O1xubGV0IEhUTUxUZXh0U3R5bGUgPSBfSFRNTFRleHRTdHlsZTtcbkhUTUxUZXh0U3R5bGUuYXZhaWxhYmxlRm9udHMgPSB7fTtcbkhUTUxUZXh0U3R5bGUuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGFsaWduOiBcImxlZnRcIixcbiAgYnJlYWtXb3JkczogZmFsc2UsXG4gIGRyb3BTaGFkb3c6IGZhbHNlLFxuICBkcm9wU2hhZG93QWxwaGE6IDEsXG4gIGRyb3BTaGFkb3dBbmdsZTogTWF0aC5QSSAvIDYsXG4gIGRyb3BTaGFkb3dCbHVyOiAwLFxuICBkcm9wU2hhZG93Q29sb3I6IFwiYmxhY2tcIixcbiAgZHJvcFNoYWRvd0Rpc3RhbmNlOiA1LFxuICBmaWxsOiBcImJsYWNrXCIsXG4gIGZvbnRGYW1pbHk6IFwiQXJpYWxcIixcbiAgZm9udFNpemU6IDI2LFxuICBmb250U3R5bGU6IFwibm9ybWFsXCIsXG4gIGZvbnRWYXJpYW50OiBcIm5vcm1hbFwiLFxuICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiLFxuICBsZXR0ZXJTcGFjaW5nOiAwLFxuICBsaW5lSGVpZ2h0OiAwLFxuICBwYWRkaW5nOiAwLFxuICBzdHJva2U6IFwiYmxhY2tcIixcbiAgc3Ryb2tlVGhpY2tuZXNzOiAwLFxuICB3aGl0ZVNwYWNlOiBcIm5vcm1hbFwiLFxuICB3b3JkV3JhcDogZmFsc2UsXG4gIHdvcmRXcmFwV2lkdGg6IDEwMFxufTtcblxuZXhwb3J0cy5IVE1MVGV4dFN0eWxlID0gSFRNTFRleHRTdHlsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhUTUxUZXh0U3R5bGUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBIVE1MVGV4dCA9IHJlcXVpcmUoJy4vSFRNTFRleHQuanMnKTtcbnZhciBIVE1MVGV4dFN0eWxlID0gcmVxdWlyZSgnLi9IVE1MVGV4dFN0eWxlLmpzJyk7XG5cblxuXG5leHBvcnRzLkhUTUxUZXh0ID0gSFRNTFRleHQuSFRNTFRleHQ7XG5leHBvcnRzLkhUTUxUZXh0U3R5bGUgPSBIVE1MVGV4dFN0eWxlLkhUTUxUZXh0U3R5bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG52YXIgc3ByaXRlID0gcmVxdWlyZSgnQHBpeGkvc3ByaXRlJyk7XG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi9jb25zdC5qcycpO1xudmFyIFRleHRNZXRyaWNzID0gcmVxdWlyZSgnLi9UZXh0TWV0cmljcy5qcycpO1xudmFyIFRleHRTdHlsZSA9IHJlcXVpcmUoJy4vVGV4dFN0eWxlLmpzJyk7XG5cbmNvbnN0IGRlZmF1bHREZXN0cm95T3B0aW9ucyA9IHtcbiAgdGV4dHVyZTogdHJ1ZSxcbiAgY2hpbGRyZW46IGZhbHNlLFxuICBiYXNlVGV4dHVyZTogdHJ1ZVxufTtcbmNvbnN0IF9UZXh0ID0gY2xhc3MgZXh0ZW5kcyBzcHJpdGUuU3ByaXRlIHtcbiAgY29uc3RydWN0b3IodGV4dCwgc3R5bGUsIGNhbnZhcykge1xuICAgIGxldCBvd25DYW52YXMgPSBmYWxzZTtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgY2FudmFzID0gY29yZS5zZXR0aW5ncy5BREFQVEVSLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgb3duQ2FudmFzID0gdHJ1ZTtcbiAgICB9XG4gICAgY2FudmFzLndpZHRoID0gMztcbiAgICBjYW52YXMuaGVpZ2h0ID0gMztcbiAgICBjb25zdCB0ZXh0dXJlID0gY29yZS5UZXh0dXJlLmZyb20oY2FudmFzKTtcbiAgICB0ZXh0dXJlLm9yaWcgPSBuZXcgY29yZS5SZWN0YW5nbGUoKTtcbiAgICB0ZXh0dXJlLnRyaW0gPSBuZXcgY29yZS5SZWN0YW5nbGUoKTtcbiAgICBzdXBlcih0ZXh0dXJlKTtcbiAgICB0aGlzLl9vd25DYW52YXMgPSBvd25DYW52YXM7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLl9yZXNvbHV0aW9uID0gX1RleHQuZGVmYXVsdFJlc29sdXRpb24gPz8gY29yZS5zZXR0aW5ncy5SRVNPTFVUSU9OO1xuICAgIHRoaXMuX2F1dG9SZXNvbHV0aW9uID0gX1RleHQuZGVmYXVsdEF1dG9SZXNvbHV0aW9uO1xuICAgIHRoaXMuX3RleHQgPSBudWxsO1xuICAgIHRoaXMuX3N0eWxlID0gbnVsbDtcbiAgICB0aGlzLl9zdHlsZUxpc3RlbmVyID0gbnVsbDtcbiAgICB0aGlzLl9mb250ID0gXCJcIjtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLmxvY2FsU3R5bGVJRCA9IC0xO1xuICB9XG4gIHN0YXRpYyBnZXQgZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZygpIHtcbiAgICByZXR1cm4gVGV4dE1ldHJpY3MuVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZztcbiAgfVxuICBzdGF0aWMgc2V0IGV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcodmFsdWUpIHtcbiAgICBjb3JlLnV0aWxzLmRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJUZXh0LmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgaXMgZGVwcmVjYXRlZCwgdXNlIFRleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdcIik7XG4gICAgVGV4dE1ldHJpY3MuVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZyA9IHZhbHVlO1xuICB9XG4gIHVwZGF0ZVRleHQocmVzcGVjdERpcnR5KSB7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLl9zdHlsZTtcbiAgICBpZiAodGhpcy5sb2NhbFN0eWxlSUQgIT09IHN0eWxlLnN0eWxlSUQpIHtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgdGhpcy5sb2NhbFN0eWxlSUQgPSBzdHlsZS5zdHlsZUlEO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZGlydHkgJiYgcmVzcGVjdERpcnR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2ZvbnQgPSB0aGlzLl9zdHlsZS50b0ZvbnRTdHJpbmcoKTtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IG1lYXN1cmVkID0gVGV4dE1ldHJpY3MuVGV4dE1ldHJpY3MubWVhc3VyZVRleHQodGhpcy5fdGV4dCB8fCBcIiBcIiwgdGhpcy5fc3R5bGUsIHRoaXMuX3N0eWxlLndvcmRXcmFwLCB0aGlzLmNhbnZhcyk7XG4gICAgY29uc3Qgd2lkdGggPSBtZWFzdXJlZC53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBtZWFzdXJlZC5oZWlnaHQ7XG4gICAgY29uc3QgbGluZXMgPSBtZWFzdXJlZC5saW5lcztcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gbWVhc3VyZWQubGluZUhlaWdodDtcbiAgICBjb25zdCBsaW5lV2lkdGhzID0gbWVhc3VyZWQubGluZVdpZHRocztcbiAgICBjb25zdCBtYXhMaW5lV2lkdGggPSBtZWFzdXJlZC5tYXhMaW5lV2lkdGg7XG4gICAgY29uc3QgZm9udFByb3BlcnRpZXMgPSBtZWFzdXJlZC5mb250UHJvcGVydGllcztcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IE1hdGguY2VpbChNYXRoLmNlaWwoTWF0aC5tYXgoMSwgd2lkdGgpICsgc3R5bGUucGFkZGluZyAqIDIpICogdGhpcy5fcmVzb2x1dGlvbik7XG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGguY2VpbChNYXRoLm1heCgxLCBoZWlnaHQpICsgc3R5bGUucGFkZGluZyAqIDIpICogdGhpcy5fcmVzb2x1dGlvbik7XG4gICAgY29udGV4dC5zY2FsZSh0aGlzLl9yZXNvbHV0aW9uLCB0aGlzLl9yZXNvbHV0aW9uKTtcbiAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICBjb250ZXh0LmZvbnQgPSB0aGlzLl9mb250O1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xuICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lO1xuICAgIGNvbnRleHQubGluZUpvaW4gPSBzdHlsZS5saW5lSm9pbjtcbiAgICBjb250ZXh0Lm1pdGVyTGltaXQgPSBzdHlsZS5taXRlckxpbWl0O1xuICAgIGxldCBsaW5lUG9zaXRpb25YO1xuICAgIGxldCBsaW5lUG9zaXRpb25ZO1xuICAgIGNvbnN0IHBhc3Nlc0NvdW50ID0gc3R5bGUuZHJvcFNoYWRvdyA/IDIgOiAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFzc2VzQ291bnQ7ICsraSkge1xuICAgICAgY29uc3QgaXNTaGFkb3dQYXNzID0gc3R5bGUuZHJvcFNoYWRvdyAmJiBpID09PSAwO1xuICAgICAgY29uc3QgZHNPZmZzZXRUZXh0ID0gaXNTaGFkb3dQYXNzID8gTWF0aC5jZWlsKE1hdGgubWF4KDEsIGhlaWdodCkgKyBzdHlsZS5wYWRkaW5nICogMikgOiAwO1xuICAgICAgY29uc3QgZHNPZmZzZXRTaGFkb3cgPSBkc09mZnNldFRleHQgKiB0aGlzLl9yZXNvbHV0aW9uO1xuICAgICAgaWYgKGlzU2hhZG93UGFzcykge1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgY29uc3QgZHJvcFNoYWRvd0NvbG9yID0gc3R5bGUuZHJvcFNoYWRvd0NvbG9yO1xuICAgICAgICBjb25zdCBkcm9wU2hhZG93Qmx1ciA9IHN0eWxlLmRyb3BTaGFkb3dCbHVyICogdGhpcy5fcmVzb2x1dGlvbjtcbiAgICAgICAgY29uc3QgZHJvcFNoYWRvd0Rpc3RhbmNlID0gc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlICogdGhpcy5fcmVzb2x1dGlvbjtcbiAgICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IGNvcmUuQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGRyb3BTaGFkb3dDb2xvcikuc2V0QWxwaGEoc3R5bGUuZHJvcFNoYWRvd0FscGhhKS50b1JnYmFTdHJpbmcoKTtcbiAgICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gZHJvcFNoYWRvd0JsdXI7XG4gICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IE1hdGguY29zKHN0eWxlLmRyb3BTaGFkb3dBbmdsZSkgKiBkcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IE1hdGguc2luKHN0eWxlLmRyb3BTaGFkb3dBbmdsZSkgKiBkcm9wU2hhZG93RGlzdGFuY2UgKyBkc09mZnNldFNoYWRvdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5fZ2VuZXJhdGVGaWxsU3R5bGUoc3R5bGUsIGxpbmVzLCBtZWFzdXJlZCk7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzdHlsZS5zdHJva2U7XG4gICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBcImJsYWNrXCI7XG4gICAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IDA7XG4gICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICB9XG4gICAgICBsZXQgbGluZVBvc2l0aW9uWVNoaWZ0ID0gKGxpbmVIZWlnaHQgLSBmb250UHJvcGVydGllcy5mb250U2l6ZSkgLyAyO1xuICAgICAgaWYgKGxpbmVIZWlnaHQgLSBmb250UHJvcGVydGllcy5mb250U2l6ZSA8IDApIHtcbiAgICAgICAgbGluZVBvc2l0aW9uWVNoaWZ0ID0gMDtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBsaW5lcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgbGluZVBvc2l0aW9uWCA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcyAvIDI7XG4gICAgICAgIGxpbmVQb3NpdGlvblkgPSBzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyICsgaTIgKiBsaW5lSGVpZ2h0ICsgZm9udFByb3BlcnRpZXMuYXNjZW50ICsgbGluZVBvc2l0aW9uWVNoaWZ0O1xuICAgICAgICBpZiAoc3R5bGUuYWxpZ24gPT09IFwicmlnaHRcIikge1xuICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpMl07XG4gICAgICAgIH0gZWxzZSBpZiAoc3R5bGUuYWxpZ24gPT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgICBsaW5lUG9zaXRpb25YICs9IChtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2kyXSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZS5zdHJva2UgJiYgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzKSB7XG4gICAgICAgICAgdGhpcy5kcmF3TGV0dGVyU3BhY2luZyhsaW5lc1tpMl0sIGxpbmVQb3NpdGlvblggKyBzdHlsZS5wYWRkaW5nLCBsaW5lUG9zaXRpb25ZICsgc3R5bGUucGFkZGluZyAtIGRzT2Zmc2V0VGV4dCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlLmZpbGwpIHtcbiAgICAgICAgICB0aGlzLmRyYXdMZXR0ZXJTcGFjaW5nKGxpbmVzW2kyXSwgbGluZVBvc2l0aW9uWCArIHN0eWxlLnBhZGRpbmcsIGxpbmVQb3NpdGlvblkgKyBzdHlsZS5wYWRkaW5nIC0gZHNPZmZzZXRUZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVRleHR1cmUoKTtcbiAgfVxuICBkcmF3TGV0dGVyU3BhY2luZyh0ZXh0LCB4LCB5LCBpc1N0cm9rZSA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLl9zdHlsZTtcbiAgICBjb25zdCBsZXR0ZXJTcGFjaW5nID0gc3R5bGUubGV0dGVyU3BhY2luZztcbiAgICBsZXQgdXNlRXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZyA9IGZhbHNlO1xuICAgIGlmIChUZXh0TWV0cmljcy5UZXh0TWV0cmljcy5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nU3VwcG9ydGVkKSB7XG4gICAgICBpZiAoVGV4dE1ldHJpY3MuVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZykge1xuICAgICAgICB0aGlzLmNvbnRleHQubGV0dGVyU3BhY2luZyA9IGAke2xldHRlclNwYWNpbmd9cHhgO1xuICAgICAgICB0aGlzLmNvbnRleHQudGV4dExldHRlclNwYWNpbmcgPSBgJHtsZXR0ZXJTcGFjaW5nfXB4YDtcbiAgICAgICAgdXNlRXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnRleHQubGV0dGVyU3BhY2luZyA9IFwiMHB4XCI7XG4gICAgICAgIHRoaXMuY29udGV4dC50ZXh0TGV0dGVyU3BhY2luZyA9IFwiMHB4XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZXR0ZXJTcGFjaW5nID09PSAwIHx8IHVzZUV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcpIHtcbiAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICB0aGlzLmNvbnRleHQuc3Ryb2tlVGV4dCh0ZXh0LCB4LCB5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5maWxsVGV4dCh0ZXh0LCB4LCB5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRQb3NpdGlvbiA9IHg7XG4gICAgY29uc3Qgc3RyaW5nQXJyYXkgPSBUZXh0TWV0cmljcy5UZXh0TWV0cmljcy5ncmFwaGVtZVNlZ21lbnRlcih0ZXh0KTtcbiAgICBsZXQgcHJldmlvdXNXaWR0aCA9IHRoaXMuY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcbiAgICBsZXQgY3VycmVudFdpZHRoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ0FycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBjdXJyZW50Q2hhciA9IHN0cmluZ0FycmF5W2ldO1xuICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5zdHJva2VUZXh0KGN1cnJlbnRDaGFyLCBjdXJyZW50UG9zaXRpb24sIHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxUZXh0KGN1cnJlbnRDaGFyLCBjdXJyZW50UG9zaXRpb24sIHkpO1xuICAgICAgfVxuICAgICAgbGV0IHRleHRTdHIgPSBcIlwiO1xuICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgc3RyaW5nQXJyYXkubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdGV4dFN0ciArPSBzdHJpbmdBcnJheVtqXTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRXaWR0aCA9IHRoaXMuY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0U3RyKS53aWR0aDtcbiAgICAgIGN1cnJlbnRQb3NpdGlvbiArPSBwcmV2aW91c1dpZHRoIC0gY3VycmVudFdpZHRoICsgbGV0dGVyU3BhY2luZztcbiAgICAgIHByZXZpb3VzV2lkdGggPSBjdXJyZW50V2lkdGg7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVRleHR1cmUoKSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgaWYgKHRoaXMuX3N0eWxlLnRyaW0pIHtcbiAgICAgIGNvbnN0IHRyaW1tZWQgPSBjb3JlLnV0aWxzLnRyaW1DYW52YXMoY2FudmFzKTtcbiAgICAgIGlmICh0cmltbWVkLmRhdGEpIHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gdHJpbW1lZC53aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRyaW1tZWQuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNvbnRleHQucHV0SW1hZ2VEYXRhKHRyaW1tZWQuZGF0YSwgMCwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlO1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5fc3R5bGU7XG4gICAgY29uc3QgcGFkZGluZyA9IHN0eWxlLnRyaW0gPyAwIDogc3R5bGUucGFkZGluZztcbiAgICBjb25zdCBiYXNlVGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgdGV4dHVyZS50cmltLndpZHRoID0gdGV4dHVyZS5fZnJhbWUud2lkdGggPSBjYW52YXMud2lkdGggLyB0aGlzLl9yZXNvbHV0aW9uO1xuICAgIHRleHR1cmUudHJpbS5oZWlnaHQgPSB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0IC8gdGhpcy5fcmVzb2x1dGlvbjtcbiAgICB0ZXh0dXJlLnRyaW0ueCA9IC1wYWRkaW5nO1xuICAgIHRleHR1cmUudHJpbS55ID0gLXBhZGRpbmc7XG4gICAgdGV4dHVyZS5vcmlnLndpZHRoID0gdGV4dHVyZS5fZnJhbWUud2lkdGggLSBwYWRkaW5nICogMjtcbiAgICB0ZXh0dXJlLm9yaWcuaGVpZ2h0ID0gdGV4dHVyZS5fZnJhbWUuaGVpZ2h0IC0gcGFkZGluZyAqIDI7XG4gICAgdGhpcy5fb25UZXh0dXJlVXBkYXRlKCk7XG4gICAgYmFzZVRleHR1cmUuc2V0UmVhbFNpemUoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0LCB0aGlzLl9yZXNvbHV0aW9uKTtcbiAgICB0ZXh0dXJlLnVwZGF0ZVV2cygpO1xuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgfVxuICBfcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgaWYgKHRoaXMuX2F1dG9SZXNvbHV0aW9uICYmIHRoaXMuX3Jlc29sdXRpb24gIT09IHJlbmRlcmVyLnJlc29sdXRpb24pIHtcbiAgICAgIHRoaXMuX3Jlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICBzdXBlci5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxuICB1cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIHN1cGVyLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICB9XG4gIGdldEJvdW5kcyhza2lwVXBkYXRlLCByZWN0KSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIGlmICh0aGlzLl90ZXh0dXJlSUQgPT09IC0xKSB7XG4gICAgICBza2lwVXBkYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5nZXRCb3VuZHMoc2tpcFVwZGF0ZSwgcmVjdCk7XG4gIH1cbiAgZ2V0TG9jYWxCb3VuZHMocmVjdCkge1xuICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0TG9jYWxCb3VuZHMuY2FsbCh0aGlzLCByZWN0KTtcbiAgfVxuICBfY2FsY3VsYXRlQm91bmRzKCkge1xuICAgIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKTtcbiAgICB0aGlzLl9ib3VuZHMuYWRkUXVhZCh0aGlzLnZlcnRleERhdGEpO1xuICB9XG4gIF9nZW5lcmF0ZUZpbGxTdHlsZShzdHlsZSwgbGluZXMsIG1ldHJpY3MpIHtcbiAgICBjb25zdCBmaWxsU3R5bGUgPSBzdHlsZS5maWxsO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShmaWxsU3R5bGUpKSB7XG4gICAgICByZXR1cm4gZmlsbFN0eWxlO1xuICAgIH0gZWxzZSBpZiAoZmlsbFN0eWxlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGZpbGxTdHlsZVswXTtcbiAgICB9XG4gICAgbGV0IGdyYWRpZW50O1xuICAgIGNvbnN0IGRyb3BTaGFkb3dDb3JyZWN0aW9uID0gc3R5bGUuZHJvcFNoYWRvdyA/IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZSA6IDA7XG4gICAgY29uc3QgcGFkZGluZyA9IHN0eWxlLnBhZGRpbmcgfHwgMDtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoIC8gdGhpcy5fcmVzb2x1dGlvbiAtIGRyb3BTaGFkb3dDb3JyZWN0aW9uIC0gcGFkZGluZyAqIDI7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0IC8gdGhpcy5fcmVzb2x1dGlvbiAtIGRyb3BTaGFkb3dDb3JyZWN0aW9uIC0gcGFkZGluZyAqIDI7XG4gICAgY29uc3QgZmlsbCA9IGZpbGxTdHlsZS5zbGljZSgpO1xuICAgIGNvbnN0IGZpbGxHcmFkaWVudFN0b3BzID0gc3R5bGUuZmlsbEdyYWRpZW50U3RvcHMuc2xpY2UoKTtcbiAgICBpZiAoIWZpbGxHcmFkaWVudFN0b3BzLmxlbmd0aCkge1xuICAgICAgY29uc3QgbGVuZ3RoUGx1czEgPSBmaWxsLmxlbmd0aCArIDE7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aFBsdXMxOyArK2kpIHtcbiAgICAgICAgZmlsbEdyYWRpZW50U3RvcHMucHVzaChpIC8gbGVuZ3RoUGx1czEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmaWxsLnVuc2hpZnQoZmlsbFN0eWxlWzBdKTtcbiAgICBmaWxsR3JhZGllbnRTdG9wcy51bnNoaWZ0KDApO1xuICAgIGZpbGwucHVzaChmaWxsU3R5bGVbZmlsbFN0eWxlLmxlbmd0aCAtIDFdKTtcbiAgICBmaWxsR3JhZGllbnRTdG9wcy5wdXNoKDEpO1xuICAgIGlmIChzdHlsZS5maWxsR3JhZGllbnRUeXBlID09PSBfY29uc3QuVEVYVF9HUkFESUVOVC5MSU5FQVJfVkVSVElDQUwpIHtcbiAgICAgIGdyYWRpZW50ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KHdpZHRoIC8gMiwgcGFkZGluZywgd2lkdGggLyAyLCBoZWlnaHQgKyBwYWRkaW5nKTtcbiAgICAgIGNvbnN0IHRleHRIZWlnaHQgPSBtZXRyaWNzLmZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplICsgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBsYXN0TGluZUJvdHRvbSA9IG1ldHJpY3MubGluZUhlaWdodCAqIChpIC0gMSkgKyB0ZXh0SGVpZ2h0O1xuICAgICAgICBjb25zdCB0aGlzTGluZVRvcCA9IG1ldHJpY3MubGluZUhlaWdodCAqIGk7XG4gICAgICAgIGxldCB0aGlzTGluZUdyYWRpZW50U3RhcnQgPSB0aGlzTGluZVRvcDtcbiAgICAgICAgaWYgKGkgPiAwICYmIGxhc3RMaW5lQm90dG9tID4gdGhpc0xpbmVUb3ApIHtcbiAgICAgICAgICB0aGlzTGluZUdyYWRpZW50U3RhcnQgPSAodGhpc0xpbmVUb3AgKyBsYXN0TGluZUJvdHRvbSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRoaXNMaW5lQm90dG9tID0gdGhpc0xpbmVUb3AgKyB0ZXh0SGVpZ2h0O1xuICAgICAgICBjb25zdCBuZXh0TGluZVRvcCA9IG1ldHJpY3MubGluZUhlaWdodCAqIChpICsgMSk7XG4gICAgICAgIGxldCB0aGlzTGluZUdyYWRpZW50RW5kID0gdGhpc0xpbmVCb3R0b207XG4gICAgICAgIGlmIChpICsgMSA8IGxpbmVzLmxlbmd0aCAmJiBuZXh0TGluZVRvcCA8IHRoaXNMaW5lQm90dG9tKSB7XG4gICAgICAgICAgdGhpc0xpbmVHcmFkaWVudEVuZCA9ICh0aGlzTGluZUJvdHRvbSArIG5leHRMaW5lVG9wKSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ3JhZFN0b3BMaW5lSGVpZ2h0ID0gKHRoaXNMaW5lR3JhZGllbnRFbmQgLSB0aGlzTGluZUdyYWRpZW50U3RhcnQpIC8gaGVpZ2h0O1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZpbGwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBsZXQgbGluZVN0b3AgPSAwO1xuICAgICAgICAgIGlmICh0eXBlb2YgZmlsbEdyYWRpZW50U3RvcHNbal0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGxpbmVTdG9wID0gZmlsbEdyYWRpZW50U3RvcHNbal07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmVTdG9wID0gaiAvIGZpbGwubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgZ2xvYmFsU3RvcCA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIHRoaXNMaW5lR3JhZGllbnRTdGFydCAvIGhlaWdodCArIGxpbmVTdG9wICogZ3JhZFN0b3BMaW5lSGVpZ2h0KSk7XG4gICAgICAgICAgZ2xvYmFsU3RvcCA9IE51bWJlcihnbG9iYWxTdG9wLnRvRml4ZWQoNSkpO1xuICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChnbG9iYWxTdG9wLCBmaWxsW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBncmFkaWVudCA9IHRoaXMuY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChwYWRkaW5nLCBoZWlnaHQgLyAyLCB3aWR0aCArIHBhZGRpbmcsIGhlaWdodCAvIDIpO1xuICAgICAgY29uc3QgdG90YWxJdGVyYXRpb25zID0gZmlsbC5sZW5ndGggKyAxO1xuICAgICAgbGV0IGN1cnJlbnRJdGVyYXRpb24gPSAxO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzdG9wO1xuICAgICAgICBpZiAodHlwZW9mIGZpbGxHcmFkaWVudFN0b3BzW2ldID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgc3RvcCA9IGZpbGxHcmFkaWVudFN0b3BzW2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0b3AgPSBjdXJyZW50SXRlcmF0aW9uIC8gdG90YWxJdGVyYXRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLCBmaWxsW2ldKTtcbiAgICAgICAgY3VycmVudEl0ZXJhdGlvbisrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3JhZGllbnQ7XG4gIH1cbiAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIikge1xuICAgICAgb3B0aW9ucyA9IHsgY2hpbGRyZW46IG9wdGlvbnMgfTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHREZXN0cm95T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgICBpZiAodGhpcy5fb3duQ2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy53aWR0aCA9IDA7XG4gICAgfVxuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgIHRoaXMuX3N0eWxlID0gbnVsbDtcbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLngpICogdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICBjb25zdCBzID0gY29yZS51dGlscy5zaWduKHRoaXMuc2NhbGUueCkgfHwgMTtcbiAgICB0aGlzLnNjYWxlLnggPSBzICogdmFsdWUgLyB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGg7XG4gICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS55KSAqIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICBjb25zdCBzID0gY29yZS51dGlscy5zaWduKHRoaXMuc2NhbGUueSkgfHwgMTtcbiAgICB0aGlzLnNjYWxlLnkgPSBzICogdmFsdWUgLyB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0O1xuICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICB9XG4gIGdldCBzdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGU7XG4gIH1cbiAgc2V0IHN0eWxlKHN0eWxlKSB7XG4gICAgc3R5bGUgPSBzdHlsZSB8fCB7fTtcbiAgICBpZiAoc3R5bGUgaW5zdGFuY2VvZiBUZXh0U3R5bGUuVGV4dFN0eWxlKSB7XG4gICAgICB0aGlzLl9zdHlsZSA9IHN0eWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdHlsZSA9IG5ldyBUZXh0U3R5bGUuVGV4dFN0eWxlKHN0eWxlKTtcbiAgICB9XG4gICAgdGhpcy5sb2NhbFN0eWxlSUQgPSAtMTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuICBnZXQgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgfVxuICBzZXQgdGV4dCh0ZXh0KSB7XG4gICAgdGV4dCA9IFN0cmluZyh0ZXh0ID09PSBudWxsIHx8IHRleHQgPT09IHZvaWQgMCA/IFwiXCIgOiB0ZXh0KTtcbiAgICBpZiAodGhpcy5fdGV4dCA9PT0gdGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl90ZXh0ID0gdGV4dDtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuICBnZXQgcmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x1dGlvbjtcbiAgfVxuICBzZXQgcmVzb2x1dGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX2F1dG9SZXNvbHV0aW9uID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuX3Jlc29sdXRpb24gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3Jlc29sdXRpb24gPSB2YWx1ZTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxufTtcbmxldCBUZXh0ID0gX1RleHQ7XG5UZXh0LmRlZmF1bHRBdXRvUmVzb2x1dGlvbiA9IHRydWU7XG5cbmV4cG9ydHMuVGV4dCA9IFRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcblxuY29uc3QgY29udGV4dFNldHRpbmdzID0ge1xuICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbn07XG5jb25zdCBfVGV4dE1ldHJpY3MgPSBjbGFzcyB7XG4gIHN0YXRpYyBnZXQgZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZ1N1cHBvcnRlZCgpIHtcbiAgICBsZXQgcmVzdWx0ID0gX1RleHRNZXRyaWNzLl9leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nU3VwcG9ydGVkO1xuICAgIGlmIChyZXN1bHQgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgcHJvdG8gPSBjb3JlLnNldHRpbmdzLkFEQVBURVIuZ2V0Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKCkucHJvdG90eXBlO1xuICAgICAgcmVzdWx0ID0gX1RleHRNZXRyaWNzLl9leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nU3VwcG9ydGVkID0gXCJsZXR0ZXJTcGFjaW5nXCIgaW4gcHJvdG8gfHwgXCJ0ZXh0TGV0dGVyU3BhY2luZ1wiIGluIHByb3RvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNvbnN0cnVjdG9yKHRleHQsIHN0eWxlLCB3aWR0aCwgaGVpZ2h0LCBsaW5lcywgbGluZVdpZHRocywgbGluZUhlaWdodCwgbWF4TGluZVdpZHRoLCBmb250UHJvcGVydGllcykge1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmxpbmVzID0gbGluZXM7XG4gICAgdGhpcy5saW5lV2lkdGhzID0gbGluZVdpZHRocztcbiAgICB0aGlzLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgIHRoaXMubWF4TGluZVdpZHRoID0gbWF4TGluZVdpZHRoO1xuICAgIHRoaXMuZm9udFByb3BlcnRpZXMgPSBmb250UHJvcGVydGllcztcbiAgfVxuICBzdGF0aWMgbWVhc3VyZVRleHQodGV4dCwgc3R5bGUsIHdvcmRXcmFwLCBjYW52YXMgPSBfVGV4dE1ldHJpY3MuX2NhbnZhcykge1xuICAgIHdvcmRXcmFwID0gd29yZFdyYXAgPT09IHZvaWQgMCB8fCB3b3JkV3JhcCA9PT0gbnVsbCA/IHN0eWxlLndvcmRXcmFwIDogd29yZFdyYXA7XG4gICAgY29uc3QgZm9udCA9IHN0eWxlLnRvRm9udFN0cmluZygpO1xuICAgIGNvbnN0IGZvbnRQcm9wZXJ0aWVzID0gX1RleHRNZXRyaWNzLm1lYXN1cmVGb250KGZvbnQpO1xuICAgIGlmIChmb250UHJvcGVydGllcy5mb250U2l6ZSA9PT0gMCkge1xuICAgICAgZm9udFByb3BlcnRpZXMuZm9udFNpemUgPSBzdHlsZS5mb250U2l6ZTtcbiAgICAgIGZvbnRQcm9wZXJ0aWVzLmFzY2VudCA9IHN0eWxlLmZvbnRTaXplO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCBjb250ZXh0U2V0dGluZ3MpO1xuICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgY29uc3Qgb3V0cHV0VGV4dCA9IHdvcmRXcmFwID8gX1RleHRNZXRyaWNzLndvcmRXcmFwKHRleHQsIHN0eWxlLCBjYW52YXMpIDogdGV4dDtcbiAgICBjb25zdCBsaW5lcyA9IG91dHB1dFRleHQuc3BsaXQoLyg/OlxcclxcbnxcXHJ8XFxuKS8pO1xuICAgIGNvbnN0IGxpbmVXaWR0aHMgPSBuZXcgQXJyYXkobGluZXMubGVuZ3RoKTtcbiAgICBsZXQgbWF4TGluZVdpZHRoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsaW5lV2lkdGggPSBfVGV4dE1ldHJpY3MuX21lYXN1cmVUZXh0KGxpbmVzW2ldLCBzdHlsZS5sZXR0ZXJTcGFjaW5nLCBjb250ZXh0KTtcbiAgICAgIGxpbmVXaWR0aHNbaV0gPSBsaW5lV2lkdGg7XG4gICAgICBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxpbmVXaWR0aCk7XG4gICAgfVxuICAgIGxldCB3aWR0aCA9IG1heExpbmVXaWR0aCArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcztcbiAgICBpZiAoc3R5bGUuZHJvcFNoYWRvdykge1xuICAgICAgd2lkdGggKz0gc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICAgIH1cbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gc3R5bGUubGluZUhlaWdodCB8fCBmb250UHJvcGVydGllcy5mb250U2l6ZSArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcztcbiAgICBsZXQgaGVpZ2h0ID0gTWF0aC5tYXgobGluZUhlaWdodCwgZm9udFByb3BlcnRpZXMuZm9udFNpemUgKyBzdHlsZS5zdHJva2VUaGlja25lc3MgKiAyKSArIChsaW5lcy5sZW5ndGggLSAxKSAqIChsaW5lSGVpZ2h0ICsgc3R5bGUubGVhZGluZyk7XG4gICAgaWYgKHN0eWxlLmRyb3BTaGFkb3cpIHtcbiAgICAgIGhlaWdodCArPSBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX1RleHRNZXRyaWNzKHRleHQsIHN0eWxlLCB3aWR0aCwgaGVpZ2h0LCBsaW5lcywgbGluZVdpZHRocywgbGluZUhlaWdodCArIHN0eWxlLmxlYWRpbmcsIG1heExpbmVXaWR0aCwgZm9udFByb3BlcnRpZXMpO1xuICB9XG4gIHN0YXRpYyBfbWVhc3VyZVRleHQodGV4dCwgbGV0dGVyU3BhY2luZywgY29udGV4dCkge1xuICAgIGxldCB1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID0gZmFsc2U7XG4gICAgaWYgKF9UZXh0TWV0cmljcy5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nU3VwcG9ydGVkKSB7XG4gICAgICBpZiAoX1RleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcpIHtcbiAgICAgICAgY29udGV4dC5sZXR0ZXJTcGFjaW5nID0gYCR7bGV0dGVyU3BhY2luZ31weGA7XG4gICAgICAgIGNvbnRleHQudGV4dExldHRlclNwYWNpbmcgPSBgJHtsZXR0ZXJTcGFjaW5nfXB4YDtcbiAgICAgICAgdXNlRXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmxldHRlclNwYWNpbmcgPSBcIjBweFwiO1xuICAgICAgICBjb250ZXh0LnRleHRMZXR0ZXJTcGFjaW5nID0gXCIwcHhcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcbiAgICBpZiAod2lkdGggPiAwKSB7XG4gICAgICBpZiAodXNlRXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZykge1xuICAgICAgICB3aWR0aCAtPSBsZXR0ZXJTcGFjaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGggKz0gKF9UZXh0TWV0cmljcy5ncmFwaGVtZVNlZ21lbnRlcih0ZXh0KS5sZW5ndGggLSAxKSAqIGxldHRlclNwYWNpbmc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3aWR0aDtcbiAgfVxuICBzdGF0aWMgd29yZFdyYXAodGV4dCwgc3R5bGUsIGNhbnZhcyA9IF9UZXh0TWV0cmljcy5fY2FudmFzKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwgY29udGV4dFNldHRpbmdzKTtcbiAgICBsZXQgd2lkdGggPSAwO1xuICAgIGxldCBsaW5lID0gXCJcIjtcbiAgICBsZXQgbGluZXMgPSBcIlwiO1xuICAgIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3QgeyBsZXR0ZXJTcGFjaW5nLCB3aGl0ZVNwYWNlIH0gPSBzdHlsZTtcbiAgICBjb25zdCBjb2xsYXBzZVNwYWNlcyA9IF9UZXh0TWV0cmljcy5jb2xsYXBzZVNwYWNlcyh3aGl0ZVNwYWNlKTtcbiAgICBjb25zdCBjb2xsYXBzZU5ld2xpbmVzID0gX1RleHRNZXRyaWNzLmNvbGxhcHNlTmV3bGluZXMod2hpdGVTcGFjZSk7XG4gICAgbGV0IGNhblByZXBlbmRTcGFjZXMgPSAhY29sbGFwc2VTcGFjZXM7XG4gICAgY29uc3Qgd29yZFdyYXBXaWR0aCA9IHN0eWxlLndvcmRXcmFwV2lkdGggKyBsZXR0ZXJTcGFjaW5nO1xuICAgIGNvbnN0IHRva2VucyA9IF9UZXh0TWV0cmljcy50b2tlbml6ZSh0ZXh0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgaWYgKF9UZXh0TWV0cmljcy5pc05ld2xpbmUodG9rZW4pKSB7XG4gICAgICAgIGlmICghY29sbGFwc2VOZXdsaW5lcykge1xuICAgICAgICAgIGxpbmVzICs9IF9UZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSAhY29sbGFwc2VTcGFjZXM7XG4gICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRva2VuID0gXCIgXCI7XG4gICAgICB9XG4gICAgICBpZiAoY29sbGFwc2VTcGFjZXMpIHtcbiAgICAgICAgY29uc3QgY3VycklzQnJlYWtpbmdTcGFjZSA9IF9UZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UodG9rZW4pO1xuICAgICAgICBjb25zdCBsYXN0SXNCcmVha2luZ1NwYWNlID0gX1RleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZShsaW5lW2xpbmUubGVuZ3RoIC0gMV0pO1xuICAgICAgICBpZiAoY3VycklzQnJlYWtpbmdTcGFjZSAmJiBsYXN0SXNCcmVha2luZ1NwYWNlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHRva2VuV2lkdGggPSBfVGV4dE1ldHJpY3MuZ2V0RnJvbUNhY2hlKHRva2VuLCBsZXR0ZXJTcGFjaW5nLCBjYWNoZSwgY29udGV4dCk7XG4gICAgICBpZiAodG9rZW5XaWR0aCA+IHdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgaWYgKGxpbmUgIT09IFwiXCIpIHtcbiAgICAgICAgICBsaW5lcyArPSBfVGV4dE1ldHJpY3MuYWRkTGluZShsaW5lKTtcbiAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9UZXh0TWV0cmljcy5jYW5CcmVha1dvcmRzKHRva2VuLCBzdHlsZS5icmVha1dvcmRzKSkge1xuICAgICAgICAgIGNvbnN0IGNoYXJhY3RlcnMgPSBfVGV4dE1ldHJpY3Mud29yZFdyYXBTcGxpdCh0b2tlbik7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGFyYWN0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgY2hhciA9IGNoYXJhY3RlcnNbal07XG4gICAgICAgICAgICBsZXQgbGFzdENoYXIgPSBjaGFyO1xuICAgICAgICAgICAgbGV0IGsgPSAxO1xuICAgICAgICAgICAgd2hpbGUgKGNoYXJhY3RlcnNbaiArIGtdKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyID0gY2hhcmFjdGVyc1tqICsga107XG4gICAgICAgICAgICAgIGlmICghX1RleHRNZXRyaWNzLmNhbkJyZWFrQ2hhcnMobGFzdENoYXIsIG5leHRDaGFyLCB0b2tlbiwgaiwgc3R5bGUuYnJlYWtXb3JkcykpIHtcbiAgICAgICAgICAgICAgICBjaGFyICs9IG5leHRDaGFyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxhc3RDaGFyID0gbmV4dENoYXI7XG4gICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGogKz0gayAtIDE7XG4gICAgICAgICAgICBjb25zdCBjaGFyYWN0ZXJXaWR0aCA9IF9UZXh0TWV0cmljcy5nZXRGcm9tQ2FjaGUoY2hhciwgbGV0dGVyU3BhY2luZywgY2FjaGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGNoYXJhY3RlcldpZHRoICsgd2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICAgIGxpbmVzICs9IF9UZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgICAgICBjYW5QcmVwZW5kU3BhY2VzID0gZmFsc2U7XG4gICAgICAgICAgICAgIGxpbmUgPSBcIlwiO1xuICAgICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lICs9IGNoYXI7XG4gICAgICAgICAgICB3aWR0aCArPSBjaGFyYWN0ZXJXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGluZXMgKz0gX1RleHRNZXRyaWNzLmFkZExpbmUobGluZSk7XG4gICAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaXNMYXN0VG9rZW4gPSBpID09PSB0b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICBsaW5lcyArPSBfVGV4dE1ldHJpY3MuYWRkTGluZSh0b2tlbiwgIWlzTGFzdFRva2VuKTtcbiAgICAgICAgICBjYW5QcmVwZW5kU3BhY2VzID0gZmFsc2U7XG4gICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodG9rZW5XaWR0aCArIHdpZHRoID4gd29yZFdyYXBXaWR0aCkge1xuICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSBmYWxzZTtcbiAgICAgICAgICBsaW5lcyArPSBfVGV4dE1ldHJpY3MuYWRkTGluZShsaW5lKTtcbiAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMCB8fCAhX1RleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZSh0b2tlbikgfHwgY2FuUHJlcGVuZFNwYWNlcykge1xuICAgICAgICAgIGxpbmUgKz0gdG9rZW47XG4gICAgICAgICAgd2lkdGggKz0gdG9rZW5XaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsaW5lcyArPSBfVGV4dE1ldHJpY3MuYWRkTGluZShsaW5lLCBmYWxzZSk7XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG4gIHN0YXRpYyBhZGRMaW5lKGxpbmUsIG5ld0xpbmUgPSB0cnVlKSB7XG4gICAgbGluZSA9IF9UZXh0TWV0cmljcy50cmltUmlnaHQobGluZSk7XG4gICAgbGluZSA9IG5ld0xpbmUgPyBgJHtsaW5lfVxuYCA6IGxpbmU7XG4gICAgcmV0dXJuIGxpbmU7XG4gIH1cbiAgc3RhdGljIGdldEZyb21DYWNoZShrZXksIGxldHRlclNwYWNpbmcsIGNhY2hlLCBjb250ZXh0KSB7XG4gICAgbGV0IHdpZHRoID0gY2FjaGVba2V5XTtcbiAgICBpZiAodHlwZW9mIHdpZHRoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB3aWR0aCA9IF9UZXh0TWV0cmljcy5fbWVhc3VyZVRleHQoa2V5LCBsZXR0ZXJTcGFjaW5nLCBjb250ZXh0KSArIGxldHRlclNwYWNpbmc7XG4gICAgICBjYWNoZVtrZXldID0gd2lkdGg7XG4gICAgfVxuICAgIHJldHVybiB3aWR0aDtcbiAgfVxuICBzdGF0aWMgY29sbGFwc2VTcGFjZXMod2hpdGVTcGFjZSkge1xuICAgIHJldHVybiB3aGl0ZVNwYWNlID09PSBcIm5vcm1hbFwiIHx8IHdoaXRlU3BhY2UgPT09IFwicHJlLWxpbmVcIjtcbiAgfVxuICBzdGF0aWMgY29sbGFwc2VOZXdsaW5lcyh3aGl0ZVNwYWNlKSB7XG4gICAgcmV0dXJuIHdoaXRlU3BhY2UgPT09IFwibm9ybWFsXCI7XG4gIH1cbiAgc3RhdGljIHRyaW1SaWdodCh0ZXh0KSB7XG4gICAgaWYgKHR5cGVvZiB0ZXh0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHRleHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGNoYXIgPSB0ZXh0W2ldO1xuICAgICAgaWYgKCFfVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKGNoYXIpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICBzdGF0aWMgaXNOZXdsaW5lKGNoYXIpIHtcbiAgICBpZiAodHlwZW9mIGNoYXIgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIF9UZXh0TWV0cmljcy5fbmV3bGluZXMuaW5jbHVkZXMoY2hhci5jaGFyQ29kZUF0KDApKTtcbiAgfVxuICBzdGF0aWMgaXNCcmVha2luZ1NwYWNlKGNoYXIsIF9uZXh0Q2hhcikge1xuICAgIGlmICh0eXBlb2YgY2hhciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gX1RleHRNZXRyaWNzLl9icmVha2luZ1NwYWNlcy5pbmNsdWRlcyhjaGFyLmNoYXJDb2RlQXQoMCkpO1xuICB9XG4gIHN0YXRpYyB0b2tlbml6ZSh0ZXh0KSB7XG4gICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgbGV0IHRva2VuID0gXCJcIjtcbiAgICBpZiAodHlwZW9mIHRleHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IHRleHRbaV07XG4gICAgICBjb25zdCBuZXh0Q2hhciA9IHRleHRbaSArIDFdO1xuICAgICAgaWYgKF9UZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UoY2hhciwgbmV4dENoYXIpIHx8IF9UZXh0TWV0cmljcy5pc05ld2xpbmUoY2hhcikpIHtcbiAgICAgICAgaWYgKHRva2VuICE9PSBcIlwiKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIHRva2VuID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbnMucHVzaChjaGFyKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0b2tlbiArPSBjaGFyO1xuICAgIH1cbiAgICBpZiAodG9rZW4gIT09IFwiXCIpIHtcbiAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRva2VucztcbiAgfVxuICBzdGF0aWMgY2FuQnJlYWtXb3JkcyhfdG9rZW4sIGJyZWFrV29yZHMpIHtcbiAgICByZXR1cm4gYnJlYWtXb3JkcztcbiAgfVxuICBzdGF0aWMgY2FuQnJlYWtDaGFycyhfY2hhciwgX25leHRDaGFyLCBfdG9rZW4sIF9pbmRleCwgX2JyZWFrV29yZHMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgd29yZFdyYXBTcGxpdCh0b2tlbikge1xuICAgIHJldHVybiBfVGV4dE1ldHJpY3MuZ3JhcGhlbWVTZWdtZW50ZXIodG9rZW4pO1xuICB9XG4gIHN0YXRpYyBtZWFzdXJlRm9udChmb250KSB7XG4gICAgaWYgKF9UZXh0TWV0cmljcy5fZm9udHNbZm9udF0pIHtcbiAgICAgIHJldHVybiBfVGV4dE1ldHJpY3MuX2ZvbnRzW2ZvbnRdO1xuICAgIH1cbiAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgYXNjZW50OiAwLFxuICAgICAgZGVzY2VudDogMCxcbiAgICAgIGZvbnRTaXplOiAwXG4gICAgfTtcbiAgICBjb25zdCBjYW52YXMgPSBfVGV4dE1ldHJpY3MuX2NhbnZhcztcbiAgICBjb25zdCBjb250ZXh0ID0gX1RleHRNZXRyaWNzLl9jb250ZXh0O1xuICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgY29uc3QgbWV0cmljc1N0cmluZyA9IF9UZXh0TWV0cmljcy5NRVRSSUNTX1NUUklORyArIF9UZXh0TWV0cmljcy5CQVNFTElORV9TWU1CT0w7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwoY29udGV4dC5tZWFzdXJlVGV4dChtZXRyaWNzU3RyaW5nKS53aWR0aCk7XG4gICAgbGV0IGJhc2VsaW5lID0gTWF0aC5jZWlsKGNvbnRleHQubWVhc3VyZVRleHQoX1RleHRNZXRyaWNzLkJBU0VMSU5FX1NZTUJPTCkud2lkdGgpO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChfVGV4dE1ldHJpY3MuSEVJR0hUX01VTFRJUExJRVIgKiBiYXNlbGluZSk7XG4gICAgYmFzZWxpbmUgPSBiYXNlbGluZSAqIF9UZXh0TWV0cmljcy5CQVNFTElORV9NVUxUSVBMSUVSIHwgMDtcbiAgICBpZiAod2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKSB7XG4gICAgICBfVGV4dE1ldHJpY3MuX2ZvbnRzW2ZvbnRdID0gcHJvcGVydGllcztcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH1cbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCIjZjAwXCI7XG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb250ZXh0LmZvbnQgPSBmb250O1xuICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gXCJhbHBoYWJldGljXCI7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBcIiMwMDBcIjtcbiAgICBjb250ZXh0LmZpbGxUZXh0KG1ldHJpY3NTdHJpbmcsIDAsIGJhc2VsaW5lKTtcbiAgICBjb25zdCBpbWFnZWRhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgIGNvbnN0IHBpeGVscyA9IGltYWdlZGF0YS5sZW5ndGg7XG4gICAgY29uc3QgbGluZSA9IHdpZHRoICogNDtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGlkeCA9IDA7XG4gICAgbGV0IHN0b3AgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYmFzZWxpbmU7ICsraSkge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lOyBqICs9IDQpIHtcbiAgICAgICAgaWYgKGltYWdlZGF0YVtpZHggKyBqXSAhPT0gMjU1KSB7XG4gICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghc3RvcCkge1xuICAgICAgICBpZHggKz0gbGluZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wZXJ0aWVzLmFzY2VudCA9IGJhc2VsaW5lIC0gaTtcbiAgICBpZHggPSBwaXhlbHMgLSBsaW5lO1xuICAgIHN0b3AgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSBoZWlnaHQ7IGkgPiBiYXNlbGluZTsgLS1pKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmU7IGogKz0gNCkge1xuICAgICAgICBpZiAoaW1hZ2VkYXRhW2lkeCArIGpdICE9PSAyNTUpIHtcbiAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFzdG9wKSB7XG4gICAgICAgIGlkeCAtPSBsaW5lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BlcnRpZXMuZGVzY2VudCA9IGkgLSBiYXNlbGluZTtcbiAgICBwcm9wZXJ0aWVzLmZvbnRTaXplID0gcHJvcGVydGllcy5hc2NlbnQgKyBwcm9wZXJ0aWVzLmRlc2NlbnQ7XG4gICAgX1RleHRNZXRyaWNzLl9mb250c1tmb250XSA9IHByb3BlcnRpZXM7XG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gIH1cbiAgc3RhdGljIGNsZWFyTWV0cmljcyhmb250ID0gXCJcIikge1xuICAgIGlmIChmb250KSB7XG4gICAgICBkZWxldGUgX1RleHRNZXRyaWNzLl9mb250c1tmb250XTtcbiAgICB9IGVsc2Uge1xuICAgICAgX1RleHRNZXRyaWNzLl9mb250cyA9IHt9O1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IF9jYW52YXMoKSB7XG4gICAgaWYgKCFfVGV4dE1ldHJpY3MuX19jYW52YXMpIHtcbiAgICAgIGxldCBjYW52YXM7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjID0gbmV3IE9mZnNjcmVlbkNhbnZhcygwLCAwKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGMuZ2V0Q29udGV4dChcIjJkXCIsIGNvbnRleHRTZXR0aW5ncyk7XG4gICAgICAgIGlmIChjb250ZXh0Py5tZWFzdXJlVGV4dCkge1xuICAgICAgICAgIF9UZXh0TWV0cmljcy5fX2NhbnZhcyA9IGM7XG4gICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzID0gY29yZS5zZXR0aW5ncy5BREFQVEVSLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgY2FudmFzID0gY29yZS5zZXR0aW5ncy5BREFQVEVSLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgfVxuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDEwO1xuICAgICAgX1RleHRNZXRyaWNzLl9fY2FudmFzID0gY2FudmFzO1xuICAgIH1cbiAgICByZXR1cm4gX1RleHRNZXRyaWNzLl9fY2FudmFzO1xuICB9XG4gIHN0YXRpYyBnZXQgX2NvbnRleHQoKSB7XG4gICAgaWYgKCFfVGV4dE1ldHJpY3MuX19jb250ZXh0KSB7XG4gICAgICBfVGV4dE1ldHJpY3MuX19jb250ZXh0ID0gX1RleHRNZXRyaWNzLl9jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIGNvbnRleHRTZXR0aW5ncyk7XG4gICAgfVxuICAgIHJldHVybiBfVGV4dE1ldHJpY3MuX19jb250ZXh0O1xuICB9XG59O1xubGV0IFRleHRNZXRyaWNzID0gX1RleHRNZXRyaWNzO1xuVGV4dE1ldHJpY3MuTUVUUklDU19TVFJJTkcgPSBcInxcXHhDOXFcXHhDNVwiO1xuVGV4dE1ldHJpY3MuQkFTRUxJTkVfU1lNQk9MID0gXCJNXCI7XG5UZXh0TWV0cmljcy5CQVNFTElORV9NVUxUSVBMSUVSID0gMS40O1xuVGV4dE1ldHJpY3MuSEVJR0hUX01VTFRJUExJRVIgPSAyO1xuVGV4dE1ldHJpY3MuZ3JhcGhlbWVTZWdtZW50ZXIgPSAoKCkgPT4ge1xuICBpZiAodHlwZW9mIEludGw/LlNlZ21lbnRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3Qgc2VnbWVudGVyID0gbmV3IEludGwuU2VnbWVudGVyKCk7XG4gICAgcmV0dXJuIChzKSA9PiBbLi4uc2VnbWVudGVyLnNlZ21lbnQocyldLm1hcCgoeCkgPT4geC5zZWdtZW50KTtcbiAgfVxuICByZXR1cm4gKHMpID0+IFsuLi5zXTtcbn0pKCk7XG5UZXh0TWV0cmljcy5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID0gZmFsc2U7XG5UZXh0TWV0cmljcy5fZm9udHMgPSB7fTtcblRleHRNZXRyaWNzLl9uZXdsaW5lcyA9IFtcbiAgMTAsXG4gIDEzXG5dO1xuVGV4dE1ldHJpY3MuX2JyZWFraW5nU3BhY2VzID0gW1xuICA5LFxuICAzMixcbiAgODE5MixcbiAgODE5MyxcbiAgODE5NCxcbiAgODE5NSxcbiAgODE5NixcbiAgODE5NyxcbiAgODE5OCxcbiAgODIwMCxcbiAgODIwMSxcbiAgODIwMixcbiAgODI4NyxcbiAgMTIyODhcbl07XG5cbmV4cG9ydHMuVGV4dE1ldHJpY3MgPSBUZXh0TWV0cmljcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHRNZXRyaWNzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi9jb25zdC5qcycpO1xudmFyIGNvcmUgPSByZXF1aXJlKCdAcGl4aS9jb3JlJyk7XG5cbmNvbnN0IGdlbmVyaWNGb250RmFtaWxpZXMgPSBbXG4gIFwic2VyaWZcIixcbiAgXCJzYW5zLXNlcmlmXCIsXG4gIFwibW9ub3NwYWNlXCIsXG4gIFwiY3Vyc2l2ZVwiLFxuICBcImZhbnRhc3lcIixcbiAgXCJzeXN0ZW0tdWlcIlxuXTtcbmNvbnN0IF9UZXh0U3R5bGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHN0eWxlKSB7XG4gICAgdGhpcy5zdHlsZUlEID0gMDtcbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgZGVlcENvcHlQcm9wZXJ0aWVzKHRoaXMsIHN0eWxlLCBzdHlsZSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmVkUHJvcGVydGllcyA9IHt9O1xuICAgIGRlZXBDb3B5UHJvcGVydGllcyhjbG9uZWRQcm9wZXJ0aWVzLCB0aGlzLCBfVGV4dFN0eWxlLmRlZmF1bHRTdHlsZSk7XG4gICAgcmV0dXJuIG5ldyBfVGV4dFN0eWxlKGNsb25lZFByb3BlcnRpZXMpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIGRlZXBDb3B5UHJvcGVydGllcyh0aGlzLCBfVGV4dFN0eWxlLmRlZmF1bHRTdHlsZSwgX1RleHRTdHlsZS5kZWZhdWx0U3R5bGUpO1xuICB9XG4gIGdldCBhbGlnbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYWxpZ247XG4gIH1cbiAgc2V0IGFsaWduKGFsaWduKSB7XG4gICAgaWYgKHRoaXMuX2FsaWduICE9PSBhbGlnbikge1xuICAgICAgdGhpcy5fYWxpZ24gPSBhbGlnbjtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgYnJlYWtXb3JkcygpIHtcbiAgICByZXR1cm4gdGhpcy5fYnJlYWtXb3JkcztcbiAgfVxuICBzZXQgYnJlYWtXb3JkcyhicmVha1dvcmRzKSB7XG4gICAgaWYgKHRoaXMuX2JyZWFrV29yZHMgIT09IGJyZWFrV29yZHMpIHtcbiAgICAgIHRoaXMuX2JyZWFrV29yZHMgPSBicmVha1dvcmRzO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBkcm9wU2hhZG93KCkge1xuICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93O1xuICB9XG4gIHNldCBkcm9wU2hhZG93KGRyb3BTaGFkb3cpIHtcbiAgICBpZiAodGhpcy5fZHJvcFNoYWRvdyAhPT0gZHJvcFNoYWRvdykge1xuICAgICAgdGhpcy5fZHJvcFNoYWRvdyA9IGRyb3BTaGFkb3c7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGRyb3BTaGFkb3dBbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0FscGhhO1xuICB9XG4gIHNldCBkcm9wU2hhZG93QWxwaGEoZHJvcFNoYWRvd0FscGhhKSB7XG4gICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dBbHBoYSAhPT0gZHJvcFNoYWRvd0FscGhhKSB7XG4gICAgICB0aGlzLl9kcm9wU2hhZG93QWxwaGEgPSBkcm9wU2hhZG93QWxwaGE7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGRyb3BTaGFkb3dBbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0FuZ2xlO1xuICB9XG4gIHNldCBkcm9wU2hhZG93QW5nbGUoZHJvcFNoYWRvd0FuZ2xlKSB7XG4gICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dBbmdsZSAhPT0gZHJvcFNoYWRvd0FuZ2xlKSB7XG4gICAgICB0aGlzLl9kcm9wU2hhZG93QW5nbGUgPSBkcm9wU2hhZG93QW5nbGU7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGRyb3BTaGFkb3dCbHVyKCkge1xuICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93Qmx1cjtcbiAgfVxuICBzZXQgZHJvcFNoYWRvd0JsdXIoZHJvcFNoYWRvd0JsdXIpIHtcbiAgICBpZiAodGhpcy5fZHJvcFNoYWRvd0JsdXIgIT09IGRyb3BTaGFkb3dCbHVyKSB7XG4gICAgICB0aGlzLl9kcm9wU2hhZG93Qmx1ciA9IGRyb3BTaGFkb3dCbHVyO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBkcm9wU2hhZG93Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3dDb2xvcjtcbiAgfVxuICBzZXQgZHJvcFNoYWRvd0NvbG9yKGRyb3BTaGFkb3dDb2xvcikge1xuICAgIGNvbnN0IG91dHB1dENvbG9yID0gZ2V0Q29sb3IoZHJvcFNoYWRvd0NvbG9yKTtcbiAgICBpZiAodGhpcy5fZHJvcFNoYWRvd0NvbG9yICE9PSBvdXRwdXRDb2xvcikge1xuICAgICAgdGhpcy5fZHJvcFNoYWRvd0NvbG9yID0gb3V0cHV0Q29sb3I7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGRyb3BTaGFkb3dEaXN0YW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICB9XG4gIHNldCBkcm9wU2hhZG93RGlzdGFuY2UoZHJvcFNoYWRvd0Rpc3RhbmNlKSB7XG4gICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dEaXN0YW5jZSAhPT0gZHJvcFNoYWRvd0Rpc3RhbmNlKSB7XG4gICAgICB0aGlzLl9kcm9wU2hhZG93RGlzdGFuY2UgPSBkcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGZpbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGw7XG4gIH1cbiAgc2V0IGZpbGwoZmlsbCkge1xuICAgIGNvbnN0IG91dHB1dENvbG9yID0gZ2V0Q29sb3IoZmlsbCk7XG4gICAgaWYgKHRoaXMuX2ZpbGwgIT09IG91dHB1dENvbG9yKSB7XG4gICAgICB0aGlzLl9maWxsID0gb3V0cHV0Q29sb3I7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGZpbGxHcmFkaWVudFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGxHcmFkaWVudFR5cGU7XG4gIH1cbiAgc2V0IGZpbGxHcmFkaWVudFR5cGUoZmlsbEdyYWRpZW50VHlwZSkge1xuICAgIGlmICh0aGlzLl9maWxsR3JhZGllbnRUeXBlICE9PSBmaWxsR3JhZGllbnRUeXBlKSB7XG4gICAgICB0aGlzLl9maWxsR3JhZGllbnRUeXBlID0gZmlsbEdyYWRpZW50VHlwZTtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgZmlsbEdyYWRpZW50U3RvcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGxHcmFkaWVudFN0b3BzO1xuICB9XG4gIHNldCBmaWxsR3JhZGllbnRTdG9wcyhmaWxsR3JhZGllbnRTdG9wcykge1xuICAgIGlmICghYXJlQXJyYXlzRXF1YWwodGhpcy5fZmlsbEdyYWRpZW50U3RvcHMsIGZpbGxHcmFkaWVudFN0b3BzKSkge1xuICAgICAgdGhpcy5fZmlsbEdyYWRpZW50U3RvcHMgPSBmaWxsR3JhZGllbnRTdG9wcztcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgZm9udEZhbWlseSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udEZhbWlseTtcbiAgfVxuICBzZXQgZm9udEZhbWlseShmb250RmFtaWx5KSB7XG4gICAgaWYgKHRoaXMuZm9udEZhbWlseSAhPT0gZm9udEZhbWlseSkge1xuICAgICAgdGhpcy5fZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGZvbnRTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9mb250U2l6ZTtcbiAgfVxuICBzZXQgZm9udFNpemUoZm9udFNpemUpIHtcbiAgICBpZiAodGhpcy5fZm9udFNpemUgIT09IGZvbnRTaXplKSB7XG4gICAgICB0aGlzLl9mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBmb250U3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRTdHlsZTtcbiAgfVxuICBzZXQgZm9udFN0eWxlKGZvbnRTdHlsZSkge1xuICAgIGlmICh0aGlzLl9mb250U3R5bGUgIT09IGZvbnRTdHlsZSkge1xuICAgICAgdGhpcy5fZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBmb250VmFyaWFudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udFZhcmlhbnQ7XG4gIH1cbiAgc2V0IGZvbnRWYXJpYW50KGZvbnRWYXJpYW50KSB7XG4gICAgaWYgKHRoaXMuX2ZvbnRWYXJpYW50ICE9PSBmb250VmFyaWFudCkge1xuICAgICAgdGhpcy5fZm9udFZhcmlhbnQgPSBmb250VmFyaWFudDtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgZm9udFdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udFdlaWdodDtcbiAgfVxuICBzZXQgZm9udFdlaWdodChmb250V2VpZ2h0KSB7XG4gICAgaWYgKHRoaXMuX2ZvbnRXZWlnaHQgIT09IGZvbnRXZWlnaHQpIHtcbiAgICAgIHRoaXMuX2ZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBsZXR0ZXJTcGFjaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9sZXR0ZXJTcGFjaW5nO1xuICB9XG4gIHNldCBsZXR0ZXJTcGFjaW5nKGxldHRlclNwYWNpbmcpIHtcbiAgICBpZiAodGhpcy5fbGV0dGVyU3BhY2luZyAhPT0gbGV0dGVyU3BhY2luZykge1xuICAgICAgdGhpcy5fbGV0dGVyU3BhY2luZyA9IGxldHRlclNwYWNpbmc7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGxpbmVIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpbmVIZWlnaHQ7XG4gIH1cbiAgc2V0IGxpbmVIZWlnaHQobGluZUhlaWdodCkge1xuICAgIGlmICh0aGlzLl9saW5lSGVpZ2h0ICE9PSBsaW5lSGVpZ2h0KSB7XG4gICAgICB0aGlzLl9saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgbGVhZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVhZGluZztcbiAgfVxuICBzZXQgbGVhZGluZyhsZWFkaW5nKSB7XG4gICAgaWYgKHRoaXMuX2xlYWRpbmcgIT09IGxlYWRpbmcpIHtcbiAgICAgIHRoaXMuX2xlYWRpbmcgPSBsZWFkaW5nO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBsaW5lSm9pbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbGluZUpvaW47XG4gIH1cbiAgc2V0IGxpbmVKb2luKGxpbmVKb2luKSB7XG4gICAgaWYgKHRoaXMuX2xpbmVKb2luICE9PSBsaW5lSm9pbikge1xuICAgICAgdGhpcy5fbGluZUpvaW4gPSBsaW5lSm9pbjtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgbWl0ZXJMaW1pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl0ZXJMaW1pdDtcbiAgfVxuICBzZXQgbWl0ZXJMaW1pdChtaXRlckxpbWl0KSB7XG4gICAgaWYgKHRoaXMuX21pdGVyTGltaXQgIT09IG1pdGVyTGltaXQpIHtcbiAgICAgIHRoaXMuX21pdGVyTGltaXQgPSBtaXRlckxpbWl0O1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBwYWRkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICB9XG4gIHNldCBwYWRkaW5nKHBhZGRpbmcpIHtcbiAgICBpZiAodGhpcy5fcGFkZGluZyAhPT0gcGFkZGluZykge1xuICAgICAgdGhpcy5fcGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IHN0cm9rZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3Ryb2tlO1xuICB9XG4gIHNldCBzdHJva2Uoc3Ryb2tlKSB7XG4gICAgY29uc3Qgb3V0cHV0Q29sb3IgPSBnZXRDb2xvcihzdHJva2UpO1xuICAgIGlmICh0aGlzLl9zdHJva2UgIT09IG91dHB1dENvbG9yKSB7XG4gICAgICB0aGlzLl9zdHJva2UgPSBvdXRwdXRDb2xvcjtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgc3Ryb2tlVGhpY2tuZXNzKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJva2VUaGlja25lc3M7XG4gIH1cbiAgc2V0IHN0cm9rZVRoaWNrbmVzcyhzdHJva2VUaGlja25lc3MpIHtcbiAgICBpZiAodGhpcy5fc3Ryb2tlVGhpY2tuZXNzICE9PSBzdHJva2VUaGlja25lc3MpIHtcbiAgICAgIHRoaXMuX3N0cm9rZVRoaWNrbmVzcyA9IHN0cm9rZVRoaWNrbmVzcztcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgdGV4dEJhc2VsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0QmFzZWxpbmU7XG4gIH1cbiAgc2V0IHRleHRCYXNlbGluZSh0ZXh0QmFzZWxpbmUpIHtcbiAgICBpZiAodGhpcy5fdGV4dEJhc2VsaW5lICE9PSB0ZXh0QmFzZWxpbmUpIHtcbiAgICAgIHRoaXMuX3RleHRCYXNlbGluZSA9IHRleHRCYXNlbGluZTtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgdHJpbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJpbTtcbiAgfVxuICBzZXQgdHJpbSh0cmltKSB7XG4gICAgaWYgKHRoaXMuX3RyaW0gIT09IHRyaW0pIHtcbiAgICAgIHRoaXMuX3RyaW0gPSB0cmltO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCB3aGl0ZVNwYWNlKCkge1xuICAgIHJldHVybiB0aGlzLl93aGl0ZVNwYWNlO1xuICB9XG4gIHNldCB3aGl0ZVNwYWNlKHdoaXRlU3BhY2UpIHtcbiAgICBpZiAodGhpcy5fd2hpdGVTcGFjZSAhPT0gd2hpdGVTcGFjZSkge1xuICAgICAgdGhpcy5fd2hpdGVTcGFjZSA9IHdoaXRlU3BhY2U7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IHdvcmRXcmFwKCkge1xuICAgIHJldHVybiB0aGlzLl93b3JkV3JhcDtcbiAgfVxuICBzZXQgd29yZFdyYXAod29yZFdyYXApIHtcbiAgICBpZiAodGhpcy5fd29yZFdyYXAgIT09IHdvcmRXcmFwKSB7XG4gICAgICB0aGlzLl93b3JkV3JhcCA9IHdvcmRXcmFwO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCB3b3JkV3JhcFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl93b3JkV3JhcFdpZHRoO1xuICB9XG4gIHNldCB3b3JkV3JhcFdpZHRoKHdvcmRXcmFwV2lkdGgpIHtcbiAgICBpZiAodGhpcy5fd29yZFdyYXBXaWR0aCAhPT0gd29yZFdyYXBXaWR0aCkge1xuICAgICAgdGhpcy5fd29yZFdyYXBXaWR0aCA9IHdvcmRXcmFwV2lkdGg7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgdG9Gb250U3RyaW5nKCkge1xuICAgIGNvbnN0IGZvbnRTaXplU3RyaW5nID0gdHlwZW9mIHRoaXMuZm9udFNpemUgPT09IFwibnVtYmVyXCIgPyBgJHt0aGlzLmZvbnRTaXplfXB4YCA6IHRoaXMuZm9udFNpemU7XG4gICAgbGV0IGZvbnRGYW1pbGllcyA9IHRoaXMuZm9udEZhbWlseTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5mb250RmFtaWx5KSkge1xuICAgICAgZm9udEZhbWlsaWVzID0gdGhpcy5mb250RmFtaWx5LnNwbGl0KFwiLFwiKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGZvbnRGYW1pbGllcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGZvbnRGYW1pbHkgPSBmb250RmFtaWxpZXNbaV0udHJpbSgpO1xuICAgICAgaWYgKCEvKFtcXFwiXFwnXSlbXlxcJ1xcXCJdK1xcMS8udGVzdChmb250RmFtaWx5KSAmJiAhZ2VuZXJpY0ZvbnRGYW1pbGllcy5pbmNsdWRlcyhmb250RmFtaWx5KSkge1xuICAgICAgICBmb250RmFtaWx5ID0gYFwiJHtmb250RmFtaWx5fVwiYDtcbiAgICAgIH1cbiAgICAgIGZvbnRGYW1pbGllc1tpXSA9IGZvbnRGYW1pbHk7XG4gICAgfVxuICAgIHJldHVybiBgJHt0aGlzLmZvbnRTdHlsZX0gJHt0aGlzLmZvbnRWYXJpYW50fSAke3RoaXMuZm9udFdlaWdodH0gJHtmb250U2l6ZVN0cmluZ30gJHtmb250RmFtaWxpZXMuam9pbihcIixcIil9YDtcbiAgfVxufTtcbmxldCBUZXh0U3R5bGUgPSBfVGV4dFN0eWxlO1xuVGV4dFN0eWxlLmRlZmF1bHRTdHlsZSA9IHtcbiAgYWxpZ246IFwibGVmdFwiLFxuICBicmVha1dvcmRzOiBmYWxzZSxcbiAgZHJvcFNoYWRvdzogZmFsc2UsXG4gIGRyb3BTaGFkb3dBbHBoYTogMSxcbiAgZHJvcFNoYWRvd0FuZ2xlOiBNYXRoLlBJIC8gNixcbiAgZHJvcFNoYWRvd0JsdXI6IDAsXG4gIGRyb3BTaGFkb3dDb2xvcjogXCJibGFja1wiLFxuICBkcm9wU2hhZG93RGlzdGFuY2U6IDUsXG4gIGZpbGw6IFwiYmxhY2tcIixcbiAgZmlsbEdyYWRpZW50VHlwZTogX2NvbnN0LlRFWFRfR1JBRElFTlQuTElORUFSX1ZFUlRJQ0FMLFxuICBmaWxsR3JhZGllbnRTdG9wczogW10sXG4gIGZvbnRGYW1pbHk6IFwiQXJpYWxcIixcbiAgZm9udFNpemU6IDI2LFxuICBmb250U3R5bGU6IFwibm9ybWFsXCIsXG4gIGZvbnRWYXJpYW50OiBcIm5vcm1hbFwiLFxuICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiLFxuICBsZWFkaW5nOiAwLFxuICBsZXR0ZXJTcGFjaW5nOiAwLFxuICBsaW5lSGVpZ2h0OiAwLFxuICBsaW5lSm9pbjogXCJtaXRlclwiLFxuICBtaXRlckxpbWl0OiAxMCxcbiAgcGFkZGluZzogMCxcbiAgc3Ryb2tlOiBcImJsYWNrXCIsXG4gIHN0cm9rZVRoaWNrbmVzczogMCxcbiAgdGV4dEJhc2VsaW5lOiBcImFscGhhYmV0aWNcIixcbiAgdHJpbTogZmFsc2UsXG4gIHdoaXRlU3BhY2U6IFwicHJlXCIsXG4gIHdvcmRXcmFwOiBmYWxzZSxcbiAgd29yZFdyYXBXaWR0aDogMTAwXG59O1xuZnVuY3Rpb24gZ2V0Q29sb3IoY29sb3IpIHtcbiAgY29uc3QgdGVtcCA9IGNvcmUuQ29sb3Iuc2hhcmVkO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgcmV0dXJuIHRlbXAuc2V0VmFsdWUoY29sb3IpLnRvSGV4KCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbG9yLm1hcCgoYykgPT4gdGVtcC5zZXRWYWx1ZShjKS50b0hleCgpKTtcbiAgfVxufVxuZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYXJyYXkxLCBhcnJheTIpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5MSkgfHwgIUFycmF5LmlzQXJyYXkoYXJyYXkyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYXJyYXkxLmxlbmd0aCAhPT0gYXJyYXkyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5MS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJheTFbaV0gIT09IGFycmF5MltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRlZXBDb3B5UHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSwgcHJvcGVydHlPYmopIHtcbiAgZm9yIChjb25zdCBwcm9wIGluIHByb3BlcnR5T2JqKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlW3Byb3BdKSkge1xuICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5UZXh0U3R5bGUgPSBUZXh0U3R5bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0U3R5bGUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBURVhUX0dSQURJRU5UID0gLyogQF9fUFVSRV9fICovICgoVEVYVF9HUkFESUVOVDIpID0+IHtcbiAgVEVYVF9HUkFESUVOVDJbVEVYVF9HUkFESUVOVDJbXCJMSU5FQVJfVkVSVElDQUxcIl0gPSAwXSA9IFwiTElORUFSX1ZFUlRJQ0FMXCI7XG4gIFRFWFRfR1JBRElFTlQyW1RFWFRfR1JBRElFTlQyW1wiTElORUFSX0hPUklaT05UQUxcIl0gPSAxXSA9IFwiTElORUFSX0hPUklaT05UQUxcIjtcbiAgcmV0dXJuIFRFWFRfR1JBRElFTlQyO1xufSkoVEVYVF9HUkFESUVOVCB8fCB7fSk7XG5cbmV4cG9ydHMuVEVYVF9HUkFESUVOVCA9IFRFWFRfR1JBRElFTlQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIF9jb25zdCA9IHJlcXVpcmUoJy4vY29uc3QuanMnKTtcbnZhciBUZXh0ID0gcmVxdWlyZSgnLi9UZXh0LmpzJyk7XG52YXIgVGV4dE1ldHJpY3MgPSByZXF1aXJlKCcuL1RleHRNZXRyaWNzLmpzJyk7XG52YXIgVGV4dFN0eWxlID0gcmVxdWlyZSgnLi9UZXh0U3R5bGUuanMnKTtcblxuXG5cbmV4cG9ydHMuVEVYVF9HUkFESUVOVCA9IF9jb25zdC5URVhUX0dSQURJRU5UO1xuZXhwb3J0cy5UZXh0ID0gVGV4dC5UZXh0O1xuZXhwb3J0cy5UZXh0TWV0cmljcyA9IFRleHRNZXRyaWNzLlRleHRNZXRyaWNzO1xuZXhwb3J0cy5UZXh0U3R5bGUgPSBUZXh0U3R5bGUuVGV4dFN0eWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBfY29uc3QgPSByZXF1aXJlKCcuL2NvbnN0LmpzJyk7XG52YXIgVGlja2VyTGlzdGVuZXIgPSByZXF1aXJlKCcuL1RpY2tlckxpc3RlbmVyLmpzJyk7XG5cbmNvbnN0IF9UaWNrZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYXV0b1N0YXJ0ID0gZmFsc2U7XG4gICAgdGhpcy5kZWx0YVRpbWUgPSAxO1xuICAgIHRoaXMubGFzdFRpbWUgPSAtMTtcbiAgICB0aGlzLnNwZWVkID0gMTtcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXF1ZXN0SWQgPSBudWxsO1xuICAgIHRoaXMuX21heEVsYXBzZWRNUyA9IDEwMDtcbiAgICB0aGlzLl9taW5FbGFwc2VkTVMgPSAwO1xuICAgIHRoaXMuX3Byb3RlY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2xhc3RGcmFtZSA9IC0xO1xuICAgIHRoaXMuX2hlYWQgPSBuZXcgVGlja2VyTGlzdGVuZXIuVGlja2VyTGlzdGVuZXIobnVsbCwgbnVsbCwgSW5maW5pdHkpO1xuICAgIHRoaXMuZGVsdGFNUyA9IDEgLyBfVGlja2VyLnRhcmdldEZQTVM7XG4gICAgdGhpcy5lbGFwc2VkTVMgPSAxIC8gX1RpY2tlci50YXJnZXRGUE1TO1xuICAgIHRoaXMuX3RpY2sgPSAodGltZSkgPT4ge1xuICAgICAgdGhpcy5fcmVxdWVzdElkID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgdGhpcy51cGRhdGUodGltZSk7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQgJiYgdGhpcy5fcmVxdWVzdElkID09PSBudWxsICYmIHRoaXMuX2hlYWQubmV4dCkge1xuICAgICAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl90aWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgX3JlcXVlc3RJZk5lZWRlZCgpIHtcbiAgICBpZiAodGhpcy5fcmVxdWVzdElkID09PSBudWxsICYmIHRoaXMuX2hlYWQubmV4dCkge1xuICAgICAgdGhpcy5sYXN0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdGhpcy5fbGFzdEZyYW1lID0gdGhpcy5sYXN0VGltZTtcbiAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl90aWNrKTtcbiAgICB9XG4gIH1cbiAgX2NhbmNlbElmTmVlZGVkKCkge1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0SWQgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlcXVlc3RJZCk7XG4gICAgICB0aGlzLl9yZXF1ZXN0SWQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBfc3RhcnRJZlBvc3NpYmxlKCkge1xuICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuX3JlcXVlc3RJZk5lZWRlZCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hdXRvU3RhcnQpIHtcbiAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gIH1cbiAgYWRkKGZuLCBjb250ZXh0LCBwcmlvcml0eSA9IF9jb25zdC5VUERBVEVfUFJJT1JJVFkuTk9STUFMKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZExpc3RlbmVyKG5ldyBUaWNrZXJMaXN0ZW5lci5UaWNrZXJMaXN0ZW5lcihmbiwgY29udGV4dCwgcHJpb3JpdHkpKTtcbiAgfVxuICBhZGRPbmNlKGZuLCBjb250ZXh0LCBwcmlvcml0eSA9IF9jb25zdC5VUERBVEVfUFJJT1JJVFkuTk9STUFMKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZExpc3RlbmVyKG5ldyBUaWNrZXJMaXN0ZW5lci5UaWNrZXJMaXN0ZW5lcihmbiwgY29udGV4dCwgcHJpb3JpdHksIHRydWUpKTtcbiAgfVxuICBfYWRkTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQubmV4dDtcbiAgICBsZXQgcHJldmlvdXMgPSB0aGlzLl9oZWFkO1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgbGlzdGVuZXIuY29ubmVjdChwcmV2aW91cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgIGlmIChsaXN0ZW5lci5wcmlvcml0eSA+IGN1cnJlbnQucHJpb3JpdHkpIHtcbiAgICAgICAgICBsaXN0ZW5lci5jb25uZWN0KHByZXZpb3VzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICB9XG4gICAgICBpZiAoIWxpc3RlbmVyLnByZXZpb3VzKSB7XG4gICAgICAgIGxpc3RlbmVyLmNvbm5lY3QocHJldmlvdXMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9zdGFydElmUG9zc2libGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZW1vdmUoZm4sIGNvbnRleHQpIHtcbiAgICBsZXQgbGlzdGVuZXIgPSB0aGlzLl9oZWFkLm5leHQ7XG4gICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICBpZiAobGlzdGVuZXIubWF0Y2goZm4sIGNvbnRleHQpKSB7XG4gICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIuZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuX2hlYWQubmV4dCkge1xuICAgICAgdGhpcy5fY2FuY2VsSWZOZWVkZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0IGNvdW50KCkge1xuICAgIGlmICghdGhpcy5faGVhZCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGxldCBjb3VudCA9IDA7XG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgIHdoaWxlIChjdXJyZW50ID0gY3VycmVudC5uZXh0KSB7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgc3RhcnQoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICB0aGlzLl9yZXF1ZXN0SWZOZWVkZWQoKTtcbiAgICB9XG4gIH1cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NhbmNlbElmTmVlZGVkKCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKCF0aGlzLl9wcm90ZWN0ZWQpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgbGV0IGxpc3RlbmVyID0gdGhpcy5faGVhZC5uZXh0O1xuICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIuZGVzdHJveSh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hlYWQuZGVzdHJveSgpO1xuICAgICAgdGhpcy5faGVhZCA9IG51bGw7XG4gICAgfVxuICB9XG4gIHVwZGF0ZShjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpKSB7XG4gICAgbGV0IGVsYXBzZWRNUztcbiAgICBpZiAoY3VycmVudFRpbWUgPiB0aGlzLmxhc3RUaW1lKSB7XG4gICAgICBlbGFwc2VkTVMgPSB0aGlzLmVsYXBzZWRNUyA9IGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VGltZTtcbiAgICAgIGlmIChlbGFwc2VkTVMgPiB0aGlzLl9tYXhFbGFwc2VkTVMpIHtcbiAgICAgICAgZWxhcHNlZE1TID0gdGhpcy5fbWF4RWxhcHNlZE1TO1xuICAgICAgfVxuICAgICAgZWxhcHNlZE1TICo9IHRoaXMuc3BlZWQ7XG4gICAgICBpZiAodGhpcy5fbWluRWxhcHNlZE1TKSB7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gY3VycmVudFRpbWUgLSB0aGlzLl9sYXN0RnJhbWUgfCAwO1xuICAgICAgICBpZiAoZGVsdGEgPCB0aGlzLl9taW5FbGFwc2VkTVMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gY3VycmVudFRpbWUgLSBkZWx0YSAlIHRoaXMuX21pbkVsYXBzZWRNUztcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVsdGFNUyA9IGVsYXBzZWRNUztcbiAgICAgIHRoaXMuZGVsdGFUaW1lID0gdGhpcy5kZWx0YU1TICogX1RpY2tlci50YXJnZXRGUE1TO1xuICAgICAgY29uc3QgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICBsZXQgbGlzdGVuZXIgPSBoZWFkLm5leHQ7XG4gICAgICB3aGlsZSAobGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5lbWl0KHRoaXMuZGVsdGFUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmICghaGVhZC5uZXh0KSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbElmTmVlZGVkKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVsdGFUaW1lID0gdGhpcy5kZWx0YU1TID0gdGhpcy5lbGFwc2VkTVMgPSAwO1xuICAgIH1cbiAgICB0aGlzLmxhc3RUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cbiAgZ2V0IEZQUygpIHtcbiAgICByZXR1cm4gMWUzIC8gdGhpcy5lbGFwc2VkTVM7XG4gIH1cbiAgZ2V0IG1pbkZQUygpIHtcbiAgICByZXR1cm4gMWUzIC8gdGhpcy5fbWF4RWxhcHNlZE1TO1xuICB9XG4gIHNldCBtaW5GUFMoZnBzKSB7XG4gICAgY29uc3QgbWluRlBTID0gTWF0aC5taW4odGhpcy5tYXhGUFMsIGZwcyk7XG4gICAgY29uc3QgbWluRlBNUyA9IE1hdGgubWluKE1hdGgubWF4KDAsIG1pbkZQUykgLyAxZTMsIF9UaWNrZXIudGFyZ2V0RlBNUyk7XG4gICAgdGhpcy5fbWF4RWxhcHNlZE1TID0gMSAvIG1pbkZQTVM7XG4gIH1cbiAgZ2V0IG1heEZQUygpIHtcbiAgICBpZiAodGhpcy5fbWluRWxhcHNlZE1TKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCgxZTMgLyB0aGlzLl9taW5FbGFwc2VkTVMpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBzZXQgbWF4RlBTKGZwcykge1xuICAgIGlmIChmcHMgPT09IDApIHtcbiAgICAgIHRoaXMuX21pbkVsYXBzZWRNUyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1heEZQUyA9IE1hdGgubWF4KHRoaXMubWluRlBTLCBmcHMpO1xuICAgICAgdGhpcy5fbWluRWxhcHNlZE1TID0gMSAvIChtYXhGUFMgLyAxZTMpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IHNoYXJlZCgpIHtcbiAgICBpZiAoIV9UaWNrZXIuX3NoYXJlZCkge1xuICAgICAgY29uc3Qgc2hhcmVkID0gX1RpY2tlci5fc2hhcmVkID0gbmV3IF9UaWNrZXIoKTtcbiAgICAgIHNoYXJlZC5hdXRvU3RhcnQgPSB0cnVlO1xuICAgICAgc2hhcmVkLl9wcm90ZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gX1RpY2tlci5fc2hhcmVkO1xuICB9XG4gIHN0YXRpYyBnZXQgc3lzdGVtKCkge1xuICAgIGlmICghX1RpY2tlci5fc3lzdGVtKSB7XG4gICAgICBjb25zdCBzeXN0ZW0gPSBfVGlja2VyLl9zeXN0ZW0gPSBuZXcgX1RpY2tlcigpO1xuICAgICAgc3lzdGVtLmF1dG9TdGFydCA9IHRydWU7XG4gICAgICBzeXN0ZW0uX3Byb3RlY3RlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBfVGlja2VyLl9zeXN0ZW07XG4gIH1cbn07XG5sZXQgVGlja2VyID0gX1RpY2tlcjtcblRpY2tlci50YXJnZXRGUE1TID0gMC4wNjtcblxuZXhwb3J0cy5UaWNrZXIgPSBUaWNrZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWNrZXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNsYXNzIFRpY2tlckxpc3RlbmVyIHtcbiAgY29uc3RydWN0b3IoZm4sIGNvbnRleHQgPSBudWxsLCBwcmlvcml0eSA9IDAsIG9uY2UgPSBmYWxzZSkge1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5mbiA9IGZuO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xuICAgIHRoaXMub25jZSA9IG9uY2U7XG4gIH1cbiAgbWF0Y2goZm4sIGNvbnRleHQgPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZm4gPT09IGZuICYmIHRoaXMuY29udGV4dCA9PT0gY29udGV4dDtcbiAgfVxuICBlbWl0KGRlbHRhVGltZSkge1xuICAgIGlmICh0aGlzLmZuKSB7XG4gICAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuZm4uY2FsbCh0aGlzLmNvbnRleHQsIGRlbHRhVGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZuKGRlbHRhVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlZGlyZWN0ID0gdGhpcy5uZXh0O1xuICAgIGlmICh0aGlzLm9uY2UpIHtcbiAgICAgIHRoaXMuZGVzdHJveSh0cnVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlZGlyZWN0O1xuICB9XG4gIGNvbm5lY3QocHJldmlvdXMpIHtcbiAgICB0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgaWYgKHByZXZpb3VzLm5leHQpIHtcbiAgICAgIHByZXZpb3VzLm5leHQucHJldmlvdXMgPSB0aGlzO1xuICAgIH1cbiAgICB0aGlzLm5leHQgPSBwcmV2aW91cy5uZXh0O1xuICAgIHByZXZpb3VzLm5leHQgPSB0aGlzO1xuICB9XG4gIGRlc3Ryb3koaGFyZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLmZuID0gbnVsbDtcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIGlmICh0aGlzLnByZXZpb3VzKSB7XG4gICAgICB0aGlzLnByZXZpb3VzLm5leHQgPSB0aGlzLm5leHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgIHRoaXMubmV4dC5wcmV2aW91cyA9IHRoaXMucHJldmlvdXM7XG4gICAgfVxuICAgIGNvbnN0IHJlZGlyZWN0ID0gdGhpcy5uZXh0O1xuICAgIHRoaXMubmV4dCA9IGhhcmQgPyBudWxsIDogcmVkaXJlY3Q7XG4gICAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG4gICAgcmV0dXJuIHJlZGlyZWN0O1xuICB9XG59XG5cbmV4cG9ydHMuVGlja2VyTGlzdGVuZXIgPSBUaWNrZXJMaXN0ZW5lcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpY2tlckxpc3RlbmVyLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZXh0ZW5zaW9ucyA9IHJlcXVpcmUoJ0BwaXhpL2V4dGVuc2lvbnMnKTtcbnZhciBfY29uc3QgPSByZXF1aXJlKCcuL2NvbnN0LmpzJyk7XG52YXIgVGlja2VyID0gcmVxdWlyZSgnLi9UaWNrZXIuanMnKTtcblxuY2xhc3MgVGlja2VyUGx1Z2luIHtcbiAgc3RhdGljIGluaXQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGF1dG9TdGFydDogdHJ1ZSxcbiAgICAgIHNoYXJlZFRpY2tlcjogZmFsc2VcbiAgICB9LCBvcHRpb25zKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aWNrZXJcIiwge1xuICAgICAgc2V0KHRpY2tlcikge1xuICAgICAgICBpZiAodGhpcy5fdGlja2VyKSB7XG4gICAgICAgICAgdGhpcy5fdGlja2VyLnJlbW92ZSh0aGlzLnJlbmRlciwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGlja2VyID0gdGlja2VyO1xuICAgICAgICBpZiAodGlja2VyKSB7XG4gICAgICAgICAgdGlja2VyLmFkZCh0aGlzLnJlbmRlciwgdGhpcywgX2NvbnN0LlVQREFURV9QUklPUklUWS5MT1cpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlja2VyO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc3RvcCA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3RpY2tlci5zdG9wKCk7XG4gICAgfTtcbiAgICB0aGlzLnN0YXJ0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5fdGlja2VyLnN0YXJ0KCk7XG4gICAgfTtcbiAgICB0aGlzLl90aWNrZXIgPSBudWxsO1xuICAgIHRoaXMudGlja2VyID0gb3B0aW9ucy5zaGFyZWRUaWNrZXIgPyBUaWNrZXIuVGlja2VyLnNoYXJlZCA6IG5ldyBUaWNrZXIuVGlja2VyKCk7XG4gICAgaWYgKG9wdGlvbnMuYXV0b1N0YXJ0KSB7XG4gICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl90aWNrZXIpIHtcbiAgICAgIGNvbnN0IG9sZFRpY2tlciA9IHRoaXMuX3RpY2tlcjtcbiAgICAgIHRoaXMudGlja2VyID0gbnVsbDtcbiAgICAgIG9sZFRpY2tlci5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59XG5UaWNrZXJQbHVnaW4uZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLkFwcGxpY2F0aW9uO1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmFkZChUaWNrZXJQbHVnaW4pO1xuXG5leHBvcnRzLlRpY2tlclBsdWdpbiA9IFRpY2tlclBsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpY2tlclBsdWdpbi5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIFVQREFURV9QUklPUklUWSA9IC8qIEBfX1BVUkVfXyAqLyAoKFVQREFURV9QUklPUklUWTIpID0+IHtcbiAgVVBEQVRFX1BSSU9SSVRZMltVUERBVEVfUFJJT1JJVFkyW1wiSU5URVJBQ1RJT05cIl0gPSA1MF0gPSBcIklOVEVSQUNUSU9OXCI7XG4gIFVQREFURV9QUklPUklUWTJbVVBEQVRFX1BSSU9SSVRZMltcIkhJR0hcIl0gPSAyNV0gPSBcIkhJR0hcIjtcbiAgVVBEQVRFX1BSSU9SSVRZMltVUERBVEVfUFJJT1JJVFkyW1wiTk9STUFMXCJdID0gMF0gPSBcIk5PUk1BTFwiO1xuICBVUERBVEVfUFJJT1JJVFkyW1VQREFURV9QUklPUklUWTJbXCJMT1dcIl0gPSAtMjVdID0gXCJMT1dcIjtcbiAgVVBEQVRFX1BSSU9SSVRZMltVUERBVEVfUFJJT1JJVFkyW1wiVVRJTElUWVwiXSA9IC01MF0gPSBcIlVUSUxJVFlcIjtcbiAgcmV0dXJuIFVQREFURV9QUklPUklUWTI7XG59KShVUERBVEVfUFJJT1JJVFkgfHwge30pO1xuXG5leHBvcnRzLlVQREFURV9QUklPUklUWSA9IFVQREFURV9QUklPUklUWTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5yZXF1aXJlKCcuL3NldHRpbmdzLmpzJyk7XG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi9jb25zdC5qcycpO1xudmFyIFRpY2tlciA9IHJlcXVpcmUoJy4vVGlja2VyLmpzJyk7XG52YXIgVGlja2VyUGx1Z2luID0gcmVxdWlyZSgnLi9UaWNrZXJQbHVnaW4uanMnKTtcblxuXG5cbmV4cG9ydHMuVVBEQVRFX1BSSU9SSVRZID0gX2NvbnN0LlVQREFURV9QUklPUklUWTtcbmV4cG9ydHMuVGlja2VyID0gVGlja2VyLlRpY2tlcjtcbmV4cG9ydHMuVGlja2VyUGx1Z2luID0gVGlja2VyUGx1Z2luLlRpY2tlclBsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgc2V0dGluZ3MgPSByZXF1aXJlKCdAcGl4aS9zZXR0aW5ncycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQHBpeGkvdXRpbHMnKTtcbnZhciBUaWNrZXIgPSByZXF1aXJlKCcuL1RpY2tlci5qcycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhzZXR0aW5ncy5zZXR0aW5ncywge1xuICBUQVJHRVRfRlBNUzoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBUaWNrZXIuVGlja2VyLnRhcmdldEZQTVM7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5UQVJHRVRfRlBNUyBpcyBkZXByZWNhdGVkLCB1c2UgVGlja2VyLnRhcmdldEZQTVNcIik7XG4gICAgICBUaWNrZXIuVGlja2VyLnRhcmdldEZQTVMgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3NldHRpbmdzJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXR0aW5ncy5zZXR0aW5nczsgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXR0aW5ncy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGRlcHJlY2F0aW9uID0gcmVxdWlyZSgnLi4vbG9nZ2luZy9kZXByZWNhdGlvbi5qcycpO1xuXG5mdW5jdGlvbiBza2lwSGVsbG8oKSB7XG4gIGRlcHJlY2F0aW9uLmRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJza2lwSGVsbG8gaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBzZXR0aW5ncy5SRU5ERVJfT1BUSU9OUy5oZWxsb1wiKTtcbn1cbmZ1bmN0aW9uIHNheUhlbGxvKCkge1xuICBkZXByZWNhdGlvbi5kZXByZWNhdGlvbihcIjcuMC4wXCIsIGBzYXlIZWxsbyBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIFJlbmRlcmVyJ3MgXCJoZWxsb1wiIG9wdGlvbmApO1xufVxuXG5leHBvcnRzLnNheUhlbGxvID0gc2F5SGVsbG87XG5leHBvcnRzLnNraXBIZWxsbyA9IHNraXBIZWxsbztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbGxvLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5yZXF1aXJlKCcuLi9zZXR0aW5ncy5qcycpO1xudmFyIHNldHRpbmdzID0gcmVxdWlyZSgnQHBpeGkvc2V0dGluZ3MnKTtcblxubGV0IHN1cHBvcnRlZDtcbmZ1bmN0aW9uIGlzV2ViR0xTdXBwb3J0ZWQoKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydGVkID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgc3VwcG9ydGVkID0gZnVuY3Rpb24gc3VwcG9ydGVkMigpIHtcbiAgICAgIGNvbnN0IGNvbnRleHRPcHRpb25zID0ge1xuICAgICAgICBzdGVuY2lsOiB0cnVlLFxuICAgICAgICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiBzZXR0aW5ncy5zZXR0aW5ncy5GQUlMX0lGX01BSk9SX1BFUkZPUk1BTkNFX0NBVkVBVFxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghc2V0dGluZ3Muc2V0dGluZ3MuQURBUFRFUi5nZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQoKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW52YXMgPSBzZXR0aW5ncy5zZXR0aW5ncy5BREFQVEVSLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgICBsZXQgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsIGNvbnRleHRPcHRpb25zKSB8fCBjYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBjb250ZXh0T3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSAhIWdsPy5nZXRDb250ZXh0QXR0cmlidXRlcygpPy5zdGVuY2lsO1xuICAgICAgICBpZiAoZ2wpIHtcbiAgICAgICAgICBjb25zdCBsb3NlQ29udGV4dCA9IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2xvc2VfY29udGV4dFwiKTtcbiAgICAgICAgICBpZiAobG9zZUNvbnRleHQpIHtcbiAgICAgICAgICAgIGxvc2VDb250ZXh0Lmxvc2VDb250ZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdsID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KCk7XG4gIH1cbiAgcmV0dXJuIHN1cHBvcnRlZDtcbn1cblxuZXhwb3J0cy5pc1dlYkdMU3VwcG9ydGVkID0gaXNXZWJHTFN1cHBvcnRlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzV2ViR0xTdXBwb3J0ZWQuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb2xvciA9IHJlcXVpcmUoJ0BwaXhpL2NvbG9yJyk7XG52YXIgZGVwcmVjYXRpb24gPSByZXF1aXJlKCcuLi9sb2dnaW5nL2RlcHJlY2F0aW9uLmpzJyk7XG5cbmZ1bmN0aW9uIGhleDJyZ2IoaGV4LCBvdXQgPSBbXSkge1xuICBkZXByZWNhdGlvbi5kZXByZWNhdGlvbihcIjcuMi4wXCIsIFwidXRpbHMuaGV4MnJnYiBpcyBkZXByZWNhdGVkLCB1c2UgQ29sb3IjdG9SZ2JBcnJheSBpbnN0ZWFkXCIpO1xuICByZXR1cm4gY29sb3IuQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGhleCkudG9SZ2JBcnJheShvdXQpO1xufVxuZnVuY3Rpb24gaGV4MnN0cmluZyhoZXgpIHtcbiAgZGVwcmVjYXRpb24uZGVwcmVjYXRpb24oXCI3LjIuMFwiLCBcInV0aWxzLmhleDJzdHJpbmcgaXMgZGVwcmVjYXRlZCwgdXNlIENvbG9yI3RvSGV4IGluc3RlYWRcIik7XG4gIHJldHVybiBjb2xvci5Db2xvci5zaGFyZWQuc2V0VmFsdWUoaGV4KS50b0hleCgpO1xufVxuZnVuY3Rpb24gc3RyaW5nMmhleChzdHJpbmcpIHtcbiAgZGVwcmVjYXRpb24uZGVwcmVjYXRpb24oXCI3LjIuMFwiLCBcInV0aWxzLnN0cmluZzJoZXggaXMgZGVwcmVjYXRlZCwgdXNlIENvbG9yI3RvTnVtYmVyIGluc3RlYWRcIik7XG4gIHJldHVybiBjb2xvci5Db2xvci5zaGFyZWQuc2V0VmFsdWUoc3RyaW5nKS50b051bWJlcigpO1xufVxuZnVuY3Rpb24gcmdiMmhleChyZ2IpIHtcbiAgZGVwcmVjYXRpb24uZGVwcmVjYXRpb24oXCI3LjIuMFwiLCBcInV0aWxzLnJnYjJoZXggaXMgZGVwcmVjYXRlZCwgdXNlIENvbG9yI3RvTnVtYmVyIGluc3RlYWRcIik7XG4gIHJldHVybiBjb2xvci5Db2xvci5zaGFyZWQuc2V0VmFsdWUocmdiKS50b051bWJlcigpO1xufVxuXG5leHBvcnRzLmhleDJyZ2IgPSBoZXgycmdiO1xuZXhwb3J0cy5oZXgyc3RyaW5nID0gaGV4MnN0cmluZztcbmV4cG9ydHMucmdiMmhleCA9IHJnYjJoZXg7XG5leHBvcnRzLnN0cmluZzJoZXggPSBzdHJpbmcyaGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29sb3IgPSByZXF1aXJlKCdAcGl4aS9jb2xvcicpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ0BwaXhpL2NvbnN0YW50cycpO1xudmFyIGRlcHJlY2F0aW9uID0gcmVxdWlyZSgnLi4vbG9nZ2luZy9kZXByZWNhdGlvbi5qcycpO1xuXG5mdW5jdGlvbiBtYXBQcmVtdWx0aXBsaWVkQmxlbmRNb2RlcygpIHtcbiAgY29uc3QgcG0gPSBbXTtcbiAgY29uc3QgbnBtID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIHBtW2ldID0gaTtcbiAgICBucG1baV0gPSBpO1xuICB9XG4gIHBtW2NvbnN0YW50cy5CTEVORF9NT0RFUy5OT1JNQUxfTlBNXSA9IGNvbnN0YW50cy5CTEVORF9NT0RFUy5OT1JNQUw7XG4gIHBtW2NvbnN0YW50cy5CTEVORF9NT0RFUy5BRERfTlBNXSA9IGNvbnN0YW50cy5CTEVORF9NT0RFUy5BREQ7XG4gIHBtW2NvbnN0YW50cy5CTEVORF9NT0RFUy5TQ1JFRU5fTlBNXSA9IGNvbnN0YW50cy5CTEVORF9NT0RFUy5TQ1JFRU47XG4gIG5wbVtjb25zdGFudHMuQkxFTkRfTU9ERVMuTk9STUFMXSA9IGNvbnN0YW50cy5CTEVORF9NT0RFUy5OT1JNQUxfTlBNO1xuICBucG1bY29uc3RhbnRzLkJMRU5EX01PREVTLkFERF0gPSBjb25zdGFudHMuQkxFTkRfTU9ERVMuQUREX05QTTtcbiAgbnBtW2NvbnN0YW50cy5CTEVORF9NT0RFUy5TQ1JFRU5dID0gY29uc3RhbnRzLkJMRU5EX01PREVTLlNDUkVFTl9OUE07XG4gIGNvbnN0IGFycmF5ID0gW107XG4gIGFycmF5LnB1c2gobnBtKTtcbiAgYXJyYXkucHVzaChwbSk7XG4gIHJldHVybiBhcnJheTtcbn1cbmNvbnN0IHByZW11bHRpcGx5QmxlbmRNb2RlID0gbWFwUHJlbXVsdGlwbGllZEJsZW5kTW9kZXMoKTtcbmZ1bmN0aW9uIGNvcnJlY3RCbGVuZE1vZGUoYmxlbmRNb2RlLCBwcmVtdWx0aXBsaWVkKSB7XG4gIHJldHVybiBwcmVtdWx0aXBseUJsZW5kTW9kZVtwcmVtdWx0aXBsaWVkID8gMSA6IDBdW2JsZW5kTW9kZV07XG59XG5mdW5jdGlvbiBwcmVtdWx0aXBseVJnYmEocmdiLCBhbHBoYSwgb3V0LCBwcmVtdWx0aXBseSA9IHRydWUpIHtcbiAgZGVwcmVjYXRpb24uZGVwcmVjYXRpb24oXCI3LjIuMFwiLCBgdXRpbHMucHJlbXVsdGlwbHlSZ2JhIGhhcyBtb3ZlZCB0byBDb2xvci5wcmVtdWx0aXBseWApO1xuICByZXR1cm4gY29sb3IuQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHJnYikucHJlbXVsdGlwbHkoYWxwaGEsIHByZW11bHRpcGx5KS50b0FycmF5KG91dCA/PyBuZXcgRmxvYXQzMkFycmF5KDQpKTtcbn1cbmZ1bmN0aW9uIHByZW11bHRpcGx5VGludCh0aW50LCBhbHBoYSkge1xuICBkZXByZWNhdGlvbi5kZXByZWNhdGlvbihcIjcuMi4wXCIsIGB1dGlscy5wcmVtdWx0aXBseVRpbnQgaGFzIG1vdmVkIHRvIENvbG9yLnRvUHJlbXVsdGlwbGllZGApO1xuICByZXR1cm4gY29sb3IuQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHRpbnQpLnRvUHJlbXVsdGlwbGllZChhbHBoYSk7XG59XG5mdW5jdGlvbiBwcmVtdWx0aXBseVRpbnRUb1JnYmEodGludCwgYWxwaGEsIG91dCwgcHJlbXVsdGlwbHkgPSB0cnVlKSB7XG4gIGRlcHJlY2F0aW9uLmRlcHJlY2F0aW9uKFwiNy4yLjBcIiwgYHV0aWxzLnByZW11bHRpcGx5VGludFRvUmdiYSBoYXMgbW92ZWQgdG8gQ29sb3IucHJlbXVsdGlwbHlgKTtcbiAgcmV0dXJuIGNvbG9yLkNvbG9yLnNoYXJlZC5zZXRWYWx1ZSh0aW50KS5wcmVtdWx0aXBseShhbHBoYSwgcHJlbXVsdGlwbHkpLnRvQXJyYXkob3V0ID8/IG5ldyBGbG9hdDMyQXJyYXkoNCkpO1xufVxuXG5leHBvcnRzLmNvcnJlY3RCbGVuZE1vZGUgPSBjb3JyZWN0QmxlbmRNb2RlO1xuZXhwb3J0cy5wcmVtdWx0aXBseUJsZW5kTW9kZSA9IHByZW11bHRpcGx5QmxlbmRNb2RlO1xuZXhwb3J0cy5wcmVtdWx0aXBseVJnYmEgPSBwcmVtdWx0aXBseVJnYmE7XG5leHBvcnRzLnByZW11bHRpcGx5VGludCA9IHByZW11bHRpcGx5VGludDtcbmV4cG9ydHMucHJlbXVsdGlwbHlUaW50VG9SZ2JhID0gcHJlbXVsdGlwbHlUaW50VG9SZ2JhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlbXVsdGlwbHkuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNvbnN0IERBVEFfVVJJID0gL15cXHMqZGF0YTooPzooW1xcdy1dKylcXC8oW1xcdysuLV0rKSk/KD86O2NoYXJzZXQ9KFtcXHctXSspKT8oPzo7KGJhc2U2NCkpPywoLiopL2k7XG5cbmV4cG9ydHMuREFUQV9VUkkgPSBEQVRBX1VSSTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBjcmVhdGVJbmRpY2VzRm9yUXVhZHMoc2l6ZSwgb3V0QnVmZmVyID0gbnVsbCkge1xuICBjb25zdCB0b3RhbEluZGljZXMgPSBzaXplICogNjtcbiAgb3V0QnVmZmVyID0gb3V0QnVmZmVyIHx8IG5ldyBVaW50MTZBcnJheSh0b3RhbEluZGljZXMpO1xuICBpZiAob3V0QnVmZmVyLmxlbmd0aCAhPT0gdG90YWxJbmRpY2VzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBPdXQgYnVmZmVyIGxlbmd0aCBpcyBpbmNvcnJlY3QsIGdvdCAke291dEJ1ZmZlci5sZW5ndGh9IGFuZCBleHBlY3RlZCAke3RvdGFsSW5kaWNlc31gKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCB0b3RhbEluZGljZXM7IGkgKz0gNiwgaiArPSA0KSB7XG4gICAgb3V0QnVmZmVyW2kgKyAwXSA9IGogKyAwO1xuICAgIG91dEJ1ZmZlcltpICsgMV0gPSBqICsgMTtcbiAgICBvdXRCdWZmZXJbaSArIDJdID0gaiArIDI7XG4gICAgb3V0QnVmZmVyW2kgKyAzXSA9IGogKyAwO1xuICAgIG91dEJ1ZmZlcltpICsgNF0gPSBqICsgMjtcbiAgICBvdXRCdWZmZXJbaSArIDVdID0gaiArIDM7XG4gIH1cbiAgcmV0dXJuIG91dEJ1ZmZlcjtcbn1cblxuZXhwb3J0cy5jcmVhdGVJbmRpY2VzRm9yUXVhZHMgPSBjcmVhdGVJbmRpY2VzRm9yUXVhZHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVJbmRpY2VzRm9yUXVhZHMuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIGdldEJ1ZmZlclR5cGUoYXJyYXkpIHtcbiAgaWYgKGFycmF5LkJZVEVTX1BFUl9FTEVNRU5UID09PSA0KSB7XG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICByZXR1cm4gXCJGbG9hdDMyQXJyYXlcIjtcbiAgICB9IGVsc2UgaWYgKGFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkpIHtcbiAgICAgIHJldHVybiBcIlVpbnQzMkFycmF5XCI7XG4gICAgfVxuICAgIHJldHVybiBcIkludDMyQXJyYXlcIjtcbiAgfSBlbHNlIGlmIChhcnJheS5CWVRFU19QRVJfRUxFTUVOVCA9PT0gMikge1xuICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KSB7XG4gICAgICByZXR1cm4gXCJVaW50MTZBcnJheVwiO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcnJheS5CWVRFU19QRVJfRUxFTUVOVCA9PT0gMSkge1xuICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHJldHVybiBcIlVpbnQ4QXJyYXlcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydHMuZ2V0QnVmZmVyVHlwZSA9IGdldEJ1ZmZlclR5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRCdWZmZXJUeXBlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZ2V0QnVmZmVyVHlwZSA9IHJlcXVpcmUoJy4vZ2V0QnVmZmVyVHlwZS5qcycpO1xuXG5jb25zdCBtYXAgPSB7IEZsb2F0MzJBcnJheSwgVWludDMyQXJyYXksIEludDMyQXJyYXksIFVpbnQ4QXJyYXkgfTtcbmZ1bmN0aW9uIGludGVybGVhdmVUeXBlZEFycmF5cyhhcnJheXMsIHNpemVzKSB7XG4gIGxldCBvdXRTaXplID0gMDtcbiAgbGV0IHN0cmlkZSA9IDA7XG4gIGNvbnN0IHZpZXdzID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3RyaWRlICs9IHNpemVzW2ldO1xuICAgIG91dFNpemUgKz0gYXJyYXlzW2ldLmxlbmd0aDtcbiAgfVxuICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIob3V0U2l6ZSAqIDQpO1xuICBsZXQgb3V0ID0gbnVsbDtcbiAgbGV0IGxpdHRsZU9mZnNldCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHNpemVzW2ldO1xuICAgIGNvbnN0IGFycmF5ID0gYXJyYXlzW2ldO1xuICAgIGNvbnN0IHR5cGUgPSBnZXRCdWZmZXJUeXBlLmdldEJ1ZmZlclR5cGUoYXJyYXkpO1xuICAgIGlmICghdmlld3NbdHlwZV0pIHtcbiAgICAgIHZpZXdzW3R5cGVdID0gbmV3IG1hcFt0eXBlXShidWZmZXIpO1xuICAgIH1cbiAgICBvdXQgPSB2aWV3c1t0eXBlXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBpbmRleFN0YXJ0ID0gKGogLyBzaXplIHwgMCkgKiBzdHJpZGUgKyBsaXR0bGVPZmZzZXQ7XG4gICAgICBjb25zdCBpbmRleCA9IGogJSBzaXplO1xuICAgICAgb3V0W2luZGV4U3RhcnQgKyBpbmRleF0gPSBhcnJheVtqXTtcbiAgICB9XG4gICAgbGl0dGxlT2Zmc2V0ICs9IHNpemU7XG4gIH1cbiAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcbn1cblxuZXhwb3J0cy5pbnRlcmxlYXZlVHlwZWRBcnJheXMgPSBpbnRlcmxlYXZlVHlwZWRBcnJheXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmxlYXZlVHlwZWRBcnJheXMuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIG5leHRQb3cyKHYpIHtcbiAgdiArPSB2ID09PSAwID8gMSA6IDA7XG4gIC0tdjtcbiAgdiB8PSB2ID4+PiAxO1xuICB2IHw9IHYgPj4+IDI7XG4gIHYgfD0gdiA+Pj4gNDtcbiAgdiB8PSB2ID4+PiA4O1xuICB2IHw9IHYgPj4+IDE2O1xuICByZXR1cm4gdiArIDE7XG59XG5mdW5jdGlvbiBpc1BvdzIodikge1xuICByZXR1cm4gISh2ICYgdiAtIDEpICYmICEhdjtcbn1cbmZ1bmN0aW9uIGxvZzIodikge1xuICBsZXQgciA9ICh2ID4gNjU1MzUgPyAxIDogMCkgPDwgNDtcbiAgdiA+Pj49IHI7XG4gIGxldCBzaGlmdCA9ICh2ID4gMjU1ID8gMSA6IDApIDw8IDM7XG4gIHYgPj4+PSBzaGlmdDtcbiAgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDE1ID8gMSA6IDApIDw8IDI7XG4gIHYgPj4+PSBzaGlmdDtcbiAgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDMgPyAxIDogMCkgPDwgMTtcbiAgdiA+Pj49IHNoaWZ0O1xuICByIHw9IHNoaWZ0O1xuICByZXR1cm4gciB8IHYgPj4gMTtcbn1cblxuZXhwb3J0cy5pc1BvdzIgPSBpc1BvdzI7XG5leHBvcnRzLmxvZzIgPSBsb2cyO1xuZXhwb3J0cy5uZXh0UG93MiA9IG5leHRQb3cyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG93Mi5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gcmVtb3ZlSXRlbXMoYXJyLCBzdGFydElkeCwgcmVtb3ZlQ291bnQpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgbGV0IGk7XG4gIGlmIChzdGFydElkeCA+PSBsZW5ndGggfHwgcmVtb3ZlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVtb3ZlQ291bnQgPSBzdGFydElkeCArIHJlbW92ZUNvdW50ID4gbGVuZ3RoID8gbGVuZ3RoIC0gc3RhcnRJZHggOiByZW1vdmVDb3VudDtcbiAgY29uc3QgbGVuID0gbGVuZ3RoIC0gcmVtb3ZlQ291bnQ7XG4gIGZvciAoaSA9IHN0YXJ0SWR4OyBpIDwgbGVuOyArK2kpIHtcbiAgICBhcnJbaV0gPSBhcnJbaSArIHJlbW92ZUNvdW50XTtcbiAgfVxuICBhcnIubGVuZ3RoID0gbGVuO1xufVxuXG5leHBvcnRzLnJlbW92ZUl0ZW1zID0gcmVtb3ZlSXRlbXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmVJdGVtcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gc2lnbihuKSB7XG4gIGlmIChuID09PSAwKVxuICAgIHJldHVybiAwO1xuICByZXR1cm4gbiA8IDAgPyAtMSA6IDE7XG59XG5cbmV4cG9ydHMuc2lnbiA9IHNpZ247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5sZXQgbmV4dFVpZCA9IDA7XG5mdW5jdGlvbiB1aWQoKSB7XG4gIHJldHVybiArK25leHRVaWQ7XG59XG5cbmV4cG9ydHMudWlkID0gdWlkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWlkLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5yZXF1aXJlKCcuL3NldHRpbmdzLmpzJyk7XG52YXIgc2V0dGluZ3MgPSByZXF1aXJlKCdAcGl4aS9zZXR0aW5ncycpO1xudmFyIGV2ZW50ZW1pdHRlcjMgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIzJyk7XG52YXIgZWFyY3V0ID0gcmVxdWlyZSgnZWFyY3V0Jyk7XG52YXIgdXJsID0gcmVxdWlyZSgnLi91cmwuanMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi9wYXRoLmpzJyk7XG52YXIgaGVsbG8gPSByZXF1aXJlKCcuL2Jyb3dzZXIvaGVsbG8uanMnKTtcbnZhciBpc1dlYkdMU3VwcG9ydGVkID0gcmVxdWlyZSgnLi9icm93c2VyL2lzV2ViR0xTdXBwb3J0ZWQuanMnKTtcbnZhciBoZXggPSByZXF1aXJlKCcuL2NvbG9yL2hleC5qcycpO1xudmFyIHByZW11bHRpcGx5ID0gcmVxdWlyZSgnLi9jb2xvci9wcmVtdWx0aXBseS5qcycpO1xudmFyIF9jb25zdCA9IHJlcXVpcmUoJy4vY29uc3QuanMnKTtcbnZhciBjcmVhdGVJbmRpY2VzRm9yUXVhZHMgPSByZXF1aXJlKCcuL2RhdGEvY3JlYXRlSW5kaWNlc0ZvclF1YWRzLmpzJyk7XG52YXIgZ2V0QnVmZmVyVHlwZSA9IHJlcXVpcmUoJy4vZGF0YS9nZXRCdWZmZXJUeXBlLmpzJyk7XG52YXIgaW50ZXJsZWF2ZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnLi9kYXRhL2ludGVybGVhdmVUeXBlZEFycmF5cy5qcycpO1xudmFyIHBvdzIgPSByZXF1aXJlKCcuL2RhdGEvcG93Mi5qcycpO1xudmFyIHJlbW92ZUl0ZW1zID0gcmVxdWlyZSgnLi9kYXRhL3JlbW92ZUl0ZW1zLmpzJyk7XG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vZGF0YS9zaWduLmpzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9kYXRhL3VpZC5qcycpO1xudmFyIGRlcHJlY2F0aW9uID0gcmVxdWlyZSgnLi9sb2dnaW5nL2RlcHJlY2F0aW9uLmpzJyk7XG52YXIgQm91bmRpbmdCb3ggPSByZXF1aXJlKCcuL21lZGlhL0JvdW5kaW5nQm94LmpzJyk7XG52YXIgY2FjaGVzID0gcmVxdWlyZSgnLi9tZWRpYS9jYWNoZXMuanMnKTtcbnZhciBDYW52YXNSZW5kZXJUYXJnZXQgPSByZXF1aXJlKCcuL21lZGlhL0NhbnZhc1JlbmRlclRhcmdldC5qcycpO1xudmFyIGdldENhbnZhc0JvdW5kaW5nQm94ID0gcmVxdWlyZSgnLi9tZWRpYS9nZXRDYW52YXNCb3VuZGluZ0JveC5qcycpO1xudmFyIHRyaW1DYW52YXMgPSByZXF1aXJlKCcuL21lZGlhL3RyaW1DYW52YXMuanMnKTtcbnZhciBkZWNvbXBvc2VEYXRhVXJpID0gcmVxdWlyZSgnLi9uZXR3b3JrL2RlY29tcG9zZURhdGFVcmkuanMnKTtcbnZhciBkZXRlcm1pbmVDcm9zc09yaWdpbiA9IHJlcXVpcmUoJy4vbmV0d29yay9kZXRlcm1pbmVDcm9zc09yaWdpbi5qcycpO1xudmFyIGdldFJlc29sdXRpb25PZlVybCA9IHJlcXVpcmUoJy4vbmV0d29yay9nZXRSZXNvbHV0aW9uT2ZVcmwuanMnKTtcbnJlcXVpcmUoJy4vdHlwZXMvaW5kZXguanMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBldmVudGVtaXR0ZXIzX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShldmVudGVtaXR0ZXIzKTtcbnZhciBlYXJjdXRfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KGVhcmN1dCk7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2lzTW9iaWxlJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldHRpbmdzLmlzTW9iaWxlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRXZlbnRFbWl0dGVyJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV2ZW50ZW1pdHRlcjNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZWFyY3V0Jywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVhcmN1dF9fZGVmYXVsdFtcImRlZmF1bHRcIl07IH1cbn0pO1xuZXhwb3J0cy51cmwgPSB1cmwudXJsO1xuZXhwb3J0cy5wYXRoID0gcGF0aC5wYXRoO1xuZXhwb3J0cy5zYXlIZWxsbyA9IGhlbGxvLnNheUhlbGxvO1xuZXhwb3J0cy5za2lwSGVsbG8gPSBoZWxsby5za2lwSGVsbG87XG5leHBvcnRzLmlzV2ViR0xTdXBwb3J0ZWQgPSBpc1dlYkdMU3VwcG9ydGVkLmlzV2ViR0xTdXBwb3J0ZWQ7XG5leHBvcnRzLmhleDJyZ2IgPSBoZXguaGV4MnJnYjtcbmV4cG9ydHMuaGV4MnN0cmluZyA9IGhleC5oZXgyc3RyaW5nO1xuZXhwb3J0cy5yZ2IyaGV4ID0gaGV4LnJnYjJoZXg7XG5leHBvcnRzLnN0cmluZzJoZXggPSBoZXguc3RyaW5nMmhleDtcbmV4cG9ydHMuY29ycmVjdEJsZW5kTW9kZSA9IHByZW11bHRpcGx5LmNvcnJlY3RCbGVuZE1vZGU7XG5leHBvcnRzLnByZW11bHRpcGx5QmxlbmRNb2RlID0gcHJlbXVsdGlwbHkucHJlbXVsdGlwbHlCbGVuZE1vZGU7XG5leHBvcnRzLnByZW11bHRpcGx5UmdiYSA9IHByZW11bHRpcGx5LnByZW11bHRpcGx5UmdiYTtcbmV4cG9ydHMucHJlbXVsdGlwbHlUaW50ID0gcHJlbXVsdGlwbHkucHJlbXVsdGlwbHlUaW50O1xuZXhwb3J0cy5wcmVtdWx0aXBseVRpbnRUb1JnYmEgPSBwcmVtdWx0aXBseS5wcmVtdWx0aXBseVRpbnRUb1JnYmE7XG5leHBvcnRzLkRBVEFfVVJJID0gX2NvbnN0LkRBVEFfVVJJO1xuZXhwb3J0cy5jcmVhdGVJbmRpY2VzRm9yUXVhZHMgPSBjcmVhdGVJbmRpY2VzRm9yUXVhZHMuY3JlYXRlSW5kaWNlc0ZvclF1YWRzO1xuZXhwb3J0cy5nZXRCdWZmZXJUeXBlID0gZ2V0QnVmZmVyVHlwZS5nZXRCdWZmZXJUeXBlO1xuZXhwb3J0cy5pbnRlcmxlYXZlVHlwZWRBcnJheXMgPSBpbnRlcmxlYXZlVHlwZWRBcnJheXMuaW50ZXJsZWF2ZVR5cGVkQXJyYXlzO1xuZXhwb3J0cy5pc1BvdzIgPSBwb3cyLmlzUG93MjtcbmV4cG9ydHMubG9nMiA9IHBvdzIubG9nMjtcbmV4cG9ydHMubmV4dFBvdzIgPSBwb3cyLm5leHRQb3cyO1xuZXhwb3J0cy5yZW1vdmVJdGVtcyA9IHJlbW92ZUl0ZW1zLnJlbW92ZUl0ZW1zO1xuZXhwb3J0cy5zaWduID0gc2lnbi5zaWduO1xuZXhwb3J0cy51aWQgPSB1aWQudWlkO1xuZXhwb3J0cy5kZXByZWNhdGlvbiA9IGRlcHJlY2F0aW9uLmRlcHJlY2F0aW9uO1xuZXhwb3J0cy5Cb3VuZGluZ0JveCA9IEJvdW5kaW5nQm94LkJvdW5kaW5nQm94O1xuZXhwb3J0cy5CYXNlVGV4dHVyZUNhY2hlID0gY2FjaGVzLkJhc2VUZXh0dXJlQ2FjaGU7XG5leHBvcnRzLlByb2dyYW1DYWNoZSA9IGNhY2hlcy5Qcm9ncmFtQ2FjaGU7XG5leHBvcnRzLlRleHR1cmVDYWNoZSA9IGNhY2hlcy5UZXh0dXJlQ2FjaGU7XG5leHBvcnRzLmNsZWFyVGV4dHVyZUNhY2hlID0gY2FjaGVzLmNsZWFyVGV4dHVyZUNhY2hlO1xuZXhwb3J0cy5kZXN0cm95VGV4dHVyZUNhY2hlID0gY2FjaGVzLmRlc3Ryb3lUZXh0dXJlQ2FjaGU7XG5leHBvcnRzLkNhbnZhc1JlbmRlclRhcmdldCA9IENhbnZhc1JlbmRlclRhcmdldC5DYW52YXNSZW5kZXJUYXJnZXQ7XG5leHBvcnRzLmdldENhbnZhc0JvdW5kaW5nQm94ID0gZ2V0Q2FudmFzQm91bmRpbmdCb3guZ2V0Q2FudmFzQm91bmRpbmdCb3g7XG5leHBvcnRzLnRyaW1DYW52YXMgPSB0cmltQ2FudmFzLnRyaW1DYW52YXM7XG5leHBvcnRzLmRlY29tcG9zZURhdGFVcmkgPSBkZWNvbXBvc2VEYXRhVXJpLmRlY29tcG9zZURhdGFVcmk7XG5leHBvcnRzLmRldGVybWluZUNyb3NzT3JpZ2luID0gZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4uZGV0ZXJtaW5lQ3Jvc3NPcmlnaW47XG5leHBvcnRzLmdldFJlc29sdXRpb25PZlVybCA9IGdldFJlc29sdXRpb25PZlVybC5nZXRSZXNvbHV0aW9uT2ZVcmw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY29uc3Qgd2FybmluZ3MgPSB7fTtcbmZ1bmN0aW9uIGRlcHJlY2F0aW9uKHZlcnNpb24sIG1lc3NhZ2UsIGlnbm9yZURlcHRoID0gMykge1xuICBpZiAod2FybmluZ3NbbWVzc2FnZV0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gIGlmICh0eXBlb2Ygc3RhY2sgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjb25zb2xlLndhcm4oXCJQaXhpSlMgRGVwcmVjYXRpb24gV2FybmluZzogXCIsIGAke21lc3NhZ2V9XG5EZXByZWNhdGVkIHNpbmNlIHYke3ZlcnNpb259YCk7XG4gIH0gZWxzZSB7XG4gICAgc3RhY2sgPSBzdGFjay5zcGxpdChcIlxcblwiKS5zcGxpY2UoaWdub3JlRGVwdGgpLmpvaW4oXCJcXG5cIik7XG4gICAgaWYgKGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQpIHtcbiAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXCIlY1BpeGlKUyBEZXByZWNhdGlvbiBXYXJuaW5nOiAlYyVzXCIsIFwiY29sb3I6IzYxNDEwODtiYWNrZ3JvdW5kOiNmZmZiZTZcIiwgXCJmb250LXdlaWdodDpub3JtYWw7Y29sb3I6IzYxNDEwODtiYWNrZ3JvdW5kOiNmZmZiZTZcIiwgYCR7bWVzc2FnZX1cbkRlcHJlY2F0ZWQgc2luY2UgdiR7dmVyc2lvbn1gKTtcbiAgICAgIGNvbnNvbGUud2FybihzdGFjayk7XG4gICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlBpeGlKUyBEZXByZWNhdGlvbiBXYXJuaW5nOiBcIiwgYCR7bWVzc2FnZX1cbkRlcHJlY2F0ZWQgc2luY2UgdiR7dmVyc2lvbn1gKTtcbiAgICAgIGNvbnNvbGUud2FybihzdGFjayk7XG4gICAgfVxuICB9XG4gIHdhcm5pbmdzW21lc3NhZ2VdID0gdHJ1ZTtcbn1cblxuZXhwb3J0cy5kZXByZWNhdGlvbiA9IGRlcHJlY2F0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVwcmVjYXRpb24uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNvbnN0IF9Cb3VuZGluZ0JveCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobGVmdCwgdG9wLCByaWdodCwgYm90dG9tKSB7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgdGhpcy5ib3R0b20gPSBib3R0b207XG4gIH1cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0O1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm90dG9tIC0gdGhpcy50b3A7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0ID09PSB0aGlzLnJpZ2h0IHx8IHRoaXMudG9wID09PSB0aGlzLmJvdHRvbTtcbiAgfVxufTtcbmxldCBCb3VuZGluZ0JveCA9IF9Cb3VuZGluZ0JveDtcbkJvdW5kaW5nQm94LkVNUFRZID0gbmV3IF9Cb3VuZGluZ0JveCgwLCAwLCAwLCAwKTtcblxuZXhwb3J0cy5Cb3VuZGluZ0JveCA9IEJvdW5kaW5nQm94O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qm91bmRpbmdCb3guanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBzZXR0aW5ncyA9IHJlcXVpcmUoJ0BwaXhpL3NldHRpbmdzJyk7XG5cbmNsYXNzIENhbnZhc1JlbmRlclRhcmdldCB7XG4gIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIHJlc29sdXRpb24pIHtcbiAgICB0aGlzLl9jYW52YXMgPSBzZXR0aW5ncy5zZXR0aW5ncy5BREFQVEVSLmNyZWF0ZUNhbnZhcygpO1xuICAgIHRoaXMuX2NvbnRleHQgPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgc2V0dGluZ3Muc2V0dGluZ3MuUkVTT0xVVElPTjtcbiAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9jaGVja0Rlc3Ryb3llZCgpO1xuICAgIHRoaXMuX2NvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIHRoaXMuX2NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCk7XG4gIH1cbiAgcmVzaXplKGRlc2lyZWRXaWR0aCwgZGVzaXJlZEhlaWdodCkge1xuICAgIHRoaXMuX2NoZWNrRGVzdHJveWVkKCk7XG4gICAgdGhpcy5fY2FudmFzLndpZHRoID0gTWF0aC5yb3VuZChkZXNpcmVkV2lkdGggKiB0aGlzLnJlc29sdXRpb24pO1xuICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBNYXRoLnJvdW5kKGRlc2lyZWRIZWlnaHQgKiB0aGlzLnJlc29sdXRpb24pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fY2FudmFzID0gbnVsbDtcbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgdGhpcy5fY2hlY2tEZXN0cm95ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzLndpZHRoO1xuICB9XG4gIHNldCB3aWR0aCh2YWwpIHtcbiAgICB0aGlzLl9jaGVja0Rlc3Ryb3llZCgpO1xuICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IE1hdGgucm91bmQodmFsKTtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHRoaXMuX2NoZWNrRGVzdHJveWVkKCk7XG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhcy5oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWwpIHtcbiAgICB0aGlzLl9jaGVja0Rlc3Ryb3llZCgpO1xuICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBNYXRoLnJvdW5kKHZhbCk7XG4gIH1cbiAgZ2V0IGNhbnZhcygpIHtcbiAgICB0aGlzLl9jaGVja0Rlc3Ryb3llZCgpO1xuICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgdGhpcy5fY2hlY2tEZXN0cm95ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dDtcbiAgfVxuICBfY2hlY2tEZXN0cm95ZWQoKSB7XG4gICAgaWYgKHRoaXMuX2NhbnZhcyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBDYW52YXNSZW5kZXJUYXJnZXQgaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWRcIik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuQ2FudmFzUmVuZGVyVGFyZ2V0ID0gQ2FudmFzUmVuZGVyVGFyZ2V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FudmFzUmVuZGVyVGFyZ2V0LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jb25zdCBQcm9ncmFtQ2FjaGUgPSB7fTtcbmNvbnN0IFRleHR1cmVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3QgQmFzZVRleHR1cmVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gZGVzdHJveVRleHR1cmVDYWNoZSgpIHtcbiAgbGV0IGtleTtcbiAgZm9yIChrZXkgaW4gVGV4dHVyZUNhY2hlKSB7XG4gICAgVGV4dHVyZUNhY2hlW2tleV0uZGVzdHJveSgpO1xuICB9XG4gIGZvciAoa2V5IGluIEJhc2VUZXh0dXJlQ2FjaGUpIHtcbiAgICBCYXNlVGV4dHVyZUNhY2hlW2tleV0uZGVzdHJveSgpO1xuICB9XG59XG5mdW5jdGlvbiBjbGVhclRleHR1cmVDYWNoZSgpIHtcbiAgbGV0IGtleTtcbiAgZm9yIChrZXkgaW4gVGV4dHVyZUNhY2hlKSB7XG4gICAgZGVsZXRlIFRleHR1cmVDYWNoZVtrZXldO1xuICB9XG4gIGZvciAoa2V5IGluIEJhc2VUZXh0dXJlQ2FjaGUpIHtcbiAgICBkZWxldGUgQmFzZVRleHR1cmVDYWNoZVtrZXldO1xuICB9XG59XG5cbmV4cG9ydHMuQmFzZVRleHR1cmVDYWNoZSA9IEJhc2VUZXh0dXJlQ2FjaGU7XG5leHBvcnRzLlByb2dyYW1DYWNoZSA9IFByb2dyYW1DYWNoZTtcbmV4cG9ydHMuVGV4dHVyZUNhY2hlID0gVGV4dHVyZUNhY2hlO1xuZXhwb3J0cy5jbGVhclRleHR1cmVDYWNoZSA9IGNsZWFyVGV4dHVyZUNhY2hlO1xuZXhwb3J0cy5kZXN0cm95VGV4dHVyZUNhY2hlID0gZGVzdHJveVRleHR1cmVDYWNoZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhY2hlcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIEJvdW5kaW5nQm94ID0gcmVxdWlyZSgnLi9Cb3VuZGluZ0JveC5qcycpO1xuXG5mdW5jdGlvbiBjaGVja1JvdyhkYXRhLCB3aWR0aCwgeSkge1xuICBmb3IgKGxldCB4ID0gMCwgaW5kZXggPSA0ICogeSAqIHdpZHRoOyB4IDwgd2lkdGg7ICsreCwgaW5kZXggKz0gNCkge1xuICAgIGlmIChkYXRhW2luZGV4ICsgM10gIT09IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjaGVja0NvbHVtbihkYXRhLCB3aWR0aCwgeCwgdG9wLCBib3R0b20pIHtcbiAgY29uc3Qgc3RyaWRlID0gNCAqIHdpZHRoO1xuICBmb3IgKGxldCB5ID0gdG9wLCBpbmRleCA9IHRvcCAqIHN0cmlkZSArIDQgKiB4OyB5IDw9IGJvdHRvbTsgKyt5LCBpbmRleCArPSBzdHJpZGUpIHtcbiAgICBpZiAoZGF0YVtpbmRleCArIDNdICE9PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0Q2FudmFzQm91bmRpbmdCb3goY2FudmFzKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY2FudmFzO1xuICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG4gIH0pO1xuICBpZiAoY29udGV4dCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gZ2V0IGNhbnZhcyAyRCBjb250ZXh0XCIpO1xuICB9XG4gIGNvbnN0IGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICBjb25zdCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG4gIGxldCBsZWZ0ID0gMDtcbiAgbGV0IHRvcCA9IDA7XG4gIGxldCByaWdodCA9IHdpZHRoIC0gMTtcbiAgbGV0IGJvdHRvbSA9IGhlaWdodCAtIDE7XG4gIHdoaWxlICh0b3AgPCBoZWlnaHQgJiYgY2hlY2tSb3coZGF0YSwgd2lkdGgsIHRvcCkpXG4gICAgKyt0b3A7XG4gIGlmICh0b3AgPT09IGhlaWdodClcbiAgICByZXR1cm4gQm91bmRpbmdCb3guQm91bmRpbmdCb3guRU1QVFk7XG4gIHdoaWxlIChjaGVja1JvdyhkYXRhLCB3aWR0aCwgYm90dG9tKSlcbiAgICAtLWJvdHRvbTtcbiAgd2hpbGUgKGNoZWNrQ29sdW1uKGRhdGEsIHdpZHRoLCBsZWZ0LCB0b3AsIGJvdHRvbSkpXG4gICAgKytsZWZ0O1xuICB3aGlsZSAoY2hlY2tDb2x1bW4oZGF0YSwgd2lkdGgsIHJpZ2h0LCB0b3AsIGJvdHRvbSkpXG4gICAgLS1yaWdodDtcbiAgKytyaWdodDtcbiAgKytib3R0b207XG4gIHJldHVybiBuZXcgQm91bmRpbmdCb3guQm91bmRpbmdCb3gobGVmdCwgdG9wLCByaWdodCwgYm90dG9tKTtcbn1cblxuZXhwb3J0cy5nZXRDYW52YXNCb3VuZGluZ0JveCA9IGdldENhbnZhc0JvdW5kaW5nQm94O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0Q2FudmFzQm91bmRpbmdCb3guanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBnZXRDYW52YXNCb3VuZGluZ0JveCA9IHJlcXVpcmUoJy4vZ2V0Q2FudmFzQm91bmRpbmdCb3guanMnKTtcblxuZnVuY3Rpb24gdHJpbUNhbnZhcyhjYW52YXMpIHtcbiAgY29uc3QgYm91bmRpbmdCb3ggPSBnZXRDYW52YXNCb3VuZGluZ0JveC5nZXRDYW52YXNCb3VuZGluZ0JveChjYW52YXMpO1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGJvdW5kaW5nQm94O1xuICBsZXQgZGF0YSA9IG51bGw7XG4gIGlmICghYm91bmRpbmdCb3guaXNFbXB0eSgpKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gZ2V0IGNhbnZhcyAyRCBjb250ZXh0XCIpO1xuICAgIH1cbiAgICBkYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoYm91bmRpbmdCb3gubGVmdCwgYm91bmRpbmdCb3gudG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0LCBkYXRhIH07XG59XG5cbmV4cG9ydHMudHJpbUNhbnZhcyA9IHRyaW1DYW52YXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmltQ2FudmFzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgX2NvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QuanMnKTtcblxuZnVuY3Rpb24gZGVjb21wb3NlRGF0YVVyaShkYXRhVXJpKSB7XG4gIGNvbnN0IGRhdGFVcmlNYXRjaCA9IF9jb25zdC5EQVRBX1VSSS5leGVjKGRhdGFVcmkpO1xuICBpZiAoZGF0YVVyaU1hdGNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lZGlhVHlwZTogZGF0YVVyaU1hdGNoWzFdID8gZGF0YVVyaU1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiB2b2lkIDAsXG4gICAgICBzdWJUeXBlOiBkYXRhVXJpTWF0Y2hbMl0gPyBkYXRhVXJpTWF0Y2hbMl0udG9Mb3dlckNhc2UoKSA6IHZvaWQgMCxcbiAgICAgIGNoYXJzZXQ6IGRhdGFVcmlNYXRjaFszXSA/IGRhdGFVcmlNYXRjaFszXS50b0xvd2VyQ2FzZSgpIDogdm9pZCAwLFxuICAgICAgZW5jb2Rpbmc6IGRhdGFVcmlNYXRjaFs0XSA/IGRhdGFVcmlNYXRjaFs0XS50b0xvd2VyQ2FzZSgpIDogdm9pZCAwLFxuICAgICAgZGF0YTogZGF0YVVyaU1hdGNoWzVdXG4gICAgfTtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG5leHBvcnRzLmRlY29tcG9zZURhdGFVcmkgPSBkZWNvbXBvc2VEYXRhVXJpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb21wb3NlRGF0YVVyaS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHVybCA9IHJlcXVpcmUoJy4uL3VybC5qcycpO1xuXG5sZXQgdGVtcEFuY2hvcjtcbmZ1bmN0aW9uIGRldGVybWluZUNyb3NzT3JpZ2luKHVybCQxLCBsb2MgPSBnbG9iYWxUaGlzLmxvY2F0aW9uKSB7XG4gIGlmICh1cmwkMS5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBsb2MgPSBsb2MgfHwgZ2xvYmFsVGhpcy5sb2NhdGlvbjtcbiAgaWYgKCF0ZW1wQW5jaG9yKSB7XG4gICAgdGVtcEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICB9XG4gIHRlbXBBbmNob3IuaHJlZiA9IHVybCQxO1xuICBjb25zdCBwYXJzZWRVcmwgPSB1cmwudXJsLnBhcnNlKHRlbXBBbmNob3IuaHJlZik7XG4gIGNvbnN0IHNhbWVQb3J0ID0gIXBhcnNlZFVybC5wb3J0ICYmIGxvYy5wb3J0ID09PSBcIlwiIHx8IHBhcnNlZFVybC5wb3J0ID09PSBsb2MucG9ydDtcbiAgaWYgKHBhcnNlZFVybC5ob3N0bmFtZSAhPT0gbG9jLmhvc3RuYW1lIHx8ICFzYW1lUG9ydCB8fCBwYXJzZWRVcmwucHJvdG9jb2wgIT09IGxvYy5wcm90b2NvbCkge1xuICAgIHJldHVybiBcImFub255bW91c1wiO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuXG5leHBvcnRzLmRldGVybWluZUNyb3NzT3JpZ2luID0gZGV0ZXJtaW5lQ3Jvc3NPcmlnaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlcm1pbmVDcm9zc09yaWdpbi5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxucmVxdWlyZSgnLi4vc2V0dGluZ3MuanMnKTtcbnZhciBzZXR0aW5ncyA9IHJlcXVpcmUoJ0BwaXhpL3NldHRpbmdzJyk7XG5cbmZ1bmN0aW9uIGdldFJlc29sdXRpb25PZlVybCh1cmwsIGRlZmF1bHRWYWx1ZSA9IDEpIHtcbiAgY29uc3QgcmVzb2x1dGlvbiA9IHNldHRpbmdzLnNldHRpbmdzLlJFVElOQV9QUkVGSVg/LmV4ZWModXJsKTtcbiAgaWYgKHJlc29sdXRpb24pIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChyZXNvbHV0aW9uWzFdKTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFZhbHVlO1xufVxuXG5leHBvcnRzLmdldFJlc29sdXRpb25PZlVybCA9IGdldFJlc29sdXRpb25PZlVybDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFJlc29sdXRpb25PZlVybC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHNldHRpbmdzID0gcmVxdWlyZSgnQHBpeGkvc2V0dGluZ3MnKTtcblxuZnVuY3Rpb24gYXNzZXJ0UGF0aChwYXRoMikge1xuICBpZiAodHlwZW9mIHBhdGgyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KHBhdGgyKX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlVXJsUGFyYW1zKHVybCkge1xuICBjb25zdCByZSA9IHVybC5zcGxpdChcIj9cIilbMF07XG4gIHJldHVybiByZS5zcGxpdChcIiNcIilbMF07XG59XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xufVxuZnVuY3Rpb24gcmVwbGFjZUFsbChzdHIsIGZpbmQsIHJlcGxhY2UpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKGZpbmQpLCBcImdcIiksIHJlcGxhY2UpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5nUG9zaXgocGF0aDIsIGFsbG93QWJvdmVSb290KSB7XG4gIGxldCByZXMgPSBcIlwiO1xuICBsZXQgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICBsZXQgbGFzdFNsYXNoID0gLTE7XG4gIGxldCBkb3RzID0gMDtcbiAgbGV0IGNvZGUgPSAtMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcGF0aDIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoaSA8IHBhdGgyLmxlbmd0aCkge1xuICAgICAgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoaSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgPSA0NztcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICBpZiAobGFzdFNsYXNoID09PSBpIC0gMSB8fCBkb3RzID09PSAxKSB7XG4gICAgICB9IGVsc2UgaWYgKGxhc3RTbGFzaCAhPT0gaSAtIDEgJiYgZG90cyA9PT0gMikge1xuICAgICAgICBpZiAocmVzLmxlbmd0aCA8IDIgfHwgbGFzdFNlZ21lbnRMZW5ndGggIT09IDIgfHwgcmVzLmNoYXJDb2RlQXQocmVzLmxlbmd0aCAtIDEpICE9PSA0NiB8fCByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMikgIT09IDQ2KSB7XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0U2xhc2hJbmRleCA9IHJlcy5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgICAgICAgICBpZiAobGFzdFNsYXNoSW5kZXggIT09IHJlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0U2xhc2hJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuc2xpY2UoMCwgbGFzdFNsYXNoSW5kZXgpO1xuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gcmVzLmxlbmd0aCAtIDEgLSByZXMubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICAgICAgICAgIGRvdHMgPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJlcy5sZW5ndGggPT09IDIgfHwgcmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmVzID0gXCJcIjtcbiAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICAgICAgICBkb3RzID0gMDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlcyArPSBcIi8uLlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBcIi4uXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmVzICs9IGAvJHtwYXRoMi5zbGljZShsYXN0U2xhc2ggKyAxLCBpKX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcyA9IHBhdGgyLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gaSAtIGxhc3RTbGFzaCAtIDE7XG4gICAgICB9XG4gICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgZG90cyA9IDA7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSA0NiAmJiBkb3RzICE9PSAtMSkge1xuICAgICAgKytkb3RzO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb3RzID0gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5jb25zdCBwYXRoID0ge1xuICB0b1Bvc2l4KHBhdGgyKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VBbGwocGF0aDIsIFwiXFxcXFwiLCBcIi9cIik7XG4gIH0sXG4gIGlzVXJsKHBhdGgyKSB7XG4gICAgcmV0dXJuIC9eaHR0cHM/Oi8udGVzdCh0aGlzLnRvUG9zaXgocGF0aDIpKTtcbiAgfSxcbiAgaXNEYXRhVXJsKHBhdGgyKSB7XG4gICAgcmV0dXJuIC9eZGF0YTooW2Etel0rXFwvW2EtejAtOS0rLl0rKDtbYS16MC05LS4hIyQlKisue318fmBdKz1bYS16MC05LS4hIyQlKisue30oKV98fmBdKykqKT8oO2Jhc2U2NCk/LChbYS16MC05ISQmJywoKSorOz1cXC0uX346QFxcLz8lXFxzPD5dKj8pJC9pLnRlc3QocGF0aDIpO1xuICB9LFxuICBoYXNQcm90b2NvbChwYXRoMikge1xuICAgIHJldHVybiAvXlteLzpdKzpcXC8vLnRlc3QodGhpcy50b1Bvc2l4KHBhdGgyKSk7XG4gIH0sXG4gIGdldFByb3RvY29sKHBhdGgyKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoMik7XG4gICAgcGF0aDIgPSB0aGlzLnRvUG9zaXgocGF0aDIpO1xuICAgIGxldCBwcm90b2NvbCA9IFwiXCI7XG4gICAgY29uc3QgaXNGaWxlID0gL15maWxlOlxcL1xcL1xcLy8uZXhlYyhwYXRoMik7XG4gICAgY29uc3QgaXNIdHRwID0gL15bXi86XSs6XFwvXFwvLy5leGVjKHBhdGgyKTtcbiAgICBjb25zdCBpc1dpbmRvd3MgPSAvXlteLzpdKzpcXC8vLmV4ZWMocGF0aDIpO1xuICAgIGlmIChpc0ZpbGUgfHwgaXNIdHRwIHx8IGlzV2luZG93cykge1xuICAgICAgY29uc3QgYXJyID0gaXNGaWxlPy5bMF0gfHwgaXNIdHRwPy5bMF0gfHwgaXNXaW5kb3dzPy5bMF07XG4gICAgICBwcm90b2NvbCA9IGFycjtcbiAgICAgIHBhdGgyID0gcGF0aDIuc2xpY2UoYXJyLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBwcm90b2NvbDtcbiAgfSxcbiAgdG9BYnNvbHV0ZSh1cmwsIGN1c3RvbUJhc2VVcmwsIGN1c3RvbVJvb3RVcmwpIHtcbiAgICBpZiAodGhpcy5pc0RhdGFVcmwodXJsKSlcbiAgICAgIHJldHVybiB1cmw7XG4gICAgY29uc3QgYmFzZVVybCA9IHJlbW92ZVVybFBhcmFtcyh0aGlzLnRvUG9zaXgoY3VzdG9tQmFzZVVybCA/PyBzZXR0aW5ncy5zZXR0aW5ncy5BREFQVEVSLmdldEJhc2VVcmwoKSkpO1xuICAgIGNvbnN0IHJvb3RVcmwgPSByZW1vdmVVcmxQYXJhbXModGhpcy50b1Bvc2l4KGN1c3RvbVJvb3RVcmwgPz8gdGhpcy5yb290bmFtZShiYXNlVXJsKSkpO1xuICAgIGFzc2VydFBhdGgodXJsKTtcbiAgICB1cmwgPSB0aGlzLnRvUG9zaXgodXJsKTtcbiAgICBpZiAodXJsLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICByZXR1cm4gcGF0aC5qb2luKHJvb3RVcmwsIHVybC5zbGljZSgxKSk7XG4gICAgfVxuICAgIGNvbnN0IGFic29sdXRlUGF0aCA9IHRoaXMuaXNBYnNvbHV0ZSh1cmwpID8gdXJsIDogdGhpcy5qb2luKGJhc2VVcmwsIHVybCk7XG4gICAgcmV0dXJuIGFic29sdXRlUGF0aDtcbiAgfSxcbiAgbm9ybWFsaXplKHBhdGgyKSB7XG4gICAgcGF0aDIgPSB0aGlzLnRvUG9zaXgocGF0aDIpO1xuICAgIGFzc2VydFBhdGgocGF0aDIpO1xuICAgIGlmIChwYXRoMi5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gXCIuXCI7XG4gICAgbGV0IHByb3RvY29sID0gXCJcIjtcbiAgICBjb25zdCBpc0Fic29sdXRlID0gcGF0aDIuc3RhcnRzV2l0aChcIi9cIik7XG4gICAgaWYgKHRoaXMuaGFzUHJvdG9jb2wocGF0aDIpKSB7XG4gICAgICBwcm90b2NvbCA9IHRoaXMucm9vdG5hbWUocGF0aDIpO1xuICAgICAgcGF0aDIgPSBwYXRoMi5zbGljZShwcm90b2NvbC5sZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCB0cmFpbGluZ1NlcGFyYXRvciA9IHBhdGgyLmVuZHNXaXRoKFwiL1wiKTtcbiAgICBwYXRoMiA9IG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHBhdGgyLCBmYWxzZSk7XG4gICAgaWYgKHBhdGgyLmxlbmd0aCA+IDAgJiYgdHJhaWxpbmdTZXBhcmF0b3IpXG4gICAgICBwYXRoMiArPSBcIi9cIjtcbiAgICBpZiAoaXNBYnNvbHV0ZSlcbiAgICAgIHJldHVybiBgLyR7cGF0aDJ9YDtcbiAgICByZXR1cm4gcHJvdG9jb2wgKyBwYXRoMjtcbiAgfSxcbiAgaXNBYnNvbHV0ZShwYXRoMikge1xuICAgIGFzc2VydFBhdGgocGF0aDIpO1xuICAgIHBhdGgyID0gdGhpcy50b1Bvc2l4KHBhdGgyKTtcbiAgICBpZiAodGhpcy5oYXNQcm90b2NvbChwYXRoMikpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gcGF0aDIuc3RhcnRzV2l0aChcIi9cIik7XG4gIH0sXG4gIGpvaW4oLi4uc2VnbWVudHMpIHtcbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gXCIuXCI7XG4gICAgfVxuICAgIGxldCBqb2luZWQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgYXJnID0gc2VnbWVudHNbaV07XG4gICAgICBhc3NlcnRQYXRoKGFyZyk7XG4gICAgICBpZiAoYXJnLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGpvaW5lZCA9PT0gdm9pZCAwKVxuICAgICAgICAgIGpvaW5lZCA9IGFyZztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3QgcHJldkFyZyA9IHNlZ21lbnRzW2kgLSAxXSA/PyBcIlwiO1xuICAgICAgICAgIGlmICh0aGlzLmV4dG5hbWUocHJldkFyZykpIHtcbiAgICAgICAgICAgIGpvaW5lZCArPSBgLy4uLyR7YXJnfWA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGpvaW5lZCArPSBgLyR7YXJnfWA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChqb2luZWQgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIFwiLlwiO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUoam9pbmVkKTtcbiAgfSxcbiAgZGlybmFtZShwYXRoMikge1xuICAgIGFzc2VydFBhdGgocGF0aDIpO1xuICAgIGlmIChwYXRoMi5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gXCIuXCI7XG4gICAgcGF0aDIgPSB0aGlzLnRvUG9zaXgocGF0aDIpO1xuICAgIGxldCBjb2RlID0gcGF0aDIuY2hhckNvZGVBdCgwKTtcbiAgICBjb25zdCBoYXNSb290ID0gY29kZSA9PT0gNDc7XG4gICAgbGV0IGVuZCA9IC0xO1xuICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIGNvbnN0IHByb3RvID0gdGhpcy5nZXRQcm90b2NvbChwYXRoMik7XG4gICAgY29uc3Qgb3JpZ3BhdGggPSBwYXRoMjtcbiAgICBwYXRoMiA9IHBhdGgyLnNsaWNlKHByb3RvLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IHBhdGgyLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XG4gICAgICBjb2RlID0gcGF0aDIuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kID09PSAtMSlcbiAgICAgIHJldHVybiBoYXNSb290ID8gXCIvXCIgOiB0aGlzLmlzVXJsKG9yaWdwYXRoKSA/IHByb3RvICsgcGF0aDIgOiBwcm90bztcbiAgICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpXG4gICAgICByZXR1cm4gXCIvL1wiO1xuICAgIHJldHVybiBwcm90byArIHBhdGgyLnNsaWNlKDAsIGVuZCk7XG4gIH0sXG4gIHJvb3RuYW1lKHBhdGgyKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoMik7XG4gICAgcGF0aDIgPSB0aGlzLnRvUG9zaXgocGF0aDIpO1xuICAgIGxldCByb290ID0gXCJcIjtcbiAgICBpZiAocGF0aDIuc3RhcnRzV2l0aChcIi9cIikpXG4gICAgICByb290ID0gXCIvXCI7XG4gICAgZWxzZSB7XG4gICAgICByb290ID0gdGhpcy5nZXRQcm90b2NvbChwYXRoMik7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVXJsKHBhdGgyKSkge1xuICAgICAgY29uc3QgaW5kZXggPSBwYXRoMi5pbmRleE9mKFwiL1wiLCByb290Lmxlbmd0aCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHJvb3QgPSBwYXRoMi5zbGljZSgwLCBpbmRleCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcm9vdCA9IHBhdGgyO1xuICAgICAgaWYgKCFyb290LmVuZHNXaXRoKFwiL1wiKSlcbiAgICAgICAgcm9vdCArPSBcIi9cIjtcbiAgICB9XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH0sXG4gIGJhc2VuYW1lKHBhdGgyLCBleHQpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgyKTtcbiAgICBpZiAoZXh0KVxuICAgICAgYXNzZXJ0UGF0aChleHQpO1xuICAgIHBhdGgyID0gcmVtb3ZlVXJsUGFyYW1zKHRoaXMudG9Qb3NpeChwYXRoMikpO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IC0xO1xuICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIGxldCBpO1xuICAgIGlmIChleHQgIT09IHZvaWQgMCAmJiBleHQubGVuZ3RoID4gMCAmJiBleHQubGVuZ3RoIDw9IHBhdGgyLmxlbmd0aCkge1xuICAgICAgaWYgKGV4dC5sZW5ndGggPT09IHBhdGgyLmxlbmd0aCAmJiBleHQgPT09IHBhdGgyKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIGxldCBleHRJZHggPSBleHQubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBmaXJzdE5vblNsYXNoRW5kID0gLTE7XG4gICAgICBmb3IgKGkgPSBwYXRoMi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBjb25zdCBjb2RlID0gcGF0aDIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZpcnN0Tm9uU2xhc2hFbmQgPT09IC0xKSB7XG4gICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGZpcnN0Tm9uU2xhc2hFbmQgPSBpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dElkeCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gZXh0LmNoYXJDb2RlQXQoZXh0SWR4KSkge1xuICAgICAgICAgICAgICBpZiAoLS1leHRJZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXh0SWR4ID0gLTE7XG4gICAgICAgICAgICAgIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPT09IGVuZClcbiAgICAgICAgZW5kID0gZmlyc3ROb25TbGFzaEVuZDtcbiAgICAgIGVsc2UgaWYgKGVuZCA9PT0gLTEpXG4gICAgICAgIGVuZCA9IHBhdGgyLmxlbmd0aDtcbiAgICAgIHJldHVybiBwYXRoMi5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgZm9yIChpID0gcGF0aDIubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGlmIChwYXRoMi5jaGFyQ29kZUF0KGkpID09PSA0Nykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmQgPT09IC0xKVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgcmV0dXJuIHBhdGgyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICB9LFxuICBleHRuYW1lKHBhdGgyKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoMik7XG4gICAgcGF0aDIgPSByZW1vdmVVcmxQYXJhbXModGhpcy50b1Bvc2l4KHBhdGgyKSk7XG4gICAgbGV0IHN0YXJ0RG90ID0gLTE7XG4gICAgbGV0IHN0YXJ0UGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IC0xO1xuICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIGxldCBwcmVEb3RTdGF0ZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IHBhdGgyLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBjb2RlID0gcGF0aDIuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgIGVuZCA9IGkgKyAxO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGUgPT09IDQ2KSB7XG4gICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSlcbiAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHwgcHJlRG90U3RhdGUgPT09IDAgfHwgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDIuc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG4gIH0sXG4gIHBhcnNlKHBhdGgyKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoMik7XG4gICAgY29uc3QgcmV0ID0geyByb290OiBcIlwiLCBkaXI6IFwiXCIsIGJhc2U6IFwiXCIsIGV4dDogXCJcIiwgbmFtZTogXCJcIiB9O1xuICAgIGlmIChwYXRoMi5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gcmV0O1xuICAgIHBhdGgyID0gcmVtb3ZlVXJsUGFyYW1zKHRoaXMudG9Qb3NpeChwYXRoMikpO1xuICAgIGxldCBjb2RlID0gcGF0aDIuY2hhckNvZGVBdCgwKTtcbiAgICBjb25zdCBpc0Fic29sdXRlID0gdGhpcy5pc0Fic29sdXRlKHBhdGgyKTtcbiAgICBsZXQgc3RhcnQ7XG4gICAgY29uc3QgcHJvdG9jb2wgPSBcIlwiO1xuICAgIHJldC5yb290ID0gdGhpcy5yb290bmFtZShwYXRoMik7XG4gICAgaWYgKGlzQWJzb2x1dGUgfHwgdGhpcy5oYXNQcm90b2NvbChwYXRoMikpIHtcbiAgICAgIHN0YXJ0ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBsZXQgc3RhcnREb3QgPSAtMTtcbiAgICBsZXQgc3RhcnRQYXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gLTE7XG4gICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgbGV0IGkgPSBwYXRoMi5sZW5ndGggLSAxO1xuICAgIGxldCBwcmVEb3RTdGF0ZSA9IDA7XG4gICAgZm9yICg7IGkgPj0gc3RhcnQ7IC0taSkge1xuICAgICAgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoY29kZSA9PT0gNDcpIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA0Nikge1xuICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8IHByZURvdFN0YXRlID09PSAwIHx8IHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgICBpZiAoZW5kICE9PSAtMSkge1xuICAgICAgICBpZiAoc3RhcnRQYXJ0ID09PSAwICYmIGlzQWJzb2x1dGUpXG4gICAgICAgICAgcmV0LmJhc2UgPSByZXQubmFtZSA9IHBhdGgyLnNsaWNlKDEsIGVuZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aDIuc2xpY2Uoc3RhcnRQYXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhcnRQYXJ0ID09PSAwICYmIGlzQWJzb2x1dGUpIHtcbiAgICAgICAgcmV0Lm5hbWUgPSBwYXRoMi5zbGljZSgxLCBzdGFydERvdCk7XG4gICAgICAgIHJldC5iYXNlID0gcGF0aDIuc2xpY2UoMSwgZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5uYW1lID0gcGF0aDIuc2xpY2Uoc3RhcnRQYXJ0LCBzdGFydERvdCk7XG4gICAgICAgIHJldC5iYXNlID0gcGF0aDIuc2xpY2Uoc3RhcnRQYXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgcmV0LmV4dCA9IHBhdGgyLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICAgIH1cbiAgICByZXQuZGlyID0gdGhpcy5kaXJuYW1lKHBhdGgyKTtcbiAgICBpZiAocHJvdG9jb2wpXG4gICAgICByZXQuZGlyID0gcHJvdG9jb2wgKyByZXQuZGlyO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIHNlcDogXCIvXCIsXG4gIGRlbGltaXRlcjogXCI6XCJcbn07XG5cbmV4cG9ydHMucGF0aCA9IHBhdGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgc2V0dGluZ3MgPSByZXF1aXJlKCdAcGl4aS9zZXR0aW5ncycpO1xuXG5zZXR0aW5ncy5zZXR0aW5ncy5SRVRJTkFfUFJFRklYID0gL0AoWzAtOVxcLl0rKXgvO1xuc2V0dGluZ3Muc2V0dGluZ3MuRkFJTF9JRl9NQUpPUl9QRVJGT1JNQU5DRV9DQVZFQVQgPSBmYWxzZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdzZXR0aW5ncycsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXR0aW5ncy5zZXR0aW5nczsgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXR0aW5ncy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB1cmwkMSA9IHJlcXVpcmUoJ3VybCcpO1xuXG5jb25zdCB1cmwgPSB7XG4gIHBhcnNlOiB1cmwkMS5wYXJzZSxcbiAgZm9ybWF0OiB1cmwkMS5mb3JtYXQsXG4gIHJlc29sdmU6IHVybCQxLnJlc29sdmVcbn07XG5cbmV4cG9ydHMudXJsID0gdXJsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIiwiLyoqXG4gKiBFeHBvc2UgYFByaW9yaXR5UXVldWVgLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFByaW9yaXR5UXVldWU7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBuZXcgZW1wdHkgYFByaW9yaXR5UXVldWVgIHdpdGggdGhlIGdpdmVuIGBjb21wYXJhdG9yKGEsIGIpYFxuICogZnVuY3Rpb24sIHVzZXMgYC5ERUZBVUxUX0NPTVBBUkFUT1IoKWAgd2hlbiBubyBmdW5jdGlvbiBpcyBwcm92aWRlZC5cbiAqXG4gKiBUaGUgY29tcGFyYXRvciBmdW5jdGlvbiBtdXN0IHJldHVybiBhIHBvc2l0aXZlIG51bWJlciB3aGVuIGBhID4gYmAsIDAgd2hlblxuICogYGEgPT0gYmAgYW5kIGEgbmVnYXRpdmUgbnVtYmVyIHdoZW4gYGEgPCBiYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQHJldHVybiB7UHJpb3JpdHlRdWV1ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIFByaW9yaXR5UXVldWUoY29tcGFyYXRvcikge1xuICB0aGlzLl9jb21wYXJhdG9yID0gY29tcGFyYXRvciB8fCBQcmlvcml0eVF1ZXVlLkRFRkFVTFRfQ09NUEFSQVRPUjtcbiAgdGhpcy5fZWxlbWVudHMgPSBbXTtcbn1cblxuLyoqXG4gKiBDb21wYXJlcyBgYWAgYW5kIGBiYCwgd2hlbiBgYSA+IGJgIGl0IHJldHVybnMgYSBwb3NpdGl2ZSBudW1iZXIsIHdoZW5cbiAqIGl0IHJldHVybnMgMCBhbmQgd2hlbiBgYSA8IGJgIGl0IHJldHVybnMgYSBuZWdhdGl2ZSBudW1iZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBhXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblByaW9yaXR5UXVldWUuREVGQVVMVF9DT01QQVJBVE9SID0gZnVuY3Rpb24oYSwgYikge1xuICBpZiAodHlwZW9mIGEgPT09ICdudW1iZXInICYmIHR5cGVvZiBiID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBhIC0gYjtcbiAgfSBlbHNlIHtcbiAgICBhID0gYS50b1N0cmluZygpO1xuICAgIGIgPSBiLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAoYSA9PSBiKSByZXR1cm4gMDtcblxuICAgIHJldHVybiAoYSA+IGIpID8gMSA6IC0xO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcHJpb3JpdHkgcXVldWUgaXMgZW1wdHkgb3Igbm90LlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnNpemUoKSA9PT0gMDtcbn07XG5cbi8qKlxuICogUGVla3MgYXQgdGhlIHRvcCBlbGVtZW50IG9mIHRoZSBwcmlvcml0eSBxdWV1ZS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiB0aGUgcXVldWUgaXMgZW1wdHkuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlzRW1wdHkoKSkgdGhyb3cgbmV3IEVycm9yKCdQcmlvcml0eVF1ZXVlIGlzIGVtcHR5Jyk7XG5cbiAgcmV0dXJuIHRoaXMuX2VsZW1lbnRzWzBdO1xufTtcblxuLyoqXG4gKiBEZXF1ZXVlcyB0aGUgdG9wIGVsZW1lbnQgb2YgdGhlIHByaW9yaXR5IHF1ZXVlLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEB0aHJvd3Mge0Vycm9yfSB3aGVuIHRoZSBxdWV1ZSBpcyBlbXB0eS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmRlcSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlyc3QgPSB0aGlzLnBlZWsoKTtcbiAgdmFyIGxhc3QgPSB0aGlzLl9lbGVtZW50cy5wb3AoKTtcbiAgdmFyIHNpemUgPSB0aGlzLnNpemUoKTtcblxuICBpZiAoc2l6ZSA9PT0gMCkgcmV0dXJuIGZpcnN0O1xuXG4gIHRoaXMuX2VsZW1lbnRzWzBdID0gbGFzdDtcbiAgdmFyIGN1cnJlbnQgPSAwO1xuXG4gIHdoaWxlIChjdXJyZW50IDwgc2l6ZSkge1xuICAgIHZhciBsYXJnZXN0ID0gY3VycmVudDtcbiAgICB2YXIgbGVmdCA9ICgyICogY3VycmVudCkgKyAxO1xuICAgIHZhciByaWdodCA9ICgyICogY3VycmVudCkgKyAyO1xuXG4gICAgaWYgKGxlZnQgPCBzaXplICYmIHRoaXMuX2NvbXBhcmUobGVmdCwgbGFyZ2VzdCkgPj0gMCkge1xuICAgICAgbGFyZ2VzdCA9IGxlZnQ7XG4gICAgfVxuXG4gICAgaWYgKHJpZ2h0IDwgc2l6ZSAmJiB0aGlzLl9jb21wYXJlKHJpZ2h0LCBsYXJnZXN0KSA+PSAwKSB7XG4gICAgICBsYXJnZXN0ID0gcmlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKGxhcmdlc3QgPT09IGN1cnJlbnQpIGJyZWFrO1xuXG4gICAgdGhpcy5fc3dhcChsYXJnZXN0LCBjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gbGFyZ2VzdDtcbiAgfVxuXG4gIHJldHVybiBmaXJzdDtcbn07XG5cbi8qKlxuICogRW5xdWV1ZXMgdGhlIGBlbGVtZW50YCBhdCB0aGUgcHJpb3JpdHkgcXVldWUgYW5kIHJldHVybnMgaXRzIG5ldyBzaXplLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5lbnEgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciBzaXplID0gdGhpcy5fZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgdmFyIGN1cnJlbnQgPSBzaXplIC0gMTtcblxuICB3aGlsZSAoY3VycmVudCA+IDApIHtcbiAgICB2YXIgcGFyZW50ID0gTWF0aC5mbG9vcigoY3VycmVudCAtIDEpIC8gMik7XG5cbiAgICBpZiAodGhpcy5fY29tcGFyZShjdXJyZW50LCBwYXJlbnQpIDw9IDApIGJyZWFrO1xuXG4gICAgdGhpcy5fc3dhcChwYXJlbnQsIGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBwYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gc2l6ZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgcHJpb3JpdHkgcXVldWUuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZWxlbWVudHMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiAgSXRlcmF0ZXMgb3ZlciBxdWV1ZSBlbGVtZW50c1xuICpcbiAqICBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIHRoaXMuX2VsZW1lbnRzLmZvckVhY2goZm4pO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0aGUgdmFsdWVzIGF0IHBvc2l0aW9uIGBhYCBhbmQgYGJgIGluIHRoZSBwcmlvcml0eSBxdWV1ZSB1c2luZyBpdHNcbiAqIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuX2NvbXBhcmUgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiB0aGlzLl9jb21wYXJhdG9yKHRoaXMuX2VsZW1lbnRzW2FdLCB0aGlzLl9lbGVtZW50c1tiXSk7XG59O1xuXG4vKipcbiAqIFN3YXBzIHRoZSB2YWx1ZXMgYXQgcG9zaXRpb24gYGFgIGFuZCBgYmAgaW4gdGhlIHByaW9yaXR5IHF1ZXVlLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhXG4gKiBAcGFyYW0ge051bWJlcn0gYlxuICogQGFwaSBwcml2YXRlXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLl9zd2FwID0gZnVuY3Rpb24oYSwgYikge1xuICB2YXIgYXV4ID0gdGhpcy5fZWxlbWVudHNbYV07XG4gIHRoaXMuX2VsZW1lbnRzW2FdID0gdGhpcy5fZWxlbWVudHNbYl07XG4gIHRoaXMuX2VsZW1lbnRzW2JdID0gYXV4O1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gb2JqW2tdLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8vIEEgbGlicmFyeSBvZiBzZWVkYWJsZSBSTkdzIGltcGxlbWVudGVkIGluIEphdmFzY3JpcHQuXG4vL1xuLy8gVXNhZ2U6XG4vL1xuLy8gdmFyIHNlZWRyYW5kb20gPSByZXF1aXJlKCdzZWVkcmFuZG9tJyk7XG4vLyB2YXIgcmFuZG9tID0gc2VlZHJhbmRvbSgxKTsgLy8gb3IgYW55IHNlZWQuXG4vLyB2YXIgeCA9IHJhbmRvbSgpOyAgICAgICAvLyAwIDw9IHggPCAxLiAgRXZlcnkgYml0IGlzIHJhbmRvbS5cbi8vIHZhciB4ID0gcmFuZG9tLnF1aWNrKCk7IC8vIDAgPD0geCA8IDEuICAzMiBiaXRzIG9mIHJhbmRvbW5lc3MuXG5cbi8vIGFsZWEsIGEgNTMtYml0IG11bHRpcGx5LXdpdGgtY2FycnkgZ2VuZXJhdG9yIGJ5IEpvaGFubmVzIEJhYWfDuGUuXG4vLyBQZXJpb2Q6IH4yXjExNlxuLy8gUmVwb3J0ZWQgdG8gcGFzcyBhbGwgQmlnQ3J1c2ggdGVzdHMuXG52YXIgYWxlYSA9IHJlcXVpcmUoJy4vbGliL2FsZWEnKTtcblxuLy8geG9yMTI4LCBhIHB1cmUgeG9yLXNoaWZ0IGdlbmVyYXRvciBieSBHZW9yZ2UgTWFyc2FnbGlhLlxuLy8gUGVyaW9kOiAyXjEyOC0xLlxuLy8gUmVwb3J0ZWQgdG8gZmFpbDogTWF0cml4UmFuayBhbmQgTGluZWFyQ29tcC5cbnZhciB4b3IxMjggPSByZXF1aXJlKCcuL2xpYi94b3IxMjgnKTtcblxuLy8geG9yd293LCBHZW9yZ2UgTWFyc2FnbGlhJ3MgMTYwLWJpdCB4b3Itc2hpZnQgY29tYmluZWQgcGx1cyB3ZXlsLlxuLy8gUGVyaW9kOiAyXjE5Mi0yXjMyXG4vLyBSZXBvcnRlZCB0byBmYWlsOiBDb2xsaXNpb25PdmVyLCBTaW1wUG9rZXIsIGFuZCBMaW5lYXJDb21wLlxudmFyIHhvcndvdyA9IHJlcXVpcmUoJy4vbGliL3hvcndvdycpO1xuXG4vLyB4b3JzaGlmdDcsIGJ5IEZyYW7Dp29pcyBQYW5uZXRvbiBhbmQgUGllcnJlIEwnZWN1eWVyLCB0YWtlc1xuLy8gYSBkaWZmZXJlbnQgYXBwcm9hY2g6IGl0IGFkZHMgcm9idXN0bmVzcyBieSBhbGxvd2luZyBtb3JlIHNoaWZ0c1xuLy8gdGhhbiBNYXJzYWdsaWEncyBvcmlnaW5hbCB0aHJlZS4gIEl0IGlzIGEgNy1zaGlmdCBnZW5lcmF0b3Jcbi8vIHdpdGggMjU2IGJpdHMsIHRoYXQgcGFzc2VzIEJpZ0NydXNoIHdpdGggbm8gc3lzdG1hdGljIGZhaWx1cmVzLlxuLy8gUGVyaW9kIDJeMjU2LTEuXG4vLyBObyBzeXN0ZW1hdGljIEJpZ0NydXNoIGZhaWx1cmVzIHJlcG9ydGVkLlxudmFyIHhvcnNoaWZ0NyA9IHJlcXVpcmUoJy4vbGliL3hvcnNoaWZ0NycpO1xuXG4vLyB4b3I0MDk2LCBieSBSaWNoYXJkIEJyZW50LCBpcyBhIDQwOTYtYml0IHhvci1zaGlmdCB3aXRoIGFcbi8vIHZlcnkgbG9uZyBwZXJpb2QgdGhhdCBhbHNvIGFkZHMgYSBXZXlsIGdlbmVyYXRvci4gSXQgYWxzbyBwYXNzZXNcbi8vIEJpZ0NydXNoIHdpdGggbm8gc3lzdGVtYXRpYyBmYWlsdXJlcy4gIEl0cyBsb25nIHBlcmlvZCBtYXlcbi8vIGJlIHVzZWZ1bCBpZiB5b3UgaGF2ZSBtYW55IGdlbmVyYXRvcnMgYW5kIG5lZWQgdG8gYXZvaWRcbi8vIGNvbGxpc2lvbnMuXG4vLyBQZXJpb2Q6IDJeNDEyOC0yXjMyLlxuLy8gTm8gc3lzdGVtYXRpYyBCaWdDcnVzaCBmYWlsdXJlcyByZXBvcnRlZC5cbnZhciB4b3I0MDk2ID0gcmVxdWlyZSgnLi9saWIveG9yNDA5NicpO1xuXG4vLyBUeWNoZS1pLCBieSBTYW11ZWwgTmV2ZXMgYW5kIEZpbGlwZSBBcmF1am8sIGlzIGEgYml0LXNoaWZ0aW5nIHJhbmRvbVxuLy8gbnVtYmVyIGdlbmVyYXRvciBkZXJpdmVkIGZyb20gQ2hhQ2hhLCBhIG1vZGVybiBzdHJlYW0gY2lwaGVyLlxuLy8gaHR0cHM6Ly9lZGVuLmRlaS51Yy5wdC9+c25ldmVzL3B1YnMvMjAxMS1zbmZhMi5wZGZcbi8vIFBlcmlvZDogfjJeMTI3XG4vLyBObyBzeXN0ZW1hdGljIEJpZ0NydXNoIGZhaWx1cmVzIHJlcG9ydGVkLlxudmFyIHR5Y2hlaSA9IHJlcXVpcmUoJy4vbGliL3R5Y2hlaScpO1xuXG4vLyBUaGUgb3JpZ2luYWwgQVJDNC1iYXNlZCBwcm5nIGluY2x1ZGVkIGluIHRoaXMgbGlicmFyeS5cbi8vIFBlcmlvZDogfjJeMTYwMFxudmFyIHNyID0gcmVxdWlyZSgnLi9zZWVkcmFuZG9tJyk7XG5cbnNyLmFsZWEgPSBhbGVhO1xuc3IueG9yMTI4ID0geG9yMTI4O1xuc3IueG9yd293ID0geG9yd293O1xuc3IueG9yc2hpZnQ3ID0geG9yc2hpZnQ3O1xuc3IueG9yNDA5NiA9IHhvcjQwOTY7XG5zci50eWNoZWkgPSB0eWNoZWk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3I7XG4iLCIvLyBBIHBvcnQgb2YgYW4gYWxnb3JpdGhtIGJ5IEpvaGFubmVzIEJhYWfDuGUgPGJhYWdvZUBiYWFnb2UuY29tPiwgMjAxMFxuLy8gaHR0cDovL2JhYWdvZS5jb20vZW4vUmFuZG9tTXVzaW5ncy9qYXZhc2NyaXB0L1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25xdWlubGFuL2JldHRlci1yYW5kb20tbnVtYmVycy1mb3ItamF2YXNjcmlwdC1taXJyb3Jcbi8vIE9yaWdpbmFsIHdvcmsgaXMgdW5kZXIgTUlUIGxpY2Vuc2UgLVxuXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgYnkgSm9oYW5uZXMgQmFhZ8O4ZSA8YmFhZ29lQGJhYWdvZS5vcmc+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIEFsZWEoc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBtYXNoID0gTWFzaCgpO1xuXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IDIwOTE2MzkgKiBtZS5zMCArIG1lLmMgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICAgIG1lLnMwID0gbWUuczE7XG4gICAgbWUuczEgPSBtZS5zMjtcbiAgICByZXR1cm4gbWUuczIgPSB0IC0gKG1lLmMgPSB0IHwgMCk7XG4gIH07XG5cbiAgLy8gQXBwbHkgdGhlIHNlZWRpbmcgYWxnb3JpdGhtIGZyb20gQmFhZ29lLlxuICBtZS5jID0gMTtcbiAgbWUuczAgPSBtYXNoKCcgJyk7XG4gIG1lLnMxID0gbWFzaCgnICcpO1xuICBtZS5zMiA9IG1hc2goJyAnKTtcbiAgbWUuczAgLT0gbWFzaChzZWVkKTtcbiAgaWYgKG1lLnMwIDwgMCkgeyBtZS5zMCArPSAxOyB9XG4gIG1lLnMxIC09IG1hc2goc2VlZCk7XG4gIGlmIChtZS5zMSA8IDApIHsgbWUuczEgKz0gMTsgfVxuICBtZS5zMiAtPSBtYXNoKHNlZWQpO1xuICBpZiAobWUuczIgPCAwKSB7IG1lLnMyICs9IDE7IH1cbiAgbWFzaCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmMgPSBmLmM7XG4gIHQuczAgPSBmLnMwO1xuICB0LnMxID0gZi5zMTtcbiAgdC5zMiA9IGYuczI7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IEFsZWEoc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSB4Zy5uZXh0O1xuICBwcm5nLmludDMyID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpICogMHgxMDAwMDAwMDApIHwgMDsgfVxuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwcm5nKCkgKyAocHJuZygpICogMHgyMDAwMDAgfCAwKSAqIDEuMTEwMjIzMDI0NjI1MTU2NWUtMTY7IC8vIDJeLTUzXG4gIH07XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5mdW5jdGlvbiBNYXNoKCkge1xuICB2YXIgbiA9IDB4ZWZjODI0OWQ7XG5cbiAgdmFyIG1hc2ggPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgZGF0YSA9IFN0cmluZyhkYXRhKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIG4gKz0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgICAgdmFyIGggPSAwLjAyNTE5NjAzMjgyNDE2OTM4ICogbjtcbiAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgaCAtPSBuO1xuICAgICAgaCAqPSBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBuICs9IGggKiAweDEwMDAwMDAwMDsgLy8gMl4zMlxuICAgIH1cbiAgICByZXR1cm4gKG4gPj4+IDApICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgfTtcblxuICByZXR1cm4gbWFzaDtcbn1cblxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLmFsZWEgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcIlR5Y2hlLWlcIiBwcm5nIGFsZ29yaXRobSBieVxuLy8gU2FtdWVsIE5ldmVzIGFuZCBGaWxpcGUgQXJhdWpvLlxuLy8gU2VlIGh0dHBzOi8vZWRlbi5kZWkudWMucHQvfnNuZXZlcy9wdWJzLzIwMTEtc25mYTIucGRmXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGIgPSBtZS5iLCBjID0gbWUuYywgZCA9IG1lLmQsIGEgPSBtZS5hO1xuICAgIGIgPSAoYiA8PCAyNSkgXiAoYiA+Pj4gNykgXiBjO1xuICAgIGMgPSAoYyAtIGQpIHwgMDtcbiAgICBkID0gKGQgPDwgMjQpIF4gKGQgPj4+IDgpIF4gYTtcbiAgICBhID0gKGEgLSBiKSB8IDA7XG4gICAgbWUuYiA9IGIgPSAoYiA8PCAyMCkgXiAoYiA+Pj4gMTIpIF4gYztcbiAgICBtZS5jID0gYyA9IChjIC0gZCkgfCAwO1xuICAgIG1lLmQgPSAoZCA8PCAxNikgXiAoYyA+Pj4gMTYpIF4gYTtcbiAgICByZXR1cm4gbWUuYSA9IChhIC0gYikgfCAwO1xuICB9O1xuXG4gIC8qIFRoZSBmb2xsb3dpbmcgaXMgbm9uLWludmVydGVkIHR5Y2hlLCB3aGljaCBoYXMgYmV0dGVyIGludGVybmFsXG4gICAqIGJpdCBkaWZmdXNpb24sIGJ1dCB3aGljaCBpcyBhYm91dCAyNSUgc2xvd2VyIHRoYW4gdHljaGUtaSBpbiBKUy5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhID0gbWUuYSwgYiA9IG1lLmIsIGMgPSBtZS5jLCBkID0gbWUuZDtcbiAgICBhID0gKG1lLmEgKyBtZS5iIHwgMCkgPj4+IDA7XG4gICAgZCA9IG1lLmQgXiBhOyBkID0gZCA8PCAxNiBeIGQgPj4+IDE2O1xuICAgIGMgPSBtZS5jICsgZCB8IDA7XG4gICAgYiA9IG1lLmIgXiBjOyBiID0gYiA8PCAxMiBeIGQgPj4+IDIwO1xuICAgIG1lLmEgPSBhID0gYSArIGIgfCAwO1xuICAgIGQgPSBkIF4gYTsgbWUuZCA9IGQgPSBkIDw8IDggXiBkID4+PiAyNDtcbiAgICBtZS5jID0gYyA9IGMgKyBkIHwgMDtcbiAgICBiID0gYiBeIGM7XG4gICAgcmV0dXJuIG1lLmIgPSAoYiA8PCA3IF4gYiA+Pj4gMjUpO1xuICB9XG4gICovXG5cbiAgbWUuYSA9IDA7XG4gIG1lLmIgPSAwO1xuICBtZS5jID0gMjY1NDQzNTc2OSB8IDA7XG4gIG1lLmQgPSAxMzY3MTMwNTUxO1xuXG4gIGlmIChzZWVkID09PSBNYXRoLmZsb29yKHNlZWQpKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLmEgPSAoc2VlZCAvIDB4MTAwMDAwMDAwKSB8IDA7XG4gICAgbWUuYiA9IHNlZWQgfCAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgMjA7IGsrKykge1xuICAgIG1lLmIgXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuYSA9IGYuYTtcbiAgdC5iID0gZi5iO1xuICB0LmMgPSBmLmM7XG4gIHQuZCA9IGYuZDtcbiAgcmV0dXJuIHQ7XG59O1xuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnR5Y2hlaSA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yMTI4XCIgcHJuZyBhbGdvcml0aG0gYnlcbi8vIEdlb3JnZSBNYXJzYWdsaWEuICBTZWUgaHR0cDovL3d3dy5qc3RhdHNvZnQub3JnL3YwOC9pMTQvcGFwZXJcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIG1lLnggPSAwO1xuICBtZS55ID0gMDtcbiAgbWUueiA9IDA7XG4gIG1lLncgPSAwO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IG1lLnggXiAobWUueCA8PCAxMSk7XG4gICAgbWUueCA9IG1lLnk7XG4gICAgbWUueSA9IG1lLno7XG4gICAgbWUueiA9IG1lLnc7XG4gICAgcmV0dXJuIG1lLncgXj0gKG1lLncgPj4+IDE5KSBeIHQgXiAodCA+Pj4gOCk7XG4gIH07XG5cbiAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAvLyBJbnRlZ2VyIHNlZWQuXG4gICAgbWUueCA9IHNlZWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaW5nIHNlZWQuXG4gICAgc3Ryc2VlZCArPSBzZWVkO1xuICB9XG5cbiAgLy8gTWl4IGluIHN0cmluZyBzZWVkLCB0aGVuIGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiA2NCB2YWx1ZXMuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3Ryc2VlZC5sZW5ndGggKyA2NDsgaysrKSB7XG4gICAgbWUueCBePSBzdHJzZWVkLmNoYXJDb2RlQXQoaykgfCAwO1xuICAgIG1lLm5leHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC54ID0gZi54O1xuICB0LnkgPSBmLnk7XG4gIHQueiA9IGYuejtcbiAgdC53ID0gZi53O1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3IxMjggPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIFJpY2hhcmQgQnJlbnQncyBYb3JnZW5zIHhvcjQwOTYgYWxnb3JpdGhtLlxuLy9cbi8vIFRoaXMgZmFzdCBub24tY3J5cHRvZ3JhcGhpYyByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBpcyBkZXNpZ25lZCBmb3Jcbi8vIHVzZSBpbiBNb250ZS1DYXJsbyBhbGdvcml0aG1zLiBJdCBjb21iaW5lcyBhIGxvbmctcGVyaW9kIHhvcnNoaWZ0XG4vLyBnZW5lcmF0b3Igd2l0aCBhIFdleWwgZ2VuZXJhdG9yLCBhbmQgaXQgcGFzc2VzIGFsbCBjb21tb24gYmF0dGVyaWVzXG4vLyBvZiBzdGFzdGljaWFsIHRlc3RzIGZvciByYW5kb21uZXNzIHdoaWxlIGNvbnN1bWluZyBvbmx5IGEgZmV3IG5hbm9zZWNvbmRzXG4vLyBmb3IgZWFjaCBwcm5nIGdlbmVyYXRlZC4gIEZvciBiYWNrZ3JvdW5kIG9uIHRoZSBnZW5lcmF0b3IsIHNlZSBCcmVudCdzXG4vLyBwYXBlcjogXCJTb21lIGxvbmctcGVyaW9kIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9ycyB1c2luZyBzaGlmdHMgYW5kIHhvcnMuXCJcbi8vIGh0dHA6Ly9hcnhpdi5vcmcvcGRmLzEwMDQuMzExNXYxLnBkZlxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vIHZhciB4b3I0MDk2ID0gcmVxdWlyZSgneG9yNDA5NicpO1xuLy8gcmFuZG9tID0geG9yNDA5NigxKTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWVkIHdpdGggaW50MzIgb3Igc3RyaW5nLlxuLy8gYXNzZXJ0LmVxdWFsKHJhbmRvbSgpLCAwLjE1MjA0MzY0NTA1Mzg1NDcpOyAvLyAoMCwgMSkgcmFuZ2UsIDUzIGJpdHMuXG4vLyBhc3NlcnQuZXF1YWwocmFuZG9tLmludDMyKCksIDE4MDY1MzQ4OTcpOyAgIC8vIHNpZ25lZCBpbnQzMiwgMzIgYml0cy5cbi8vXG4vLyBGb3Igbm9uemVybyBudW1lcmljIGtleXMsIHRoaXMgaW1wZWxlbWVudGF0aW9uIHByb3ZpZGVzIGEgc2VxdWVuY2Vcbi8vIGlkZW50aWNhbCB0byB0aGF0IGJ5IEJyZW50J3MgeG9yZ2VucyAzIGltcGxlbWVudGFpb24gaW4gQy4gIFRoaXNcbi8vIGltcGxlbWVudGF0aW9uIGFsc28gcHJvdmlkZXMgZm9yIGluaXRhbGl6aW5nIHRoZSBnZW5lcmF0b3Igd2l0aFxuLy8gc3RyaW5nIHNlZWRzLCBvciBmb3Igc2F2aW5nIGFuZCByZXN0b3JpbmcgdGhlIHN0YXRlIG9mIHRoZSBnZW5lcmF0b3IuXG4vL1xuLy8gT24gQ2hyb21lLCB0aGlzIHBybmcgYmVuY2htYXJrcyBhYm91dCAyLjEgdGltZXMgc2xvd2VyIHRoYW5cbi8vIEphdmFzY3JpcHQncyBidWlsdC1pbiBNYXRoLnJhbmRvbSgpLlxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdyA9IG1lLncsXG4gICAgICAgIFggPSBtZS5YLCBpID0gbWUuaSwgdCwgdjtcbiAgICAvLyBVcGRhdGUgV2V5bCBnZW5lcmF0b3IuXG4gICAgbWUudyA9IHcgPSAodyArIDB4NjFjODg2NDcpIHwgMDtcbiAgICAvLyBVcGRhdGUgeG9yIGdlbmVyYXRvci5cbiAgICB2ID0gWFsoaSArIDM0KSAmIDEyN107XG4gICAgdCA9IFhbaSA9ICgoaSArIDEpICYgMTI3KV07XG4gICAgdiBePSB2IDw8IDEzO1xuICAgIHQgXj0gdCA8PCAxNztcbiAgICB2IF49IHYgPj4+IDE1O1xuICAgIHQgXj0gdCA+Pj4gMTI7XG4gICAgLy8gVXBkYXRlIFhvciBnZW5lcmF0b3IgYXJyYXkgc3RhdGUuXG4gICAgdiA9IFhbaV0gPSB2IF4gdDtcbiAgICBtZS5pID0gaTtcbiAgICAvLyBSZXN1bHQgaXMgdGhlIGNvbWJpbmF0aW9uLlxuICAgIHJldHVybiAodiArICh3IF4gKHcgPj4+IDE2KSkpIHwgMDtcbiAgfTtcblxuICBmdW5jdGlvbiBpbml0KG1lLCBzZWVkKSB7XG4gICAgdmFyIHQsIHYsIGksIGosIHcsIFggPSBbXSwgbGltaXQgPSAxMjg7XG4gICAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAgIC8vIE51bWVyaWMgc2VlZHMgaW5pdGlhbGl6ZSB2LCB3aGljaCBpcyB1c2VkIHRvIGdlbmVyYXRlcyBYLlxuICAgICAgdiA9IHNlZWQ7XG4gICAgICBzZWVkID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RyaW5nIHNlZWRzIGFyZSBtaXhlZCBpbnRvIHYgYW5kIFggb25lIGNoYXJhY3RlciBhdCBhIHRpbWUuXG4gICAgICBzZWVkID0gc2VlZCArICdcXDAnO1xuICAgICAgdiA9IDA7XG4gICAgICBsaW1pdCA9IE1hdGgubWF4KGxpbWl0LCBzZWVkLmxlbmd0aCk7XG4gICAgfVxuICAgIC8vIEluaXRpYWxpemUgY2lyY3VsYXIgYXJyYXkgYW5kIHdleWwgdmFsdWUuXG4gICAgZm9yIChpID0gMCwgaiA9IC0zMjsgaiA8IGxpbWl0OyArK2opIHtcbiAgICAgIC8vIFB1dCB0aGUgdW5pY29kZSBjaGFyYWN0ZXJzIGludG8gdGhlIGFycmF5LCBhbmQgc2h1ZmZsZSB0aGVtLlxuICAgICAgaWYgKHNlZWQpIHYgXj0gc2VlZC5jaGFyQ29kZUF0KChqICsgMzIpICUgc2VlZC5sZW5ndGgpO1xuICAgICAgLy8gQWZ0ZXIgMzIgc2h1ZmZsZXMsIHRha2UgdiBhcyB0aGUgc3RhcnRpbmcgdyB2YWx1ZS5cbiAgICAgIGlmIChqID09PSAwKSB3ID0gdjtcbiAgICAgIHYgXj0gdiA8PCAxMDtcbiAgICAgIHYgXj0gdiA+Pj4gMTU7XG4gICAgICB2IF49IHYgPDwgNDtcbiAgICAgIHYgXj0gdiA+Pj4gMTM7XG4gICAgICBpZiAoaiA+PSAwKSB7XG4gICAgICAgIHcgPSAodyArIDB4NjFjODg2NDcpIHwgMDsgICAgIC8vIFdleWwuXG4gICAgICAgIHQgPSAoWFtqICYgMTI3XSBePSAodiArIHcpKTsgIC8vIENvbWJpbmUgeG9yIGFuZCB3ZXlsIHRvIGluaXQgYXJyYXkuXG4gICAgICAgIGkgPSAoMCA9PSB0KSA/IGkgKyAxIDogMDsgICAgIC8vIENvdW50IHplcm9lcy5cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgaGF2ZSBkZXRlY3RlZCBhbGwgemVyb2VzOyBtYWtlIHRoZSBrZXkgbm9uemVyby5cbiAgICBpZiAoaSA+PSAxMjgpIHtcbiAgICAgIFhbKHNlZWQgJiYgc2VlZC5sZW5ndGggfHwgMCkgJiAxMjddID0gLTE7XG4gICAgfVxuICAgIC8vIFJ1biB0aGUgZ2VuZXJhdG9yIDUxMiB0aW1lcyB0byBmdXJ0aGVyIG1peCB0aGUgc3RhdGUgYmVmb3JlIHVzaW5nIGl0LlxuICAgIC8vIEZhY3RvcmluZyB0aGlzIGFzIGEgZnVuY3Rpb24gc2xvd3MgdGhlIG1haW4gZ2VuZXJhdG9yLCBzbyBpdCBpcyBqdXN0XG4gICAgLy8gdW5yb2xsZWQgaGVyZS4gIFRoZSB3ZXlsIGdlbmVyYXRvciBpcyBub3QgYWR2YW5jZWQgd2hpbGUgd2FybWluZyB1cC5cbiAgICBpID0gMTI3O1xuICAgIGZvciAoaiA9IDQgKiAxMjg7IGogPiAwOyAtLWopIHtcbiAgICAgIHYgPSBYWyhpICsgMzQpICYgMTI3XTtcbiAgICAgIHQgPSBYW2kgPSAoKGkgKyAxKSAmIDEyNyldO1xuICAgICAgdiBePSB2IDw8IDEzO1xuICAgICAgdCBePSB0IDw8IDE3O1xuICAgICAgdiBePSB2ID4+PiAxNTtcbiAgICAgIHQgXj0gdCA+Pj4gMTI7XG4gICAgICBYW2ldID0gdiBeIHQ7XG4gICAgfVxuICAgIC8vIFN0b3Jpbmcgc3RhdGUgYXMgb2JqZWN0IG1lbWJlcnMgaXMgZmFzdGVyIHRoYW4gdXNpbmcgY2xvc3VyZSB2YXJpYWJsZXMuXG4gICAgbWUudyA9IHc7XG4gICAgbWUuWCA9IFg7XG4gICAgbWUuaSA9IGk7XG4gIH1cblxuICBpbml0KG1lLCBzZWVkKTtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuaSA9IGYuaTtcbiAgdC53ID0gZi53O1xuICB0LlggPSBmLlguc2xpY2UoKTtcbiAgcmV0dXJuIHQ7XG59O1xuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgaWYgKHNlZWQgPT0gbnVsbCkgc2VlZCA9ICsobmV3IERhdGUpO1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5YKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yNDA5NiA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aW5kb3cgb2JqZWN0IG9yIGdsb2JhbFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG4iLCIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiB0aGUgXCJ4b3JzaGlmdDdcIiBhbGdvcml0aG0gYnlcbi8vIEZyYW7Dp29pcyBQYW5uZXRvbiBhbmQgUGllcnJlIEwnZWN1eWVyOlxuLy8gXCJPbiB0aGUgWG9yZ3NoaWZ0IFJhbmRvbSBOdW1iZXIgR2VuZXJhdG9yc1wiXG4vLyBodHRwOi8vc2FsdWMuZW5nci51Y29ubi5lZHUvcmVmcy9jcnlwdG8vcm5nL3Bhbm5ldG9uMDVvbnRoZXhvcnNoaWZ0LnBkZlxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBVcGRhdGUgeG9yIGdlbmVyYXRvci5cbiAgICB2YXIgWCA9IG1lLngsIGkgPSBtZS5pLCB0LCB2LCB3O1xuICAgIHQgPSBYW2ldOyB0IF49ICh0ID4+PiA3KTsgdiA9IHQgXiAodCA8PCAyNCk7XG4gICAgdCA9IFhbKGkgKyAxKSAmIDddOyB2IF49IHQgXiAodCA+Pj4gMTApO1xuICAgIHQgPSBYWyhpICsgMykgJiA3XTsgdiBePSB0IF4gKHQgPj4+IDMpO1xuICAgIHQgPSBYWyhpICsgNCkgJiA3XTsgdiBePSB0IF4gKHQgPDwgNyk7XG4gICAgdCA9IFhbKGkgKyA3KSAmIDddOyB0ID0gdCBeICh0IDw8IDEzKTsgdiBePSB0IF4gKHQgPDwgOSk7XG4gICAgWFtpXSA9IHY7XG4gICAgbWUuaSA9IChpICsgMSkgJiA3O1xuICAgIHJldHVybiB2O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGluaXQobWUsIHNlZWQpIHtcbiAgICB2YXIgaiwgdywgWCA9IFtdO1xuXG4gICAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAgIC8vIFNlZWQgc3RhdGUgYXJyYXkgdXNpbmcgYSAzMi1iaXQgaW50ZWdlci5cbiAgICAgIHcgPSBYWzBdID0gc2VlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VlZCBzdGF0ZSB1c2luZyBhIHN0cmluZy5cbiAgICAgIHNlZWQgPSAnJyArIHNlZWQ7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgc2VlZC5sZW5ndGg7ICsraikge1xuICAgICAgICBYW2ogJiA3XSA9IChYW2ogJiA3XSA8PCAxNSkgXlxuICAgICAgICAgICAgKHNlZWQuY2hhckNvZGVBdChqKSArIFhbKGogKyAxKSAmIDddIDw8IDEzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRW5mb3JjZSBhbiBhcnJheSBsZW5ndGggb2YgOCwgbm90IGFsbCB6ZXJvZXMuXG4gICAgd2hpbGUgKFgubGVuZ3RoIDwgOCkgWC5wdXNoKDApO1xuICAgIGZvciAoaiA9IDA7IGogPCA4ICYmIFhbal0gPT09IDA7ICsraik7XG4gICAgaWYgKGogPT0gOCkgdyA9IFhbN10gPSAtMTsgZWxzZSB3ID0gWFtqXTtcblxuICAgIG1lLnggPSBYO1xuICAgIG1lLmkgPSAwO1xuXG4gICAgLy8gRGlzY2FyZCBhbiBpbml0aWFsIDI1NiB2YWx1ZXMuXG4gICAgZm9yIChqID0gMjU2OyBqID4gMDsgLS1qKSB7XG4gICAgICBtZS5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgaW5pdChtZSwgc2VlZCk7XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLnguc2xpY2UoKTtcbiAgdC5pID0gZi5pO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIGlmIChzZWVkID09IG51bGwpIHNlZWQgPSArKG5ldyBEYXRlKTtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUueCkgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcnNoaWZ0NyA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcInhvcndvd1wiIHBybmcgYWxnb3JpdGhtIGJ5XG4vLyBHZW9yZ2UgTWFyc2FnbGlhLiAgU2VlIGh0dHA6Ly93d3cuanN0YXRzb2Z0Lm9yZy92MDgvaTE0L3BhcGVyXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSAobWUueCBeIChtZS54ID4+PiAyKSk7XG4gICAgbWUueCA9IG1lLnk7IG1lLnkgPSBtZS56OyBtZS56ID0gbWUudzsgbWUudyA9IG1lLnY7XG4gICAgcmV0dXJuIChtZS5kID0gKG1lLmQgKyAzNjI0MzcgfCAwKSkgK1xuICAgICAgIChtZS52ID0gKG1lLnYgXiAobWUudiA8PCA0KSkgXiAodCBeICh0IDw8IDEpKSkgfCAwO1xuICB9O1xuXG4gIG1lLnggPSAwO1xuICBtZS55ID0gMDtcbiAgbWUueiA9IDA7XG4gIG1lLncgPSAwO1xuICBtZS52ID0gMDtcblxuICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgIC8vIEludGVnZXIgc2VlZC5cbiAgICBtZS54ID0gc2VlZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdHJpbmcgc2VlZC5cbiAgICBzdHJzZWVkICs9IHNlZWQ7XG4gIH1cblxuICAvLyBNaXggaW4gc3RyaW5nIHNlZWQsIHRoZW4gZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIDY0IHZhbHVlcy5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJzZWVkLmxlbmd0aCArIDY0OyBrKyspIHtcbiAgICBtZS54IF49IHN0cnNlZWQuY2hhckNvZGVBdChrKSB8IDA7XG4gICAgaWYgKGsgPT0gc3Ryc2VlZC5sZW5ndGgpIHtcbiAgICAgIG1lLmQgPSBtZS54IDw8IDEwIF4gbWUueCA+Pj4gNDtcbiAgICB9XG4gICAgbWUubmV4dCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLng7XG4gIHQueSA9IGYueTtcbiAgdC56ID0gZi56O1xuICB0LncgPSBmLnc7XG4gIHQudiA9IGYudjtcbiAgdC5kID0gZi5kO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3J3b3cgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxOSBEYXZpZCBCYXUuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxuSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcbkNMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXG5UT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRVxuU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBwb29sLCBtYXRoKSB7XG4vL1xuLy8gVGhlIGZvbGxvd2luZyBjb25zdGFudHMgYXJlIHJlbGF0ZWQgdG8gSUVFRSA3NTQgbGltaXRzLlxuLy9cblxudmFyIHdpZHRoID0gMjU2LCAgICAgICAgLy8gZWFjaCBSQzQgb3V0cHV0IGlzIDAgPD0geCA8IDI1NlxuICAgIGNodW5rcyA9IDYsICAgICAgICAgLy8gYXQgbGVhc3Qgc2l4IFJDNCBvdXRwdXRzIGZvciBlYWNoIGRvdWJsZVxuICAgIGRpZ2l0cyA9IDUyLCAgICAgICAgLy8gdGhlcmUgYXJlIDUyIHNpZ25pZmljYW50IGRpZ2l0cyBpbiBhIGRvdWJsZVxuICAgIHJuZ25hbWUgPSAncmFuZG9tJywgLy8gcm5nbmFtZTogbmFtZSBmb3IgTWF0aC5yYW5kb20gYW5kIE1hdGguc2VlZHJhbmRvbVxuICAgIHN0YXJ0ZGVub20gPSBtYXRoLnBvdyh3aWR0aCwgY2h1bmtzKSxcbiAgICBzaWduaWZpY2FuY2UgPSBtYXRoLnBvdygyLCBkaWdpdHMpLFxuICAgIG92ZXJmbG93ID0gc2lnbmlmaWNhbmNlICogMixcbiAgICBtYXNrID0gd2lkdGggLSAxLFxuICAgIG5vZGVjcnlwdG87ICAgICAgICAgLy8gbm9kZS5qcyBjcnlwdG8gbW9kdWxlLCBpbml0aWFsaXplZCBhdCB0aGUgYm90dG9tLlxuXG4vL1xuLy8gc2VlZHJhbmRvbSgpXG4vLyBUaGlzIGlzIHRoZSBzZWVkcmFuZG9tIGZ1bmN0aW9uIGRlc2NyaWJlZCBhYm92ZS5cbi8vXG5mdW5jdGlvbiBzZWVkcmFuZG9tKHNlZWQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBrZXkgPSBbXTtcbiAgb3B0aW9ucyA9IChvcHRpb25zID09IHRydWUpID8geyBlbnRyb3B5OiB0cnVlIH0gOiAob3B0aW9ucyB8fCB7fSk7XG5cbiAgLy8gRmxhdHRlbiB0aGUgc2VlZCBzdHJpbmcgb3IgYnVpbGQgb25lIGZyb20gbG9jYWwgZW50cm9weSBpZiBuZWVkZWQuXG4gIHZhciBzaG9ydHNlZWQgPSBtaXhrZXkoZmxhdHRlbihcbiAgICBvcHRpb25zLmVudHJvcHkgPyBbc2VlZCwgdG9zdHJpbmcocG9vbCldIDpcbiAgICAoc2VlZCA9PSBudWxsKSA/IGF1dG9zZWVkKCkgOiBzZWVkLCAzKSwga2V5KTtcblxuICAvLyBVc2UgdGhlIHNlZWQgdG8gaW5pdGlhbGl6ZSBhbiBBUkM0IGdlbmVyYXRvci5cbiAgdmFyIGFyYzQgPSBuZXcgQVJDNChrZXkpO1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHJhbmRvbSBkb3VibGUgaW4gWzAsIDEpIHRoYXQgY29udGFpbnNcbiAgLy8gcmFuZG9tbmVzcyBpbiBldmVyeSBiaXQgb2YgdGhlIG1hbnRpc3NhIG9mIHRoZSBJRUVFIDc1NCB2YWx1ZS5cbiAgdmFyIHBybmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IGFyYzQuZyhjaHVua3MpLCAgICAgICAgICAgICAvLyBTdGFydCB3aXRoIGEgbnVtZXJhdG9yIG4gPCAyIF4gNDhcbiAgICAgICAgZCA9IHN0YXJ0ZGVub20sICAgICAgICAgICAgICAgICAvLyAgIGFuZCBkZW5vbWluYXRvciBkID0gMiBeIDQ4LlxuICAgICAgICB4ID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgYW5kIG5vICdleHRyYSBsYXN0IGJ5dGUnLlxuICAgIHdoaWxlIChuIDwgc2lnbmlmaWNhbmNlKSB7ICAgICAgICAgIC8vIEZpbGwgdXAgYWxsIHNpZ25pZmljYW50IGRpZ2l0cyBieVxuICAgICAgbiA9IChuICsgeCkgKiB3aWR0aDsgICAgICAgICAgICAgIC8vICAgc2hpZnRpbmcgbnVtZXJhdG9yIGFuZFxuICAgICAgZCAqPSB3aWR0aDsgICAgICAgICAgICAgICAgICAgICAgIC8vICAgZGVub21pbmF0b3IgYW5kIGdlbmVyYXRpbmcgYVxuICAgICAgeCA9IGFyYzQuZygxKTsgICAgICAgICAgICAgICAgICAgIC8vICAgbmV3IGxlYXN0LXNpZ25pZmljYW50LWJ5dGUuXG4gICAgfVxuICAgIHdoaWxlIChuID49IG92ZXJmbG93KSB7ICAgICAgICAgICAgIC8vIFRvIGF2b2lkIHJvdW5kaW5nIHVwLCBiZWZvcmUgYWRkaW5nXG4gICAgICBuIC89IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBsYXN0IGJ5dGUsIHNoaWZ0IGV2ZXJ5dGhpbmdcbiAgICAgIGQgLz0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHJpZ2h0IHVzaW5nIGludGVnZXIgbWF0aCB1bnRpbFxuICAgICAgeCA+Pj49IDE7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgd2UgaGF2ZSBleGFjdGx5IHRoZSBkZXNpcmVkIGJpdHMuXG4gICAgfVxuICAgIHJldHVybiAobiArIHgpIC8gZDsgICAgICAgICAgICAgICAgIC8vIEZvcm0gdGhlIG51bWJlciB3aXRoaW4gWzAsIDEpLlxuICB9O1xuXG4gIHBybmcuaW50MzIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGFyYzQuZyg0KSB8IDA7IH1cbiAgcHJuZy5xdWljayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJjNC5nKDQpIC8gMHgxMDAwMDAwMDA7IH1cbiAgcHJuZy5kb3VibGUgPSBwcm5nO1xuXG4gIC8vIE1peCB0aGUgcmFuZG9tbmVzcyBpbnRvIGFjY3VtdWxhdGVkIGVudHJvcHkuXG4gIG1peGtleSh0b3N0cmluZyhhcmM0LlMpLCBwb29sKTtcblxuICAvLyBDYWxsaW5nIGNvbnZlbnRpb246IHdoYXQgdG8gcmV0dXJuIGFzIGEgZnVuY3Rpb24gb2YgcHJuZywgc2VlZCwgaXNfbWF0aC5cbiAgcmV0dXJuIChvcHRpb25zLnBhc3MgfHwgY2FsbGJhY2sgfHxcbiAgICAgIGZ1bmN0aW9uKHBybmcsIHNlZWQsIGlzX21hdGhfY2FsbCwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgLy8gTG9hZCB0aGUgYXJjNCBzdGF0ZSBmcm9tIHRoZSBnaXZlbiBzdGF0ZSBpZiBpdCBoYXMgYW4gUyBhcnJheS5cbiAgICAgICAgICBpZiAoc3RhdGUuUykgeyBjb3B5KHN0YXRlLCBhcmM0KTsgfVxuICAgICAgICAgIC8vIE9ubHkgcHJvdmlkZSB0aGUgLnN0YXRlIG1ldGhvZCBpZiByZXF1ZXN0ZWQgdmlhIG9wdGlvbnMuc3RhdGUuXG4gICAgICAgICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weShhcmM0LCB7fSk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGNhbGxlZCBhcyBhIG1ldGhvZCBvZiBNYXRoIChNYXRoLnNlZWRyYW5kb20oKSksIG11dGF0ZVxuICAgICAgICAvLyBNYXRoLnJhbmRvbSBiZWNhdXNlIHRoYXQgaXMgaG93IHNlZWRyYW5kb20uanMgaGFzIHdvcmtlZCBzaW5jZSB2MS4wLlxuICAgICAgICBpZiAoaXNfbWF0aF9jYWxsKSB7IG1hdGhbcm5nbmFtZV0gPSBwcm5nOyByZXR1cm4gc2VlZDsgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgaXQgaXMgYSBuZXdlciBjYWxsaW5nIGNvbnZlbnRpb24sIHNvIHJldHVybiB0aGVcbiAgICAgICAgLy8gcHJuZyBkaXJlY3RseS5cbiAgICAgICAgZWxzZSByZXR1cm4gcHJuZztcbiAgICAgIH0pKFxuICBwcm5nLFxuICBzaG9ydHNlZWQsXG4gICdnbG9iYWwnIGluIG9wdGlvbnMgPyBvcHRpb25zLmdsb2JhbCA6ICh0aGlzID09IG1hdGgpLFxuICBvcHRpb25zLnN0YXRlKTtcbn1cblxuLy9cbi8vIEFSQzRcbi8vXG4vLyBBbiBBUkM0IGltcGxlbWVudGF0aW9uLiAgVGhlIGNvbnN0cnVjdG9yIHRha2VzIGEga2V5IGluIHRoZSBmb3JtIG9mXG4vLyBhbiBhcnJheSBvZiBhdCBtb3N0ICh3aWR0aCkgaW50ZWdlcnMgdGhhdCBzaG91bGQgYmUgMCA8PSB4IDwgKHdpZHRoKS5cbi8vXG4vLyBUaGUgZyhjb3VudCkgbWV0aG9kIHJldHVybnMgYSBwc2V1ZG9yYW5kb20gaW50ZWdlciB0aGF0IGNvbmNhdGVuYXRlc1xuLy8gdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGZyb20gQVJDNC4gIEl0cyByZXR1cm4gdmFsdWUgaXMgYSBudW1iZXIgeFxuLy8gdGhhdCBpcyBpbiB0aGUgcmFuZ2UgMCA8PSB4IDwgKHdpZHRoIF4gY291bnQpLlxuLy9cbmZ1bmN0aW9uIEFSQzQoa2V5KSB7XG4gIHZhciB0LCBrZXlsZW4gPSBrZXkubGVuZ3RoLFxuICAgICAgbWUgPSB0aGlzLCBpID0gMCwgaiA9IG1lLmkgPSBtZS5qID0gMCwgcyA9IG1lLlMgPSBbXTtcblxuICAvLyBUaGUgZW1wdHkga2V5IFtdIGlzIHRyZWF0ZWQgYXMgWzBdLlxuICBpZiAoIWtleWxlbikgeyBrZXkgPSBba2V5bGVuKytdOyB9XG5cbiAgLy8gU2V0IHVwIFMgdXNpbmcgdGhlIHN0YW5kYXJkIGtleSBzY2hlZHVsaW5nIGFsZ29yaXRobS5cbiAgd2hpbGUgKGkgPCB3aWR0aCkge1xuICAgIHNbaV0gPSBpKys7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICBzW2ldID0gc1tqID0gbWFzayAmIChqICsga2V5W2kgJSBrZXlsZW5dICsgKHQgPSBzW2ldKSldO1xuICAgIHNbal0gPSB0O1xuICB9XG5cbiAgLy8gVGhlIFwiZ1wiIG1ldGhvZCByZXR1cm5zIHRoZSBuZXh0IChjb3VudCkgb3V0cHV0cyBhcyBvbmUgbnVtYmVyLlxuICAobWUuZyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgLy8gVXNpbmcgaW5zdGFuY2UgbWVtYmVycyBpbnN0ZWFkIG9mIGNsb3N1cmUgc3RhdGUgbmVhcmx5IGRvdWJsZXMgc3BlZWQuXG4gICAgdmFyIHQsIHIgPSAwLFxuICAgICAgICBpID0gbWUuaSwgaiA9IG1lLmosIHMgPSBtZS5TO1xuICAgIHdoaWxlIChjb3VudC0tKSB7XG4gICAgICB0ID0gc1tpID0gbWFzayAmIChpICsgMSldO1xuICAgICAgciA9IHIgKiB3aWR0aCArIHNbbWFzayAmICgoc1tpXSA9IHNbaiA9IG1hc2sgJiAoaiArIHQpXSkgKyAoc1tqXSA9IHQpKV07XG4gICAgfVxuICAgIG1lLmkgPSBpOyBtZS5qID0gajtcbiAgICByZXR1cm4gcjtcbiAgICAvLyBGb3Igcm9idXN0IHVucHJlZGljdGFiaWxpdHksIHRoZSBmdW5jdGlvbiBjYWxsIGJlbG93IGF1dG9tYXRpY2FsbHlcbiAgICAvLyBkaXNjYXJkcyBhbiBpbml0aWFsIGJhdGNoIG9mIHZhbHVlcy4gIFRoaXMgaXMgY2FsbGVkIFJDNC1kcm9wWzI1Nl0uXG4gICAgLy8gU2VlIGh0dHA6Ly9nb29nbGUuY29tL3NlYXJjaD9xPXJzYStmbHVocmVyK3Jlc3BvbnNlJmJ0bklcbiAgfSkod2lkdGgpO1xufVxuXG4vL1xuLy8gY29weSgpXG4vLyBDb3BpZXMgaW50ZXJuYWwgc3RhdGUgb2YgQVJDNCB0byBvciBmcm9tIGEgcGxhaW4gb2JqZWN0LlxuLy9cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmkgPSBmLmk7XG4gIHQuaiA9IGYuajtcbiAgdC5TID0gZi5TLnNsaWNlKCk7XG4gIHJldHVybiB0O1xufTtcblxuLy9cbi8vIGZsYXR0ZW4oKVxuLy8gQ29udmVydHMgYW4gb2JqZWN0IHRyZWUgdG8gbmVzdGVkIGFycmF5cyBvZiBzdHJpbmdzLlxuLy9cbmZ1bmN0aW9uIGZsYXR0ZW4ob2JqLCBkZXB0aCkge1xuICB2YXIgcmVzdWx0ID0gW10sIHR5cCA9ICh0eXBlb2Ygb2JqKSwgcHJvcDtcbiAgaWYgKGRlcHRoICYmIHR5cCA9PSAnb2JqZWN0Jykge1xuICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgIHRyeSB7IHJlc3VsdC5wdXNoKGZsYXR0ZW4ob2JqW3Byb3BdLCBkZXB0aCAtIDEpKTsgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gIH1cbiAgcmV0dXJuIChyZXN1bHQubGVuZ3RoID8gcmVzdWx0IDogdHlwID09ICdzdHJpbmcnID8gb2JqIDogb2JqICsgJ1xcMCcpO1xufVxuXG4vL1xuLy8gbWl4a2V5KClcbi8vIE1peGVzIGEgc3RyaW5nIHNlZWQgaW50byBhIGtleSB0aGF0IGlzIGFuIGFycmF5IG9mIGludGVnZXJzLCBhbmRcbi8vIHJldHVybnMgYSBzaG9ydGVuZWQgc3RyaW5nIHNlZWQgdGhhdCBpcyBlcXVpdmFsZW50IHRvIHRoZSByZXN1bHQga2V5LlxuLy9cbmZ1bmN0aW9uIG1peGtleShzZWVkLCBrZXkpIHtcbiAgdmFyIHN0cmluZ3NlZWQgPSBzZWVkICsgJycsIHNtZWFyLCBqID0gMDtcbiAgd2hpbGUgKGogPCBzdHJpbmdzZWVkLmxlbmd0aCkge1xuICAgIGtleVttYXNrICYgal0gPVxuICAgICAgbWFzayAmICgoc21lYXIgXj0ga2V5W21hc2sgJiBqXSAqIDE5KSArIHN0cmluZ3NlZWQuY2hhckNvZGVBdChqKyspKTtcbiAgfVxuICByZXR1cm4gdG9zdHJpbmcoa2V5KTtcbn1cblxuLy9cbi8vIGF1dG9zZWVkKClcbi8vIFJldHVybnMgYW4gb2JqZWN0IGZvciBhdXRvc2VlZGluZywgdXNpbmcgd2luZG93LmNyeXB0byBhbmQgTm9kZSBjcnlwdG9cbi8vIG1vZHVsZSBpZiBhdmFpbGFibGUuXG4vL1xuZnVuY3Rpb24gYXV0b3NlZWQoKSB7XG4gIHRyeSB7XG4gICAgdmFyIG91dDtcbiAgICBpZiAobm9kZWNyeXB0byAmJiAob3V0ID0gbm9kZWNyeXB0by5yYW5kb21CeXRlcykpIHtcbiAgICAgIC8vIFRoZSB1c2Ugb2YgJ291dCcgdG8gcmVtZW1iZXIgcmFuZG9tQnl0ZXMgbWFrZXMgdGlnaHQgbWluaWZpZWQgY29kZS5cbiAgICAgIG91dCA9IG91dCh3aWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IG5ldyBVaW50OEFycmF5KHdpZHRoKTtcbiAgICAgIChnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0bykuZ2V0UmFuZG9tVmFsdWVzKG91dCk7XG4gICAgfVxuICAgIHJldHVybiB0b3N0cmluZyhvdXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGJyb3dzZXIgPSBnbG9iYWwubmF2aWdhdG9yLFxuICAgICAgICBwbHVnaW5zID0gYnJvd3NlciAmJiBicm93c2VyLnBsdWdpbnM7XG4gICAgcmV0dXJuIFsrbmV3IERhdGUsIGdsb2JhbCwgcGx1Z2lucywgZ2xvYmFsLnNjcmVlbiwgdG9zdHJpbmcocG9vbCldO1xuICB9XG59XG5cbi8vXG4vLyB0b3N0cmluZygpXG4vLyBDb252ZXJ0cyBhbiBhcnJheSBvZiBjaGFyY29kZXMgdG8gYSBzdHJpbmdcbi8vXG5mdW5jdGlvbiB0b3N0cmluZyhhKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KDAsIGEpO1xufVxuXG4vL1xuLy8gV2hlbiBzZWVkcmFuZG9tLmpzIGlzIGxvYWRlZCwgd2UgaW1tZWRpYXRlbHkgbWl4IGEgZmV3IGJpdHNcbi8vIGZyb20gdGhlIGJ1aWx0LWluIFJORyBpbnRvIHRoZSBlbnRyb3B5IHBvb2wuICBCZWNhdXNlIHdlIGRvXG4vLyBub3Qgd2FudCB0byBpbnRlcmZlcmUgd2l0aCBkZXRlcm1pbmlzdGljIFBSTkcgc3RhdGUgbGF0ZXIsXG4vLyBzZWVkcmFuZG9tIHdpbGwgbm90IGNhbGwgbWF0aC5yYW5kb20gb24gaXRzIG93biBhZ2FpbiBhZnRlclxuLy8gaW5pdGlhbGl6YXRpb24uXG4vL1xubWl4a2V5KG1hdGgucmFuZG9tKCksIHBvb2wpO1xuXG4vL1xuLy8gTm9kZWpzIGFuZCBBTUQgc3VwcG9ydDogZXhwb3J0IHRoZSBpbXBsZW1lbnRhdGlvbiBhcyBhIG1vZHVsZSB1c2luZ1xuLy8gZWl0aGVyIGNvbnZlbnRpb24uXG4vL1xuaWYgKCh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHNlZWRyYW5kb207XG4gIC8vIFdoZW4gaW4gbm9kZS5qcywgdHJ5IHVzaW5nIGNyeXB0byBwYWNrYWdlIGZvciBhdXRvc2VlZGluZy5cbiAgdHJ5IHtcbiAgICBub2RlY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gIH0gY2F0Y2ggKGV4KSB7fVxufSBlbHNlIGlmICgodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIHNlZWRyYW5kb207IH0pO1xufSBlbHNlIHtcbiAgLy8gV2hlbiBpbmNsdWRlZCBhcyBhIHBsYWluIHNjcmlwdCwgc2V0IHVwIE1hdGguc2VlZHJhbmRvbSBnbG9iYWwuXG4gIG1hdGhbJ3NlZWQnICsgcm5nbmFtZV0gPSBzZWVkcmFuZG9tO1xufVxuXG5cbi8vIEVuZCBhbm9ueW1vdXMgc2NvcGUsIGFuZCBwYXNzIGluaXRpYWwgdmFsdWVzLlxufSkoXG4gIC8vIGdsb2JhbDogYHNlbGZgIGluIGJyb3dzZXJzIChpbmNsdWRpbmcgc3RyaWN0IG1vZGUgYW5kIHdlYiB3b3JrZXJzKSxcbiAgLy8gb3RoZXJ3aXNlIGB0aGlzYCBpbiBOb2RlIGFuZCBvdGhlciBlbnZpcm9ubWVudHNcbiAgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgPyBzZWxmIDogdGhpcyxcbiAgW10sICAgICAvLyBwb29sOiBlbnRyb3B5IHBvb2wgc3RhcnRzIGVtcHR5XG4gIE1hdGggICAgLy8gbWF0aDogcGFja2FnZSBjb250YWluaW5nIHJhbmRvbSwgcG93LCBhbmQgc2VlZHJhbmRvbVxuKTtcbiIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIjtcclxuaW1wb3J0IHsgR2FtZURhdGEsIFJvb3RzIH0gZnJvbSBcIi4vcm9vdHMvUm9vdHNcIjtcclxuaW1wb3J0IHsgR2FtZVJlbmRlcmVyIGFzIEdhbWVSZW5kZXJlciB9IGZyb20gXCIuL3JlbmRlci9HYW1lUmVuZGVyZXJcIjtcclxuXHJcbndpbmRvdy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vIENyZWF0ZSB0aGUgYXBwbGljYXRpb24gaGVscGVyIGFuZCBhZGQgaXRzIHJlbmRlciB0YXJnZXQgdG8gdGhlIHBhZ2VcclxuICAgIGxldCBhcHAgPSBuZXcgUElYSS5BcHBsaWNhdGlvbjxIVE1MQ2FudmFzRWxlbWVudD4oeyBcclxuICAgICAgICB3aWR0aDogMTIwMCwgXHJcbiAgICAgICAgaGVpZ2h0OiA4MDAsXHJcbiAgICAgICAgYW50aWFsaWFzOiB0cnVlLFxyXG4gICAgICAgIGF1dG9EZW5zaXR5OiB0cnVlLFxyXG4gICAgfSk7XHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGFwcC52aWV3KTtcclxuXHJcbiAgICBsZXQgc2VlZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKTtcclxuICAgIGxldCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xyXG4gICAgaWYgKHBhcmFtcy5oYXMoJ3NlZWQnKSkge1xyXG4gICAgICAgIGxldCBwYXJhbVNlZWQgPSBwYXJhbXMuZ2V0KCdzZWVkJyk7XHJcbiAgICAgICAgaWYgKHBhcmFtU2VlZC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHNlZWQgPSBwYXJhbVNlZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBsZXQgZ2FtZSA9IG5ldyBSb290cyhzZWVkKTtcclxuICAgIGdhbWUub25OZWVkU2F2ZSA9IChkYXRhOiBHYW1lRGF0YSkgPT4ge1xyXG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShzZWVkLCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBsZXQgc2F2ZWRKU09OID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKHNlZWQpO1xyXG4gICAgaWYgKHNhdmVkSlNPTiAhPSBudWxsKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKHNhdmVkSlNPTik7XHJcbiAgICAgICAgICAgIGdhbWUuZGVzZXJpYWxpemUoZGF0YSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdmaWxlZCB0byBsb2FkIHNhdmUgZm9yIHNlZWQnLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGdhbWUuY3JlYXRlTmV3TGV2ZWwoKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgcmVuZGVyZXIgPSBuZXcgR2FtZVJlbmRlcmVyKGFwcCwgZ2FtZSk7XHJcbiAgICByZW5kZXJlci5zdGFydCgpO1xyXG5cclxuICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShudWxsLCBudWxsLCBgP3NlZWQ9JHtzZWVkfWApO1xyXG5cclxuICAgIGRvY3VtZW50Lm9uY29udGV4dG1lbnUgPSBkb2N1bWVudC5ib2R5Lm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIC8vIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufTtcclxuIiwiZXhwb3J0IGNvbnN0IGFuaW1hbEljb25zID0gYFxyXG5hbGxpZ2F0b3IucG5nXHJcbmFuYWNvbmRhLnBuZ1xyXG5hbmdlbGZpc2gucG5nXHJcbmFudC5wbmdcclxuYW50ZWF0ZXIucG5nXHJcbmFudGVsb3BlLnBuZ1xyXG5hcGF0b3NhdXJ1cy5wbmdcclxuYXRsYXNfYmVldGxlLnBuZ1xyXG5iYWJvb24ucG5nXHJcbmJhc3MucG5nXHJcbmJhdC5wbmdcclxuYmVhci5wbmdcclxuYmVhdmVyLnBuZ1xyXG5iZWUucG5nXHJcbmJpc29uLnBuZ1xyXG5ibGFja19wYW50aGVyLnBuZ1xyXG5ibHVlX3doYWxlLnBuZ1xyXG5ib2FyLnBuZ1xyXG5ib3hlcl9kb2cucG5nXHJcbmJ1ZmZhbG8ucG5nXHJcbmJ1bGwucG5nXHJcbmJ1bGxkb2cucG5nXHJcbmJ1dHRlcmZseS5wbmdcclxuYnV0dGVyZmx5ZmlzaC5wbmdcclxuY2FtZWwucG5nXHJcbmNhcmRpbmFsLnBuZ1xyXG5jYXQucG5nXHJcbmNhdGZpc2gucG5nXHJcbmNhdHRlcnBpbGxhci5wbmdcclxuY2VudGlwZWRlLnBuZ1xyXG5jaGFtZWxlb24ucG5nXHJcbmNoZWV0YWgucG5nXHJcbmNoaWNrZW4ucG5nXHJcbmNoaW1lcmEucG5nXHJcbmNoaW1wYW56ZWUucG5nXHJcbmNoaW5lc2VfZHJhZ29uLnBuZ1xyXG5jaGlwbXVuay5wbmdcclxuY2xhbS5wbmdcclxuY29icmEucG5nXHJcbmNvY2thdG9vLnBuZ1xyXG5jb2Nrcm9hY2gucG5nXHJcbmNvZGZpc2gucG5nXHJcbmNvcmFsLnBuZ1xyXG5jb3VnYXIucG5nXHJcbmNvdy5wbmdcclxuY3JhYi5wbmdcclxuY3JvY29kaWxlLnBuZ1xyXG5jcm93LnBuZ1xyXG5kYWxtYXRpYW4ucG5nXHJcbmRlZXIucG5nXHJcbmRvYmVybWFuLnBuZ1xyXG5kb2xwaGluLnBuZ1xyXG5kb25rZXkucG5nXHJcbmRyYWdvbmZseS5wbmdcclxuZHVjay5wbmdcclxuZWFnbGUucG5nXHJcbmVhcnRod29ybS5wbmdcclxuZWFyd2lnLnBuZ1xyXG5lbGVjdHJpY19rbmlmZWZpc2gucG5nXHJcbmVsZXBoYW50LnBuZ1xyXG5mYWxjb24ucG5nXHJcbmZpbmNoLnBuZ1xyXG5maXNoLnBuZ1xyXG5mbGFtaW5nby5wbmdcclxuZmxhdHdvcm0ucG5nXHJcbmZsZWEucG5nXHJcbmZseS5wbmdcclxuZmx5aW5nX2Zpc2gucG5nXHJcbmZveC5wbmdcclxuZnJvZy5wbmdcclxuZnJvZzIucG5nXHJcbmdhemVsbGUucG5nXHJcbmdlcm1hbl9zaGVwaGVyZC5wbmdcclxuZ2hhcmlhbC5wbmdcclxuZ2lyYWZmZS5wbmdcclxuZ29hdC5wbmdcclxuZ29sZGVuX3JldHJpZXZlci5wbmdcclxuZ29sZGZpc2gucG5nXHJcbmdvb3NlLnBuZ1xyXG5nb3JpbGxhLnBuZ1xyXG5ncmFzc2hvcHBlci5wbmdcclxuZ3JleWhvdW5kLnBuZ1xyXG5ncmlmZmluLnBuZ1xyXG5ndWluZWFfcGlnLnBuZ1xyXG5ndWxsLnBuZ1xyXG5oYXJlLnBuZ1xyXG5oZW4ucG5nXHJcbmhlcm9uLnBuZ1xyXG5oZXJyaW5nLnBuZ1xyXG5oaXBwb3BvdGFtdXMucG5nXHJcbmhvcm5iaWxsLnBuZ1xyXG5ob3JzZS5wbmdcclxuaG93bGluZ19tb25rZXkucG5nXHJcbmh1bW1pbmdiaXJkLnBuZ1xyXG5oeWVuYS5wbmdcclxuaWJleC5wbmdcclxuaWd1YW5hLnBuZ1xyXG5qYWNrYWwucG5nXHJcbmplbGx5ZmlzaC5wbmdcclxua2FuZ2Fyb28ucG5nXHJcbmtpbGxlcl93aGFsZS5wbmdcclxua2luZ2Zpc2hlci5wbmdcclxua2l3aV9iaXJkLnBuZ1xyXG5rb2FsYS5wbmdcclxua3Jha2VuLnBuZ1xyXG5sYWR5YnVnLnBuZ1xyXG5sZW11ci5wbmdcclxubGVvcGFyZC5wbmdcclxubGlvbi5wbmdcclxubGlvbmVzcy5wbmdcclxubGxhbWEucG5nXHJcbmxvYnN0ZXIucG5nXHJcbmxvbmdob3JuX2JlZXRsZS5wbmdcclxubG92ZWJpcmQucG5nXHJcbmx1bXBmaXNoLnBuZ1xyXG5tYWNhdy5wbmdcclxubWFtbW90aC5wbmdcclxubWFuYXRlZS5wbmdcclxubWFudGFyYXkucG5nXHJcbm1hbnRpcy5wbmdcclxubWVlcmthdC5wbmdcclxubWlsbGlwZWRlLnBuZ1xyXG5taXRlLnBuZ1xyXG5tb2xlLnBuZ1xyXG5tb25rZXkucG5nXHJcbm1vb3NlLnBuZ1xyXG5tb3NxdWl0by5wbmdcclxubW91c2UucG5nXHJcbm9jdG9wdXMucG5nXHJcbm9zdHJpY2gucG5nXHJcbm90dGVyLnBuZ1xyXG5vd2wucG5nXHJcbnBhbmRhLnBuZ1xyXG5wYW5nb2xpbi5wbmdcclxucGFyYWtlZXQucG5nXHJcbnBhcmFzYXVyb2xvcGh1cy5wbmdcclxucGFycm90LnBuZ1xyXG5wZWFjb2NrLnBuZ1xyXG5wZWdhc3VzLnBuZ1xyXG5wZWxpY2FuLnBuZ1xyXG5wZW5ndWluLnBuZ1xyXG5waGVhc2FudC5wbmdcclxucGlnLnBuZ1xyXG5waWdlb24ucG5nXHJcbnBpbGxidWcucG5nXHJcbnBpcmFuaGEucG5nXHJcbnBsYXR5cHVzLnBuZ1xyXG5wbGVzaW9zYXVyLnBuZ1xyXG5wb2xhcl9iZWFyLnBuZ1xyXG5wcmF3bi5wbmdcclxucHRlcm9zYXVyLnBuZ1xyXG5wdWZmZXJmaXNoLnBuZ1xyXG5wdWZmaW4ucG5nXHJcbnB5dGhvbi5wbmdcclxucmFiYml0LnBuZ1xyXG5yYWNjb29uLnBuZ1xyXG5yYW0ucG5nXHJcbnJhdC5wbmdcclxucmF0dGxlc25ha2UucG5nXHJcbnJlZF9wYW5kYS5wbmdcclxucmhpbm9jZXJvcy5wbmdcclxucmhpbm9jZXJvc19iZWV0bGUucG5nXHJcbnJvYmluLnBuZ1xyXG5yb29zdGVyLnBuZ1xyXG5zYWlsZmlzaC5wbmdcclxuc2FsYW1hbmRlci5wbmdcclxuc2FsbW9uLnBuZ1xyXG5zY29ycGlvbi5wbmdcclxuc2VhaG9yc2UucG5nXHJcbnNlYWwucG5nXHJcbnNlYWxpb24ucG5nXHJcbnNlYV9hbmVtb25lLnBuZ1xyXG5zZWFfdXJjaGluLnBuZ1xyXG5zaGFyay5wbmdcclxuc2hlZXAucG5nXHJcbnNsb3RoLnBuZ1xyXG5zbHVnLnBuZ1xyXG5zbmFpbC5wbmdcclxuc3BhcnJvdy5wbmdcclxuc3Blcm1fd2hhbGUucG5nXHJcbnNwaWRlci5wbmdcclxuc3F1aWQucG5nXHJcbnNxdWlycmVsLnBuZ1xyXG5zdGFnX2JlZXRsZS5wbmdcclxuc3RhcmZpc2gucG5nXHJcbnN0ZWdvc2F1cnVzLnBuZ1xyXG5zdG9yay5wbmdcclxuc3R1cmdlb24ucG5nXHJcbnN3YWxsb3cucG5nXHJcbnN3YW4ucG5nXHJcbnRhZHBvbGUucG5nXHJcbnRhcGlyLnBuZ1xyXG50YXJhbnR1bGEucG5nXHJcbnRlcm1pdGUucG5nXHJcbnRpZ2VyLnBuZ1xyXG50b2FkLnBuZ1xyXG50b3J0b2lzZS5wbmdcclxudG91Y2FuLnBuZ1xyXG50cmljZXJhdG9wcy5wbmdcclxudHVuYS5wbmdcclxudHVya2V5LnBuZ1xyXG50dXJ0bGUucG5nXHJcbnR5cmFubm9zYXVydXMucG5nXHJcbnVuaWNvcm4ucG5nXHJcbnZ1bHR1cmUucG5nXHJcbndhbHJ1cy5wbmdcclxud2FzcC5wbmdcclxud2lsZF9kb2cucG5nXHJcbndvbGYucG5nXHJcbndvb2RwZWNrZXIucG5nXHJcbnplYnJhLnBuZ1xyXG5gIiwiaW1wb3J0ICogYXMgUElYSSBmcm9tICdwaXhpLmpzJztcclxuaW1wb3J0IHsgUm9vdHMgfSBmcm9tICcuLi9yb290cy9Sb290cyc7XHJcbmltcG9ydCB7IEdyaWRSZW5kZXJlciB9IGZyb20gJy4vR3JpZFJlbmRlcic7XHJcbmltcG9ydCB7IGFuaW1hbEljb25zIH0gZnJvbSAnLi9BbmltYWxzJztcclxuaW1wb3J0IHsgTGV2ZWxHZW5lcmF0b3IgfSBmcm9tICcuLi9yb290cy9MZXZlbEdlbmVyYXRvcic7XHJcbmltcG9ydCBzZWVkcmFuZG9tIGZyb20gJ3NlZWRyYW5kb20nXHJcblxyXG5leHBvcnQgY2xhc3MgR2FtZVJlbmRlcmVyIHtcclxuICAgIFxyXG4gICAgYXBwOiBQSVhJLkFwcGxpY2F0aW9uO1xyXG4gICAgZ2FtZTogUm9vdHM7XHJcbiAgICBncmlkUmVuZGVyZXI6IEdyaWRSZW5kZXJlcjtcclxuXHJcbiAgICBncm91cEFuaW1hbFBhdGhzOiBzdHJpbmdbXTtcclxuICAgIGdyb3VwQ29sb3JzOiBQSVhJLkNvbG9yW107XHJcblxyXG4gICAgc3RvbmVSZW5kZXJlcnM6IFBJWEkuR3JhcGhpY3NbXTtcclxuICAgIGNvbnRhaW5lcjogUElYSS5Db250YWluZXI7XHJcblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwcDogUElYSS5BcHBsaWNhdGlvbiwgZ2FtZTogUm9vdHMpIHtcclxuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcclxuICAgICAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gbmV3IFBJWEkuQ29udGFpbmVyKCk7XHJcbiAgICAgICAgYXBwLnN0YWdlLmFkZENoaWxkKHRoaXMuY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgdGhpcy5pbml0R3JvdXBzKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5nYW1lLm9uTmVlZFJlZnJlc2ggPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RvbmVzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JpZFJlbmRlcmVyLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdEdyb3VwcygpIHtcclxuICAgICAgICBsZXQgcm5nOiAoKSA9PiBudW1iZXIgPSBzZWVkcmFuZG9tKHRoaXMuZ2FtZS5zZWVkKTtcclxuXHJcbiAgICAgICAgbGV0IG5CYXNpY0NvbG9ycyA9IDU7XHJcbiAgICAgICAgbGV0IGJhc2ljQ29sb3JzID0gQXJyYXkuZnJvbShuZXcgQXJyYXkobkJhc2ljQ29sb3JzKS5rZXlzKCkpLm1hcChpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQSVhJLkNvbG9yKHtoOiBpICogMzYwIC8gbkJhc2ljQ29sb3JzLCBzOiA4NSwgdjogMTAwfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gYmFzaWNDb2xvcnMuZm9yRWFjaCgoYywgaSkgPT4gY29uc29sZS5sb2coaSwgYy50b1JnYmFTdHJpbmcoKSkpXHJcbiAgICAgICAgdGhpcy5ncm91cENvbG9ycyA9IGJhc2ljQ29sb3JzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCBuR3JvdXBzID0gTGV2ZWxHZW5lcmF0b3IubWF4R3JvdXBJbmRleDtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgcGF0aHMgPSBhbmltYWxJY29ucy5zcGxpdCgnXFxuJykuZmlsdGVyKHMgPT4gcy5sZW5ndGggPiAwKS5tYXAocyA9PiBzLnRyaW0oKSk7XHJcbiAgICAgICAgLy8gc2h1ZmZsZSBwYXRoc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBwYXRocy5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKHJuZygpICogKGkgKyAxKSk7XHJcbiAgICAgICAgICAgIFtwYXRoc1tpXSwgcGF0aHNbal1dID0gW3BhdGhzW2pdLCBwYXRoc1tpXV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ3JvdXBBbmltYWxQYXRocyA9IEFycmF5LmZyb20obmV3IEFycmF5KG5Hcm91cHMpLmtleXMoKSlcclxuICAgICAgICAubWFwKGkgPT4gcGF0aHNbaSAlIHBhdGhzLmxlbmd0aF0pO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVN0b25lcygpIHtcclxuICAgICAgICB0aGlzLnN0b25lUmVuZGVyZXJzLmZvckVhY2goKHNwcml0ZSwgaSkgPT4ge1xyXG4gICAgICAgICAgICBzcHJpdGUudmlzaWJsZSA9IGkgPCB0aGlzLmdhbWUubkZyZWVTdG9uZXM7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29sb3JGb3JHcm91cEluZGV4KGluZGV4OiBudW1iZXIpIDogUElYSS5Db2xvciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBDb2xvcnNbaW5kZXhdO1xyXG4gICAgfVxyXG5cclxuICAgIGljb25QYXRoRm9yR3JvdXBJbmRleChpbmRleDogbnVtYmVyKSA6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIGBpbWcvYW5pbWFscy8ke3RoaXMuZ3JvdXBBbmltYWxQYXRoc1tpbmRleF19YDtcclxuICAgIH1cclxuXHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKGRlbHRhID0+IHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUoZGVsdGEpOyAgXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5ncmlkUmVuZGVyZXIgPSBuZXcgR3JpZFJlbmRlcmVyKHRoaXMsIHRoaXMuZ2FtZS5ncmlkKTtcclxuICAgICAgICB0aGlzLmdyaWRSZW5kZXJlci5pbml0KCk7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2hpbGQodGhpcy5ncmlkUmVuZGVyZXIuY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgLy8gdGhpcy5ncmlkUmVuZGVyZXIuZ3JhcGhpY3MueCA9IHRoaXMuYXBwLnNjcmVlbi53aWR0aCAvIDI7XHJcbiAgICAgICAgLy8gdGhpcy5ncmlkUmVuZGVyZXIuZ3JhcGhpY3MueSA9IHRoaXMuYXBwLnNjcmVlbi5oZWlnaHQgLyAyO1xyXG5cclxuICAgICAgICB0aGlzLnN0b25lUmVuZGVyZXJzID0gQXJyYXkuZnJvbShuZXcgQXJyYXkoTGV2ZWxHZW5lcmF0b3IubWF4U3RvbmVzKS5rZXlzKCkpLm1hcChpID0+IHtcclxuICAgICAgICAgICAgbGV0IHNwcml0ZSA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XHJcbiAgICAgICAgICAgIHNwcml0ZS5iZWdpbkZpbGwoMHhmZmZmZmYpO1xyXG4gICAgICAgICAgICBzcHJpdGUuZHJhd0NpcmNsZSgwLCAwLCAxMCk7XHJcbiAgICAgICAgICAgIHNwcml0ZS5lbmRGaWxsKCk7XHJcbiAgICAgICAgICAgIHNwcml0ZS54ID0gaSAqIDI1ICsgMTA7XHJcbiAgICAgICAgICAgIHNwcml0ZS55ID0gdGhpcy5hcHAuc2NyZWVuLmhlaWdodCAtIDIwO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDaGlsZChzcHJpdGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3ByaXRlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMudXBkYXRlU3RvbmVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKGRlbHRhOiBudW1iZXIpIHtcclxuICAgICAgICBcclxuICAgIH1cclxufSIsImltcG9ydCB7IEdyaWQgfSBmcm9tIFwiaG9uZXljb21iLWdyaWRcIjtcclxuaW1wb3J0IHsgVGlsZSB9IGZyb20gXCIuLi9yb290cy9UaWxlXCI7XHJcbmltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIjtcclxuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSBcInBpeGkuanNcIjtcclxuaW1wb3J0IHsgR2FtZVJlbmRlcmVyIH0gZnJvbSBcIi4vR2FtZVJlbmRlcmVyXCI7XHJcbmltcG9ydCB7IEhleFJlbmRlcmVyIH0gZnJvbSBcIi4vSGV4UmVuZGVyZXJcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBHcmlkUmVuZGVyZXIge1xyXG5cclxuICAgIHJlbmRlcmVyOiBHYW1lUmVuZGVyZXJcclxuICAgIGdyaWQ6IEdyaWQ8VGlsZT47XHJcblxyXG4gICAgY29udGFpbmVyOiBDb250YWluZXI7XHJcbiAgICBjaGlsZHJlbjogSGV4UmVuZGVyZXJbXSA9IFtdO1xyXG4gICAgaG92ZXJHcm91cEluZGV4OiBudW1iZXIgPSAtMTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcjogR2FtZVJlbmRlcmVyLCBncmlkOiBHcmlkPFRpbGU+KSB7XHJcbiAgICAgICAgdGhpcy5ncmlkID0gZ3JpZDtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBuZXcgUElYSS5Db250YWluZXIoKTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lci5zb3J0YWJsZUNoaWxkcmVuID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpbml0KCkge1xyXG4gICAgICAgIHRoaXMuZ3JpZC5mb3JFYWNoKHRpbGUgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaGV4UmVuZGVyZXIgPSBuZXcgSGV4UmVuZGVyZXIodGlsZSwgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChoZXhSZW5kZXJlcik7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENoaWxkKGhleFJlbmRlcmVyKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZWZyZXNoKCkge1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChoZXhSZW5kZXJlciA9PiB7XHJcbiAgICAgICAgICAgIGhleFJlbmRlcmVyLnJlZHJhdygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUhvdmVyKGluZGV4OiBudW1iZXIsIGhvdmVyOiBib29sZWFuKSB7XHJcbiAgICAgICAgbGV0IG9sZEluZGV4ID0gdGhpcy5ob3Zlckdyb3VwSW5kZXg7XHJcbiAgICAgICAgdGhpcy5ob3Zlckdyb3VwSW5kZXggPSBob3ZlciA/IGluZGV4IDogLTE7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlblxyXG4gICAgICAgIC5maWx0ZXIoaGV4UmVuZGVyZXIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGV4UmVuZGVyZXIudGlsZS5ncm91cEluZGV4ID09PSBvbGRJbmRleCB8fCBcclxuICAgICAgICAgICAgICAgIGhleFJlbmRlcmVyLnRpbGUuZ3JvdXBJbmRleCA9PT0gaW5kZXhcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5mb3JFYWNoKGhleFJlbmRlcmVyID0+IHtcclxuICAgICAgICAgICAgaGV4UmVuZGVyZXIucmVkcmF3KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKGRlbHRhOiBudW1iZXIpIHtcclxuICAgIH1cclxuXHJcbn0iLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCI7XHJcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gXCJwaXhpLmpzXCI7XHJcbmltcG9ydCB7IFRpbGUgfSBmcm9tIFwiLi4vcm9vdHMvVGlsZVwiO1xyXG5pbXBvcnQgeyBHcmlkUmVuZGVyZXIgfSBmcm9tIFwiLi9HcmlkUmVuZGVyXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgSGV4UmVuZGVyZXIgZXh0ZW5kcyBDb250YWluZXIge1xyXG4gICAgdGlsZTogVGlsZTtcclxuICAgIGljb246IFBJWEkuU3ByaXRlO1xyXG4gICAgaGV4OiBQSVhJLkdyYXBoaWNzO1xyXG4gICAgaG92ZXJlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgZ3JpZFJlbmRlcmVyOiBHcmlkUmVuZGVyZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IodGlsZTogVGlsZSwgZ3JpZFJlbmRlcmVyOiBHcmlkUmVuZGVyZXIpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZ3JpZFJlbmRlcmVyID0gZ3JpZFJlbmRlcmVyO1xyXG4gICAgICAgIHRoaXMudGlsZSA9IHRpbGU7XHJcblxyXG4gICAgICAgIGxldCBpY29uID0gdGhpcy5pY29uID0gbmV3IFBJWEkuU3ByaXRlKCk7XHJcbiAgICAgICAgaWYgKHRpbGUuZ3JvdXBJbmRleCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGljb24udGV4dHVyZSA9IFBJWEkuVGV4dHVyZS5mcm9tKHRoaXMuZ3JpZFJlbmRlcmVyLnJlbmRlcmVyLmljb25QYXRoRm9yR3JvdXBJbmRleCh0aWxlLmdyb3VwSW5kZXgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWNvbi5hbmNob3Iuc2V0KDAuNSk7XHJcbiAgICAgICAgbGV0IGljb25SYXRpbyA9IDAuNjtcclxuICAgICAgICBpY29uLndpZHRoID0gdGlsZS53aWR0aCAqIGljb25SYXRpbztcclxuICAgICAgICBpY29uLmhlaWdodCA9IHRpbGUuaGVpZ2h0ICogaWNvblJhdGlvO1xyXG4gICAgICAgIGljb24ueCA9IHRpbGUud2lkdGggLyAyO1xyXG4gICAgICAgIGljb24ueSA9IHRpbGUuaGVpZ2h0IC8gMjtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgZ3JhcGhpY3MgPSB0aGlzLmhleCA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5hZGRDaGlsZChncmFwaGljcyk7XHJcbiAgICAgICAgdGhpcy5hZGRDaGlsZChpY29uKTtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gLXRpbGUuY2VudGVyLng7XHJcbiAgICAgICAgdGhpcy55ID0gLXRpbGUuY2VudGVyLnk7XHJcblxyXG4gICAgICAgIHRoaXMucmVkcmF3KCk7XHJcblxyXG4gICAgICAgIGdyYXBoaWNzLmludGVyYWN0aXZlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZ3JhcGhpY3Mub25tb3VzZWVudGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50aWxlLnVubG9ja2VkIHx8IHRoaXMudGlsZS5ncm91cEluZGV4ID09PSB1bmRlZmluZWQpIHJldHVybjtcclxuICAgICAgICAgICAgdGhpcy5ob3ZlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5ncmlkUmVuZGVyZXIudXBkYXRlSG92ZXIodGlsZS5ncm91cEluZGV4LCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ3JhcGhpY3Mub25tb3VzZWxlYXZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmhvdmVyZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5ncmlkUmVuZGVyZXIudXBkYXRlSG92ZXIodGlsZS5ncm91cEluZGV4LCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdyYXBoaWNzLm9ucmlnaHRjbGljayA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyaWdodCBjbGlja2VkJywgdGlsZS5pZCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JpZFJlbmRlcmVyLnJlbmRlcmVyLmdhbWUuY2xlYXJTZWxlY3Rpb24oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdyYXBoaWNzLm9uY2xpY2sgPSAoZSkgPT4geyAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aWxlLmNsaWNrZWQoKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5ob3ZlcmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIHRoaXMuZ3JpZFJlbmRlcmVyLnVwZGF0ZUhvdmVyKHRpbGUuZ3JvdXBJbmRleCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLnJlZHJhdygpO1xyXG4gICAgICAgICAgICB0aGlzLmdyaWRSZW5kZXJlci5yZW5kZXJlci51cGRhdGVTdG9uZXMoKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2NsaWNrZWQnLCB0aWxlLmlkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgXHJcblxyXG4gICAgcmVkcmF3KCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCB0aWxlID0gdGhpcy50aWxlO1xyXG4gICAgICAgIGxldCBoZXggPSB0aGlzLmhleDtcclxuXHJcbiAgICAgICAgbGV0IGFjdGl2ZSA9IHRpbGUudW5sb2NrZWQgfHwgdGlsZS5hY3RpdmU7XHJcblxyXG4gICAgICAgIGxldCBjb2xvciA9IHRoaXMuZ3JpZFJlbmRlcmVyLnJlbmRlcmVyLmNvbG9yRm9yR3JvdXBJbmRleCh0aWxlLmdyb3VwQ291bnQgLSAyKTtcclxuICAgICAgICBpZiAodGlsZS5pc1N0b25lVGlsZSkgY29sb3IgPSBuZXcgUElYSS5Db2xvcigweDg4ODg4OCk7XHJcbiAgICAgICAgbGV0IGxpbmVDb2xvcjtcclxuICAgICAgICBsZXQgbGluZUNvbG9yQWxwaGEgPSAxO1xyXG4gICAgICAgIGxldCB6SW5kZXggPSAwO1xyXG4gICAgICAgIGlmICh0aWxlLnVubG9ja2VkKSB7XHJcbiAgICAgICAgICAgIGxpbmVDb2xvciA9IDB4ZWVlZWVlO1xyXG4gICAgICAgICAgICBoZXguekluZGV4ID0gYWN0aXZlID8gMSA6IDA7XHJcbiAgICAgICAgICAgIHpJbmRleCA9IDE7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aWxlLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICBsaW5lQ29sb3IgPSAweGZmMDBmZjtcclxuICAgICAgICAgICAgekluZGV4ID0gMjtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZ3JpZFJlbmRlcmVyLmhvdmVyR3JvdXBJbmRleCA9PT0gdGlsZS5ncm91cEluZGV4KSB7XHJcbiAgICAgICAgICAgIGxpbmVDb2xvciA9IDB4ZWVhYWVlO1xyXG4gICAgICAgICAgICB6SW5kZXggPSAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxpbmVDb2xvciA9IDB4MDAwMDAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnpJbmRleCA9IHpJbmRleDtcclxuXHJcbiAgICAgICAgaGV4LmNsZWFyKCk7XHJcbiAgICAgICAgaGV4LmJlZ2luRmlsbChjb2xvcik7XHJcbiAgICAgICAgaGV4LmxpbmVTdHlsZSgzLCBsaW5lQ29sb3IsIGxpbmVDb2xvckFscGhhKTtcclxuICAgICAgICBsZXQgdHJhbnNsYXRlZENvcm5lcnMgPSB0aWxlLmNvcm5lcnMubWFwKGMgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4ge3g6IGMueCArIHRpbGUuY2VudGVyLngsIHk6IGMueSArIHRpbGUuY2VudGVyLnl9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGhleC5kcmF3UG9seWdvbih0cmFuc2xhdGVkQ29ybmVycyk7XHJcbiAgICAgICAgaGV4LmVuZEZpbGwoKTtcclxuXHJcblxyXG4gICAgICAgIGlmICh0aGlzLmdyaWRSZW5kZXJlci5ob3Zlckdyb3VwSW5kZXggPT09IHRpbGUuZ3JvdXBJbmRleCkge1xyXG4gICAgICAgICAgICBoZXgudGludCA9IGFjdGl2ZSA/IDB4ZWVlZWVlIDogMHhlZWVlZWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaGV4LnRpbnQgPSBhY3RpdmUgPyAweGZmZmZmZiA6IDB4ODg4ODg4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCB7IFRpbGUgfSBmcm9tIFwiLi9UaWxlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgQ2x1c3RlcmluZyB7XHJcbiAgICAvLyBtYXA6IE1hcDxudW1iZXIsIG51bWJlcj47XHJcbiAgICBjbHVzdGVyczogbnVtYmVyW11bXTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvLyB0aGlzLm1hcCA9IG5ldyBNYXA8bnVtYmVyLCBudW1iZXI+KCk7XHJcbiAgICAgICAgdGhpcy5jbHVzdGVycyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIGdldENsdXN0ZXJJbmRleCh0aWxlSUQ6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgLy8gcmV0dXJuIHRoaXMubWFwLmdldCh0aWxlSUQpO1xyXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuY2x1c3RlcnMuZmluZEluZGV4KGNsdXN0ZXIgPT4gY2x1c3Rlci5pbmNsdWRlcyh0aWxlSUQpKTtcclxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJldHVybiBpbmRleDtcclxuICAgIH1cclxuXHJcbiAgICBhZGROZXdDbHVzdGVyKHRpbGVJRDogbnVtYmVyKSB7XHJcbiAgICAgICAgbGV0IGNsdXN0ZXJJRCA9IHRoaXMuY2x1c3RlcnMubGVuZ3RoXHJcbiAgICAgICAgLy8gdGhpcy5tYXAuc2V0KGlkLCBjbHVzdGVySUQpO1xyXG4gICAgICAgIHRoaXMuY2x1c3RlcnMucHVzaChbdGlsZUlEXSk7XHJcbiAgICAgICAgcmV0dXJuIGNsdXN0ZXJJRDtcclxuICAgIH1cclxuXHJcbiAgICBhZGRUaWxlQW5kQ29ubmVjdE5laWdoYm9ycyh0aWxlOiBUaWxlKSB7XHJcbiAgICAgICAgbGV0IG1lcmdlZENsdXN0ZXJzID0gW3RoaXMuYWRkTmV3Q2x1c3Rlcih0aWxlLmlkKV07XHJcbiAgICAgICAgbGV0IG5laWdoYm9ycyA9IHRpbGUuZ2V0UGFzc2FibGVOZWlnaGJvcnMoKTtcclxuICAgICAgICBmb3IgKGxldCBuZWlnaGJvciBvZiBuZWlnaGJvcnMpIHtcclxuICAgICAgICAgICAgbGV0IG5laWdoYm9yQ2x1c3RlckluZGV4ID0gdGhpcy5nZXRDbHVzdGVySW5kZXgobmVpZ2hib3IuaWQpO1xyXG4gICAgICAgICAgICBpZiAobmVpZ2hib3JDbHVzdGVySW5kZXggPT09IHVuZGVmaW5lZCkgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmICghbWVyZ2VkQ2x1c3RlcnMuaW5jbHVkZXMobmVpZ2hib3JDbHVzdGVySW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICBtZXJnZWRDbHVzdGVycy5wdXNoKG5laWdoYm9yQ2x1c3RlckluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhtZXJnZWRDbHVzdGVycyk7XHJcbiAgICAgICAgdGhpcy5qb2luKG1lcmdlZENsdXN0ZXJzKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgam9pbihjbHVzdGVySURzOiBudW1iZXJbXSkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdqb2luaW5nIGNsdXN0ZXJzJywgY2x1c3RlcklEcyk7XHJcbiAgICAgICAgaWYgKGNsdXN0ZXJJRHMubGVuZ3RoIDw9IDEpIHJldHVybjtcclxuICAgICAgICBsZXQgbmV3Q2x1c3RlciA9IFtdO1xyXG4gICAgICAgIGNsdXN0ZXJJRHMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG4gICAgICAgIGNsdXN0ZXJJRHMucmV2ZXJzZSgpO1xyXG4gICAgICAgIGNsdXN0ZXJJRHMuZm9yRWFjaChpZCA9PiB7XHJcbiAgICAgICAgICAgIG5ld0NsdXN0ZXIgPSBuZXdDbHVzdGVyLmNvbmNhdCh0aGlzLmNsdXN0ZXJzW2lkXSk7XHJcbiAgICAgICAgICAgIHRoaXMuY2x1c3RlcnMuc3BsaWNlKGlkLCAxKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNsdXN0ZXJzLnB1c2gobmV3Q2x1c3Rlcik7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBpbnN1ZmZpY2llbnQgLSB3ZSdkIG5lZWQgdG8gc2hpZnQgYWxsIHRoZSBjbHVzdGVySURzIGFmdGVyIHRoZSBvbmUgd2UganVzdCByZW1vdmVkXHJcbiAgICAgICAgLy8gTWF5YmUgY2FuIGp1c3QgZ2V0IGF3YXkgd2l0aG91dCBhIG1hcFxyXG4gICAgICAgIC8vIG5ld0NsdXN0ZXIuZm9yRWFjaChpZCA9PiB7XHJcbiAgICAgICAgLy8gICAgIHRoaXMubWFwLnNldChpZCwgdGhpcy5jbHVzdGVycy5sZW5ndGggLSAxKTtcclxuICAgICAgICAvLyB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb3B5KCk6IENsdXN0ZXJpbmcge1xyXG4gICAgICAgIGxldCBjb3B5ID0gbmV3IENsdXN0ZXJpbmcoKTtcclxuICAgICAgICAvLyBjb3B5Lm1hcCA9IG5ldyBNYXAodGhpcy5tYXApO1xyXG4gICAgICAgIGNvcHkuY2x1c3RlcnMgPSB0aGlzLmNsdXN0ZXJzLm1hcChjbHVzdGVyID0+IGNsdXN0ZXIuc2xpY2UoKSk7XHJcbiAgICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBHcmlkLCBUcmF2ZXJzZXIsIHJlY3RhbmdsZSwgc3BpcmFsIH0gZnJvbSBcImhvbmV5Y29tYi1ncmlkXCI7XHJcbmltcG9ydCB7IFRpbGUgfSBmcm9tIFwiLi9UaWxlXCI7XHJcbmltcG9ydCB7IEVkZ2UsIGRpamtzdHJhLCBJR3JhcGhBZGFwdGVyIH0gZnJvbSBcIi4uL3V0aWwvRGlqa3N0cmFcIjtcclxuaW1wb3J0IHNlZWRyYW5kb20gZnJvbSAnc2VlZHJhbmRvbSdcclxuXHJcbmNsYXNzIEdyaWRBZGFwdGVyIGltcGxlbWVudHMgSUdyYXBoQWRhcHRlcjxUaWxlPiB7XHJcbiAgICBncmlkOiBHcmlkPFRpbGU+O1xyXG4gICAgaWdub3JlR3JvdXBpbmdUaWxlczogVGlsZVtdID0gW107XHJcblxyXG4gICAgY29uc3RydWN0b3IoZ3JpZDogR3JpZDxUaWxlPikge1xyXG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0S2V5KG5vZGU6IFRpbGUpIHtcclxuICAgICAgICByZXR1cm4gbm9kZS5pZDtcclxuICAgIH1cclxuXHJcbiAgICBnZXRFZGdlcyhub2RlOiBUaWxlKSB7XHJcbiAgICAgICAgbGV0IGJhc2VXZWlnaHQgPSB0aGlzLmdldFdlaWdodChub2RlKTtcclxuICAgICAgICByZXR1cm4gbm9kZS5nZXROZWlnaGJvcnMoKS5tYXAobmVpZ2hib3IgPT4ge1xyXG4gICAgICAgICAgICBsZXQgd2VpZ2h0ID0gYmFzZVdlaWdodCArIHRoaXMuZ2V0V2VpZ2h0KG5laWdoYm9yKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG5vZGU6IG5laWdoYm9yLFxyXG4gICAgICAgICAgICAgICAgd2VpZ2h0LFxyXG4gICAgICAgICAgICB9IGFzIEVkZ2U8VGlsZT47XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0V2VpZ2h0KHRpbGU6IFRpbGUpIHtcclxuICAgICAgICByZXR1cm4gKHRpbGUuZ3JvdXBJbmRleCA9PSBudWxsIHx8IFxyXG4gICAgICAgICAgICB0aGlzLmlnbm9yZUdyb3VwaW5nVGlsZXMuaW5jbHVkZXModGlsZSkpID8gXHJcbiAgICAgICAgICAgIDAuNSA6IDA7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIE1vdmVzZXQge1xyXG4gICAgcmVhZG9ubHkgdGlsZXM6IFNldDxUaWxlPiA9IG5ldyBTZXQoKTtcclxuICAgIHJlYWRvbmx5IGZvb3RwcmludDogU2V0PFRpbGU+ID0gbmV3IFNldCgpO1xyXG4gICAgcmVhZG9ubHkgbW92ZXM6IFRpbGVbXVtdID0gW107XHJcbiAgICBzdG9uZXM6IG51bWJlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzdG9uZXM6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuc3RvbmVzID0gc3RvbmVzO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZE1vdmUobW92ZTogVGlsZVtdKSB7XHJcbiAgICAgICAgdGhpcy5tb3Zlcy5wdXNoKG1vdmUpO1xyXG4gICAgICAgIG1vdmUuZm9yRWFjaCh0aWxlID0+IHtcclxuICAgICAgICAgICAgdGhpcy50aWxlcy5hZGQodGlsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRm9vdHByaW50KHRpbGUsIHRoaXMuZm9vdHByaW50LCB0aGlzLnN0b25lcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlRm9vdHByaW50KHJhZGl1czogbnVtYmVyID0gMCkge1xyXG4gICAgICAgIGxldCBmb290cHJpbnQgPSBuZXcgU2V0PFRpbGU+KCk7XHJcbiAgICAgICAgdGhpcy50aWxlcy5mb3JFYWNoKHRpbGUgPT4gdGhpcy5hZGRGb290cHJpbnQodGlsZSwgZm9vdHByaW50LCByYWRpdXMpKTtcclxuICAgICAgICByZXR1cm4gZm9vdHByaW50O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYWRkRm9vdHByaW50KHRpbGU6IFRpbGUsIGZvb3RwcmludDogU2V0PFRpbGU+LCByYWRpdXM6IG51bWJlciA9IDApIHtcclxuICAgICAgICBjb25zdCBzcGlyYWxUcmF2ZXJzZXIgPSBzcGlyYWwoeyBzdGFydDogdGlsZSwgcmFkaXVzIH0pIGFzIFRyYXZlcnNlcjxUaWxlPjtcclxuICAgICAgICB0aWxlLmdyaWQudHJhdmVyc2Uoc3BpcmFsVHJhdmVyc2VyKS5mb3JFYWNoKG5laWdoYm9yID0+IHtcclxuICAgICAgICAgICAgZm9vdHByaW50LmFkZChuZWlnaGJvcik7IFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFN0b25lcyhzdG9uZXM6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuc3RvbmVzID0gc3RvbmVzO1xyXG4gICAgICAgIHRoaXMudGlsZXMuZm9yRWFjaCh0aWxlID0+IHRoaXMuYWRkRm9vdHByaW50KHRpbGUsIHRoaXMuZm9vdHByaW50LCB0aGlzLnN0b25lcykpO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZChvdGhlcjogTW92ZXNldCkge1xyXG4gICAgICAgIG90aGVyLnRpbGVzLmZvckVhY2godGlsZSA9PiB0aGlzLnRpbGVzLmFkZCh0aWxlKSk7XHJcbiAgICAgICAgb3RoZXIuZm9vdHByaW50LmZvckVhY2godGlsZSA9PiB0aGlzLmZvb3RwcmludC5hZGQodGlsZSkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIE9uZSBvcHRpb246IG9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgbW92ZSwgd2hpY2ggc2hvdWxkIGJlIHRoZSBvbmUgdGhhdCBqb2luZWQgdGhlbVxyXG4gICAgICAgIC8vIFRoaXMgbWF5IGNhdXNlIHRoZSBnZW5lcmF0b3IgdG8gc3RvcCwgd2hlbiB0aGF0IG1vdmUgaXNuJ3QgZWFzeSB0byBidWlsZCBmcm9tXHJcbiAgICAgICAgLy8gdGhpcy5tb3Zlcy5zcGxpY2UoMCwgdGhpcy5tb3Zlcy5sZW5ndGggLSAxKTtcclxuXHJcbiAgICAgICAgLy8gWmlwcGVyIGluIHRoZSBvdGhlciBtb3Zlc1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBvdGhlci5tb3Zlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSBNYXRoLm1heCgwLCB0aGlzLm1vdmVzLmxlbmd0aCAtIG9mZnNldCAtIDEpO1xyXG4gICAgICAgICAgICBvZmZzZXQrKztcclxuICAgICAgICAgICAgdGhpcy5tb3Zlcy5zcGxpY2UoaW5kZXgsIDAsIG90aGVyLm1vdmVzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbnR5cGUgQ29zdCA9IHtpZDogbnVtYmVyLCBjb3N0OiBudW1iZXJ9O1xyXG5cclxuZXhwb3J0IGNsYXNzIExldmVsR2VuZXJhdG9yIHtcclxuXHJcbiAgICB3aWR0aDogbnVtYmVyO1xyXG4gICAgaGVpZ2h0OiBudW1iZXI7XHJcbiAgICBncmlkOiBHcmlkPFRpbGU+O1xyXG4gICAgdGlsZU1hcDogTWFwPG51bWJlciwgVGlsZT4gPSBuZXcgTWFwKCk7XHJcbiAgICBzZWVkOiBzdHJpbmc7XHJcbiAgICByYW5kb206ICgpID0+IG51bWJlcjtcclxuXHJcbiAgICBzdGF0aWMgcmVhZG9ubHkgbWF4U3RvbmVzID0gNjtcclxuXHJcbiAgICBzdGF0aWMgcmVhZG9ubHkgbWF4R3JvdXBJbmRleCA9IDIwMDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzZWVkOiBzdHJpbmcsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZmluZFN1YnNldHNUaGF0U3VtVG8pO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgICAgdGhpcy5ncmlkID0gbmV3IEdyaWQoVGlsZSwgcmVjdGFuZ2xlKHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KSk7XHJcblxyXG4gICAgICAgIGxldCBpZCA9IDA7XHJcbiAgICAgICAgdGhpcy5ncmlkLmZvckVhY2godGlsZSA9PiB7XHJcbiAgICAgICAgICAgIHRpbGUuaWQgPSBpZCsrO1xyXG4gICAgICAgICAgICB0aWxlLmdyaWQgPSB0aGlzLmdyaWQ7XHJcbiAgICAgICAgICAgIHRoaXMudGlsZU1hcC5zZXQodGlsZS5pZCwgdGlsZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XHJcbiAgICAgICAgdGhpcy5yYW5kb20gPSBzZWVkcmFuZG9tKHNlZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZmluZFVuZ3JvdXBlZFRpbGVzV2l0aGluRGlzdGFuY2UoYWRhcHRlcjogR3JpZEFkYXB0ZXIsIHRpbGU6IFRpbGUsIGRpc3RhbmNlOiBudW1iZXIpOiBDb3N0W10ge1xyXG4gICAgICAgIGxldCBwYXRocyA9IGRpamtzdHJhKGFkYXB0ZXIsIHRpbGUsIG51bGwsIGRpc3RhbmNlKTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMocGF0aHMuY29zdHMpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGlkOiBwYXJzZUludChrZXkpLCBjb3N0OiB2YWx1ZSB9O1xyXG4gICAgICAgIH0pLmZpbHRlcihwYWlyID0+IFxyXG4gICAgICAgICAgICAvLyBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5LCBzaW5jZSBhbGwgdW5ncm91cGVkIHdpbGwgYmUgYXQgbGVhc3QgMSBhd2F5XHJcbiAgICAgICAgICAgIC8vIHBhaXIuY29zdCA+PSAxICYmXHJcbiAgICAgICAgICAgIHBhaXIuaWQgIT0gdGlsZS5pZCAmJiBcclxuICAgICAgICAgICAgdGhpcy50aWxlTWFwLmdldChwYWlyLmlkKS5ncm91cEluZGV4ID09IG51bGxcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGdlbmVyYXRlKCkge1xyXG4gICAgICAgIGxldCBncmlkQWRhcHRlciA9IG5ldyBHcmlkQWRhcHRlcih0aGlzLmdyaWQpO1xyXG5cclxuICAgICAgICBsZXQgZ3JvdXBlZFRpbGVzID0gW107XHJcbiAgICAgICAgbGV0IHVuZ3JvdXBlZFRpbGVzID0gdGhpcy5ncmlkLnRvQXJyYXkoKTtcclxuXHJcbiAgICAgICAgbGV0IG1vdmVzZXRzOiBNb3Zlc2V0W10gPSBbXTtcclxuXHJcbiAgICAgICAgbGV0IG5leHRHcm91cEluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgbGV0IHN0b25lcyA9IDI7XHJcblxyXG4gICAgICAgIGxldCBjcmVhdGVNb3ZlID0gKHRpbGU6IFRpbGUsIGRlcGVuZGVudE1vdmU6IFRpbGVbXSA9IG51bGwsIGRpc2FsbG93ZWRUaWxlczogU2V0PFRpbGU+ID0gbmV3IFNldCgpLCBtYXhpbWl6ZUNvc3RHYWluID0gZmFsc2UpID0+IHtcclxuXHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdhdHRlbXB0aW5nIHRvIGdyb3VwIHdpdGggdGlsZScsIHRpbGUuaWQsIHRpbGUpO1xyXG5cclxuICAgICAgICAgICAgbGV0IG1heFBhdGhDb3N0ID0gc3RvbmVzIC0gMTtcclxuICAgICAgICAgICAgbGV0IHBvc3NpYmxlUGFpcnMgPSB0aGlzLmZpbmRVbmdyb3VwZWRUaWxlc1dpdGhpbkRpc3RhbmNlKGdyaWRBZGFwdGVyLCB0aWxlLCBtYXhQYXRoQ29zdCk7XHJcbiAgICAgICAgICAgIHBvc3NpYmxlUGFpcnMgPSBwb3NzaWJsZVBhaXJzLmZpbHRlcihwYWlyID0+ICFkaXNhbGxvd2VkVGlsZXMuaGFzKHRoaXMudGlsZU1hcC5nZXQocGFpci5pZCkpKTtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2ZvdW5kIHBvc3NpYmxlIHBhaXJzJywgcG9zc2libGVQYWlycy5zbGljZSgpKTtcclxuICAgICAgICAgICAgaWYgKHBvc3NpYmxlUGFpcnMubGVuZ3RoID09IDApIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAgICAgbGV0IHJlbWFpbmluZ1N0b25lcyA9IHN0b25lcyAtIDE7XHJcbiAgICAgICAgICAgIGxldCBncm91cDogKHtpZDogbnVtYmVyLCBjb3N0OiBudW1iZXJ9KVtdO1xyXG4gICAgICAgICAgICBncm91cCA9IFtdO1xyXG5cclxuICAgICAgICAgICAgbGV0IGFkZFBhaXIgPSAoYWRkZWQ6IENvc3QpID0+IHtcclxuICAgICAgICAgICAgICAgIGdyb3VwLnB1c2goYWRkZWQpO1xyXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nU3RvbmVzIC09IGFkZGVkLmNvc3Q7XHJcbiAgICAgICAgICAgICAgICBwb3NzaWJsZVBhaXJzID0gcG9zc2libGVQYWlycy5maWx0ZXIocGFpciA9PiBwYWlyLmlkICE9IGFkZGVkLmlkICYmIHBhaXIuY29zdCA8PSByZW1haW5pbmdTdG9uZXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVwZW5kZW50TW92ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBncmlkQWRhcHRlci5pZ25vcmVHcm91cGluZ1RpbGVzID0gZGVwZW5kZW50TW92ZTtcclxuICAgICAgICAgICAgICAgIGxldCBwb3NzaWJsZVBhaXJzQmVmb3JlRGVwZW5kZW50TW92ZSA9IHRoaXMuZmluZFVuZ3JvdXBlZFRpbGVzV2l0aGluRGlzdGFuY2UoZ3JpZEFkYXB0ZXIsIHRpbGUsIG1heFBhdGhDb3N0KTtcclxuICAgICAgICAgICAgICAgIGdyaWRBZGFwdGVyLmlnbm9yZUdyb3VwaW5nVGlsZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgY29zdE1hcCA9IG5ldyBNYXA8bnVtYmVyLCBudW1iZXI+KCk7XHJcbiAgICAgICAgICAgICAgICBwb3NzaWJsZVBhaXJzQmVmb3JlRGVwZW5kZW50TW92ZS5mb3JFYWNoKHBhaXIgPT4gY29zdE1hcC5zZXQocGFpci5pZCwgcGFpci5jb3N0KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IG5ld2x5UG9zc2libGVQYWlycyA9IHBvc3NpYmxlUGFpcnNcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIocGFpciA9PiAhY29zdE1hcC5oYXMocGFpci5pZCkgfHwgY29zdE1hcC5nZXQocGFpci5pZCkgPiBwYWlyLmNvc3QpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdvdWxkbid0IG5vcm1hbGx5IG5lZWQgdG8gYnJlYWssIGJ1dCBmb3IgdGVzdGluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld2x5UG9zc2libGVQYWlycy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdubyBuZXdseSBwb3NzaWJsZSBwYWlycycpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IE5lZWQgYSBtb3JlIHJvYnVzdCBzb2x1dGlvbjogdGhpcyBjYW4gZ2V0IHByZXR0eSBleHBlbnNpdmVcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgbGV0IHRvQWRkID0gbmV3bHlQb3NzaWJsZVBhaXJzW01hdGguZmxvb3IodGhpcy5yYW5kb20oKSAqIG5ld2x5UG9zc2libGVQYWlycy5sZW5ndGgpXTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXhpbWl6ZUNvc3RHYWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvc3RHYWluID0gKGNvc3Q6IENvc3QpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvc3RCZWZvcmUgPSBjb3N0TWFwLmdldChjb3N0LmlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvc3RCZWZvcmUgPT0gbnVsbCkgY29zdEJlZm9yZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvc3RCZWZvcmUgLSBjb3N0LmNvc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTb3J0IGZyb20gbGFyZ2VzdCB0byBzbWFsbGVzdCBjb3N0IGdhaW5cclxuICAgICAgICAgICAgICAgICAgICBuZXdseVBvc3NpYmxlUGFpcnMuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29zdEdhaW4oYikgLSBjb3N0R2FpbihhKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0b0FkZCA9IG5ld2x5UG9zc2libGVQYWlyc1swXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFkZFBhaXIodG9BZGQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBHcmVlZHkgYXBwcm9hY2g6IGNob29zZSBhIHJhbmRvbSB0aWxlICh3aGljaCBjYW4gYmUgcmVhY2hlZCB3aXRoIHRoZSByZW1haW5pbmcgc3RvbmVzKVxyXG4gICAgICAgICAgICAvLyBhbmQgYWRkIGl0IHRvIHRoZSBncm91cDsgdGhlbiBhZGp1c3QgcG9zc2libGUgcGFpcnMgYmFzZWQgb24gdGhlIHJlbWFpbmluZyBzdG9uZXNcclxuICAgICAgICAgICAgLy8gTm90ZTogdGhpcyBtYXkgcmVzdWx0IGluIGEgZ3JvdXAgdGhhdCBpcyBiZWxvdyB0aGUgdGFyZ2V0IGNvc3QsIGJ1dCBpdCdzXHJcbiAgICAgICAgICAgIC8vIHBvc3NpYmxlIHRoYXQgbm8gZ3JvdXAgZXhpc3RzIHRoYXQgaXMgZXhhY3RseSB0aGUgdGFyZ2V0IGNvc3QsIGFuZCBldmVuIGlmIGl0IGV4aXN0c1xyXG4gICAgICAgICAgICAvLyBmaW5kaW5nIGl0IGlzIHZlcnkgY29tcHV0YXRpb25hbGx5IGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICB3aGlsZSAocG9zc2libGVQYWlycy5sZW5ndGggPiAwICYmIHJlbWFpbmluZ1N0b25lcyA+IDApIHtcclxuICAgICAgICAgICAgICAgIGxldCBhZGRlZEluZGV4ID0gTWF0aC5mbG9vcih0aGlzLnJhbmRvbSgpICogcG9zc2libGVQYWlycy5sZW5ndGgpOyBcclxuICAgICAgICAgICAgICAgIGxldCBhZGRlZCA9IHBvc3NpYmxlUGFpcnNbYWRkZWRJbmRleF07XHJcbiAgICAgICAgICAgICAgICBhZGRQYWlyKGFkZGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnY29zdGdyb3VwJywgZ3JvdXApXHJcblxyXG4gICAgICAgICAgICBsZXQgdG90YWxDb3N0ID0gZ3JvdXAubWFwKGcgPT4gZy5jb3N0KS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCB0aWxlR3JvdXAgPSBncm91cFxyXG4gICAgICAgICAgICAubWFwKGcgPT4gdGhpcy50aWxlTWFwLmdldChnLmlkKSk7XHJcbiAgICAgICAgICAgIHRpbGVHcm91cC5wdXNoKHRpbGUpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2dyb3VwaW5nJywgdGlsZUdyb3VwLm1hcCh0aWxlID0+IHRpbGUuaWQpLCAnZm9yIGNvc3QnLCB0b3RhbENvc3QsICc9PicsIG5leHRHcm91cEluZGV4KTtcclxuXHJcbiAgICAgICAgICAgIHRpbGVHcm91cC5mb3JFYWNoKGdyb3VwVGlsZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB1bmdyb3VwZWRUaWxlcy5zcGxpY2UodW5ncm91cGVkVGlsZXMuaW5kZXhPZihncm91cFRpbGUpLCAxKTtcclxuICAgICAgICAgICAgICAgIGlmIChncm91cFRpbGUuZ3JvdXBJbmRleCAhPSBudWxsKSBjb25zb2xlLmVycm9yKFwidGlsZSBhbHJlYWR5IGhhcyBncm91cCBpbmRleFwiLCBncm91cFRpbGUuZ3JvdXBJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBncm91cFRpbGUuZ3JvdXBJbmRleCA9IG5leHRHcm91cEluZGV4O1xyXG4gICAgICAgICAgICAgICAgZ3JvdXBlZFRpbGVzLnB1c2goZ3JvdXBUaWxlKTtcclxuICAgICAgICAgICAgICAgIC8vIGlmIChhZGRTdG9uZSkgZ3JvdXBUaWxlLmlzU3RvbmVUaWxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG5leHRHcm91cEluZGV4Kys7XHJcbiAgICAgICAgICAgIHJldHVybiB0aWxlR3JvdXA7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgbGV0IGFkZE1vdmVzZXQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBhdmFpbGFibGUgPSBuZXcgU2V0PFRpbGU+KCk7XHJcbiAgICAgICAgICAgIHVuZ3JvdXBlZFRpbGVzLmZvckVhY2godGlsZSA9PiBhdmFpbGFibGUuYWRkKHRpbGUpKTtcclxuICAgICAgICAgICAgbW92ZXNldHMuZm9yRWFjaChtb3Zlc2V0ID0+IG1vdmVzZXQuZm9vdHByaW50LmZvckVhY2godGlsZSA9PiBhdmFpbGFibGUuZGVsZXRlKHRpbGUpKSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYXZhaWxhYmxlLnNpemUgPT0gMCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgICAgICBsZXQgcHJlZmVycmVkVGlsZXMgPSBBcnJheS5mcm9tKGF2YWlsYWJsZSkuZmlsdGVyKHRpbGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5laWdoYm9ycyA9IHRpbGUuZ2V0TmVpZ2hib3JzKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmVpZ2hib3JzLmV2ZXJ5KG5laWdoYm9yID0+IGF2YWlsYWJsZS5oYXMobmVpZ2hib3IpKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAocHJlZmVycmVkVGlsZXMubGVuZ3RoID09IDApIHByZWZlcnJlZFRpbGVzID0gQXJyYXkuZnJvbShhdmFpbGFibGUpO1xyXG4gICAgICAgICAgICBsZXQgYmFzZVRpbGUgPSBwcmVmZXJyZWRUaWxlc1tNYXRoLmZsb29yKHRoaXMucmFuZG9tKCkgKiBwcmVmZXJyZWRUaWxlcy5sZW5ndGgpXTtcclxuXHJcbiAgICAgICAgICAgIGxldCBtb3ZlID0gY3JlYXRlTW92ZShiYXNlVGlsZSk7XHJcbiAgICAgICAgICAgIGlmIChtb3ZlID09IG51bGwpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAgICAgbGV0IG1vdmVzZXQgPSBuZXcgTW92ZXNldChzdG9uZXMpO1xyXG4gICAgICAgICAgICBtb3Zlc2V0LmFkZE1vdmUobW92ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBtb3Zlc2V0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGxldCBjcmVhdGVOZXdNb3Zlc2V0cyA9ICgpID0+IHtcclxuICAgICAgICAgICAgbGV0IHJlZHVjdGlvbiA9IE1hdGguY2VpbCgoc3RvbmVzIC0gMikgLyAyKTtcclxuICAgICAgICAgICAgbGV0IG1heE1vdmVzZXRzID0gNCAtIHJlZHVjdGlvbiwgbWluTW92ZXNldHMgPSBNYXRoLm1heCgwLCAyIC0gcmVkdWN0aW9uKTtcclxuICAgICAgICAgICAgbGV0IG5Nb3Zlc2V0cz0gTWF0aC5mbG9vcih0aGlzLnJhbmRvbSgpICogKG1heE1vdmVzZXRzIC0gbWluTW92ZXNldHMgKyAxKSkgKyBtaW5Nb3Zlc2V0cztcclxuICAgICAgICAgICAgbGV0IGNyZWF0ZWRNb3Zlc2V0cyA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbk1vdmVzZXRzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBtb3Zlc2V0ID0gYWRkTW92ZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1vdmVzZXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdmVzZXRzLnB1c2gobW92ZXNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlZE1vdmVzZXRzKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2NyZWF0ZWQnLCBjcmVhdGVkTW92ZXNldHMsICduZXcgbW92ZXNldHMnKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZWRNb3Zlc2V0cyA+IDA7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgbGV0IHNlbGVjdE5leHRCYXNlVGlsZSA9IChtb3Zlc2V0OiBNb3Zlc2V0LCBkaXNhbGxvd2VkVGlsZXM6IFNldDxUaWxlPiwgdXNlTW9zdFJlY2VudE1vdmUgPSBmYWxzZSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbW92ZXMgPSBtb3Zlc2V0Lm1vdmVzO1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSBtb3Zlcy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICBpZiAoIXVzZU1vc3RSZWNlbnRNb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPiAwICYmIHRoaXMucmFuZG9tKCkgPiAwLjQpIGluZGV4LS07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBkZXBlbmRlbnRNb3ZlID0gbW92ZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZGVwZW5kZW50IG1vdmUnLCBkZXBlbmRlbnRNb3ZlKTtcclxuICAgICAgICAgICAgbGV0IHBvc3NpYmxlU3RhcnRpbmdUaWxlcyA9IG5ldyBTZXQ8VGlsZT4oKTtcclxuICAgICAgICAgICAgZGVwZW5kZW50TW92ZS5mb3JFYWNoKHRpbGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maW5kVW5ncm91cGVkVGlsZXNXaXRoaW5EaXN0YW5jZShncmlkQWRhcHRlciwgdGlsZSwgc3RvbmVzIC0gMSlcclxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKHBhaXIgPT4gcG9zc2libGVTdGFydGluZ1RpbGVzLmFkZCh0aGlzLnRpbGVNYXAuZ2V0KHBhaXIuaWQpKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxTdGFydGluZ1RpbGVzID0gbmV3IFNldChwb3NzaWJsZVN0YXJ0aW5nVGlsZXMpO1xyXG4gICAgICAgICAgICByZW1vdmVBbGxGcm9tKHBvc3NpYmxlU3RhcnRpbmdUaWxlcywgZGlzYWxsb3dlZFRpbGVzKTtcclxuICAgICAgICAgICAgZGVwZW5kZW50TW92ZS5mb3JFYWNoKHRpbGUgPT4gcG9zc2libGVTdGFydGluZ1RpbGVzLmRlbGV0ZSh0aWxlKSk7XHJcbiAgICAgICAgICAgIGlmIChwb3NzaWJsZVN0YXJ0aW5nVGlsZXMuc2l6ZSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbm8gcG9zc2libGUgc3RhcnRpbmcgdGlsZXMgZm9yIGRlcGVuZGVudCBtb3ZlJywgZGVwZW5kZW50TW92ZSwgZGlzYWxsb3dlZFRpbGVzLCBvcmlnaW5hbFN0YXJ0aW5nVGlsZXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHRpbGUgPSBBcnJheS5mcm9tKHBvc3NpYmxlU3RhcnRpbmdUaWxlcylbTWF0aC5mbG9vcih0aGlzLnJhbmRvbSgpICogcG9zc2libGVTdGFydGluZ1RpbGVzLnNpemUpXTtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3RhZG0nLCB0aWxlLCAuLi5kZXBlbmRlbnRNb3ZlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHt0aWxlLCBkZXBlbmRlbnRNb3ZlfTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBUT0RPOiBTdGlsbCBzb21lIGJsYWNrIHRpbGVzIC0gY291bGQgYmFpbCBvdXQgZWFybHkgd2l0aCBhIGZpeFxyXG4gICAgICAgIGxldCBtYXhBdHRlbXB0cyA9IDUwO1xyXG4gICAgICAgIGxldCBhdHRlbXB0c1NpbmNlTGFzdFByb2dyZXNzID0gMDtcclxuICAgICAgICBsZXQgYWxsb3dVbmlvbnMgPSBmYWxzZTtcclxuICAgICAgICAvLyBsZXQgc3RvbmVNb3Zlc2V0ID0gbnVsbCBhcyBNb3Zlc2V0O1xyXG5cclxuICAgICAgICBsZXQgam9pbmFibGVGb290cHJpbnRzOiBTZXQ8VGlsZT5bXSA9IFtdO1xyXG5cclxuICAgICAgICAvLyBUT0RPOiBTaG91bGQgbG93ZXIgdGhpcyBiYXI6IHdlIHdhbnQgbW9yZSBqb2luc1xyXG4gICAgICAgIGxldCB1cGRhdGVBbGxvd1VuaW9ucyA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGdyb3VwZWRUaWxlcy5sZW5ndGggKiB0aGlzLnJhbmRvbSgpID4gTWF0aC5wb3coc3RvbmVzLCAyLjUpICogMi41KSB7XHJcbiAgICAgICAgICAgICAgICBhbGxvd1VuaW9ucyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNlZWQgd2l0aCBpbml0aWFsIG1vdmVzZXRzXHJcbiAgICAgICAgY3JlYXRlTmV3TW92ZXNldHMoKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnaW5pdGlhbCBtb3Zlc2V0cycsIG1vdmVzZXRzKTtcclxuXHJcbiAgICAgICAgd2hpbGUgKHVuZ3JvdXBlZFRpbGVzLmxlbmd0aCA+PSBzdG9uZXMgJiYgbmV4dEdyb3VwSW5kZXggPCBMZXZlbEdlbmVyYXRvci5tYXhHcm91cEluZGV4KSB7XHJcbiAgICAgICAgICAgIGF0dGVtcHRzU2luY2VMYXN0UHJvZ3Jlc3MrKztcclxuICAgICAgICAgICAgaWYgKGF0dGVtcHRzU2luY2VMYXN0UHJvZ3Jlc3MgPiBtYXhBdHRlbXB0cykge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgdHJpZWQgZW5vdWdoIHdpdGggdW5pb25zIGFsbG93ZWQsIHdlJ3JlIHJlYWxseSBzdHVjaywgc28gYmFpbCBvdXRcclxuICAgICAgICAgICAgICAgIGlmIChhbGxvd1VuaW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbm90LCBhbGxvdyB1bmlvbnMgYW5kIGtlZXAgdHJ5aW5nXHJcbiAgICAgICAgICAgICAgICBhbGxvd1VuaW9ucyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBhdHRlbXB0c1NpbmNlTGFzdFByb2dyZXNzID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IG1vdmVzZXQgPSBtb3Zlc2V0c1tNYXRoLmZsb29yKHRoaXMucmFuZG9tKCkgKiBtb3Zlc2V0cy5sZW5ndGgpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHNldCBoYXZlIGEgbW92ZXNldCBtYXJrZWQgdG8gYWRkIGEgc3RvbmUsIHVzZSB0aGF0IG1vdmVzZXRcclxuICAgICAgICAgICAgLy8gVE9ETzogQ291bGQgYWRkIHNvbWUgcmFuZG9tbmVzc1xyXG4gICAgICAgICAgICAvLyBsZXQgYWRkU3RvbmUgPSBzdG9uZU1vdmVzZXQgIT0gbnVsbDtcclxuICAgICAgICAgICAgLy8gaWYgKGFkZFN0b25lKSB7XHJcbiAgICAgICAgICAgIC8vICAgICBtb3Zlc2V0ID0gc3RvbmVNb3Zlc2V0O1xyXG4gICAgICAgICAgICAvLyAgICAgc3RvbmVNb3Zlc2V0ID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAgICAgbGV0IGRpc2FsbG93ZWRUaWxlcyA9IG5ldyBTZXQ8VGlsZT4oKTtcclxuICAgICAgICAgICAgbW92ZXNldHMuZm9yRWFjaChtcyA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobXMgPT0gbW92ZXNldCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgbXMuZm9vdHByaW50LmZvckVhY2godGlsZSA9PiBkaXNhbGxvd2VkVGlsZXMuYWRkKHRpbGUpKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgbmV4dCA9IHNlbGVjdE5leHRCYXNlVGlsZShtb3Zlc2V0LCBkaXNhbGxvd2VkVGlsZXMsIGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKG5leHQgPT0gbnVsbCkgY29udGludWU7XHJcbiAgICAgICAgICAgIGxldCB7dGlsZSwgZGVwZW5kZW50TW92ZX0gPSBuZXh0O1xyXG4gICAgICAgICAgICBpZiAoZGlzYWxsb3dlZFRpbGVzLmhhcyh0aWxlKSkgY29uc29sZS5lcnJvcignZGlzYWxsb3dlZCB0aWxlJywgdGlsZSk7XHJcbiAgICAgICAgICAgIGxldCBtb3ZlID0gY3JlYXRlTW92ZSh0aWxlLCBkZXBlbmRlbnRNb3ZlLCBhbGxvd1VuaW9ucyA/IG5ldyBTZXQoKSA6IGRpc2FsbG93ZWRUaWxlcywgZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAobW92ZSA9PSBudWxsKSBjb250aW51ZTtcclxuICAgICAgICAgICAgbW92ZXNldC5hZGRNb3ZlKG1vdmUpO1xyXG4gICAgICAgICAgICBhdHRlbXB0c1NpbmNlTGFzdFByb2dyZXNzID0gMDtcclxuICAgICAgICAgICAgdXBkYXRlQWxsb3dVbmlvbnMoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE86IEVpdGhlciBuZWVkIHRvIGd1YXJhbnRlZSBzb21laG93IHRoZSBtb3Zlc2V0cyBqb2luIGVhcmxpZXJcclxuICAgICAgICAgICAgLy8gT3IgYWxsb3cgc3RvbmUgaW5jcmVhc2Ugb3V0c2lkZSBvZiBtb3Zlc2V0IGpvaW5nIChmb3JtZXIgcHJlZmVycmVkKVxyXG4gICAgICAgICAgICBpZiAoc3RvbmVzIDwgTGV2ZWxHZW5lcmF0b3IubWF4U3RvbmVzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBCVUc6IFRoaXMgZG9lc24ndCBzZWVtIHRvIHRyaWdnZXIgb24gc29tZSBtYXBzISFcclxuICAgICAgICAgICAgICAgIC8vIEZvciBlYWNoIHRpbGUgaW4gdGhpcyBtb3ZlLCBjaGVjayBpZiBpdCBoYXMgYSB1bmlxdWUgZm9vdHByaW50XHJcbiAgICAgICAgICAgICAgICAvLyAoaXQgc3RhcnRzIGluIG9uZSBhbmQgb3V0c2lkZSBvZiBhbGwgb3RoZXJzKSwgYW5kIGNvbGxlY3QgdGhlc2VcclxuICAgICAgICAgICAgICAgIGxldCB1bmlxdWVGb290cHJpbnRzID0gbW92ZS5tYXAobSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvb3RwcmludHMgPSBqb2luYWJsZUZvb3RwcmludHMuZmlsdGVyKGpmID0+IGpmLmhhcyhtKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBtb3ZlIGlzIHBhcnQgb2YgbXVsdGlwbGUgZm9vdHByaW50cywgc2tpcCBpdCBzaW5jZSBpdCdzIGEgYm9yZGVyIHRpbGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZm9vdHByaW50cy5sZW5ndGggPT0gMSkgcmV0dXJuIGZvb3RwcmludHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoamYgPT4gamYgIT0gbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgdG8gcmVtb3ZlIGR1cGxpY2F0ZXM6IHdlIG5lZWQgbXVsdGlwbGUgZGlzdGluY3QgXCJ1bmlxdWUgZm9vdHByaW50c1wiXHJcbiAgICAgICAgICAgICAgICB1bmlxdWVGb290cHJpbnRzID0gdW5pcXVlRm9vdHByaW50cy5maWx0ZXIoKHYsIGksIGEpID0+IGEuaW5kZXhPZih2KSA9PT0gaSk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh1bmlxdWVGb290cHJpbnRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIG1vdmUgam9pbnMgMiB1bmlxdWUgZm9vdHByaW50cywgaXQncyBhIHN0b25lIG1vdmVcclxuICAgICAgICAgICAgICAgIGlmICh1bmlxdWVGb290cHJpbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnc3RvbmUgbW92ZScsIG1vdmUsICdmcm9tIGpvaW5pbmcnLCB1bmlxdWVGb290cHJpbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGZvb3RwcmludHMgdGhhdCBhcmUgYmVpbmcgam9pbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgam9pbmFibGVGb290cHJpbnRzID0gam9pbmFibGVGb290cHJpbnRzLmZpbHRlcihqZiA9PiAhdW5pcXVlRm9vdHByaW50cy5pbmNsdWRlcyhqZikpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdmUuZm9yRWFjaCh0aWxlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZS5pc1N0b25lVGlsZSAgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b25lcysrO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdmVzZXRzLmZvckVhY2gobXMgPT4gbXMuc2V0U3RvbmVzKHN0b25lcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZU5ld01vdmVzZXRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvbmVNb3Zlc2V0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogVGhlcmUgc3RpbGwgc2VlbXMgdG8gYmUgc29tZSB3YXkgdGhhdCBzdG9uZXMgYXJlIHBsYWNlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBvbmUgc2VlbWluZyBncm91cC4gSSdtIHdvbmRlcmluZyBpZiB3ZSBuZWVkIHRoZSBiaWcgYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc21hbGwgZm9vdHByaW50cyAoZXhjbHVkZSBmcm9tIGJpZywgaW5jbHVkZSBpbiBzbWFsbClcclxuICAgICAgICAgICAgICAgICAgICAvLyBPciBpZiBtYXliZSBlYXJsaWVyIGZvb3RwcmludHMgbmVlZCB0byBiZSByZW1vdmVkIHdoZW4gc3RvbmVzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVhc2UuLi4/IE5lZWQgdG8gdGhpbmsgYWJvdXQgaXQuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgZm9yIHRoaXMgLSB1bmlvbnMgY2FuIGZvcm0gd2hlbiBzdG9uZXMgaW5jcmVhc2UsXHJcbiAgICAgICAgICAgIC8vIHNvIHdlIGFsd2F5cyBzb3J0IG9mIG5lZWQgdG8gY2hlY2tcclxuICAgICAgICAgICAgLy8gaWYgKCFhbGxvd1VuaW9ucykgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBsZXQgam9pbmVkTW92ZXNldEZvb3RwcmludHM6IFNldDxUaWxlPltdID0gW107XHJcbiAgICAgICAgICAgIGxldCBuRm9vdHByaW50U3RvbmVzID0gMTsgLy8gTWF0aC5jZWlsKHN0b25lcyAvIDIpO1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBhbGxvd2VkIHRvIGpvaW4gbW92ZXNldHMsIGNoZWNrIGlmIHdlIGhhdmVcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb3Zlc2V0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IG1zID0gbW92ZXNldHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAobXMgPT0gbW92ZXNldCkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBpZiAobW92ZS5zb21lKHQgPT4gbXMuZm9vdHByaW50Lmhhcyh0KSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjb3JkIHRoZSBmb290cHJpbnRzIG9mIGVhY2ggbW92ZXNldCAoYmVmb3JlIGpvaW5pbmchKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBqb2luYWJsZSBmb290cHJpbnQgaXMgMSBzbWFsbGVyIHRoYW4gdGhlIHJlZ3VsYXIgZm9vdHByaW50LCBzaW5jZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWxlIGl0J3MgcG9zc2libGUgdG8gaW50ZXJmZXJlIHdpdGggYW5vdGhlciBtb3Zlc2V0IGF0IFwic3RvbmVzXCIgcmFkaXVzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gam9pbmluZyB3b3VsZCBvbmx5IHJlcXVpcmUgc3RvbmVzIC0gMSByYWRpdXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoam9pbmVkTW92ZXNldEZvb3RwcmludHMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbmVkTW92ZXNldEZvb3RwcmludHMucHVzaChtb3Zlc2V0LmNyZWF0ZUZvb3RwcmludChuRm9vdHByaW50U3RvbmVzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGpvaW5lZE1vdmVzZXRGb290cHJpbnRzLnB1c2gobXMuY3JlYXRlRm9vdHByaW50KG5Gb290cHJpbnRTdG9uZXMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2pvaW5pbmcgbW92ZXNldHMnLCBtb3Zlc2V0LCBtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbW92ZXNldC5hZGQobXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdmVzZXRzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIElmIHdlIGRpZG4ndCBqb2luIGFueSBtb3Zlc2V0cywgY29udGludWVcclxuICAgICAgICAgICAgaWYgKGpvaW5lZE1vdmVzZXRGb290cHJpbnRzLmxlbmd0aCA8PSAxKSBjb250aW51ZTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2pvaW5lZCBtb3Zlc2V0IGZvb3RwcmludHMnLCBqb2luZWRNb3Zlc2V0Rm9vdHByaW50cyk7XHJcblxyXG4gICAgICAgICAgICAvLyBObyBtb3JlIG5ldyB1bmlvbnMgdW50aWwgdGhlIGNyaXRlcmlhIGFyZSBtZXRcclxuICAgICAgICAgICAgYWxsb3dVbmlvbnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHN0b25lcyA8IExldmVsR2VuZXJhdG9yLm1heFN0b25lcykge1xyXG4gICAgICAgICAgICAgICAgam9pbmVkTW92ZXNldEZvb3RwcmludHMuZm9yRWFjaChtcyA9PiBqb2luYWJsZUZvb3RwcmludHMucHVzaChtcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbmRTdWJzZXRzVGhhdFN1bVRvKHRhcmdldDogbnVtYmVyLCBudW1iZXJzOiBudW1iZXJbXSkge1xyXG4gICAgbGV0IHdoZWVsID0gWzBdO1xyXG4gICAgbGV0IHJlc3VsdHNDb3VudCA9IDA7XHJcbiAgICBsZXQgc3VtID0gMDtcclxuXHJcbiAgICBsZXQgc3VtSW5kaWNlcyA9IFtdO1xyXG5cclxuICAgIGRvIHtcclxuICAgICAgICBzdW0gPSBpbmNyZW1lbnRXaGVlbCgwLCBzdW0sIG51bWJlcnMsIHdoZWVsKTtcclxuICAgICAgICAvL1VzZSBzdWJ0cmFjdGlvbiBjb21wYXJpc29uIGR1ZSB0byBqYXZhc2NyaXB0IGZsb2F0IGltcHJlY2lzaW9uXHJcbiAgICAgICAgaWYgKHN1bSAhPSBudWxsICYmIE1hdGguYWJzKHRhcmdldCAtIHN1bSkgPCAwLjAwMDAwMSkge1xyXG4gICAgICAgICAgICAvL0ZvdW5kIGEgc3Vic2V0LiBBZGQgdGhlIHJlc3VsdC5cclxuICAgICAgICAgICAgc3VtSW5kaWNlcy5wdXNoKFsuLi53aGVlbC5rZXlzKCldLmZpbHRlcihpID0+IHdoZWVsW2ldID09PSAxKSk7XHJcbiAgICAgICAgICAgIHJlc3VsdHNDb3VudCsrO1xyXG4gICAgICAgIH1cclxuICAgIH0gd2hpbGUgKHN1bSAhPSBudWxsKTtcclxuICAgIHJldHVybiBzdW1JbmRpY2VzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbmNyZW1lbnRXaGVlbChwb3NpdGlvbiwgc3VtLCBudW1iZXJzLCB3aGVlbCkge1xyXG4gICAgaWYgKHBvc2l0aW9uID09PSBudW1iZXJzLmxlbmd0aCB8fCBzdW0gPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHdoZWVsW3Bvc2l0aW9uXSsrO1xyXG4gICAgaWYgKHdoZWVsW3Bvc2l0aW9uXSA9PT0gMikge1xyXG4gICAgICAgIHdoZWVsW3Bvc2l0aW9uXSA9IDA7XHJcbiAgICAgICAgc3VtIC09IG51bWJlcnNbcG9zaXRpb25dO1xyXG4gICAgICAgIGlmICh3aGVlbC5sZW5ndGggPCBwb3NpdGlvbiArIDIpIHtcclxuICAgICAgICAgICAgd2hlZWwucHVzaCgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VtID0gaW5jcmVtZW50V2hlZWwocG9zaXRpb24gKyAxLCBzdW0sIG51bWJlcnMsIHdoZWVsKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHN1bSArPSBudW1iZXJzW3Bvc2l0aW9uXTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdW07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZUFsbEZyb20oc2V0OiBTZXQ8YW55PiwgdG9SZW1vdmU6IFNldDxhbnk+KSB7XHJcbiAgICB0b1JlbW92ZS5mb3JFYWNoKGl0ZW0gPT4gc2V0LmRlbGV0ZShpdGVtKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludGVyc2VjdDxUPihhOiBTZXQ8VD4sIGI6IFNldDxUPik6IFNldDxUPiB7XHJcbiAgICBsZXQgcmVzdWx0ID0gbmV3IFNldDxUPigpO1xyXG4gICAgYS5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgIGlmIChiLmhhcyhpdGVtKSkgcmVzdWx0LmFkZChpdGVtKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufSIsImltcG9ydCB7IGRlZmluZUhleCwgRGlyZWN0aW9uLCBHcmlkLCByZWN0YW5nbGUgfSBmcm9tIFwiaG9uZXljb21iLWdyaWRcIjtcclxuaW1wb3J0IHsgVGlsZSwgVGlsZURhdGEgfSBmcm9tIFwiLi9UaWxlXCI7XHJcbmltcG9ydCB7IENsdXN0ZXJpbmcgfSBmcm9tIFwiLi9DbHVzdGVyaW5nXCI7XHJcbmltcG9ydCB7IExldmVsR2VuZXJhdG9yIH0gZnJvbSBcIi4vTGV2ZWxHZW5lcmF0b3JcIjtcclxuXHJcbmV4cG9ydCB0eXBlIEdhbWVEYXRhID0ge1xyXG4gICAgc2VlZDogc3RyaW5nO1xyXG4gICAgd2lkdGg6IG51bWJlcjtcclxuICAgIGhlaWdodDogbnVtYmVyO1xyXG4gICAgdGlsZXM6IFRpbGVEYXRhW107XHJcbiAgICBuU3RvbmVzOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBSb290cyB7XHJcblxyXG4gICAgLy8gc2VyaWFsaXphYmxlIGZpZWxkc1xyXG4gICAgd2lkdGggPSAyMDtcclxuICAgIGhlaWdodCA9IDE1O1xyXG4gICAgc2VlZDogc3RyaW5nO1xyXG4gICAgZ3JpZDogR3JpZDxUaWxlPjtcclxuICAgIG5TdG9uZXMgPSAyO1xyXG4gICAgXHJcbiAgICAvLyBkZXJpdmVkIGZpZWxkc1xyXG4gICAgZ3JvdXBzOiBUaWxlW11bXSA9IFtdO1xyXG4gICAgY2x1c3RlcmluZzogQ2x1c3RlcmluZyA9IG5ldyBDbHVzdGVyaW5nKCk7XHJcbiAgICBiYWNrdXBDbHVzdGVyaW5nOiBDbHVzdGVyaW5nO1xyXG5cclxuICAgIC8vIGNsaWVudC1vbmx5IGZpZWxkc1xyXG4gICAgLy8gVE9ETzogQ29uc2lkZXIganVzdCBwYXNzaW5nIHRoaXMgZnJvbSB0aGUgcmVuZGVyZXJcclxuICAgIGFjdGl2ZVRpbGVzOiBUaWxlW10gPSBbXTtcclxuXHJcbiAgICBvbk5lZWRSZWZyZXNoOiAoKSA9PiB2b2lkO1xyXG4gICAgb25OZWVkU2F2ZTogKGRhdGE6IEdhbWVEYXRhKSA9PiB2b2lkO1xyXG5cclxuICAgIGdldCBuRnJlZVN0b25lcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5uU3RvbmVzIC0gdGhpcy5hY3RpdmVUaWxlcy5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3RydWN0b3Ioc2VlZDogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVOZXdMZXZlbCgpIHtcclxuICAgICAgICBsZXQgZ2VuZXJhdG9yID0gbmV3IExldmVsR2VuZXJhdG9yKHRoaXMuc2VlZCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuZ3JpZCA9IGdlbmVyYXRvci5nZW5lcmF0ZSgpO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUdyaWQoKTtcclxuICAgICAgICB0aGlzLnNhdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGluaXRpYWxpemVHcmlkKCkge1xyXG4gICAgICAgIHRoaXMuZ3JpZC5mb3JFYWNoKHRpbGUgPT4ge1xyXG4gICAgICAgICAgICB0aWxlLmdhbWUgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aWxlLmdyaWQgPSB0aGlzLmdyaWQ7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5ncm91cHNbdGlsZS5ncm91cEluZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cHNbdGlsZS5ncm91cEluZGV4XSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW3RpbGUuZ3JvdXBJbmRleF0ucHVzaCh0aWxlKTtcclxuICAgICAgICAgICAgaWYgKHRpbGUudW5sb2NrZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2x1c3RlcmluZy5hZGRUaWxlQW5kQ29ubmVjdE5laWdoYm9ycyh0aWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZ3JpZC5mb3JFYWNoKHRpbGUgPT4ge1xyXG4gICAgICAgICAgICB0aWxlLmdyb3VwQ291bnQgPSB0aGlzLmdyb3Vwc1t0aWxlLmdyb3VwSW5kZXhdLmxlbmd0aDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zb2xlLmxvZygnY3JlYXRlZCBzdGFydGluZyBjbHVzdGVyaW5nJywgdGhpcy5jbHVzdGVyaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICBzYXZlKCkge1xyXG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5zZXJpYWxpemUoKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnc2F2aW5nLi4uJywgZGF0YSk7XHJcbiAgICAgICAgdGhpcy5vbk5lZWRTYXZlKHRoaXMuc2VyaWFsaXplKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHNlcmlhbGl6ZSgpIDogR2FtZURhdGEge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNlZWQ6IHRoaXMuc2VlZCxcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIHRpbGVzOiB0aGlzLmdyaWQudG9BcnJheSgpLm1hcCh0aWxlID0+IHRpbGUuc2VyaWFsaXplKCkpLFxyXG4gICAgICAgICAgICBuU3RvbmVzOiB0aGlzLm5TdG9uZXMsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBkZXNlcmlhbGl6ZShkYXRhOiBHYW1lRGF0YSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdsb2FkaW5nLi4uJywgZGF0YSk7XHJcbiAgICAgICAgdGhpcy5zZWVkID0gZGF0YS5zZWVkO1xyXG4gICAgICAgIHRoaXMublN0b25lcyA9IGRhdGEublN0b25lcztcclxuICAgICAgICB0aGlzLndpZHRoID0gZGF0YS53aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGRhdGEuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuZ3JpZCA9IG5ldyBHcmlkKFRpbGUsIHJlY3RhbmdsZSh7IHdpZHRoOiBkYXRhLndpZHRoLCBoZWlnaHQ6IGRhdGEuaGVpZ2h0IH0pKTtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgdGhpcy5ncmlkLmZvckVhY2godGlsZSA9PiB7XHJcbiAgICAgICAgICAgIHRpbGUuZGVzZXJpYWxpemUoaSwgZGF0YS50aWxlc1tpKytdKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVHcmlkKCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIGxvYWRpbmcnLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFaXRoZXIgdGhpcyBvciBcIkNoZWNrIENvbm5lY3Rpb25zXCIgc3RpbGwgaGFzIGEgYnVnIGluIGl0IC0gbmVlZCB0byBmaW5kIGl0XHJcbiAgICB0aWxlQ2xpY2tlZCh0aWxlOiBUaWxlKSB7XHJcbiAgICAgICAgaWYgKHRpbGUuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHRpbGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlVGlsZXMuc3BsaWNlKHRoaXMuYWN0aXZlVGlsZXMuaW5kZXhPZih0aWxlKSwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuY2x1c3RlcmluZyA9IHRoaXMuYmFja3VwQ2x1c3RlcmluZy5jb3B5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlVGlsZXMuZm9yRWFjaCh0aWxlID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHRoaXMuY2x1c3RlcmluZyksIHRpbGUuaWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbHVzdGVyaW5nLmFkZFRpbGVBbmRDb25uZWN0TmVpZ2hib3JzKHRpbGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVUaWxlcy5sZW5ndGggPj0gdGhpcy5uU3RvbmVzKSByZXR1cm47XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuYWN0aXZlVGlsZXMubGVuZ3RoLCB0aGlzLm5TdG9uZXMpO1xyXG4gICAgICAgICAgICB0aWxlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlVGlsZXMucHVzaCh0aWxlKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYmFja3VwQ2x1c3RlcmluZyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2t1cENsdXN0ZXJpbmcgPSB0aGlzLmNsdXN0ZXJpbmcuY29weSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY2x1c3RlcmluZy5hZGRUaWxlQW5kQ29ubmVjdE5laWdoYm9ycyh0aWxlKTtcclxuICAgICAgICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpb25zKCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuY2x1c3RlcmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuY2x1c3RlcmluZy5jbHVzdGVycyk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXJTZWxlY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZShmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5vbk5lZWRSZWZyZXNoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2hlY2tDb25uZWN0aW9ucygpIHtcclxuICAgICAgICBsZXQgYWN0aXZlR3JvdXBJbmRpY2VzID0gdGhpcy5hY3RpdmVUaWxlcy5tYXAodGlsZSA9PiB0aWxlLmdyb3VwSW5kZXgpO1xyXG4gICAgICAgIGFjdGl2ZUdyb3VwSW5kaWNlcyA9IGFjdGl2ZUdyb3VwSW5kaWNlcy5maWx0ZXIoZ3JvdXBJbmRleCA9PiBncm91cEluZGV4ICE9PSB1bmRlZmluZWQpO1xyXG4gICAgICAgIC8vIHJlbW92ZSBkdXBsaWNhdGVzXHJcbiAgICAgICAgYWN0aXZlR3JvdXBJbmRpY2VzID0gYWN0aXZlR3JvdXBJbmRpY2VzLmZpbHRlcigodmFsdWUsIGluZGV4LCBzZWxmKSA9PiBzZWxmLmluZGV4T2YodmFsdWUpID09PSBpbmRleCk7XHJcbiAgICAgICAgaWYgKGFjdGl2ZUdyb3VwSW5kaWNlcy5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2NoZWNraW5nIGNvbm5lY3Rpb25zJywgYWN0aXZlR3JvdXBJbmRpY2VzKTtcclxuICAgICAgICBsZXQgY2xlYXIgPSBmYWxzZSwgcmVmcmVzaCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aXZlR3JvdXBJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBncm91cEluZGV4ID0gYWN0aXZlR3JvdXBJbmRpY2VzW2ldO1xyXG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cEluZGV4XTtcclxuICAgICAgICAgICAgbGV0IGNsdXN0ZXJJbmRleCA9IHRoaXMuY2x1c3RlcmluZy5nZXRDbHVzdGVySW5kZXgoZ3JvdXBbMF0uaWQpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhncm91cCwgZ3JvdXAubWFwKHRpbGUgPT4gdGhpcy5jbHVzdGVyaW5nLmdldENsdXN0ZXJJbmRleCh0aWxlLmlkKSkpO1xyXG4gICAgICAgICAgICBpZiAoZ3JvdXAuZXZlcnkodGlsZSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVUaWxlcy5pbmNsdWRlcyh0aWxlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJJbmRleCA9PT0gdGhpcy5jbHVzdGVyaW5nLmdldENsdXN0ZXJJbmRleCh0aWxlLmlkKTtcclxuICAgICAgICAgICAgfSkpIHtcclxuICAgICAgICAgICAgICAgIGdyb3VwLmZvckVhY2godGlsZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZS51bmxvY2tlZCA9IHRydWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwLmxlbmd0aCA+IDEpIGNsZWFyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJlZnJlc2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwWzBdLmlzU3RvbmVUaWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uU3RvbmVzKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndW5sb2NrZWQgZ3JvdXAgJyArIGdyb3VwSW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVmcmVzaCkge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCFjbGVhcik7XHJcbiAgICAgICAgICAgIHRoaXMuc2F2ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm9uTmVlZFJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXJBY3RpdmUocmVzdG9yZUFjdGl2ZTogYm9vbGVhbikge1xyXG4gICAgICAgIGlmICh0aGlzLmJhY2t1cENsdXN0ZXJpbmcgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmNsdXN0ZXJpbmcgPSB0aGlzLmJhY2t1cENsdXN0ZXJpbmcuY29weSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJhY2t1cENsdXN0ZXJpbmcgPSBudWxsO1xyXG4gICAgICAgIGxldCB0b1Jlc3RvcmUgPSBbXTtcclxuICAgICAgICB0aGlzLmFjdGl2ZVRpbGVzLmZvckVhY2godGlsZSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aWxlLnVubG9ja2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsdXN0ZXJpbmcuYWRkVGlsZUFuZENvbm5lY3ROZWlnaGJvcnModGlsZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0b1Jlc3RvcmUucHVzaCh0aWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aWxlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlVGlsZXMgPSBbXTtcclxuICAgICAgICBpZiAocmVzdG9yZUFjdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmJhY2t1cENsdXN0ZXJpbmcgPSB0aGlzLmNsdXN0ZXJpbmcuY29weSgpO1xyXG4gICAgICAgICAgICB0b1Jlc3RvcmUuZm9yRWFjaCh0aWxlID0+IHtcclxuICAgICAgICAgICAgICAgIHRpbGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlVGlsZXMucHVzaCh0aWxlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2x1c3RlcmluZy5hZGRUaWxlQW5kQ29ubmVjdE5laWdoYm9ycyh0aWxlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgR3JpZCwgZGVmaW5lSGV4IH0gZnJvbSBcImhvbmV5Y29tYi1ncmlkXCI7XHJcbmltcG9ydCB7IFJvb3RzIH0gZnJvbSBcIi4vUm9vdHNcIjtcclxuXHJcbmV4cG9ydCB0eXBlIFRpbGVEYXRhID0ge1xyXG4gICAgdW5sb2NrZWQ6IGJvb2xlYW47XHJcbiAgICBncm91cEluZGV4OiBudW1iZXI7XHJcbiAgICBpc1N0b25lVGlsZTogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFRpbGUgZXh0ZW5kcyBkZWZpbmVIZXgoeyBkaW1lbnNpb25zOiAzMCwgb3JpZ2luOiBcInRvcExlZnRcIiB9KSB7XHJcbiAgXHJcbiAgICAvLyBzZXJpYWxpemFibGUgZmllbGRzXHJcbiAgICBpZDogbnVtYmVyO1xyXG4gICAgZ3JvdXBJbmRleDogbnVtYmVyO1xyXG4gICAgaXNTdG9uZVRpbGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHVubG9ja2VkOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgZ3JpZDogR3JpZDxUaWxlPjtcclxuICAgIGFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgZ3JvdXBDb3VudDogbnVtYmVyO1xyXG4gICAgZ2FtZTogUm9vdHM7XHJcblxyXG4gICAgc2VyaWFsaXplKCk6IFRpbGVEYXRhIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1bmxvY2tlZDogdGhpcy51bmxvY2tlZCxcclxuICAgICAgICAgICAgZ3JvdXBJbmRleDogdGhpcy5ncm91cEluZGV4LFxyXG4gICAgICAgICAgICBpc1N0b25lVGlsZTogdGhpcy5pc1N0b25lVGlsZSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGRlc2VyaWFsaXplKGlkOiBudW1iZXIsIGRhdGE6IFRpbGVEYXRhKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMudW5sb2NrZWQgPSBkYXRhLnVubG9ja2VkO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBJbmRleCA9IGRhdGEuZ3JvdXBJbmRleDtcclxuICAgICAgICB0aGlzLmlzU3RvbmVUaWxlID0gZGF0YS5pc1N0b25lVGlsZTtcclxuICAgIH1cclxuICBcclxuICAgIGlzUGFzc2FibGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlIHx8IHRoaXMudW5sb2NrZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgY2xpY2tlZCgpIHtcclxuICAgICAgICBpZiAodGhpcy51bmxvY2tlZCkgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuZ2FtZS50aWxlQ2xpY2tlZCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXROZWlnaGJvcnMoKTogVGlsZVtdIHtcclxuICAgICAgICBsZXQgbmVpZ2hib3JzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IG5laWdoYm9yID0gdGhpcy5ncmlkLm5laWdoYm9yT2YodGhpcywgaSwge2FsbG93T3V0c2lkZTogZmFsc2V9KTtcclxuICAgICAgICAgICAgaWYgKG5laWdoYm9yKSB7XHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChuZWlnaGJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5laWdoYm9ycztcclxuICAgIH1cclxuXHJcbiAgICBnZXRQYXNzYWJsZU5laWdoYm9ycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXROZWlnaGJvcnMoKS5maWx0ZXIobmVpZ2hib3IgPT4gbmVpZ2hib3IuaXNQYXNzYWJsZSgpKTtcclxuICAgIH1cclxuXHJcbn0iLCJpbXBvcnQgUHJpb3JpdHlRdWV1ZSBmcm9tIFwicHJpb3JpdHlxdWV1ZWpzXCI7XHJcblxyXG5leHBvcnQgdHlwZSBOb2RlS2V5ID0gc3RyaW5nIHwgbnVtYmVyO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBFZGdlPFQ+IHtcclxuICAgIG5vZGU6IFQ7XHJcbiAgICB3ZWlnaHQ6IG51bWJlcjtcclxufVxyXG5cclxuaW50ZXJmYWNlIFF1ZXVlRW50cnk8VD4ge1xyXG4gICAgbm9kZTogVDtcclxuICAgIGNvc3Q6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJR3JhcGhBZGFwdGVyPFQ+IHtcclxuICAgIGdldEtleT86IChub2RlOiBUKSA9PiBOb2RlS2V5O1xyXG4gICAgZ2V0RWRnZXM6IChub2RlOiBUKSA9PiBFZGdlPFQ+W107XHJcbn1cclxuXHJcbmNvbnN0IGdldE5vZGVLZXkgPSA8VD4obm9kZTogVCwgYWRhcHRlcjogSUdyYXBoQWRhcHRlcjxUPik6IE5vZGVLZXkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiBhZGFwdGVyLmdldEtleSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gYWRhcHRlci5nZXRLZXkobm9kZSk7XHJcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG5vZGUgPT09IFwibnVtYmVyXCIpIHJldHVybiBub2RlO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQWRhcHRlciBtdXN0IGltcGxlbWVudCBtZXRob2QgZ2V0S2V5XCIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGRpamtzdHJhID0gPFQ+KFxyXG4gICAgYWRhcHRlcjogSUdyYXBoQWRhcHRlcjxUPixcclxuICAgIHN0YXJ0Tm9kZTogVCxcclxuICAgIGZpbmlzaE5vZGU/OiBULFxyXG4gICAgbWF4Q29zdD86IG51bWJlclxyXG4pID0+IHtcclxuICAgIGNvbnN0IGdldEtleSA9IChub2RlOiBUKSA9PiBnZXROb2RlS2V5KG5vZGUsIGFkYXB0ZXIpO1xyXG4gICAgY29uc3QgcGFyZW50czogUmVjb3JkPE5vZGVLZXksIFQ+ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIGNvbnN0IGNvc3RzOiBSZWNvcmQ8Tm9kZUtleSwgbnVtYmVyPiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICBjb25zdCBleHBsb3JlZDogUmVjb3JkPE5vZGVLZXksIGJvb2xlYW4+ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIGNvbnN0IHByaW9RdWV1ZSA9IG5ldyBQcmlvcml0eVF1ZXVlPFF1ZXVlRW50cnk8VD4+KChhLCBiKSA9PiBiLmNvc3QgLSBhLmNvc3QpO1xyXG4gICAgcHJpb1F1ZXVlLmVucSh7IG5vZGU6IHN0YXJ0Tm9kZSwgY29zdDogMCB9KTtcclxuXHJcbiAgICBkbyB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSBwcmlvUXVldWUuZGVxKCkubm9kZTtcclxuICAgICAgICBsZXQgbm9kZUtleSA9IGdldEtleShub2RlKTtcclxuICAgICAgICBsZXQgY29zdCA9IGNvc3RzW25vZGVLZXldIHx8IDA7XHJcbiAgICAgICAgaWYgKG1heENvc3QgIT0gbnVsbCAmJiBjb3N0ID4gbWF4Q29zdCkgYnJlYWs7XHJcblxyXG4gICAgICAgIGV4cGxvcmVkW25vZGVLZXldID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gRWFybHkgcmV0dXJuIHdoZW4gdGhlIHNob3J0ZXN0IHBhdGggaW4gb3VyXHJcbiAgICAgICAgLy8gZ3JhcGggaXMgYWxyZWFkeSB0aGUgZmluaXNoTm9kZVxyXG4gICAgICAgIGlmIChmaW5pc2hOb2RlICE9IG51bGwgJiYgbm9kZUtleSA9PT0gZ2V0S2V5KGZpbmlzaE5vZGUpKSBicmVhaztcclxuXHJcbiAgICAgICAgY29uc3QgZWRnZXMgPSBhZGFwdGVyLmdldEVkZ2VzKG5vZGUpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gZWRnZXNbaV0ubm9kZTtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlS2V5ID0gZ2V0S2V5KGNoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgIGxldCBhbHQgPSBjb3N0ICsgZWRnZXNbaV0ud2VpZ2h0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGFsdCA8PSBtYXhDb3N0ICYmICh1bmRlZmluZWQgPT09IGNvc3RzW2NoaWxkTm9kZUtleV0gfHwgYWx0IDwgY29zdHNbY2hpbGROb2RlS2V5XSkpIHtcclxuICAgICAgICAgICAgICAgIGNvc3RzW2NoaWxkTm9kZUtleV0gPSBhbHQ7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRzW2NoaWxkTm9kZUtleV0gPSBub2RlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghZXhwbG9yZWRbY2hpbGROb2RlS2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByaW9RdWV1ZS5lbnEoeyBub2RlOiBjaGlsZE5vZGUsIGNvc3Q6IGFsdCB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gd2hpbGUgKCFwcmlvUXVldWUuaXNFbXB0eSgpKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvc3RzLFxyXG4gICAgICAgIHBhcmVudHMsXHJcbiAgICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGZpbmRTaG9ydGVzdFBhdGggPSA8VD4oXHJcbiAgICBhZGFwdGVyOiBJR3JhcGhBZGFwdGVyPFQ+LFxyXG4gICAgc3RhcnROb2RlOiBULFxyXG4gICAgZmluaXNoTm9kZTogVFxyXG4pID0+IHtcclxuICAgIGNvbnN0IGdldEtleSA9IChub2RlOiBUKSA9PiBnZXROb2RlS2V5KG5vZGUsIGFkYXB0ZXIpO1xyXG4gICAgY29uc3QgeyBjb3N0cywgcGFyZW50cyB9ID0gZGlqa3N0cmEoYWRhcHRlciwgc3RhcnROb2RlLCBmaW5pc2hOb2RlKTtcclxuXHJcbiAgICBsZXQgb3B0aW1hbFBhdGggPSBbZmluaXNoTm9kZV07XHJcbiAgICBsZXQgcGFyZW50ID0gcGFyZW50c1tnZXRLZXkoZmluaXNoTm9kZSldO1xyXG4gICAgd2hpbGUgKHBhcmVudCkge1xyXG4gICAgICAgIG9wdGltYWxQYXRoLnB1c2gocGFyZW50KTtcclxuICAgICAgICBwYXJlbnQgPSBwYXJlbnRzW2dldEtleShwYXJlbnQpXTtcclxuICAgIH1cclxuICAgIG9wdGltYWxQYXRoLnJldmVyc2UoKTtcclxuXHJcbiAgICBjb25zdCByZXN1bHRzID0ge1xyXG4gICAgICAgIGRpc3RhbmNlOiBjb3N0c1tnZXRLZXkoZmluaXNoTm9kZSldLFxyXG4gICAgICAgIHBhdGg6IG9wdGltYWxQYXRoLFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxufTtcclxuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS4zLjIgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuMy4yJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcbiIsIi8qIChpZ25vcmVkKSAqLyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdGxvYWRlZDogZmFsc2UsXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIl9fd2VicGFja19yZXF1aXJlX18uYW1kRCA9IGZ1bmN0aW9uICgpIHtcblx0dGhyb3cgbmV3IEVycm9yKCdkZWZpbmUgY2Fubm90IGJlIHVzZWQgaW5kaXJlY3QnKTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5hbWRPID0ge307IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQgPSAobW9kdWxlKSA9PiB7XG5cdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdHJldHVybiBtb2R1bGU7XG59OyIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2luZGV4LnRzXCIpO1xuIiwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9